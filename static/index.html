<script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@6.5.2/dist/browser/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js"></script>

<head>
    <style>
        body {
            background-image: url('https://img.freepik.com/free-vector/japanese-wave-line-art-landscape-background-abstract-mountain-banner-design-pattern-vector-illustration-geometric-poster_90220-715.jpg?w=2000&t=st=1717966340~exp=1717966940~hmac=ee528da7b4f1df4e3420b4d3cae7923d3ec1fb545b8bf116b07bef5b4e852b92');
            background-size: cover;
            background-position: center;
        }

        .fixed-bottom {
            position: fixed;
            bottom: 0;
            left: 0.5vw;
            right: 0.5vw;
            width: 100%;
            background-color: rgba(33, 33, 33, 0.8);
            color: white;
            text-align: left;
            text-wrap: wrap;
            padding: 10px;
            z-index: 1000; /* 确保元素在最前面 */
        }

    </style>
</head>

<body style="position: fixed; bottom: 0;">
    <canvas id="canvas"></canvas>
    <ul class="fixed-bottom" id="messages"></ul>
</body>

<script src="./modelDict.js"></script>
<script src="./index.js"></script>

<script>
    // task queue
    // - store tasks in queue, and run them one by one if there are tasks in the queue
    class TaskQueue {
        constructor() {
            this.queue = [];
            this.running = false;
            this.taskInterval = 3000;
        }

        addTask(task) {
            this.queue.push(task);
            this.runNextTask();
        }

        clearQueue() {
            this.queue = [];
        }

        async runNextTask() {
            if (this.running || this.queue.length === 0) {
                if (this.queue.length === 0) {
                    console.log("Queue is empty");
                }
                return;
            }

            this.running = true;
            const task = this.queue.shift();
            try {
                await task();
            } catch (error) {
                console.error('Task failed', error);
            }
            this.running = false;
            setTimeout(() => this.runNextTask(), this.taskInterval);
            // this.runNextTask();
        }
    }

    // 示例异步任务
    // const asyncTask = (taskName, duration) => async () => {
    //     console.log(`Starting task: ${taskName}`);
    //     await new Promise((resolve) => setTimeout(resolve, duration));
    //     console.log(`Completed task: ${taskName}`);
    // };

    const taskQueue = new TaskQueue();


</script>

<script>
    let dev;
    const wsUrl = "ws://127.0.0.1:8000/live2d-motion-ws"
    // handle ws
    document.addEventListener("DOMContentLoaded", function () {
        const ws = new WebSocket(wsUrl);
        ws.onopen = function () {
            console.log("Connected to WebSocket " + wsUrl);
        };

        ws.onclose = function () {
            console.log("Disconnected from WebSocket " + wsUrl);
            talk = false;
            taskQueue.clearQueue();
        };

        ws.onmessage = function (event) {
            console.log("Received message: " + event.data);
            console.log(event);
            dev = event
            handleMessage(JSON.parse(event.data));
        };
    });


    function handleMessage(message) {
        console.log("MessageOBJ is.. ", message)
        switch (message.type) {
            case "full-text":
                console.log("full-text: ", message.text);
                const html_messages = document.getElementById("messages");
                const newElement = document.createElement("li");
                newElement.textContent = message.text;
                html_messages.appendChild(newElement);
                checkStringForExpression(message.text);
            case "control":
                if (message.text === "speaking-start") {
                    talk = true;
                    stupidTalk();
                } else if (message.text === "speaking-stop") {
                    talk = false;
                }
                break;
            case "expression": // not yet implemented
                // setExpression(message.expression);
                break;
            case "listExpressions":
                console.log(listSupportedExpressions());
                break;
            default:
                console.error("Unknown message type: " + message.type);
        }
    }






    // set expression of the model2
    // @param {int} expression - the expression name defined in the emotionMap in modelDict.js
    async function setExpression(expression) {
        model2.internalModel.motionManager.expressionManager.setExpression(emoMap[expression]);
        console.info(`>> [x] -> Expression set to: (${emoMap[expression]}) [${expression}]`);

        // Reset the expression after 3 seconds
        // setTimeout(() => {
        //     model2.internalModel.motionManager.expressionManager.setExpression(0);
        //     console.info(">> Expression reset");
        // }, 3000);
    }

    // Check if the string contains an expression. If it does, set the expression of the model2.
    // @param {string} str - the string to check
    // 
    async function checkStringForExpression(str) {
        console.log("emo map: ", emoMap);
        for (const key of Object.keys(emoMap)) {
            if (str.toLowerCase().includes("[" + key + "]")) {
                console.info(">> [ ] <- add to exec queue: " + key + ", " + emoMap[key]);
                taskQueue.addTask(() => {setExpression(key);});
                taskQueue.addTask(() => {console.log("timing out...")});
                // setExpression(emoMap[key]);
            }
        }
    }

    function listSupportedExpressions() {
        emoMap = model2.internalModel.motionManager.expressionManager.emotionMap;
        console.log(emoMap);
    }



    let talk = false;

    /**
     * Toggles the state of talking. If currently talking, it stops talking. If not talking, it starts talking and initiates the `stupidTalk` function.
     */
    function setTalkState(state) {
        talk = state;
        if (talk) {
            stupidTalk();
        }
    }

    /**
     * Initiates an animation that simulates talking by opening and closing the mouth randomly. This function uses a recursive timeout to continuously toggle the mouth's open state at random intervals, simulating random talking movements.
     */
    function stupidTalk() {
        let isOpen = false; // track if mouth is open

        function toggleMouth() {
            if (!talk) {
                model2.internalModel.coreModel.setParamFloat('PARAM_MOUTH_OPEN_Y', 0.1);
                return;
            }

            if (isOpen) {
                model2.internalModel.coreModel.setParamFloat('PARAM_MOUTH_OPEN_Y', 0.1);
                isOpen = false;
            } else {
                model2.internalModel.coreModel.setParamFloat('PARAM_MOUTH_OPEN_Y', (Math.random() * (0.9 - 0.5) + 0.5) );
                isOpen = true;
            }

            setTimeout(toggleMouth, (Math.random() * (0.2 - 0.1) + 0.1)*1000);
        }

        toggleMouth();
    }



</script>