function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = z$2 && a2[z$2] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$2 = G$1.prototype = new F();
H$2.constructor = G$1;
C$1(H$2, E$1.prototype);
H$2.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2) a2 = null;
  var h2 = false;
  if (null === a2) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a2.$$typeof) {
        case l$3:
        case n$3:
          h2 = true;
      }
  }
  if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
    return a3;
  })) : null != c2 && (O$1(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
    k2 = a2[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2) return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status) return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2)) throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$2, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$3.call(a2, b2) && !p$3.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a2[d2];
      if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length) return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a2);
    }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports2.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports2.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports2.unstable_now());
    }, b2);
  }
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports2.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports2.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = function() {
  };
  exports2.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports2.unstable_shouldYield = M2;
  exports2.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2)) return true;
  if (ja.call(la, a2)) return false;
  if (ka.test(a2)) return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$1[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$1[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua$1 = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a2, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a2.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2) return null;
  if ("function" === typeof a2) return a2.displayName || a2.name || null;
  if ("string" === typeof a2) return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2) switch (a2.$$typeof) {
    case Ca:
      return (a2.displayName || "Context") + ".Consumer";
    case Ba:
      return (a2._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a2.render;
      a2 = a2.displayName;
      a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      return a2;
    case Ga:
      return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
    case Ha:
      b2 = a2._payload;
      a2 = a2._init;
      try {
        return Qa(a2(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2) return false;
  var b2 = a2._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2) return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
  } else a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$2(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$2(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$2(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
    for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$2(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$2(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$2(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb) throw Error(p$2(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib) return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
      a2 = !d2;
      break a;
    default:
      a2 = false;
  }
  if (a2) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$2(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a2) {
  Lb = false;
}
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2) throw Error(p$2(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2) throw Error(p$2(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a2;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$2(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$2(190));
  }
  if (3 !== c2.tag) throw Error(p$2(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2) return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn) return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua$1.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2) hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
  else if (c2 = b2.tag, 13 === c2) {
    a2 = Wb(b2);
    if (null !== a2) return a2;
    a2 = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a2 = null;
  } else b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2) return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2)) return a2;
}
function ve(a2, b2) {
  if ("change" === a2) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2) return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2) return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2)) return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a2 = b2.contentWindow;
    else break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2]) return Xe[a2];
  if (!We[a2]) return a2;
  var b2 = We[a2], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a2) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2) return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2) throw Error(p$2(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a2.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a2;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2) return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
        if (c2 = a2[Of]) return c2;
        a2 = Mf(a2);
      }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
  throw Error(p$2(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H$1);
}
function ag(a2, b2, c2) {
  if (H$1.current !== Vf) throw Error(p$2(168));
  G(H$1, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$2(108, Ra(a2) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$1.current;
  G(H$1, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2) throw Error(p$2(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H$1), G(H$1, a2)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2)) throw Error(p$2(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2)) throw Error(p$2(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg) return false;
  if (!I) return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2)) throw Hg(), Error(p$2(418));
    for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2) throw Error(p$2(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$2(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$2(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2) throw Error(p$2(284));
    if (!c2._owner) throw Error(p$2(290, a2));
  }
  return a2;
}
function Mg(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function Ng(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function Og(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Pg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Lg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
      Mg(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      Mg(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$2(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$2(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a3, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a3;
                a3 = d3;
                break a;
              } else {
                c2(a3, d3);
                break;
              }
              else b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a3, d3, f3, h3);
      if (Ka(f3)) return t2(a3, d3, f3, h3);
      Mg(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a2) {
  var b2 = Wg.current;
  E(Wg);
  a2._currentValue = b2;
}
function bh(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2) break;
    a2 = a2.return;
  }
}
function ch(a2, b2) {
  Xg = a2;
  Zg = Yg = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
}
function eh(a2) {
  var b2 = a2._currentValue;
  if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$2(308));
    Yg = a2;
    Xg.dependencies = { lanes: 0, firstContext: a2 };
  } else Yg = Yg.next = a2;
  return b2;
}
var fh = null;
function gh(a2) {
  null === fh ? fh = [a2] : fh.push(a2);
}
function hh(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a2, d2);
}
function ih(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function mh(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a2, c2);
}
function oh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function ph(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function sh(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
    var d2 = a2[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$2(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a2) {
  if (a2 === th) throw Error(p$2(174));
  return a2;
}
function yh(a2, b2) {
  G(wh, b2);
  G(vh, a2);
  G(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(vh, a2), G(uh, c2));
}
function Bh(a2) {
  vh.current === a2 && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua$1.ReactCurrentDispatcher, Gh = ua$1.ReactCurrentBatchConfig, Hh = 0, M$1 = null, N$1 = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$1() {
  throw Error(p$2(321));
}
function Mh(a2, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  M$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$2(301));
      f2 += 1;
      O = N$1 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$1 && null !== N$1.next;
  Hh = 0;
  O = N$1 = M$1 = null;
  Ih = false;
  if (b2) throw Error(p$2(300));
  return a2;
}
function Sh() {
  var a2 = 0 !== Kh;
  Kh = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M$1.memoizedState = O = a2 : O = O.next = a2;
  return O;
}
function Uh() {
  if (null === N$1) {
    var a2 = M$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else a2 = N$1.next;
  var b2 = null === O ? M$1.memoizedState : O.next;
  if (null !== b2) O = b2, N$1 = a2;
  else {
    if (null === a2) throw Error(p$2(310));
    N$1 = a2;
    a2 = { memoizedState: N$1.memoizedState, baseState: N$1.baseState, baseQueue: N$1.baseQueue, queue: N$1.queue, next: null };
    null === O ? M$1.memoizedState = O = a2 : O = O.next = a2;
  }
  return O;
}
function Vh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = N$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M$1.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, M$1.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = M$1, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$2(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = M$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function ci(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a2);
}
function ai(a2, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a2);
  });
}
function ei(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = ih(a2, 1);
  null !== b2 && gi(b2, a2, 1, -1);
}
function hi(a2) {
  var b2 = Th();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ii.bind(null, M$1, a2);
  return [b2.memoizedState, a2];
}
function bi(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a2, b2, c2, d2) {
  var e2 = Th();
  M$1.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N$1) {
    var g2 = N$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M$1.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a2, b2) {
  return ki(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return li(2048, 8, a2, b2);
}
function ni(a2, b2) {
  return li(4, 2, a2, b2);
}
function oi(a2, b2) {
  return li(4, 4, a2, b2);
}
function pi(a2, b2) {
  if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
    b2.current = null;
  };
}
function qi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return li(4, 4, pi.bind(null, b2, a2), c2);
}
function ri() {
}
function si(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ti(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function ui(a2, b2, c2) {
  if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M$1.lanes |= c2, rh |= c2, a2.baseState = true);
  return b2;
}
function vi(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a2, b2, c2) {
  var d2 = yi(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, c2);
  else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a2, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a2, b2, c2) {
  var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a2, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a2) {
  var b2 = a2.alternate;
  return a2 === M$1 || null !== b2 && b2 === M$1;
}
function Ai(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Bi(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ki(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ki(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = xi.bind(null, M$1, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
  return Th().memoizedState = a2;
}, useTransition: function() {
  var a2 = hi(false), b2 = a2[0];
  a2 = vi.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = M$1, e2 = Th();
  if (I) {
    if (void 0 === c2) throw Error(p$2(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$2(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a2) {
    var b2 = Uh();
    return ui(b2, N$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a2) {
  var b2 = Uh();
  return null === N$1 ? b2.memoizedState = a2 : ui(b2, N$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a2, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Di(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = R(), d2 = yi(a2), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a2, e2, d2);
  null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
} };
function Fi(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = {};
  kh(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function Ji(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Ki(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a2, b2);
  };
  return c2;
}
function Qi(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a2, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ui(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Vi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Wi = ua$1.ReactCurrentOwner, dh = false;
function Xi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = Pg(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
    else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  }
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function gj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$1.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function hj(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a2, b2, c2, d2, f2, e2);
}
function jj(a2, b2, c2, d2, e2, f2) {
  gj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function lj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function oj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
  G(L, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a2, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a2.child, null, c2);
  a2 = qj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function rj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$2(422))), sj(a2, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$2(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$2(421)));
    return sj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a2.return, b2, c2);
}
function wj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
      if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
      else if (19 === a2.tag) vj(a2, c2, b2);
      else if (null !== a2.child) {
        a2.child.return = a2;
        a2 = a2.child;
        continue;
      }
      if (a2 === b2) break a;
      for (; null === a2.sibling; ) {
        if (null === a2.return || a2.return === b2) break a;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      a2 = a2.sibling;
    }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a2 = e2.alternate;
        if (null !== a2 && null === Ch(a2)) {
          b2.child = e2;
          break;
        }
        a2 = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a2;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a2 && b2.child !== a2.child) throw Error(p$2(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = Pg(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
        G(L, L.current & 1);
        a2 = Zi(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2) return xj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a2, b2) {
  if (!I) switch (a2.tailMode) {
    case "hidden":
      b2 = a2.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a2.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a2.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
  }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Ej(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H$1);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$2(166));
          S$1(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a2
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          zj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a2);
                D("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a2
                );
                D("load", a2);
                e2 = d2;
                break;
              case "details":
                D("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$2(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2) switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                break;
              case 5:
                true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2) throw Error(p$2(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$2(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return ah(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2) return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
          g2 = Ch(a2);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a2 = a2.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a2 = Ch(g2), null !== a2) {
          if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S$1(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
function Ij(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H$1), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate) throw Error(p$2(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a2, b2, d2);
  }
  else c2.current = null;
}
function Mj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Nj = false;
function Oj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else a: {
      c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a2) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V = a2;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$2(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a2 = b2.sibling;
    if (null !== a2) {
      a2.return = b2.return;
      V = a2;
      break;
    }
    V = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Sj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Sj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Tj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Uj(a2) {
  a: for (; ; ) {
    for (; null === a2.sibling; ) {
      if (null === a2.return || Tj(a2.return)) return null;
      a2 = a2.return;
    }
    a2.sibling.return = a2.return;
    for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
      if (a2.flags & 2) continue a;
      if (null === a2.child || 4 === a2.tag) continue a;
      else a2.child.return = a2, a2 = a2.child;
    }
    if (!(a2.flags & 2)) return a2.stateNode;
  }
}
function Vj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Xj = false;
function Yj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
}
function Zj(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a2, b2, c2);
      break;
    case 21:
      Yj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a2, b2, c2), U = d2) : Yj(a2, b2, c2);
      break;
    default:
      Yj(a2, b2, c2);
  }
}
function ak(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a2, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X) throw Error(p$2(160));
      Zj(f2, g2, e2);
      X = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
}
function dk(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        try {
          Pj(3, a2, a2.return), Qj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Pj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        if (null === a2.stateNode) throw Error(p$2(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a2, a2.return, t2);
      }
      break;
    case 4:
      ck(b2, a2);
      ek(a2);
      break;
    case 13:
      ck(b2, a2);
      ek(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a2), U = l2) : ck(b2, a2);
      ek(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a2; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a2) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a2) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a2);
      ek(a2);
      d2 & 4 && ak(a2);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a2
      ), ek(a2);
  }
}
function ek(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$2(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a2);
          Wj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
          Vj(a2, h2, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function hk(a2, b2, c2) {
  V = a2;
  ik(a2);
}
function ik(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a2);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a2);
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$2(163));
        }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua$1.ReactCurrentDispatcher, nk = ua$1.ReactCurrentOwner, ok = ua$1.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a2) {
  if (0 === (a2.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a2 = C;
  if (0 !== a2) return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function gi(a2, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$2(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Gk(a2, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$2(327));
  var c2 = a2.callbackNode;
  if (Hk() && a2.callbackNode !== c2) return null;
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a2 || Z !== b2) uk = null, Gj = B() + 500, Kk(a2, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a2, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
    if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
    if (6 === b2) Ck(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Pk(a2, tk, uk);
          break;
        case 3:
          Ck(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0)) break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 4:
          Ck(a2, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 5:
          Pk(a2, tk, uk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Dk(a2, B());
  return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
}
function Nk(a2, b2) {
  var c2 = sk;
  a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
  a2 = Ik(a2, b2);
  2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a2;
}
function Fj(a2) {
  null === tk ? tk = a2 : tk.push.apply(tk, a2);
}
function Ok(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a2, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a2) {
  if (0 !== (K & 6)) throw Error(p$2(327));
  Hk();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1)) return Dk(a2, B()), null;
  var c2 = Ik(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
  if (6 === c2) throw Error(p$2(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Pk(a2, tk, uk);
  Dk(a2, B());
  return null;
}
function Qk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a2) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a2) return a2();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H$1);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a2;
  Y = a2 = Pg(a2.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a2;
}
function Mk(a2, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N$1 = M$1 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a2 = mk.current;
  mk.current = Rh;
  return null === a2 ? Rh : a2;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a2 || Z !== b2) uk = null, Kk(a2, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a2, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y) throw Error(p$2(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a2) {
  var b2 = Vk(a2.alternate, a2, fj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Sk(a2) : Y = b2;
  nk.current = null;
}
function Sk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a2, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a2, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$2(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2) return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current) throw Error(p$2(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a2, c2);
    dk(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else a2.current = c2;
  vk && (vk = false, wk = a2, xk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a2, B());
  if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
  0 !== (xk & 1) && 0 !== a2.tag && Hk();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a2 = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === wk) var d2 = false;
      else {
        a2 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$2(331));
        var e2 = K;
        K |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a2);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a2, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a2, b2, 1);
  a2 = nh(a2, b2, 1);
  b2 = R();
  null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag) Xk(a2, a2, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a2, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a2 = Ji(c2, a2);
        a2 = Qi(b2, a2, 1);
        b2 = nh(b2, a2, 1);
        a2 = R();
        null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
  Dk(a2, b2);
}
function Yk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a2 = ih(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
}
function uj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a2, c2);
}
function bk(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a2, c2);
}
var Vk;
Vk = function(a2, b2, c2) {
  if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
    dh = 0 !== (a2.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$1.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a2 = Ci(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
            break a;
        }
        throw Error(p$2(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a2) throw Error(p$2(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a2, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$2(423)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$2(424)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return oj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$2(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
    case 19:
      return xj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$2(156, b2.tag));
};
function Fk(a2, b2) {
  return ac(a2, b2);
}
function $k(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new $k(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Zk(a2) {
  if ("function" === typeof a2) return aj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da) return 11;
    if (a2 === Ga) return 14;
  }
  return 2;
}
function Pg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Rg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2) aj(a2) && (g2 = 1);
  else if ("string" === typeof a2) g2 = 5;
  else a: switch (a2) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
    case Ea:
      return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
    case Fa:
      return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$2(130, null == a2 ? a2 : typeof a2, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function pj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function Qg(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Sg(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function al(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new al(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a2;
}
function cl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function dl(a2) {
  if (!a2) return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p$2(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$2(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2)) return bg(a2, c2, b2);
  }
  return b2;
}
function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = dl(null);
  c2 = a2.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Dk(a2, d2);
  return a2;
}
function fl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = nh(e2, b2, g2);
  null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
  return g2;
}
function gl(a2) {
  a2 = a2.current;
  if (!a2.child) return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function hl(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a2, b2) {
  hl(a2, b2);
  (a2 = a2.alternate) && hl(a2, b2);
}
var kl = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ll(a2) {
  this._internalRoot = a2;
}
ml.prototype.render = ll.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$2(409));
  fl(a2, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Rk(function() {
      fl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a2) {
  this._internalRoot = a2;
}
ml.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function nl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function pl() {
}
function ql(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = gl(g2);
        f2.call(a3);
      };
    }
    var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk();
    return g2;
  }
  for (; e2 = a2.lastChild; ) a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = gl(k2);
      h2.call(a3);
    };
  }
  var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = gl(g2);
        h2.call(a3);
      };
    }
    fl(b2, g2, a2, e2);
  } else g2 = ql(c2, b2, a2, e2, d2);
  return gl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a2, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a2, 1, c3);
        }
      }), il(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = ih(a2, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a2, 134217728, c2);
    }
    il(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = yi(a2), c2 = ih(a2, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a2, b2, d2);
    }
    il(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$2(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a2) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$2(200));
  return cl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!nl(a2)) throw Error(p$2(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2) return null;
  if (1 === a2.nodeType) return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render) throw Error(p$2(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$2(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Rk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$2(200));
  return rl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!nl(a2)) throw Error(p$2(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$2(200));
  return rl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!ol(a2)) throw Error(p$2(40));
  return a2._reactRootContainer ? (Rk(function() {
    rl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$2(200));
  if (null == a2 || void 0 === a2._reactInternals) throw Error(p$2(38));
  return rl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$2 = reactDomExports;
{
  createRoot = m$2.createRoot;
  m$2.hydrateRoot;
}
const cx = (...classNames2) => classNames2.filter(Boolean).map((r2) => r2.trim()).join(" ");
function getErrorMessage$1(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext$1(options = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue: defaultValue2
  } = options;
  const Context = reactExports.createContext(defaultValue2);
  Context.displayName = name2;
  function useContext$1() {
    const context2 = reactExports.useContext(Context);
    if (!context2 && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage$1(hookName, providerName)
      );
      error.name = "ContextError";
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context2;
  }
  return [Context.Provider, useContext$1, Context];
}
function callAll$1(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn?.(...args));
  };
}
const clsx$1 = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
const eventRegex = /^on[A-Z]/;
function mergeProps$1(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll$1(result[key], props[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx$1(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {});
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
const EMPTY_STYLES = Object.freeze({});
const EMPTY_SLOT_STYLES = Object.freeze(
  {}
);
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid$1 = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs$3 = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match$3(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type2, props, children, length2) {
  return { value, root, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign$1(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse$4("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$4(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace$1(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset2, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$4(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$4(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$4(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset2, rules, points, type2, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs$3(j2 = points[i2])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset2 === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify$2(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection2) {
  var length2 = sizeof(collection2);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection2[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix$1(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$1([copy(element, {
          value: replace$1(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine$1(element.props, function(value) {
          switch (match$3(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$1([copy(element, {
                props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize$1([copy(element, {
                props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$2 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$1:
              case t$1:
              case r$1:
              case h$1:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m$1;
}
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h$1;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n$1;
reactIs_production_min.Fragment = e$1;
reactIs_production_min.Lazy = t$1;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$1;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k$1;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h$1;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n$1;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e$1;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t$1;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$1 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$1 || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$1 || a2.$$typeof === r$1 || a2.$$typeof === h$1 || a2.$$typeof === k$1 || a2.$$typeof === n$1 || a2.$$typeof === w$2 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor$1 = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor$1
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor$1 = {
              name: next2.name,
              styles: next2.styles,
              next: cursor$1
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor$1;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor$1
  };
}
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var hasOwn$2 = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn$2.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion$1 = function Insertion2(_ref2) {
  var cache2 = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn$2.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwn$2.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i2 = 2; i2 < argsLength; i2++) {
    createElementArgArray[i2] = args[i2];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx);
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function assignRef(ref2, value) {
  if (ref2 == null) return;
  if (typeof ref2 === "function") {
    ref2(value);
    return;
  }
  try {
    ref2.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref2}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref2) => {
      assignRef(ref2, node2);
    });
  };
}
function compact$3(object) {
  const clone2 = Object.assign({}, object);
  for (let key in clone2) {
    if (clone2[key] === void 0) delete clone2[key];
  }
  return clone2;
}
function interopDefault(mod2) {
  return mod2.default || mod2;
}
const isObject$4 = (v2) => v2 != null && typeof v2 === "object" && !Array.isArray(v2);
const isString$2 = (v2) => typeof v2 === "string";
const isFunction$2 = (v2) => typeof v2 === "function";
function getElementRef(el2) {
  const version = reactExports.version;
  if (!isString$2(version)) return el2?.ref;
  if (version.startsWith("18.")) return el2?.ref;
  return el2?.props?.ref;
}
const [ChakraContextProvider, useChakraContext] = createContext$1({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props) {
  const { value: sys, children } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: sys.layers.atRule }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: sys._global }),
    children
  ] });
}
const splitProps = (props, keys) => {
  const descriptors = Object.getOwnPropertyDescriptors(props);
  const dKeys = Object.keys(descriptors);
  const split = (k2) => {
    const clone2 = {};
    for (let i2 = 0; i2 < k2.length; i2++) {
      const key = k2[i2];
      if (descriptors[key]) {
        Object.defineProperty(clone2, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone2;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return [keys].map(fn).concat(split(dKeys));
};
const htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props } = inProps;
  const result = reactExports.useMemo(() => {
    const [forwardedProps, restProps_B] = splitProps(
      props,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = reactExports.useMemo(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props.colorPalette, props.orientation]);
  const styles2 = reactExports.useMemo(() => {
    return css2(cvaStyles, ...toArray$1(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles: styles2,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
const toArray$1 = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};
const isPropValid = interopDefault(isPropValid$1);
const testOmitPropsOnStringTag = isPropValid;
const testOmitPropsOnComponent = (key) => key !== "theme";
const composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
let isBrowser = typeof document !== "undefined";
const Insertion = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser && rules !== void 0) {
    let serializedNames = serialized.name;
    let next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames = cx(serializedNames, next2.name);
      next2 = next2.next;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
const createStyled = (tag, configOrCva = {}, options = {}) => {
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles2 = [];
  const Styled = withEmotionCache((inProps, cache2, ref2) => {
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva$1(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props2) => {
      return (prop, variantKeys) => {
        if (props2.includes(prop)) return true;
        return !variantKeys?.includes(prop) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !variantKeys?.includes(prop) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = reactExports.useMemo(
      () => Object.assign({}, options.defaultProps, compact$3(inProps)),
      [inProps]
    );
    const { props, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props;
    if (props.theme == null) {
      mergedProps = {};
      for (let key in props) {
        mergedProps[key] = props[key];
      }
      mergedProps.theme = reactExports.useContext(ThemeContext);
    }
    if (typeof props.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props.className
      );
    } else if (props.className != null) {
      className = cx(className, props.className);
    }
    const serialized = serializeStyles(
      styles2.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props.as || baseTag;
    let finalProps = {};
    for (let prop in props) {
      if (shouldUseAs && prop === "as") continue;
      if (isHtmlProp(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref2;
    const forwardAsChild = options.forwardAsChild || options.forwardProps?.includes("asChild");
    if (props.asChild && !forwardAsChild) {
      const child = reactExports.Children.only(props.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = mergeProps$1(finalProps, child.props);
      finalProps.ref = mergeRefs(ref2, getElementRef(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Insertion,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { asChild: true, ...finalProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(props.as, { children: finalProps.children }) })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Insertion,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
const styledFn = createStyled.bind();
const cache = /* @__PURE__ */ new Map();
const chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el2) {
    if (!cache.has(el2)) {
      cache.set(el2, styledFn(el2));
    }
    return cache.get(el2);
  }
});
const chakra = chakraImpl;
const mergeCva$1 = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst$1(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider2, usePropsContext2] = createContext$1({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult2(props) {
    const { unstyled, ...restProps } = props;
    const recipe = useRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = recipe.splitVariantProps(restProps);
    const styles2 = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return {
      styles: styles2,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext2 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = reactExports.forwardRef((inProps, ref2) => {
      const props = mergeProps$1(usePropsContext2(), inProps);
      const { styles: styles2, className, props: localProps } = useRecipeResult2(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...localProps,
          ref: ref2,
          css: [styles2, props.css],
          className: cx(className, props.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider() {
    return PropsProvider2;
  }
  return {
    withContext: withContext2,
    PropsProvider: PropsProvider2,
    withPropsProvider,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult2
  };
}
var clamp$2 = (value) => Math.max(0, Math.min(1, value));
var wrap$3 = (v2, idx) => {
  return v2.map((_, index) => v2[(Math.max(idx, 0) + index) % v2.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop$6 = () => void 0;
var isObject$3 = (v2) => typeof v2 === "object" && v2 !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr$1 = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement$1 = (el2) => isObject$3(el2) && el2.nodeType === ELEMENT_NODE && typeof el2.nodeName === "string";
var isDocument = (el2) => isObject$3(el2) && el2.nodeType === DOCUMENT_NODE;
var isWindow = (el2) => isObject$3(el2) && el2 === el2.window;
var getNodeName$1 = (node2) => {
  if (isHTMLElement$1(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName$1(node2));
}
var isNode$2 = (el2) => isObject$3(el2) && el2.nodeType !== void 0;
var isShadowRoot$1 = (el2) => isNode$2(el2) && el2.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el2;
var isInputElement = (el2) => isHTMLElement$1(el2) && el2.localName === "input";
var isAnchorElement = (el2) => !!el2?.matches("a[href]");
var isElementVisible = (el2) => {
  if (!isHTMLElement$1(el2)) return false;
  return el2.offsetWidth > 0 || el2.offsetHeight > 0 || el2.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el2) {
  if (el2 == null || !isHTMLElement$1(el2)) return false;
  try {
    return isInputElement(el2) && el2.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el2.localName) || el2.isContentEditable || el2.getAttribute("contenteditable") === "true" || el2.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement$1(parent) || !isHTMLElement$1(child)) return false;
  const rootNode = child.getRootNode?.();
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot$1(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) return true;
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getDocument(el2) {
  if (isDocument(el2)) return el2;
  if (isWindow(el2)) return el2.document;
  return el2?.ownerDocument ?? document;
}
function getDocumentElement$1(el2) {
  return getDocument(el2).documentElement;
}
function getWindow$1(el2) {
  if (isShadowRoot$1(el2)) return getWindow$1(el2.host);
  if (isDocument(el2)) return el2.defaultView ?? window;
  if (isHTMLElement$1(el2)) return el2.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el2 = activeElement.shadowRoot.activeElement;
    if (el2 === activeElement) break;
    else activeElement = el2;
  }
  return activeElement;
}
function getParentNode$2(node2) {
  if (getNodeName$1(node2) === "html") return node2;
  const result = node2.assignedSlot || node2.parentNode || isShadowRoot$1(node2) && node2.host || getDocumentElement$1(node2);
  return isShadowRoot$1(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle$2(el2) {
  if (!styleCache.has(el2)) {
    styleCache.set(el2, getWindow$1(el2).getComputedStyle(el2));
  }
  return styleCache.get(el2);
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v2) => isDom() && v2.test(getPlatform());
var ua = (v2) => isDom() && v2.test(getUserAgent());
var vn = (v2) => isDom() && v2.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing;
}
var isLeftClick = (e2) => e2.button === 0;
var isContextMenuEvent = (e2) => {
  return e2.button === 2 || isMac() && e2.ctrlKey && e2.button === 0;
};
var isModifierKey = (e2) => e2.ctrlKey || e2.altKey || e2.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type2 = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type2}X`], y: point[`${type2}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node2 = typeof target === "function" ? target() : target;
  node2?.addEventListener(eventName, handler, options);
  return () => {
    node2?.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el2, options) {
  const { type: type2 = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow$1(el2)[type2].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el2) {
  if (el2.localName === "input") return "HTMLInputElement";
  if (el2.localName === "textarea") return "HTMLTextAreaElement";
  if (el2.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el2, value, property = "value") {
  const type2 = getElementType(el2);
  if (type2) {
    const descriptor = getDescriptor(el2, { type: type2, property });
    descriptor.set?.call(el2, value);
  }
  el2.setAttribute(property, value);
}
function setElementChecked(el2, checked) {
  const descriptor = getDescriptor(el2, { type: "HTMLInputElement", property: "checked" });
  descriptor.set?.call(el2, checked);
  if (checked) el2.setAttribute("checked", "");
  else el2.removeAttribute("checked");
}
function dispatchInputValueEvent(el2, options) {
  const { value, bubbles = true } = options;
  if (!el2) return;
  const win = getWindow$1(el2);
  if (!(el2 instanceof win.HTMLInputElement)) return;
  setElementValue(el2, `${value}`);
  el2.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el2, options) {
  const { checked, bubbles = true } = options;
  if (!el2) return;
  const win = getWindow$1(el2);
  if (!(el2 instanceof win.HTMLInputElement)) return;
  setElementChecked(el2, checked);
  el2.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el2) {
  return isFormElement(el2) ? el2.form : el2.closest("form");
}
function isFormElement(el2) {
  return el2.matches("textarea, input, select, button");
}
function trackFormReset(el2, callback) {
  if (!el2) return;
  const form = getClosestForm(el2);
  const onReset = (e2) => {
    if (e2.defaultPrevented) return;
    callback();
  };
  form?.addEventListener("reset", onReset, { passive: true });
  return () => form?.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el2, callback) {
  const fieldset = el2?.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow$1(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el2, options) {
  if (!el2) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el2, onFormReset), trackFieldsetDisabled(el2, onFieldsetDisabledChange)];
  return () => cleanups2.forEach((cleanup) => cleanup?.());
}
var isFrame = (el2) => isHTMLElement$1(el2) && el2.tagName === "IFRAME";
var hasTabIndex = (el2) => !Number.isNaN(parseInt(el2.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el2) => parseInt(el2.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement$1(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i2) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i2, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  tabbableElements.forEach((element, i2) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i2, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) ;
  return tabbableElements;
}
function isTabbable(el2) {
  if (el2 != null && el2.tabIndex > 0) return true;
  return isFocusable(el2) && !hasNegativeTabIndex(el2);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getTabIndex(node2) {
  if (node2.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node2.localName) || isEditableElement(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root?.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id2 = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id2));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function raf$1(fn) {
  const id2 = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id2);
  };
}
function queueBeforeEvent(el2, type2, cb2) {
  const cancelTimer = raf$1(() => {
    el2.removeEventListener(type2, exec2, true);
    cb2();
  });
  const exec2 = () => {
    cancelTimer();
    cb2();
  };
  el2.addEventListener(type2, exec2, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node2, options) {
  if (!node2) return;
  const { attributes, callback: fn } = options;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node2, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function observeChildrenImpl(node2, options) {
  const { callback: fn } = options;
  if (!node2) return;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node2, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function clickIfLink(el2) {
  const click = () => el2.click();
  if (isFirefox()) {
    queueBeforeEvent(el2, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor$1(el2) {
  const parentNode = getParentNode$2(el2);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) return parentNode;
  return getNearestOverflowAncestor$1(parentNode);
}
function getOverflowAncestors$1(el2, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor$1(el2);
  const isBody = scrollableAncestor === el2.ownerDocument.body;
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement$1(el2) {
  const win = getWindow$1(el2);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el2);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el2) {
  return el2.scrollHeight > el2.clientHeight || el2.scrollWidth > el2.clientWidth;
}
function scrollIntoView(el2, options) {
  const { rootEl, ...scrollOptions } = options;
  if (!el2 || !rootEl) return;
  if (!isOverflowElement$1(rootEl) || !isScrollable(rootEl)) return;
  el2.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset2 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp$2(offset2.x / width), y: clamp$2(offset2.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset2, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported2 = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
  }
  function onPointerError(event) {
    if (isLocked()) ;
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported2) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e2) => e2.key === "Enter"
  } = options;
  if (!pointerNode) return noop$6;
  const win = getWindow$1(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop$6;
  let removeEndListeners = noop$6;
  let removeAccessibleListeners = noop$6;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart?.(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd?.(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress?.(getInfo(endEvent));
      } else {
        onPressEnd?.(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress?.(info);
        onPressEnd?.(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function queryAll(root, selector) {
  return Array.from(root?.querySelectorAll(selector) ?? []);
}
function query(root, selector) {
  return root?.querySelector(selector) ?? null;
}
var defaultItemToId = (v2) => v2.id;
function itemById(v2, id2, itemToId = defaultItemToId) {
  return v2.find((item) => itemToId(item) === id2);
}
function indexOfId(v2, id2, itemToId = defaultItemToId) {
  const item = itemById(v2, id2, itemToId);
  return item ? v2.indexOf(item) : -1;
}
function nextById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  idx = loop ? (idx + 1) % v2.length : Math.min(idx + 1, v2.length - 1);
  return v2[idx];
}
function prevById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  if (idx === -1) return loop ? v2[v2.length - 1] : null;
  idx = loop ? (idx - 1 + v2.length) % v2.length : Math.max(0, idx - 1);
  return v2[idx];
}
function createScope(methods) {
  const dom2 = {
    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => dom2.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom2.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom2.getActiveElement(ctx),
    getById: (ctx, id2) => dom2.getRootNode(ctx).getElementById(id2),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      setElementValue(elem, value.toString());
    }
  };
  return { ...dom2, ...methods };
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el2) => {
  return sanitize(el2.dataset?.valuetext ?? el2.textContent ?? "");
};
var match$2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v2, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v2, currentId, itemToId) : -1;
  let items = currentId ? wrap$3(v2, index) : v2;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match$2(getValueText(item), text));
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set$6(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      elementCleanups.get(key)?.();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set$6(element, "style", setup);
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next2 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update2(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update2("");
        cleanup();
      }, timeout);
    }
  }
  update2(search);
  return next2;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb2) {
  const el2 = query2();
  if (isHTMLElement$1(el2) && el2.isConnected) {
    cb2(el2);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el22 = query2();
      if (isHTMLElement$1(el22) && el22.isConnected) {
        cb2(el22);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb2) {
  const cleanups2 = [];
  queries?.forEach((query2) => {
    const clean = waitForElement(query2, cb2);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue: defaultValue2
  } = options;
  const Context = reactExports.createContext(defaultValue2);
  Context.displayName = name2;
  function useContext$1() {
    const context2 = reactExports.useContext(Context);
    if (!context2 && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context2;
  }
  return [Context.Provider, useContext$1, Context];
}
const [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    for (const ref2 of refs) {
      setRef(ref2, node2);
    }
  };
}
const TRACK_MEMO_SYMBOL = Symbol();
const GET_ORIGINAL_SYMBOL = Symbol();
const AFFECTED_PROPERTY = "a";
const IS_TARGET_COPIED_PROPERTY = "f";
const PROXY_PROPERTY = "p";
const PROXY_CACHE_PROPERTY = "c";
const TARGET_CACHE_PROPERTY = "t";
const HAS_KEY_PROPERTY = "h";
const ALL_OWN_KEYS_PROPERTY = "w";
const HAS_OWN_KEY_PROPERTY = "o";
const KEYS_PROPERTY = "k";
let newProxy = (target, handler) => new Proxy(target, handler);
const getProto$2 = Object.getPrototypeOf;
const objectsToTrack = /* @__PURE__ */ new WeakMap();
const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto$2(obj) === Object.prototype || getProto$2(obj) === Array.prototype);
const isObject$2 = (x2) => typeof x2 === "object" && x2 !== null;
const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
const copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto$2(obj), descriptors);
};
const createProxyHandler = (origObj, isTargetCopied) => {
  const state = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type2, key) => {
    if (!trackObject) {
      let used = state[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type2 === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set2 = used[type2];
        if (!set2) {
          set2 = /* @__PURE__ */ new Set();
          used[type2] = set2;
        }
        set2.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy$2(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state];
};
const getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
const createProxy$2 = (obj, affected, proxyCache, targetCache2) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache2 && targetCache2.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
  return handlerAndState[1][PROXY_PROPERTY];
};
const isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k2, i2) => k2 !== nextKeys[i2]);
};
const isChanged = (prevObj, nextObj, affected, cache2, isEqual2 = Object.is) => {
  if (isEqual2(prevObj, nextObj)) {
    return false;
  }
  if (!isObject$2(prevObj) || !isObject$2(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache2) {
    const hit = cache2.get(prevObj);
    if (hit === nextObj) {
      return false;
    }
    cache2.set(prevObj, nextObj);
  }
  let changed = null;
  for (const key of used[HAS_KEY_PROPERTY] || []) {
    changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
    if (changed)
      return changed;
  }
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    changed = isAllOwnKeysChanged(prevObj, nextObj);
    if (changed)
      return changed;
  } else {
    for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
      const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
      const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
      changed = hasPrev !== hasNext;
      if (changed)
        return changed;
    }
  }
  for (const key of used[KEYS_PROPERTY] || []) {
    changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual2);
    if (changed)
      return changed;
  }
  if (changed === null)
    throw new Error("invalid used");
  return changed;
};
const getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
const markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g2 = glob();
  if (!g2) return value();
  g2[key] || (g2[key] = value());
  return g2[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2 && "props" in x2;
var isVueElement = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
var isDOMElement = (x2) => typeof x2 === "object" && x2 !== null && "nodeType" in x2 && typeof x2.nodeName === "string";
var isElement$2 = (x2) => isReactElement(x2) || isVueElement(x2) || isDOMElement(x2);
var isObject$1 = (x2) => x2 !== null && typeof x2 === "object";
var canProxy = (x2) => isObject$1(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !isElement$2(x2) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer) && !(x2 instanceof Promise);
function set$5(obj, key, val) {
  if (typeof val.value === "object" && !canProxy(val.value)) val.value = clone$1(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function clone$1(x2) {
  if (typeof x2 !== "object") return x2;
  var i2 = 0, k2, list, tmp, str = Object.prototype.toString.call(x2);
  if (str === "[object Object]") {
    tmp = Object.create(Object.getPrototypeOf(x2) || null);
  } else if (str === "[object Array]") {
    tmp = Array(x2.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x2.forEach(function(val) {
      tmp.add(clone$1(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x2.forEach(function(val, key) {
      tmp.set(clone$1(key), clone$1(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x2);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x2.source, x2.flags);
  } else if (str === "[object DataView]") {
    tmp = new x2.constructor(clone$1(x2.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x2.slice(0);
  } else if (str === "[object Blob]") {
    tmp = x2.slice();
  } else if (str.slice(-6) === "Array]") {
    tmp = new x2.constructor(x2);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x2); i2 < list.length; i2++) {
      set$5(tmp, list[i2], Object.getOwnPropertyDescriptor(x2, list[i2]));
    }
    for (i2 = 0, list = Object.getOwnPropertyNames(x2); i2 < list.length; i2++) {
      if (Object.hasOwnProperty.call(tmp, k2 = list[i2]) && tmp[k2] === x2[k2]) continue;
      set$5(tmp, k2, Object.getOwnPropertyDescriptor(x2, k2));
    }
  }
  return tmp || x2;
}
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {
  const cache2 = snapCache.get(target);
  if (cache2?.[0] === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject$1(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener3) => listener3(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (listeners.size) {
      const remove2 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove2]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      entry[1]?.();
    }
  };
  const addListener = (listener3) => {
    listeners.add(listener3);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        const remove2 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove2]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener3);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove2], prop) => {
          if (remove2) {
            remove2();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$1(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe$1(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  let promise2;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener3 = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise2) {
      promise2 = Promise.resolve().then(() => {
        promise2 = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener3);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref$1(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get: get2, set: set2 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get2(snapshot(proxyObject));
    if (set2) {
      desc.set = (newValue) => set2(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}
var first = (v2) => v2[0];
var last = (v2) => v2[v2.length - 1];
var has$4 = (v2, t2) => v2.indexOf(t2) !== -1;
var add$1 = (v2, ...items) => v2.concat(items);
var remove$2 = (v2, ...items) => v2.filter((t2) => !items.includes(t2));
var addOrRemove = (v2, item) => {
  if (has$4(v2, item)) return remove$2(v2, item);
  return add$1(v2, item);
};
function clear(v2) {
  while (v2.length > 0) v2.pop();
  return v2;
}
var isArrayLike$1 = (value) => value?.constructor.name === "Array";
var isArrayEqual$1 = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (!isEqual$1(a2[i2], b2[i2])) return false;
  }
  return true;
};
var isEqual$1 = (a2, b2) => {
  if (Object.is(a2, b2)) return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null) return false;
  if (typeof a2?.isEqual === "function" && typeof b2?.isEqual === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike$1(a2) && isArrayLike$1(b2)) {
    return isArrayEqual$1(Array.from(a2), Array.from(b2));
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const hasKey = Reflect.has(a2, keys[i2]);
    if (!hasKey) return false;
  }
  for (let i2 = 0; i2 < length2; i2++) {
    const key = keys[i2];
    if (!isEqual$1(a2[key], b2[key])) return false;
  }
  return true;
};
var runIfFn = (v2, ...a2) => {
  const res = typeof v2 === "function" ? v2(...a2) : v2;
  return res ?? void 0;
};
var cast = (v2) => v2;
var noop$5 = () => {
};
var callAll = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn?.(...a2);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id2 = 0;
  return () => {
    id2++;
    return id2.toString(36);
  };
})();
var isArray$4 = (v2) => Array.isArray(v2);
var isObjectLike = (v2) => v2 != null && typeof v2 === "object";
var isObject = (v2) => isObjectLike(v2) && !isArray$4(v2);
var isNumber$1 = (v2) => typeof v2 === "number" && !Number.isNaN(v2);
var isString$1 = (v2) => typeof v2 === "string";
var isFunction$1 = (v2) => typeof v2 === "function";
var isNull = (v2) => v2 == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v2) => Object.prototype.toString.call(v2);
var fnToString$1 = Function.prototype.toString;
var objectCtorString = fnToString$1.call(Object);
var isPlainObject$1 = (v2) => {
  if (!isObjectLike(v2) || baseGetTag(v2) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v2);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString$1.call(Ctor) == objectCtorString;
};
var { floor: floor$3, abs: abs$2, round: round$4, min: min$3, max: max$3, pow: pow$2, sign: sign$4 } = Math;
var isNaN$1 = (v2) => Number.isNaN(v2);
var nan = (v2) => isNaN$1(v2) ? 0 : v2;
var wrap$2 = (v2, vmax) => (v2 % vmax + vmax) % vmax;
var isValueAtMax = (v2, vmax) => nan(v2) >= vmax;
var isValueAtMin = (v2, vmin) => nan(v2) <= vmin;
var isValueWithinRange = (v2, vmin, vmax) => nan(v2) >= vmin && nan(v2) <= vmax;
var roundValue = (v2, vmin, step) => round$4((nan(v2) - vmin) / step) * step + vmin;
var clampValue = (v2, vmin, vmax) => min$3(max$3(nan(v2), vmin), vmax);
var getValuePercent = (v2, vmin, vmax) => (nan(v2) - vmin) / (vmax - vmin);
var getPercentValue = (p2, vmin, vmax, step) => clampValue(roundValue(p2 * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToDpr = (v2, dpr) => typeof dpr === "number" ? floor$3(v2 * dpr + 0.5) / dpr : round$4(v2);
var getValueTransformer = (va2, vb2) => {
  const [a2, b2] = va2;
  const [c2, d2] = vb2;
  return (v2) => a2 === b2 || c2 === d2 ? c2 : c2 + (d2 - c2) / (b2 - a2) * (v2 - a2);
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e2 = 1, p2 = 0;
  while (Math.round(value * e2) / e2 !== value) {
    e2 *= 10;
    p2 += 1;
  }
  return p2;
};
var decimalOp = (a2, op, b2) => {
  let result = op === "+" ? a2 + b2 : a2 - b2;
  if (a2 % 1 !== 0 || b2 % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a2), countDecimals(b2));
    a2 = Math.round(a2 * multiplier);
    b2 = Math.round(b2 * multiplier);
    result = op === "+" ? a2 + b2 : a2 - b2;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v2, s2) => decimalOp(nan(v2), "+", s2);
var decrementValue = (v2, s2) => decimalOp(nan(v2), "-", s2);
function compact$2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact$2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v2) => {
  return v2 && typeof v2 === "object" && v2.constructor === Object;
};
function warn(...a2) {
  a2.length === 1 ? a2[0] : a2[1];
  a2.length === 2 ? a2[0] : true;
}
function invariant(...a2) {
  a2.length === 1 ? a2[0] : a2[1];
  a2.length === 2 ? a2[0] : true;
}
var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact$2(obj);
    for (const key in target) {
      if (isPlainObject$1(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function toEvent(event) {
  const obj = isString$1(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value) return [];
  return isArray$4(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    if (isString$1(guard)) {
      return !!guardMap[guard]?.(ctx, event, meta);
    }
    if (isFunction$1(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or$2(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and$4(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not$6(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or: or$2, and: and$4, not: not$6, stateIn };
function choose(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => actions.find((def) => {
      const guard = def.guard ?? Truthy;
      return exec(guardMap, ctx, event, meta)(guard);
    })?.actions
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context2, event, meta) => {
    if (isString$1(guard)) {
      const value = guardMap[guard];
      return isFunction$1(value) ? value(context2, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context2, event, meta);
    }
    return guard?.(context2, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context2, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context2, event, meta);
    }
    return values;
  };
}
function createProxy$1(config2) {
  const computedContext = config2.computed ?? cast({});
  const initialContext = config2.context ?? cast({});
  const initialTags = config2.initial ? config2.states?.[config2.initial]?.tags : [];
  const state = proxy({
    value: config2.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      const stateEvents = config2.states?.[this.value]?.["on"] ?? {};
      const globalEvents = config2?.on ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state);
}
function determineDelayFn(delay2, delaysMap) {
  return (context2, event) => {
    if (isNumber$1(delay2)) return delay2;
    if (isFunction$1(delay2)) {
      return delay2(context2, event);
    }
    if (isString$1(delay2)) {
      const value = Number.parseFloat(delay2);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap?.[delay2];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay2}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction$1(valueOrFn) ? valueOrFn(context2, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString$1(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context2, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context2, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config2, options) {
    __publicField$3(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField$3(this, "state");
    __publicField$3(this, "initialState");
    __publicField$3(this, "initialContext");
    __publicField$3(this, "id");
    __publicField$3(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField$3(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField$3(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField$3(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField$3(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField$3(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField$3(this, "removeStateListener", noop$5);
    __publicField$3(this, "parent");
    __publicField$3(this, "children", /* @__PURE__ */ new Map());
    __publicField$3(this, "guardMap");
    __publicField$3(this, "actionMap");
    __publicField$3(this, "delayMap");
    __publicField$3(this, "activityMap");
    __publicField$3(this, "sync");
    __publicField$3(this, "options");
    __publicField$3(this, "config");
    __publicField$3(this, "_created", () => {
      if (!this.config.created) return;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions(this.config.created, event);
    });
    __publicField$3(this, "start", (init2) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe$1(
        this.state,
        () => {
          this.stateListeners.forEach((listener3) => {
            listener3(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject(init2) ? init2.value : init2;
      const context2 = isObject(init2) ? init2.context : void 0;
      if (context2) {
        this.setContext(context2);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next2 = this.getNextStateInfo(transition, event);
      this.initialState = next2;
      this.performStateChangeEffects(this.state.value, next2, event);
      return this;
    });
    __publicField$3(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev2 = snapshot(this.state.context);
      const cleanup = subscribe$1(this.state.context, () => {
        const next2 = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual2 = this.options.compareFns?.[key] ?? Object.is;
          if (isEqual2(prev2[key], next2[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev2 = next2;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField$3(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField$3(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField$3(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField$3(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state) => {
        state.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField$3(this, "stopActivities", (state) => {
      if (state) {
        this.activityEvents.get(state)?.forEach((stop) => stop());
        this.activityEvents.get(state)?.clear();
        this.activityEvents.delete(state);
      } else {
        this.activityEvents.forEach((state2) => {
          state2.forEach((stop) => stop());
          state2.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField$3(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id2 = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id2);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField$3(this, "stopChild", (id2) => {
      if (!this.children.has(id2)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id2}`);
      }
      this.children.get(id2).stop();
      this.children.delete(id2);
    });
    __publicField$3(this, "removeChild", (id2) => {
      this.children.delete(id2);
    });
    __publicField$3(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField$3(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField$3(this, "spawn", (src, id2) => {
      const actor = runIfFn(src);
      if (id2) actor.id = id2;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref$1(actor));
    });
    __publicField$3(this, "stopActivity", (key) => {
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      cleanups2?.get(key)?.();
      cleanups2?.delete(key);
    });
    __publicField$3(this, "addActivityCleanup", (state, key, cleanup) => {
      if (!state) return;
      if (!this.activityEvents.has(state)) {
        this.activityEvents.set(state, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        this.activityEvents.get(state)?.set(key, cleanup);
      }
    });
    __publicField$3(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode?.tags);
      }
    });
    __publicField$3(this, "setContext", (context2) => {
      if (!context2) return;
      deepMerge(this.state.context, compact$2(context2));
    });
    __publicField$3(this, "setOptions", (options2) => {
      const opts = compact$2(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField$3(this, "getStateNode", (state) => {
      if (!state) return;
      return this.config.states?.[state];
    });
    __publicField$3(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !transition?.target;
      const target = transition?.target ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !transition?.internal;
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField$3(this, "getAfterActions", (transition, delay2) => {
      let id2;
      const current = this.state.value;
      return {
        entry: () => {
          id2 = globalThis.setTimeout(() => {
            const next2 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next2, this.state.event);
          }, delay2);
        },
        exit: () => {
          globalThis.clearTimeout(id2);
        }
      };
    });
    __publicField$3(this, "getDelayedEventActions", (state) => {
      const stateNode = this.getStateNode(state);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray$4(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject(stateNode.after)) {
        for (const delay2 in stateNode.after) {
          const transition = stateNode.after[delay2];
          const determineDelay = determineDelayFn(delay2, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField$3(this, "executeActions", (actions, event) => {
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray(pickedActions)) {
        const fn = isString$1(action) ? this.actionMap?.[action] : action;
        warn(
          isString$1(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn?.(this.state.context, event, this.meta);
      }
    });
    __publicField$3(this, "executeActivities", (event, activities, state) => {
      for (const activity of activities) {
        const fn = isString$1(activity) ? this.activityMap?.[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString$1(activity) ? activity : activity.name || uuid();
          this.addActivityCleanup(state ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField$3(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray$4(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay2 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id2 = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay2);
          return () => {
            globalThis.clearInterval(id2);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every?.[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay2 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id2 = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay2);
            return () => {
              globalThis.clearInterval(id2);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField$3(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref$1(toEvent(event));
    });
    __publicField$3(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField$3(this, "performEntryEffects", (next2, event) => {
      const stateNode = this.getStateNode(next2);
      const activities = toArray(stateNode?.activities);
      this.createEveryActivities(stateNode?.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray(pickedActions);
      const afterActions = this.getDelayedEventActions(next2);
      if (stateNode?.after && afterActions) {
        this.delayedEvents.set(next2, afterActions?.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if (stateNode?.type === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener3) => {
          listener3(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField$3(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition?.actions, event);
    });
    __publicField$3(this, "performStateChangeEffects", (current, next2, event) => {
      this.setEvent(event);
      const changed = next2.changed || next2.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next2.transition, event);
      this.setState(next2.target);
      if (changed) {
        this.performEntryEffects(next2.target, event);
      }
    });
    __publicField$3(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn?.(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField$3(this, "sendParent", (evt) => {
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      this.parent?.send(event);
    });
    __publicField$3(this, "log", (...args) => {
    });
    __publicField$3(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField$3(this, "transition", (state, evt) => {
      const stateNode = isString$1(state) ? this.getStateNode(state) : state?.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state}, \`event\`: ${event.type}`;
        warn(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        stateNode?.on?.[event.type] ?? this.config.on?.[event.type]
      );
      const next2 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next2, event);
      return next2.stateNode;
    });
    __publicField$3(this, "subscribe", (listener3) => {
      this.stateListeners.add(listener3);
      if (this.status === "Running") {
        listener3(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener3);
      };
    });
    __publicField$3(this, "onDone", (listener3) => {
      this.doneListeners.add(listener3);
      return this;
    });
    __publicField$3(this, "onTransition", (listener3) => {
      this.stateListeners.add(listener3);
      if (this.status === "Running") {
        listener3(this.stateSnapshot);
      }
      return this;
    });
    this.config = clone$1(config2);
    this.options = clone$1(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = this.options?.guards ?? {};
    this.actionMap = this.options?.actions ?? {};
    this.delayMap = this.options?.delays ?? {};
    this.activityMap = this.options?.activities ?? {};
    this.sync = this.options?.sync ?? false;
    this.state = createProxy$1(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        return self2.initialState?.target ?? "";
      }
    };
  }
  get meta() {
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: this.initialState?.target ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state = this.getState();
    return {
      value: state.value,
      tags: state.tags
    };
  }
};
var createMachine = (config2, options) => new Machine(config2, options);
var isMachine = (value) => {
  return value instanceof Machine || value?.type === "machine";
};
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX.exec(style)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css$1 = (a2, b2) => {
  if (isString$1(a2)) {
    if (isString$1(b2)) return `${a2};${b2}`;
    a2 = serialize(a2);
  } else if (isString$1(b2)) {
    b2 = serialize(b2);
  }
  return Object.assign({}, a2 ?? {}, b2 ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll(props[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css$1(result[key], props[key]);
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
function getRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const withAsChild = (Component) => {
  const Comp = reactExports.memo(
    reactExports.forwardRef((props, ref2) => {
      const { asChild, children, ...restProps } = props;
      if (!asChild) {
        return reactExports.createElement(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = reactExports.Children.only(children);
      if (!reactExports.isValidElement(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return reactExports.cloneElement(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
const jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
const ark = jsxFactory();
const createSplitProps = () => (props, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props }]
);
const splitPresenceProps = (props) => createSplitProps()(props, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps$1 = () => (props) => Array.from(new Set(props));
function connect$9(state, send, _normalize) {
  const present = state.matches("mounted", "unmountSuspended");
  return {
    skip: !state.context.initial && present,
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function machine$8(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial", "cleanupNode"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          after: {
            // Fallback to timeout to ensure we exit this state even if the `animationend` event
            // did not get trigger
            ANIMATION_DURATION: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          },
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      delays: {
        ANIMATION_DURATION(ctx2) {
          return parseMs(ctx2.styles?.animationDuration) + parseMs(ctx2.styles?.animationDelay) + ANIMATION_TIMEOUT_MARGIN;
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        cleanupNode(ctx2) {
          ctx2.node = null;
          ctx2.styles = null;
        },
        invokeOnExitComplete(ctx2) {
          ctx2.onExitComplete?.();
        },
        setNode(ctx2, evt) {
          ctx2.node = ref$1(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref$1(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          if (!ctx2.present && ctx2.node?.ownerDocument.visibilityState === "hidden") {
            send({ type: "UNMOUNT", src: "visibilitychange" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ctx2.styles?.display === "none" || ctx2.styles?.animationDuration === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node2 = ctx2.node;
          if (!node2) return;
          const onStart = (event) => {
            const target = event.composedPath?.()?.[0] ?? event.target;
            if (target === node2) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            const animationName = getAnimationName(ctx2.styles);
            const target = event.composedPath?.()?.[0] ?? event.target;
            if (target === node2 && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onEnd);
          node2.addEventListener("animationend", onEnd);
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onEnd);
            node2.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
function getAnimationName(styles2) {
  return styles2?.animationName || "none";
}
function parseMs(value) {
  return parseFloat(value || "0") * 1e3;
}
var ANIMATION_TIMEOUT_MARGIN = 16.667;
createProps$1()(["onExitComplete", "present", "immediate"]);
var normalizeProps = createNormalizer((v2) => v2);
var isArrayLike = (value) => value?.constructor.name === "Array";
var isArrayEqual = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (!isEqual(a2[i2], b2[i2])) return false;
  }
  return true;
};
var isEqual = (a2, b2) => {
  if (Object.is(a2, b2)) return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null) return false;
  if (typeof a2?.isEqual === "function" && typeof b2?.isEqual === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike(a2) && isArrayLike(b2)) {
    return isArrayEqual(Array.from(a2), Array.from(b2));
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const hasKey = Reflect.has(a2, keys[i2]);
    if (!hasKey) return false;
  }
  for (let i2 = 0; i2 < length2; i2++) {
    const key = keys[i2];
    if (!isEqual(a2[key], b2[key])) return false;
  }
  return true;
};
var fnToString = Function.prototype.toString;
fnToString.call(Object);
function compact$1(obj) {
  if (!isPlainObject(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact$1(value);
    }
  }
  return filtered;
}
var isPlainObject = (v2) => {
  return v2 && typeof v2 === "object" && v2.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = reactExports.useRef(false);
  const effect = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  reactExports.useEffect(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var targetCache = globalRef("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context: context2, sync: notifyInSync } = options ?? {};
  const lastSnapshot = reactExports.useRef(void 0);
  const lastAffected = reactExports.useRef(void 0);
  const currSnapshot = reactExports.useSyncExternalStore(
    reactExports.useCallback((callback) => subscribe$1(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state)
  );
  service.setOptions({ actions });
  const ctx = reactExports.useMemo(() => compact$1(context2 ?? {}), [context2]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  reactExports.useEffect(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = reactExports.useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy$2(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state = useSnapshot(service);
  return [state, service.send];
}
function useConstant(fn) {
  const ref2 = reactExports.useRef(void 0);
  if (!ref2.current) ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useService(machine2, options) {
  const { state: hydratedState, context: context2 } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine2 === "function" ? machine2() : machine2;
    if (context2) instance.setContext(context2);
    instance._created();
    return instance;
  });
  const snapshotRef = reactExports.useRef(void 0);
  useSafeLayoutEffect$1(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine2, options) {
  const service = useService(machine2, options);
  const state = useSnapshot(service, options);
  return [state, service.send, service];
}
function useEvent(callback, opts = {}) {
  const { sync: sync2 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return reactExports.useCallback(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      if (sync2) return queueMicrotask(() => callbackRef.current?.(...args));
      return callbackRef.current?.(...args);
    },
    [sync2, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = reactExports.useRef(value);
  ref2.current = value;
  return ref2;
}
const usePresence = (props) => {
  const { lazyMount, unmountOnExit, present, ...rest } = props;
  const wasEverPresent = reactExports.useRef(false);
  const context2 = {
    ...rest,
    present,
    onExitComplete: useEvent(props.onExitComplete)
  };
  const [state, send] = useMachine(machine$8(context2), { context: context2 });
  const api = connect$9(state, send);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};
const [PresenceProvider, usePresenceContext] = createContext({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});
function useCallbackRef(callback, deps = []) {
  const callbackRef = reactExports.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  reactExports.useInsertionEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useCallback((...args) => callbackRef.current?.(...args), deps);
}
function useDisclosure(props = {}) {
  const { onClose: onCloseProp, onOpen: onOpenProp, open: openProp } = props;
  const handleOpen = useCallbackRef(onOpenProp);
  const handleClose = useCallbackRef(onCloseProp);
  const [openState, setopen] = reactExports.useState(props.defaultOpen || false);
  const open = openProp !== void 0 ? openProp : openState;
  const isControlled = openProp !== void 0;
  const onClose = reactExports.useCallback(() => {
    if (!isControlled) {
      setopen(false);
    }
    handleClose?.();
  }, [isControlled, handleClose]);
  const onOpen = reactExports.useCallback(() => {
    if (!isControlled) {
      setopen(true);
    }
    handleOpen?.();
  }, [isControlled, handleOpen]);
  const onToggle = reactExports.useCallback(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle
  };
}
const colorMix = (value, token2) => {
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = token2.raw(`opacity.${rawOpacity}`)?.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
const createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};
function clone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone(obj[key]);
  }
  return _clone;
}
function merge$1(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject$4(target[key]) && isObject$4(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject$4(source[key])) {
      merge$1(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i2 = 0;
      for (; i2 < source[key].length; i2++) {
        if (isObject$4(target[key][i2]) && isObject$4(source[key][i2])) {
          merge$1(target[key][i2], source[key][i2]);
        } else {
          target[key][i2] = source[key][i2];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge$1(target, source);
  }
  return target;
}
const defineConditions = (v2) => v2;
const defineRecipe = (v2) => v2;
const defineSlotRecipe = (v2) => v2;
const defineKeyframes = (v2) => v2;
const defineGlobalStyles = (v2) => v2;
const defineStyle = (v2) => v2;
const defineTextStyles = (v2) => v2;
const defineAnimationStyles = (v2) => v2;
const defineLayerStyles = (v2) => v2;
function createProxy() {
  const identity2 = (v2) => v2;
  return new Proxy(identity2, {
    get() {
      return identity2;
    }
  });
}
const defineTokens = /* @__PURE__ */ createProxy();
const defineSemanticTokens = /* @__PURE__ */ createProxy();
const defineConfig = (v2) => v2;
const mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone));
};
const escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc$1(string) {
  return `${string}`.replace(escRegex, (s2) => `\\${s2}`);
}
const dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match2) => `-${match2.toLowerCase()}`);
}
function cssVar(name2, options = {}) {
  const { fallback: fallback2 = "", prefix: prefix2 = "" } = options;
  const variable = dashCase(["-", prefix2, esc$1(name2)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback2 ? `, ${fallback2}` : ""})`
  };
}
const isCssVar = (v2) => /^var\(--.+\)$/.test(v2);
const wrap$1 = (str, v2) => v2 != null ? `${str}(${v2})` : v2;
const deg = (v2) => {
  if (isCssVar(v2) || v2 == null) return v2;
  const unitless = typeof v2 === "string" && !v2.endsWith("deg");
  return typeof v2 === "number" || unitless ? `${v2}deg` : v2;
};
const createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles2 = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles2[value] ?? {};
    }
  };
};
const divideColor = createColorMixTransform("borderColor");
const createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
const defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
const currentBgVar = cssVar("bg-currentcolor");
const isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
const colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
const defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj?.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj?.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles2 = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles2,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: { values: "gradients", shorthand: ["bgImg", "bgImage"] },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { filter: v2 };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v2) => ({ "--blur": wrap$1("blur", v2) })
    },
    brightness: {
      transform: (v2) => ({ "--brightness": wrap$1("brightness", v2) })
    },
    contrast: {
      transform: (v2) => ({ "--contrast": wrap$1("contrast", v2) })
    },
    grayscale: {
      transform: (v2) => ({ "--grayscale": wrap$1("grayscale", v2) })
    },
    hueRotate: {
      transform: (v2) => ({ "--hue-rotate": wrap$1("hue-rotate", deg(v2)) })
    },
    invert: { transform: (v2) => ({ "--invert": wrap$1("invert", v2) }) },
    saturate: {
      transform: (v2) => ({ "--saturate": wrap$1("saturate", v2) })
    },
    sepia: { transform: (v2) => ({ "--sepia": wrap$1("sepia", v2) }) },
    dropShadow: {
      transform: (v2) => ({ "--drop-shadow": wrap$1("drop-shadow", v2) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { backdropFilter: v2 };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v2) => ({ "--backdrop-blur": wrap$1("blur", v2) })
    },
    backdropBrightness: {
      transform: (v2) => ({
        "--backdrop-brightness": wrap$1("brightness", v2)
      })
    },
    backdropContrast: {
      transform: (v2) => ({ "--backdrop-contrast": wrap$1("contrast", v2) })
    },
    backdropGrayscale: {
      transform: (v2) => ({
        "--backdrop-grayscale": wrap$1("grayscale", v2)
      })
    },
    backdropHueRotate: {
      transform: (v2) => ({
        "--backdrop-hue-rotate": wrap$1("hue-rotate", deg(v2))
      })
    },
    backdropInvert: {
      transform: (v2) => ({ "--backdrop-invert": wrap$1("invert", v2) })
    },
    backdropOpacity: {
      transform: (v2) => ({ "--backdrop-opacity": wrap$1("opacity", v2) })
    },
    backdropSaturate: {
      transform: (v2) => ({ "--backdrop-saturate": wrap$1("saturate", v2) })
    },
    backdropSepia: {
      transform: (v2) => ({ "--backdrop-sepia": wrap$1("sepia", v2) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v2) => ({ "--focus-ring-offset": v2 })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v2) => ({ "--focus-ring-width": v2 })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v2) => ({ "--focus-ring-style": v2 })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v2) => ({ width: v2, height: v2 })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v2) {
        switch (v2) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginLeft: v2, scrollMarginRight: v2 })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginTop: v2, scrollMarginBottom: v2 })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v2) => ({ "--scroll-snap-strictness": v2 })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v2) => ({ "--ring-inset": v2 })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing", shorthand: ["mt"] },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v2 = value;
        if (value === "auto") {
          v2 = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v2 = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v2 };
      }
    },
    skewX: { transform: (v2) => ({ "--skew-x": deg(v2) }) },
    skewY: { transform: (v2) => ({ "--skew-y": deg(v2) }) },
    scaleX: { transform: (v2) => ({ "--scale-x": v2 }) },
    scaleY: { transform: (v2) => ({ "--scale-y": v2 }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v2} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v2} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v2} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v2} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v2) => ({ "--translate-x": v2 })
    },
    translateY: {
      values: "spacing",
      transform: (v2) => ({ "--translate-y": v2 })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
const srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo$1(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = /* @__PURE__ */ memo$1((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});
const isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path2 = []) {
    if (isObject$4(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = getKey?.(prop, child) ?? prop;
        const childPath = [...path2, key];
        if (stop?.(value, childPath)) {
          return predicate(value, path2);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path2);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject$4(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}
const memo = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get2(...args) {
    const key = JSON.stringify(args);
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get2;
};
const BASE_FONT_SIZE = 16;
const UNIT_PX = "px";
const UNIT_EM = "em";
const UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit?.[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}
const capitalize$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get2(name2) {
    return values[name2];
  }
  function only(name2) {
    return build$1(get2(name2));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name2) => {
      const value = get2(name2);
      const down2 = [
        `${name2}Down`,
        build$1({ max: adjust(value.min) })
      ];
      const up2 = [name2, build$1({ min: value.min })];
      const _only = [`${name2}Only`, only(name2)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min2, max2]) => {
        const minValue = get2(min2);
        const maxValue2 = get2(max2);
        return [
          `${min2}To${capitalize$1(max2)}`,
          build$1({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name2) {
    return build$1({ min: get2(name2).min });
  }
  function down(name2) {
    return build$1({ max: adjust(get2(name2).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name2, min2], index, entries2) => {
    let max2 = null;
    if (index <= entries2.length - 1) {
      max2 = entries2[index + 1]?.[1];
    }
    if (max2 != null) {
      max2 = adjust(max2);
    }
    return [name2, { name: name2, min: toRem(min2), max: max2 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build$1({ min: min2, max: max2 }) {
  if (min2 == null && max2 == null) return "";
  return [
    "@media screen",
    min2 && `(min-width: ${min2})`,
    max2 && `(max-width: ${max2})`
  ].filter(Boolean).join(" and ");
}
const mapEntries$1 = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
const createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries$1(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v2) => v2 !== "base").sort((a2, b2) => {
      const aa2 = has2(a2);
      const bb2 = has2(b2);
      if (aa2 && !bb2) return 1;
      if (!aa2 && bb2) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve2(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve: resolve2,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};
const createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
const widthRegex = createMediaQueryRegex("width");
const heightRegex = createMediaQueryRegex("height");
const createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
const { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
const { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
const isPrint = /print/i;
const isPrintOnly = /^print$/i;
const isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
const lengthExec = /(\d)/;
const maxValue = Number.MAX_VALUE;
const multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length2 = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a2, b2) {
  const isPrintA = isPrint.test(a2), isPrintOnlyA = isPrintOnly.test(a2);
  const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a2.localeCompare(b2);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
const sortAtParams = memo((a2, b2) => {
  const testIsPrint = _testIsPrint(a2, b2);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a2) || isMinHeight(a2), maxA = isMaxWidth(a2) || isMaxHeight(a2);
  const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a2), lengthB = getQueryLength(b2);
  if (lengthA === maxValue && lengthB === maxValue) return a2.localeCompare(b2);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a2.localeCompare(b2);
});
function sortQueries(queries) {
  return queries.sort(([a2], [b2]) => sortAtParams(a2, b2));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject$4(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}
const importantRegex = /\s*!(important)?/i;
const isImportant = (v2) => isString$2(v2) ? importantRegex.test(v2) : false;
const withoutImportant = (v2) => isString$2(v2) ? v2.replace(importantRegex, "").trim() : v2;
function createCssFn(context2) {
  const { transform: transform2, conditions, normalize: normalize2 } = context2;
  const mergeFn = mergeCss(context2);
  return memo((...styleArgs) => {
    const styles2 = mergeFn(...styleArgs);
    const normalized = normalize2(styles2);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v2) => isString$2(v2) && important ? `${v2} !important` : v2,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path2 of paths) {
    if (!path2) continue;
    if (!acc[path2]) acc[path2] = /* @__PURE__ */ Object.create(null);
    acc = acc[path2];
  }
  mergeWith(acc, value);
}
function compactFn(...styles2) {
  return styles2.filter(
    (style) => isObject$4(style) && Object.keys(compact$3(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve2(styles2) {
    const comp = compactFn(...styles2);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo((...styles2) => {
    return mergeWith({}, ...resolve2(styles2));
  });
}
function omit(object, keysToOmit = []) {
  const clone2 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone2) {
      delete clone2[key];
    }
  }
  return clone2;
}
const uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};
const defaults$2 = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize2, layers } = options;
  function cva(config2 = {}) {
    const { base, variants: variants2, defaultVariants: defaultVariants2, compoundVariants } = defaults$2(config2);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        return variants2[prop]?.[value];
      }
    });
    const resolve2 = (props = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants2,
        ...compact$3(props)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants2);
    const splitVariantProps = (props) => {
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || defaultVariants2.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props) => css2(resolve2(props));
    return Object.assign(cvaFn, {
      className: config2.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve2,
      config: config2,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva(opts) {
  const { css: css2 } = opts;
  return function mergeCva2(cvaA, cvaB) {
    const override = defaults$2(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants2 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants2 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants2,
      defaultVariants: defaultVariants2,
      compoundVariants
    };
  };
}
const defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
const layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config2) {
  const layers = config2.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a2, b2) => layerOrder[a2] - layerOrder[b2]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles2) {
      if (config2.disableLayers) return styles2;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles2 };
    }
  };
}
function createNormalizeFn(context2) {
  const { utility, normalize: normalize2 } = context2;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles2) {
    return walkObject(styles2, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject$4(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k2, v2]) => {
      acc[k2] = { [selector]: v2 };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize2(styles2) {
    return walkObject(styles2, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject$4(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s2) => "&" + s2).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i2 = 0; i2 < selector.length; i2++) {
    const char2 = selector[i2];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}
const getSlotRecipes = (config2 = {}) => {
  const init2 = (slot) => ({
    base: config2.base?.[slot] ?? {},
    variants: {},
    defaultVariants: config2.defaultVariants ?? {},
    compoundVariants: config2.compoundVariants ? getSlotCompoundVariant(config2.compoundVariants, slot) : []
  });
  const slots = config2.slots ?? [];
  const entries = slots.map((slot) => [slot, init2(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config2.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a2;
        (_a2 = slotRecipe.variants)[variantsKey] ?? (_a2[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
const getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config2 = {}) {
    const slots = Object.entries(getSlotRecipes(config2)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props)]);
      return Object.fromEntries(result);
    }
    const variants2 = config2.variants ?? {};
    const variantKeys = Object.keys(variants2);
    function splitVariantProps(props) {
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || config2.defaultVariants?.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config2.className) {
      classNameMap = Object.fromEntries(
        config2.slots.map((slot) => [
          slot,
          `${config2.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}
const createProps = () => (props) => Array.from(new Set(props));
const rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
const fcssescape = function(ch2, asCodePoint) {
  if (!asCodePoint) return "\\" + ch2;
  if (ch2 === "\0") return "�";
  if (ch2 === "-" && ch2.length === 1) return "\\-";
  return ch2.slice(0, -1) + "\\" + ch2.charCodeAt(ch2.length - 1).toString(16);
};
const esc = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};
const expandTokenReferences = (str, resolve2) => {
  let expanded = "";
  let index = 0;
  let state = "char";
  let tokenPath = "";
  let fallback2 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path2 = str.slice(index + 1, endIndex);
      const resolved = resolve2(path2);
      expanded += resolved ?? path2;
      index = endIndex + 1;
      continue;
    }
    if (state === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state = "fallback";
        currentStates.push(state);
        const resolved = resolve2(tokenPath);
        if (resolved?.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback2 = "";
        continue;
      }
    }
    if (state === "fallback") {
      const nextFallback = fallback2 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state = currentStates.pop() ?? state;
        fallback2 = "";
        continue;
      }
    }
    if (state === "token" || state === "fallback") {
      index++;
      if (char2 === ")") {
        state = currentStates.pop() ?? state ?? "char";
        fallback2 += char2;
        const resolved = tokenPath ? resolve2(tokenPath) ?? esc(tokenPath) : tokenPath;
        if (fallback2) {
          fallback2 = fallback2.slice(1).trim();
          if (!fallback2.startsWith("token(") && fallback2.endsWith(")")) {
            fallback2 = fallback2.slice(0, -1);
          }
          if (fallback2.includes("token(")) {
            const parsed = expandTokenReferences(fallback2, resolve2);
            if (parsed) {
              fallback2 = parsed.slice(0, -1);
            }
          } else if (fallback2) {
            const resolvedFallback = resolve2(fallback2);
            if (resolvedFallback) {
              fallback2 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback2) {
          if (lastChar?.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback2 + ")");
          } else {
            expanded += fallback2;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback2 = "";
        state = "char";
        continue;
      }
      if (state === "token") {
        tokenPath += char2;
      }
      if (state === "fallback") {
        fallback2 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state = "token";
      currentStates.push(state);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
const cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};
function mapToJson(map2) {
  const obj = {};
  map2.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
const REFERENCE_REGEX = /({([^}]*)})/g;
const CURLY_REGEX = /[{}]/g;
const TOKEN_PATH_REGEX = /\w+\.\w+/;
const getReferences = (value) => {
  if (!isString$2(value)) return [];
  const matches2 = value.match(REFERENCE_REGEX);
  if (!matches2) return [];
  return matches2.map((match2) => match2.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
const hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  if (!token2.extensions?.references) {
    return token2.extensions?.cssVar?.ref ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}
function resolveReference(operand) {
  if (isObject$4(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
const negate = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
const calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
const addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix2, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions: extensions2 }) => extensions2.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix2);
      if (isString$2(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
const units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
const addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
const addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions: extensions2 }) => extensions2.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        const name2 = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name2) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name2, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = colorPalette.keys[0]?.filter(Boolean);
          if (!keyPath.length) return;
          const path2 = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path2), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path2 = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name2 = formatTokenName(path2);
      const prop = formatTokenName(path2.slice(1));
      const token2 = {
        name: name2,
        value: name2,
        originalValue: name2,
        path: path2,
        extensions: {
          condition: "base",
          originalPath: path2,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
const removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
const tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];
const addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path2 = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path2.filter(Boolean), prefix2)
    };
  }
};
const addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref2) => {
      const variable = formatCssVar(ref2.split("."), prefix2);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
const addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path2 = token2.path.slice();
    path2.pop();
    path2.shift();
    if (path2.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path2 = newPath;
    }
    if (path2.length === 0) {
      return {};
    }
    const roots = path2.reduce((acc, _, i2, arr) => {
      const next2 = arr.slice(0, i2 + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root = path2[0];
    const value = dict.formatTokenName(path2);
    const keys = token2.path.slice(token2.path.indexOf(root) + 1).reduce((acc, _, i2, arr) => {
      acc.push(arr.slice(i2));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
const tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];
const isToken = (value) => {
  return isObject$4(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix: prefix2 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path2) => path2.join(".");
  const formatCssVar = (path2, prefix22) => cssVar(path2.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact$3({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path2) => {
        const isDefault = path2.includes("DEFAULT");
        path2 = filterDefault(path2);
        const category = path2[0];
        const name2 = formatTokenName(path2);
        const t2 = isString$2(entry) ? { value: entry } : entry;
        const token2 = {
          value: t2.value,
          originalValue: t2.value,
          name: name2,
          path: path2,
          extensions: {
            condition: "base",
            originalPath: path2,
            category,
            prop: formatTokenName(path2.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path2) => {
        const isDefault = path2.includes("DEFAULT");
        path2 = filterBaseCondition(filterDefault(path2));
        const category = path2[0];
        const name2 = formatTokenName(path2);
        const t2 = isString$2(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t2.value.base || "",
          originalValue: t2.value.base || "",
          name: name2,
          path: path2,
          extensions: {
            originalPath: path2,
            category,
            conditions: t2.value,
            condition: "base",
            prop: formatTokenName(path2.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name2) {
    return tokenNameMap.get(name2);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      const name2 = formatTokenName(root);
      if (!colorPaletteMap.has(name2)) {
        colorPaletteMap.set(name2, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name2).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name22 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name22);
        if (!virtualToken2) return;
        const keyPath = colorPalette.keys[0]?.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo((value, fallback2) => {
    return flatMap.get(value) ?? fallback2;
  });
  const getCategoryValues = memo((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo((value) => {
    return expandTokenReferences(value, (path2) => {
      if (!path2) return;
      if (path2.includes("/")) {
        const mix = colorMix2(path2, (v2) => getVar(v2));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path2 + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path2);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path2) ? esc(path2) : path2;
    });
  });
  const dictionary = {
    prefix: prefix2,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction$2(transform2.match) && !transform2.match(token2)) return;
    const fn = (v2) => transform2.transform(v2, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref2) => getByName(ref2)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref2) => {
        acc[ref2.name] = ref2;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build3() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build3();
  return dictionary;
}
function filterDefault(path2) {
  if (path2[0] === "DEFAULT") return path2;
  return path2.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path2) {
  return path2.filter((item) => item !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path2) => {
    const nextPath = filterBaseCondition(path2);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path2, roots) {
  const startIndex = path2.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path2[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path2;
  }
  path2.splice(startIndex, roots.length);
  path2.splice(startIndex, 0, "colorPalette");
  return path2;
}
createProps()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);
function normalize(config2) {
  return config2;
}
function normalizeConfig(config2) {
  return Object.fromEntries(
    Object.entries(config2).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config2) {
    configs[property] = normalize(config2);
    assignProperty(property, config2);
  }
  const assignProperty = (property, config2) => {
    const values = getPropertyValues(config2);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config2);
  };
  const assignProperties = () => {
    for (const [prop, config2] of Object.entries(configs)) {
      if (!config2) continue;
      assignProperty(prop, config2);
    }
  };
  const assignShorthands = () => {
    for (const [property, config2] of Object.entries(configs)) {
      const { shorthand } = config2 ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name2) => shorthands.set(name2, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo((value) => values[value])
    });
  };
  const propTypes2 = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config2) => {
    if (!config2) return;
    const values = getPropertyValues(config2, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes2.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes2.set(property, keys2);
    }
    const set2 = propTypes2.get(property) ?? /* @__PURE__ */ new Set();
    if (config2.property) {
      propTypes2.set(property, set2.add(`CssProperties["${config2.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type2) => {
    const set2 = propTypes2.get(property) ?? /* @__PURE__ */ new Set();
    propTypes2.set(property, /* @__PURE__ */ new Set([...set2, ...type2]));
  };
  const getTypes = () => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes2.entries()) {
      if (values.size === 0) {
        map2.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map2.set(prop, typeValues);
    }
    return map2;
  };
  const getPropertyValues = (config2, resolveFn) => {
    const { values } = config2;
    const fn = (key) => {
      const value = resolveFn?.(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString$2(values)) {
      return fn?.(values) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction$2(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path2) => tokens.getByName(path2)
  });
  const transform2 = memo((prop, raw) => {
    const key = resolveShorthand(prop);
    if (isString$2(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config2 = configs[key];
    if (!config2) {
      return defaultTransform(key, raw);
    }
    const value = propValues.get(key)?.[raw];
    if (!config2.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config2.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build3() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build3();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}
function createSystem(...configs) {
  const config2 = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config2;
  const layers = createLayers(config2);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config2.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact$3({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v2) => isObject$4(v2) && "value" in v2
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue
  });
  const serialize2 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css2(serialize2({ [selector]: varsObj }));
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props) {
    return splitProps(props, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path2, fallback2) => {
    return tokenMap.get(path2)?.value || fallback2;
  };
  tokenFn.var = (path2, fallback2) => {
    return tokenMap.get(path2)?.variable || fallback2;
  };
  function getRecipe(key, fallback2) {
    return theme.recipes?.[key] ?? fallback2;
  }
  function getSlotRecipe(key, fallback2) {
    return theme.slotRecipes?.[key] ?? fallback2;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config2,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map2 = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map2.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map2;
}
const breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};
const empty = "var(--chakra-empty,/*!*/ /*!*/)";
const globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.muted/80"
  }
});
const layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});
const animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});
const badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});
const buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const { variants: variants$1, defaultVariants: defaultVariants$1 } = badgeRecipe;
const codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants: variants$1,
  defaultVariants: defaultVariants$1
});
const colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});
const containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});
const headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});
const iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});
const inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});
const linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});
const markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});
const radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});
const skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});
const skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});
const spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};
const semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});
const semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});
const semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});
var createAnatomy = (name2, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name2, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name2, [...parts2, ...values]),
  rename: (newName) => createAnatomy(newName, parts2),
  keys: () => parts2,
  build: () => [...new Set(parts2)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name2)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name2)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name2), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v2) => v2.length === 0;
var anatomy$n = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
anatomy$n.build();
var dom$m = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`,
  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,
  getItemContentId: (ctx, value) => ctx.ids?.itemContent?.(value) ?? `accordion:${ctx.id}:content:${value}`,
  getItemTriggerId: (ctx, value) => ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,
  getRootEl: (ctx) => dom$m.getById(ctx, dom$m.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom$m.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom$m.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom$m.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom$m.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id2) => nextById(dom$m.getTriggerEls(ctx), dom$m.getItemTriggerId(ctx, id2)),
  getPrevTriggerEl: (ctx, id2) => prevById(dom$m.getTriggerEls(ctx), dom$m.getItemTriggerId(ctx, id2))
});
createProps$1()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
createProps$1()(["value", "disabled"]);
var anatomy$m = createAnatomy("collapsible").parts("root", "trigger", "content");
anatomy$m.build();
var dom$l = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `collapsible:${ctx.id}`,
  getContentId: (ctx) => ctx.ids?.content ?? `collapsible:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`,
  getRootEl: (ctx) => dom$l.getById(ctx, dom$l.getRootId(ctx)),
  getContentEl: (ctx) => dom$l.getById(ctx, dom$l.getContentId(ctx)),
  getTriggerEl: (ctx) => dom$l.getById(ctx, dom$l.getTriggerId(ctx))
});
createProps$1()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
const [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});
const sides = ["top", "right", "bottom", "left"];
const min$2 = Math.min;
const max$2 = Math.max;
const round$3 = Math.round;
const floor$2 = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max$2(start, min$2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref2, placement, rtl) {
  let {
    reference,
    floating
  } = _ref2;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$1 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min$2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$2(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset2 = clamp$1(min$12, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref2) => {
            let {
              x: x3,
              y: y3
            } = _ref2;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max$2(overflow.left, 0);
        const xMax = max$2(overflow.right, 0);
        const yMin = max$2(overflow.top, 0);
        const yMax = max$2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode$1(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref2;
  return (_ref2 = (isNode$1(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref2.documentElement;
}
function isNode$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode$1(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode$1(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode$1(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round$3(width) !== offsetWidth || round$3(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round$3(rect.width) : rect.width) / width;
  let y2 = ($2 ? round$3(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref2;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max$2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max$2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max$2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode$1(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement$1(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode$1(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode$1(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref2) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref2;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$2(rect.right, accRect.right);
    accRect.bottom = min$2(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode$1(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode$1(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor$2(top);
    const insetRight = floor$2(root.clientWidth - (left + width));
    const insetBottom = floor$2(root.clientHeight - (top + height));
    const insetLeft = floor$2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$2(0, min$2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref2) => {
      let [firstEntry] = _ref2;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const hide = hide$1;
const arrow = arrow$1;
const limitShift = limitShift$1;
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function createDOMRect(x2 = 0, y2 = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x2, y2, width, height);
  }
  const rect = {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x: x2, y: y2, width, height } = anchorRect;
  return createDOMRect(x2, y2, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement$1(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect?.(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x: x2, y: y2 } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x2 != null ? `${x2}px` : "",
        top: y2 != null ? `${y2}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
var defaultOptions$1 = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset(({ placement }) => {
    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
    const gutter = opts.offset?.mainAxis ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift2 = !hasAlign ? opts.shift : void 0;
    const crossAxis = opts.offset?.crossAxis ?? shift2;
    return compact$2({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift()
  });
}
function getSizeMiddleware(opts) {
  return size({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  if (!opts.hideWhenDetached) return;
  return hide({ strategy: "referenceHidden", boundary: opts.boundary?.() ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions$1, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    if (!reference || !floating) return;
    const pos = await computePosition(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete?.(pos);
    onPositioned?.({ placed: true });
    const win = getWindow$1(floating);
    const x2 = roundByDpr(win, pos.x);
    const y2 = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x2}px`);
    floating.style.setProperty("--y", `${y2}px`);
    if (options.hideWhenDetached) {
      const isHidden = pos.middlewareData.hide?.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles2 = getComputedStyle$2(contentEl);
      floating.style.setProperty("--z-index", styles2.zIndex);
    }
  };
  const update2 = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned?.({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update2, autoUpdateOptions) : noop$5;
  update2();
  return () => {
    cancelAutoUpdate?.();
    onPositioned?.({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}
function getWindowFrames(win) {
  const frames = {
    each(cb2) {
      for (let i2 = 0; i2 < win.frames?.length; i2 += 1) {
        const frame = win.frames[i2];
        if (frame) cb2(frame);
      }
    },
    addEventListener(event, listener3, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener3, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener3, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener3, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener3, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener3, options) => {
      try {
        parent?.addEventListener(event, listener3, options);
      } catch {
      }
      return () => {
        try {
          parent?.removeEventListener(event, listener3, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener3, options) => {
      try {
        parent?.removeEventListener(event, listener3, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement$1(node2) && isFocusable(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow$1(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement$1(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node2.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor$1(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor$1(node2);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !exclude?.(target);
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      const func = defer ? raf$1 : (v2) => v2();
      const composedPath = event.composedPath?.() ?? [event.target];
      func(() => {
        if (!node2 || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf$1 : (v2) => v2();
    func(() => {
      if (!node2 || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function fireCustomEvent(el2, type2, init2) {
  const win = el2.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type2, init2);
  return el2.dispatchEvent(event);
}
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn?.(event);
  };
  return addDomEvent(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return layer?.node === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    this.layers[this.indexOf(node2)]?.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, persistentElements) {
  const doc = getDocument(node2);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el2) => {
      cleanups2.push(setStyle(el2, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options) {
  if (!node2) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    options.onPointerDownOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onFocusOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    options.onFocusOutside?.(event);
    options.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onEscapeKeyDown(event) {
    if (!layerStack.isTopMost(node2)) return;
    options.onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = options.persistentElements?.map((fn) => fn()).filter(isHTMLElement$1);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups2.forEach((fn) => fn?.());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction$1(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node2, options));
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn?.());
    });
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction$1(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups2.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn?.());
    });
  };
}
var anatomy$l = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
anatomy$l.build();
var dom$k = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `color-picker:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `color-picker:${ctx.id}:label`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`,
  getControlId: (ctx) => ctx.ids?.control ?? `color-picker:${ctx.id}:control`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `color-picker:${ctx.id}:content`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`,
  getFormatSelectId: (ctx) => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`,
  getAreaId: (ctx) => ctx.ids?.area ?? `color-picker:${ctx.id}:area`,
  getAreaGradientId: (ctx) => ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`,
  getAreaThumbId: (ctx) => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`,
  getChannelSliderTrackId: (ctx, channel) => ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`,
  getChannelSliderThumbId: (ctx, channel) => ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`,
  getContentEl: (ctx) => dom$k.getById(ctx, dom$k.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom$k.getById(ctx, dom$k.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom$k.getById(ctx, dom$k.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll(dom$k.getContentEl(ctx), selector),
      ...queryAll(dom$k.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom$k.getById(ctx, dom$k.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom$k.getById(ctx, dom$k.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom$k.getById(ctx, dom$k.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom$k.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom$k.getById(ctx, dom$k.getControlId(ctx)),
  getTriggerEl: (ctx) => dom$k.getById(ctx, dom$k.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom$k.getById(ctx, dom$k.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom$k.getById(ctx, dom$k.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom$k.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom$k.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom$k.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
const [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
const splitRenderStrategyProps = (props) => createSplitProps()(props, ["lazyMount", "unmountOnExit"]);
const [DialogProvider, useDialogContext] = createContext({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});
const DialogBackdrop = reactExports.forwardRef((props, ref2) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps(dialog.getBackdropProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogBackdrop.displayName = "DialogBackdrop";
const DialogCloseTrigger = reactExports.forwardRef(
  (props, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getCloseTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";
const DialogContent = reactExports.forwardRef((props, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(dialog.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogContent.displayName = "DialogContent";
const DialogDescription = reactExports.forwardRef(
  (props, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getDescriptionProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DialogDescription.displayName = "DialogDescription";
const DialogPositioner = reactExports.forwardRef((props, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
DialogPositioner.displayName = "DialogPositioner";
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x2) => Boolean(x2));
var isIgnoredNode = (node2) => {
  if (node2.localName === "next-route-announcer") return true;
  if (node2.localName === "script") return true;
  if (node2.hasAttribute("aria-live")) return true;
  return node2.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props) => {
  const { parentNode, markerName, controlAttribute } = props;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el2) => {
    if (!el2 || elementsToKeep.has(el2)) return;
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node2) => {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          if (isIgnoredNode(node2)) return;
          const attr = node2.getAttribute(controlAttribute);
          const alreadyHidden = attr !== null && attr !== "false";
          const counterValue = (counterMap.get(node2) || 0) + 1;
          const markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "");
          }
        } catch (e2) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node2) => {
      const counterValue = counterMap.get(node2) - 1;
      const markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups2.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField$2(this, "trapStack");
    __publicField$2(this, "config");
    __publicField$2(this, "doc");
    __publicField$2(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField$2(this, "listenerCleanups", []);
    __publicField$2(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node2) => node2 === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g2) => g2.tabbableNodes.some((n2) => getTabIndex(n2) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField$2(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField$2(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField$2(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField$2(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField$2(this, "_mutationObserver");
    __publicField$2(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node2) => node2 === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField$2(this, "updateObservedNodes", () => {
      this._mutationObserver?.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          this._mutationObserver?.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField$2(this, "getInitialFocusNode", () => {
      let node2 = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node2 === false) {
        return false;
      }
      if (node2 === void 0 || node2 && !isFocusable(node2)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node2 = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node2 = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node2 === null) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      if (!node2) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node2.isConnected) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      return node2;
    });
    __publicField$2(this, "tryFocus", (node2) => {
      if (node2 === false) return;
      if (node2 === getActiveElement(this.doc)) return;
      if (!node2 || !node2.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node2.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node2;
      if (isSelectableInput(node2)) {
        node2.select();
      }
    });
    __publicField$2(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate?.();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate?.();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField$2(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause?.();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause?.();
      return this;
    });
    __publicField$2(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause?.();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause?.();
      return this;
    });
    __publicField$2(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField$2(this, "getReturnFocusNode", (previousActiveElement) => {
      const node2 = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node2 ? node2 : node2 === false ? false : previousActiveElement;
    });
    __publicField$2(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField$2(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node2 = optionValue;
      if (typeof optionValue === "string") {
        try {
          node2 = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node2) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node2;
    });
    __publicField$2(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config2 = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e2) {
        return isTabEvent(e2) && !e2.shiftKey;
      },
      isKeyBackward(e2) {
        return isTabEvent(e2) && e2.shiftKey;
      },
      ...options
    };
    this.doc = config2.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config2;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof event?.composedPath === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node2) => node2 === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node2) => isTabbable(node2));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node2) => isTabbable(node2));
      const posTabIndexesFound = !!tabbableNodes.find((node2) => getTabIndex(node2) > 0);
      function nextTabbableNode(node2, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node2);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find((el2) => isTabbable(el2));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find((el2) => isTabbable(el2));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g2) => g2.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate?.();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate?.();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node2) => node2.localName === "input" && "select" in node2 && typeof node2.select === "function";
function trapFocus(el2, options = {}) {
  let trap;
  const cleanup = raf$1(() => {
    const contentEl = typeof el2 === "function" ? el2() : el2;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy2() {
    trap?.deactivate();
    cleanup();
  };
}
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el2, style) {
  if (!el2) return;
  const previousStyle = Object.keys(style).reduce(
    (acc, key) => {
      acc[key] = el2.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el2.style, style);
  return () => {
    Object.assign(el2.style, previousStyle);
  };
}
function setCSSProperty(el2, property, value) {
  if (!el2) return;
  const previousValue = el2.style.getPropertyValue(property);
  el2.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el2.style.setProperty(property, previousValue);
    } else {
      el2.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}
var anatomy$k = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts$9 = anatomy$k.build();
var dom$j = createScope({
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`,
  getBackdropId: (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`,
  getContentId: (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`,
  getTitleId: (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`,
  getDescriptionId: (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`,
  getContentEl: (ctx) => dom$j.getById(ctx, dom$j.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$j.getById(ctx, dom$j.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom$j.getById(ctx, dom$j.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom$j.getById(ctx, dom$j.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom$j.getById(ctx, dom$j.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom$j.getById(ctx, dom$j.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom$j.getById(ctx, dom$j.getCloseTriggerId(ctx))
});
function connect$8(state, send, normalize2) {
  const ariaLabel = state.context["aria-label"];
  const open = state.matches("open");
  const rendered = state.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$9.trigger.attrs,
        dir: state.context.dir,
        id: dom$j.getTriggerId(state.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom$j.getContentId(state.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts$9.backdrop.attrs,
        dir: state.context.dir,
        hidden: !open,
        id: dom$j.getBackdropId(state.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts$9.positioner.attrs,
        dir: state.context.dir,
        id: dom$j.getPositionerId(state.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$9.content.attrs,
        dir: state.context.dir,
        role: state.context.role,
        hidden: !open,
        id: dom$j.getContentId(state.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom$j.getTitleId(state.context),
        "aria-describedby": rendered.description ? dom$j.getDescriptionId(state.context) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts$9.title.attrs,
        dir: state.context.dir,
        id: dom$j.getTitleId(state.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts$9.description.attrs,
        dir: state.context.dir,
        id: dom$j.getDescriptionId(state.context)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts$9.closeTrigger.attrs,
        dir: state.context.dir,
        id: dom$j.getCloseTriggerId(state.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine$7(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["setAlertDialogProps"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed"
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom$j.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom$j.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              ctx2.onEscapeKeyDown?.(event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll) return;
          return preventBodyScroll(dom$j.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal) return;
          const contentEl = () => dom$j.getContentEl(ctx2);
          return trapFocus(contentEl, {
            preventScroll: true,
            returnFocusOnDeactivate: !!ctx2.restoreFocus,
            initialFocus: ctx2.initialFocusEl,
            setReturnFocus: (el2) => ctx2.finalFocusEl?.() ?? el2
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom$j.getContentEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        setAlertDialogProps(ctx2) {
          if (ctx2.role !== "alertdialog") return;
          ctx2.initialFocusEl || (ctx2.initialFocusEl = () => dom$j.getCloseTriggerEl(ctx2));
          ctx2.closeOnInteractOutside = false;
        },
        checkRenderedElements(ctx2) {
          raf$1(() => {
            ctx2.renderedElements.title = !!dom$j.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom$j.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf$1(() => {
            const contentEl = dom$j.getContentEl(ctx2);
            if (!contentEl) return;
            const styles2 = getComputedStyle$2(contentEl);
            const elems = [dom$j.getPositionerEl(ctx2), dom$j.getBackdropEl(ctx2)];
            elems.forEach((node2) => {
              node2?.style.setProperty("--z-index", styles2.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
createProps$1()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
const useDialog = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    getRootNode,
    dir,
    open: props.defaultOpen,
    "open.controlled": props.open !== void 0,
    ...props
  };
  const context2 = {
    ...initialContext,
    open: props.open,
    onOpenChange: useEvent(props.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props.onEscapeKeyDown),
    onInteractOutside: useEvent(props.onInteractOutside)
  };
  const [state, send] = useMachine(machine$7(initialContext), { context: context2 });
  return connect$8(state, send, normalizeProps);
};
const DialogRoot = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, { value: dialog, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) }) });
};
const DialogRootProvider = (props) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, { value: dialog, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) }) });
};
const DialogTitle = reactExports.forwardRef((props, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.h2, { ...mergedProps, ref: ref2 });
});
DialogTitle.displayName = "DialogTitle";
const DialogTrigger = reactExports.forwardRef((props, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
DialogTrigger.displayName = "DialogTrigger";
const [FieldProvider, useFieldContext] = createContext({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});
var anatomy$j = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
anatomy$j.build();
var dom$i = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `editable:${ctx.id}`,
  getAreaId: (ctx) => ctx.ids?.area ?? `editable:${ctx.id}:area`,
  getLabelId: (ctx) => ctx.ids?.label ?? `editable:${ctx.id}:label`,
  getPreviewId: (ctx) => ctx.ids?.preview ?? `editable:${ctx.id}:preview`,
  getInputId: (ctx) => ctx.ids?.input ?? `editable:${ctx.id}:input`,
  getControlId: (ctx) => ctx.ids?.control ?? `editable:${ctx.id}:control`,
  getSubmitTriggerId: (ctx) => ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`,
  getCancelTriggerId: (ctx) => ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`,
  getEditTriggerId: (ctx) => ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`,
  getInputEl: (ctx) => dom$i.getById(ctx, dom$i.getInputId(ctx)),
  getPreviewEl: (ctx) => dom$i.getById(ctx, dom$i.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom$i.getById(ctx, dom$i.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom$i.getById(ctx, dom$i.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom$i.getById(ctx, dom$i.getEditTriggerId(ctx))
});
createProps$1()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
const FieldErrorText$1 = reactExports.forwardRef((props, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field.getErrorTextProps(), props);
  if (field?.invalid) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
  }
  return null;
});
FieldErrorText$1.displayName = "FieldErrorText";
const FieldHelperText$1 = reactExports.forwardRef((props, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getHelperTextProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
FieldHelperText$1.displayName = "FieldHelperText";
const FieldInput = reactExports.forwardRef((props, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getInputProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { ...mergedProps, ref: ref2 });
});
FieldInput.displayName = "FieldInput";
const FieldLabel$1 = reactExports.forwardRef((props, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 });
});
FieldLabel$1.displayName = "FieldLabel";
const useSafeLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const [FieldsetProvider, useFieldsetContext] = createContext({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});
const fieldAnatomy$1 = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
const parts$8 = fieldAnatomy$1.build();
const useField = (props) => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset?.disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props;
  const hasErrorText = reactExports.useRef(false);
  const hasHelperText = reactExports.useRef(false);
  const id2 = props.id ?? reactExports.useId();
  const rootRef = reactExports.useRef(null);
  const rootId = ids?.control ?? `field::${id2}`;
  const errorTextId = ids?.errorText ?? `field::${id2}::error-text`;
  const helperTextId = ids?.helperText ?? `field::${id2}::helper-text`;
  const labelId = ids?.label ?? `field::${id2}::label`;
  useSafeLayoutEffect(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow$1(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = reactExports.useMemo(() => {
    const ids2 = [];
    if (hasErrorText.current && invalid) ids2.push(errorTextId);
    if (hasHelperText.current) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = reactExports.useMemo(
    () => () => ({
      ...parts$8.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr$1(disabled),
      "data-invalid": dataAttr$1(invalid),
      "data-readonly": dataAttr$1(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = reactExports.useMemo(
    () => () => ({
      ...parts$8.label.attrs,
      id: labelId,
      "data-disabled": dataAttr$1(disabled),
      "data-invalid": dataAttr$1(invalid),
      "data-readonly": dataAttr$1(readOnly),
      htmlFor: id2
    }),
    [disabled, invalid, readOnly, id2, labelId]
  );
  const getControlProps = reactExports.useMemo(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr$1(invalid),
      "data-required": dataAttr$1(required),
      "data-readonly": dataAttr$1(readOnly),
      id: id2,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id2, disabled]
  );
  const getInputProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$8.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$8.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$8.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = reactExports.useMemo(
    () => () => ({
      id: helperTextId,
      ...parts$8.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = reactExports.useMemo(
    () => () => ({
      id: errorTextId,
      ...parts$8.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = reactExports.useMemo(
    () => () => ({
      "aria-hidden": true,
      ...parts$8.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id2,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};
const FieldRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [useFieldProps, localProps] = createSplitProps()(props, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps(field.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FieldProvider, { value: field, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(ref2, field.refs.rootRef) }) });
});
FieldRoot$1.displayName = "FieldRoot";
var autoresizeTextarea = (el2) => {
  if (!el2) return;
  const style = getComputedStyle$2(el2);
  const win = getWindow$1(el2);
  const doc = getDocument(el2);
  const resize = () => {
    el2.style.height = "auto";
    const borderTopWidth = parseInt(style.borderTopWidth, 10);
    const borderBottomWidth = parseInt(style.borderBottomWidth, 10);
    el2.style.height = `${el2.scrollHeight + borderTopWidth + borderBottomWidth}px`;
  };
  el2.addEventListener("input", resize);
  const elementPrototype = Object.getPrototypeOf(el2);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el2, "value", {
    ...descriptor,
    set() {
      descriptor?.set?.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => resize());
  resizeObserver.observe(el2);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el2, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  doc.fonts?.addEventListener("loadingdone", resize);
  return () => {
    el2.removeEventListener("input", resize);
    doc.fonts?.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};
const FieldTextarea = reactExports.forwardRef((props, ref2) => {
  const { autoresize, ...textareaProps } = props;
  const textareaRef = reactExports.useRef(null);
  const field = useFieldContext();
  const mergedProps = mergeProps(
    field?.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  reactExports.useEffect(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.textarea, { ...mergedProps, ref: composeRefs(ref2, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";
const fieldsetAnatomy$1 = createAnatomy("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
fieldsetAnatomy$1.build();
var anatomy$i = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
anatomy$i.build();
var dom$h = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `file:${ctx.id}`,
  getDropzoneId: (ctx) => ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `file:${ctx.id}:trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `file:${ctx.id}:label`,
  getItemId: (ctx, id2) => ctx.ids?.item?.(id2) ?? `file:${ctx.id}:item:${id2}`,
  getItemNameId: (ctx, id2) => ctx.ids?.itemName?.(id2) ?? `file:${ctx.id}:item-name:${id2}`,
  getItemSizeTextId: (ctx, id2) => ctx.ids?.itemSizeText?.(id2) ?? `file:${ctx.id}:item-size:${id2}`,
  getItemPreviewId: (ctx, id2) => ctx.ids?.itemPreview?.(id2) ?? `file:${ctx.id}:item-preview:${id2}`,
  getRootEl: (ctx) => dom$h.getById(ctx, dom$h.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom$h.getById(ctx, dom$h.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom$h.getById(ctx, dom$h.getDropzoneId(ctx))
});
createProps$1()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
createProps$1()(["file"]);
var anatomy$h = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
anatomy$h.build();
var dom$g = createScope({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,
  getContextTriggerId: (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,
  getGroupId: (ctx, id2) => ctx.ids?.group?.(id2) ?? `menu:${ctx.id}:group:${id2}`,
  getGroupLabelId: (ctx, id2) => ctx.ids?.groupLabel?.(id2) ?? `menu:${ctx.id}:group-label:${id2}`,
  getContentEl: (ctx) => dom$g.getById(ctx, dom$g.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$g.getById(ctx, dom$g.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom$g.getById(ctx, dom$g.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom$g.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom$g.getById(ctx, dom$g.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom$g.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom$g.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom$g.getElements(ctx)),
  getLastEl: (ctx) => last(dom$g.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom$g.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom$g.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom$g.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v2) => {
    return isHTMLElement$1(v2) && (v2.dataset.disabled === "" || v2.hasAttribute("disabled"));
  },
  isTriggerItem: (el2) => {
    return !!el2?.getAttribute("role")?.startsWith("menuitem") && !!el2?.hasAttribute("aria-controls");
  },
  getOptionFromItemEl(el2) {
    return {
      id: el2.id,
      name: el2.dataset.name,
      value: el2.dataset.value,
      valueText: el2.dataset.valueText,
      type: el2.dataset.type
    };
  }
});
createProps$1()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open.controlled",
  "open",
  "positioning",
  "typeahead"
]);
createProps$1()(["closeOnSelect", "disabled", "value", "valueText"]);
createProps$1()(["htmlFor"]);
createProps$1()(["id"]);
createProps$1()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var anatomy$g = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
anatomy$g.build();
var dom$f = createScope({
  getAnchorId: (ctx) => ctx.ids?.anchor ?? `popover:${ctx.id}:anchor`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `popover:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `popover:${ctx.id}:content`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `popover:${ctx.id}:popper`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `popover:${ctx.id}:arrow`,
  getTitleId: (ctx) => ctx.ids?.title ?? `popover:${ctx.id}:title`,
  getDescriptionId: (ctx) => ctx.ids?.description ?? `popover:${ctx.id}:desc`,
  getCloseTriggerId: (ctx) => ctx.ids?.closeTrigger ?? `popover:${ctx.id}:close`,
  getAnchorEl: (ctx) => dom$f.getById(ctx, dom$f.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom$f.getById(ctx, dom$f.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$f.getById(ctx, dom$f.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$f.getById(ctx, dom$f.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom$f.getById(ctx, dom$f.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom$f.getById(ctx, dom$f.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom$f.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom$f.getFocusableEls(ctx)[0]
});
createProps$1()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e2) {
  return !(e2.metaKey || !isMac() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e2) {
  const target = e2 ? getEventTarget(e2) : null;
  const win = getWindow$1(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e2.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e2) {
  for (let handler of changeHandlers) {
    handler(modality, e2);
  }
}
function handleKeyboardEvent(e2) {
  hasEventBeforeFocus = true;
  if (isValidKey(e2)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e2);
  }
}
function handlePointerEvent(e2) {
  currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e2);
  }
}
function handleClickEvent(e2) {
  if (isVirtualClick(e2)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e2) {
  const target = getEventTarget(e2);
  if (target === getWindow$1(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e2);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow$1(root))) {
    return;
  }
  const win = getWindow$1(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow$1(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props = {}) {
  const { isTextInput, autoFocus, onChange, root } = props;
  setupGlobalFocusEvents(root);
  onChange?.({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e2) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e2)) return;
    onChange?.({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el2) => el2.getBoundingClientRect();
function trackElementRect(el2, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el2);
  if (!data) {
    observedElements.set(el2, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el2));
  }
  return function unobserve() {
    const data2 = observedElements.get(el2);
    if (!data2) return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el2);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual2 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual2(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a2, b2) => a2.width === b2.width && a2.height === b2.height;
var isEqualPosition = (a2, b2) => a2.top === b2.top && a2.left === b2.left;
var isEqualRect = (a2, b2) => isEqualSize(a2, b2) && isEqualPosition(a2, b2);
function getEqualityFn(scope) {
  if (scope === "size") return isEqualSize;
  if (scope === "position") return isEqualPosition;
  return isEqualRect;
}
var anatomy$f = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
anatomy$f.build();
var dom$e = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`,
  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,
  getItemHiddenInputId: (ctx, value) => ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,
  getItemControlId: (ctx, value) => ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,
  getItemLabelId: (ctx, value) => ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`,
  getRootEl: (ctx) => dom$e.getById(ctx, dom$e.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom$e.getById(ctx, dom$e.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom$e.getById(ctx, dom$e.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => dom$e.getRootEl(ctx)?.querySelector("input:not(:disabled)"),
  getFirstEnabledAndCheckedInputEl: (ctx) => dom$e.getRootEl(ctx)?.querySelector("input:not(:disabled):checked"),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom$e.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom$e.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom$e.getById(ctx, dom$e.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el2) => ({
    left: el2?.offsetLeft ?? 0,
    top: el2?.offsetTop ?? 0,
    width: el2?.offsetWidth ?? 0,
    height: el2?.offsetHeight ?? 0
  }),
  getRectById: (ctx, id2) => {
    const radioEl = dom$e.getById(ctx, dom$e.getItemId(ctx, id2));
    if (!radioEl) return;
    return dom$e.resolveRect(dom$e.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
createProps$1()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
createProps$1()(["value", "disabled", "invalid"]);
var anatomy$e = createAnatomy("rating-group").parts("root", "label", "item", "control");
anatomy$e.build();
var dom$d = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `rating:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `rating:${ctx.id}:label`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `rating:${ctx.id}:input`,
  getControlId: (ctx) => ctx.ids?.control ?? `rating:${ctx.id}:control`,
  getItemId: (ctx, id2) => ctx.ids?.item?.(id2) ?? `rating:${ctx.id}:item:${id2}`,
  getRootEl: (ctx) => dom$d.getById(ctx, dom$d.getRootId(ctx)),
  getControlEl: (ctx) => dom$d.getById(ctx, dom$d.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom$d.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom$d.getById(ctx, dom$d.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom$d.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
createProps$1()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
createProps$1()(["index"]);
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, key + "", value);
var fallback$1 = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "label")) return item.label;
    return fallback$1.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class {
  constructor(options) {
    this.options = options;
    __publicField$1(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual$1(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    if (item == null) return null;
    return this.options.itemToValue?.(item) ?? fallback$1.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    if (item == null) return false;
    return this.options.isItemDisabled?.(item) ?? fallback$1.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    if (item == null) return null;
    return this.options.itemToString?.(item) ?? fallback$1.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value, step = 1, clamp2 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp2 ? Math.min(index + step, this.size - 1) : index + step;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value, step = 1, clamp2 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp2 ? Math.max(index - step, 0) : index - step;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match$1(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state, currentValue, timeout = 350 } = options;
    const search = state.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query2 = isRepeated ? search[0] : search;
    const item = this.getByText(query2, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state.timer);
      state.timer = -1;
    }
    function update2(value2) {
      state.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state.timer = +setTimeout(() => {
          update2("");
          cleanup();
        }, timeout);
      }
    }
    update2(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  json() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match$1 = (label, query2) => {
  return !!label?.toLowerCase().startsWith(query2.toLowerCase());
};
var wrap = (v2, idx) => {
  return v2.map((_, index) => v2[(Math.max(idx, 0) + index) % v2.length]);
};
const createListCollection = (options) => ref$1(new ListCollection(options));
const [SelectProvider, useSelectContext] = createContext({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});
const SelectClearTrigger$2 = reactExports.forwardRef(
  (props, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getClearTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
SelectClearTrigger$2.displayName = "SelectClearTrigger";
const SelectContent$2 = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(select.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
SelectContent$2.displayName = "SelectContent";
const SelectContext$1 = (props) => props.children(useSelectContext());
const SelectControl$1 = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
SelectControl$1.displayName = "SelectControl";
const SelectHiddenSelect$1 = reactExports.forwardRef(
  (props, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getHiddenSelectProps(), props);
    const isValueEmpty = select.value.length === 0;
    const field = useFieldContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ark.select, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref: ref2, children: [
      isValueEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }),
      select.collection.items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "option",
        {
          value: select.collection.getItemValue(item) ?? "",
          disabled: select.collection.getItemDisabled(item)
        },
        index
      ))
    ] });
  }
);
SelectHiddenSelect$1.displayName = "SelectHiddenSelect";
const SelectIndicator$1 = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
SelectIndicator$1.displayName = "SelectIndicator";
const [SelectItemProvider, useSelectItemContext] = createContext({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});
const [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});
const SelectItem$2 = reactExports.forwardRef((props, ref2) => {
  const [itemProps, localProps] = createSplitProps()(props, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemProps(itemProps), localProps);
  const itemState = select.getItemState(itemProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemPropsProvider, { value: itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemProvider, { value: itemState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
SelectItem$2.displayName = "SelectItem";
const [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});
const SelectItemGroup$1 = reactExports.forwardRef((props, ref2) => {
  const id2 = reactExports.useId();
  const [_itemGroupProps, localProps] = createSplitProps()(props, ["id"]);
  const itemGroupProps = { id: id2, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemGroupProps(itemGroupProps), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemGroupPropsProvider, { value: itemGroupProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
});
SelectItemGroup$1.displayName = "SelectItemGroup";
const SelectItemGroupLabel$1 = reactExports.forwardRef(
  (props, ref2) => {
    const select = useSelectContext();
    const itemGroupProps = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps.id }),
      props
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemGroupLabel$1.displayName = "SelectItemGroupLabel";
const SelectItemIndicator$1 = reactExports.forwardRef(
  (props, ref2) => {
    const select = useSelectContext();
    const itemProps = useSelectItemPropsContext();
    const mergedProps = mergeProps(select.getItemIndicatorProps(itemProps), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemIndicator$1.displayName = "SelectItemIndicator";
const SelectItemText = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = mergeProps(select.getItemTextProps(itemProps), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
SelectItemText.displayName = "SelectItemText";
const SelectLabel = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 });
});
SelectLabel.displayName = "SelectLabel";
const SelectPositioner$1 = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
SelectPositioner$1.displayName = "SelectPositioner";
var anatomy$d = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts$7 = anatomy$d.build();
var collection = (options) => {
  return ref$1(new ListCollection(options));
};
collection.empty = () => {
  return ref$1(new ListCollection({ items: [] }));
};
var dom$c = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `select:${ctx.id}`,
  getContentId: (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,
  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `select:${ctx.id}:control`,
  getItemId: (ctx, id2) => ctx.ids?.item?.(id2) ?? `select:${ctx.id}:option:${id2}`,
  getHiddenSelectId: (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,
  getItemGroupId: (ctx, id2) => ctx.ids?.itemGroup?.(id2) ?? `select:${ctx.id}:optgroup:${id2}`,
  getItemGroupLabelId: (ctx, id2) => ctx.ids?.itemGroupLabel?.(id2) ?? `select:${ctx.id}:optgroup-label:${id2}`,
  getHiddenSelectEl: (ctx) => dom$c.getById(ctx, dom$c.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom$c.getById(ctx, dom$c.getContentId(ctx)),
  getControlEl: (ctx) => dom$c.getById(ctx, dom$c.getControlId(ctx)),
  getTriggerEl: (ctx) => dom$c.getById(ctx, dom$c.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom$c.getById(ctx, dom$c.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom$c.getById(ctx, dom$c.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom$c.getById(ctx, dom$c.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect$7(state, send, normalize2) {
  const disabled = state.context.isDisabled;
  const invalid = state.context.invalid;
  const readOnly = state.context.readOnly;
  const interactive = state.context.isInteractive;
  const composite = state.context.composite;
  const open = state.hasTag("open");
  const focused = state.matches("focused");
  const highlightedValue = state.context.highlightedValue;
  const highlightedItem = state.context.highlightedItem;
  const selectedItems = state.context.selectedItems;
  const isTypingAhead = state.context.isTypingAhead;
  const collection2 = state.context.collection;
  const ariaActiveDescendant = highlightedValue ? dom$c.getItemId(state.context, highlightedValue) : void 0;
  function getItemState(props2) {
    const _disabled = collection2.getItemDisabled(props2.item);
    const value = collection2.getItemValue(props2.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state.context.hasSelectedItems,
    value: state.context.value,
    valueAsString: state.context.valueAsString,
    collection: collection2,
    multiple: !!state.context.multiple,
    disabled: !!disabled,
    setCollection(collection3) {
      send({ type: "COLLECTION.SET", value: collection3 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      dom$c.getTriggerEl(state.context)?.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection2.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts$7.root.attrs,
        dir: state.context.dir,
        id: dom$c.getRootId(state.context),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        dir: state.context.dir,
        id: dom$c.getLabelId(state.context),
        ...parts$7.label.attrs,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly),
        htmlFor: dom$c.getHiddenSelectId(state.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          dom$c.getTriggerEl(state.context)?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$7.control.attrs,
        dir: state.context.dir,
        id: dom$c.getControlId(state.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr$1(focused),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts$7.valueText.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-focus": dataAttr$1(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        id: dom$c.getTriggerId(state.context),
        disabled,
        dir: state.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom$c.getContentId(state.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom$c.getLabelId(state.context),
        ...parts$7.trigger.attrs,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly),
        "data-placement": state.context.currentPlacement,
        "data-placeholder-shown": dataAttr$1(!state.context.hasSelectedItems),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event, state.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts$7.indicator.attrs,
        dir: state.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly)
      });
    },
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        id: dom$c.getItemId(state.context, itemState.value),
        role: "option",
        ...parts$7.item.attrs,
        dir: state.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr$1(itemState.highlighted),
        "data-disabled": dataAttr$1(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === state.context.highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props2.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = state.previousEvent.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        ...parts$7.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr$1(itemState.disabled),
        "data-highlighted": dataAttr$1(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        "aria-hidden": true,
        ...parts$7.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props2) {
      const { htmlFor } = props2;
      return normalize2.element({
        ...parts$7.itemGroupLabel.attrs,
        id: dom$c.getItemGroupLabelId(state.context, htmlFor),
        role: "group",
        dir: state.context.dir
      });
    },
    getItemGroupProps(props2) {
      const { id: id2 } = props2;
      return normalize2.element({
        ...parts$7.itemGroup.attrs,
        "data-disabled": dataAttr$1(disabled),
        id: dom$c.getItemGroupId(state.context, id2),
        "aria-labelledby": dom$c.getItemGroupLabelId(state.context, id2),
        dir: state.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts$7.clearTrigger.attrs,
        id: dom$c.getClearTriggerId(state.context),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr$1(invalid),
        disabled,
        hidden: !state.context.hasSelectedItems,
        dir: state.context.dir,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLEAR.CLICK");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize2.select({
        name: state.context.name,
        form: state.context.form,
        disabled,
        multiple: state.context.multiple,
        required: state.context.required,
        "aria-hidden": true,
        id: dom$c.getHiddenSelectId(state.context),
        defaultValue: state.context.multiple ? state.context.value : state.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          dom$c.getTriggerEl(state.context)?.focus({ preventScroll: true });
        },
        "aria-labelledby": dom$c.getLabelId(state.context)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts$7.positioner.attrs,
        dir: state.context.dir,
        id: dom$c.getPositionerId(state.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        hidden: !open,
        dir: state.context.dir,
        id: dom$c.getContentId(state.context),
        role: composite ? "listbox" : "dialog",
        ...parts$7.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom$c.getLabelId(state.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts$7.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom$c.getTriggerId(state.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and$3, not: not$5, or: or$1 } = guards;
function machine$6(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: !ctx.multiple,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "CLEAR.CLICK": {
          actions: ["clearSelectedItems", "focusTriggerEl"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightComputedLastItem"]
              },
              {
                guard: or$1("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["setInitialFocus", "highlightComputedFirstItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and$3(not$5("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not$5("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and$3(not$5("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not$5("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not$5("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not$5("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not$5("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and$3("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and$3("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and$3("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.firstValue,
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.lastValue,
        closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => evt.previousEvent?.type === "TRIGGER.CLICK",
        isTriggerEnterEvent: (_ctx, evt) => evt.previousEvent?.type === "TRIGGER.ENTER",
        isTriggerArrowUpEvent: (_ctx, evt) => evt.previousEvent?.type === "TRIGGER.ARROW_UP",
        isTriggerArrowDownEvent: (_ctx, evt) => evt.previousEvent?.type === "TRIGGER.ARROW_DOWN"
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom$c.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set$4.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom$c.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom$c.getTriggerEl(ctx2), dom$c.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom$c.getTriggerEl(ctx2);
          const positionerEl = () => dom$c.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = (immediate) => {
            if (ctx2.highlightedValue == null) return;
            const state = getState();
            if (state.event.type.includes("POINTER")) return;
            const optionEl = dom$c.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom$c.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf$1(() => exec2(true));
          const contentEl = () => dom$c.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec2(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom$c.getPositionerEl(ctx2);
          getPlacement(dom$c.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
          set$4.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
          set$4.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set$4.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set$4.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf$1(() => {
            const element = getInitialFocus({
              root: dom$c.getContentEl(ctx2)
            });
            element?.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2, evt) {
          const restoreFocus = evt.restoreFocus ?? evt.previousEvent?.restoreFocus;
          if (restoreFocus != null && !restoreFocus) return;
          raf$1(() => {
            const element = dom$c.getTriggerEl(ctx2);
            element?.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          let value = evt.value ?? ctx2.highlightedValue;
          if (value == null) return;
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
          value = nullable ? null : value;
          set$4.selectedItem(ctx2, value, nullable);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
          set$4.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
          set$4.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems) return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set$4.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set$4.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null) return;
          set$4.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set$4.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set$4.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
          const value = nullable ? null : evt.value;
          set$4.selectedItem(ctx2, value, nullable);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v2) => v2 !== evt.value);
          set$4.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set$4.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set$4.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
          set$4.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.getNextValue(ctx2.value[0]);
          set$4.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set$4.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set$4.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null) return;
          set$4.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            dom$c.getContentEl(ctx2)?.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom$c.getHiddenSelectEl(ctx2);
          if (!selectEl) return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyItems(selectedItems);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync$1.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync$1.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf$1(() => {
    const node2 = dom$c.getHiddenSelectEl(ctx);
    if (!node2) return;
    const win = dom$c.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node2.dispatchEvent(changeEvent);
  });
}
var sync$1 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((value) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === value);
      if (foundItem) return foundItem;
      return ctx.collection.find(value);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke$3 = {
  valueChange: (ctx) => {
    sync$1.valueChange(ctx);
    ctx.onValueChange?.({
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    sync$1.highlightChange(ctx);
    ctx.onHighlightChange?.({
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set$4 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual$1(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke$3.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    invoke$3.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual$1(ctx.value, value)) return;
    ctx.value = value;
    invoke$3.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual$1(ctx.highlightedValue, value)) return;
    if (value == null && !force) return;
    ctx.highlightedValue = value ?? null;
    invoke$3.highlightChange(ctx);
  }
};
createProps$1()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
createProps$1()(["item", "persistFocus"]);
createProps$1()(["id"]);
createProps$1()(["htmlFor"]);
const useSelect = (props) => {
  const { collection: collection2, ...selectProps } = props;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: reactExports.useId(),
    ids: {
      label: field?.ids.label,
      hiddenSelect: field?.ids.control
    },
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    invalid: field?.invalid,
    required: field?.required,
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    collection: collection2,
    open: props.defaultOpen,
    value: props.defaultValue,
    "open.controlled": props.open !== void 0,
    ...selectProps
  };
  const context2 = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props.value,
      onValueChange: useEvent(props.onValueChange, { sync: true }),
      onHighlightChange: useEvent(props.onHighlightChange),
      onOpenChange: useEvent(props.onOpenChange)
    };
  })();
  const [state, send, service] = useMachine(machine$6(initialContext), {
    context: context2
  });
  reactExports.useEffect(() => {
    service.setContext({ collection: collection2 });
  }, [collection2]);
  return connect$7(state, send, normalizeProps);
};
const SelectImpl$1 = (props, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [useSelectProps, localProps] = createSplitProps()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, { value: select, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
const SelectRoot$2 = reactExports.forwardRef(SelectImpl$1);
const SelectImpl = (props, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [{ value: select }, localProps] = createSplitProps()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, { value: select, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
const SelectRootProvider = reactExports.forwardRef(SelectImpl);
const SelectTrigger$2 = reactExports.forwardRef((props, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
SelectTrigger$2.displayName = "SelectTrigger";
const SelectValueText$2 = reactExports.forwardRef((props, ref2) => {
  const { children, placeholder, ...localprops } = props;
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getValueTextProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2, children: children || select.valueAsString || placeholder });
});
SelectValueText$2.displayName = "SelectValueText";
var anatomy$c = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
anatomy$c.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset2 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset2}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles2, value, index) => {
    const offset2 = getThumbOffset({ ...ctx, value });
    return { ...styles2, [`--slider-thumb-offset-${index}`]: offset2 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom$b = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => ctx.ids?.root ?? `slider:${ctx.id}`,
  getThumbId: (ctx, index) => ctx.ids?.thumb?.(index) ?? `slider:${ctx.id}:thumb:${index}`,
  getHiddenInputId: (ctx, index) => ctx.ids?.hiddenInput?.(index) ?? `slider:${ctx.id}:input:${index}`,
  getControlId: (ctx) => ctx.ids?.control ?? `slider:${ctx.id}:control`,
  getTrackId: (ctx) => ctx.ids?.track ?? `slider:${ctx.id}:track`,
  getRangeId: (ctx) => ctx.ids?.range ?? `slider:${ctx.id}:range`,
  getLabelId: (ctx) => ctx.ids?.label ?? `slider:${ctx.id}:label`,
  getValueTextId: (ctx) => ctx.ids?.valueText ?? `slider:${ctx.id}:value-text`,
  getMarkerId: (ctx, value) => ctx.ids?.marker?.(value) ?? `slider:${ctx.id}:marker:${value}`,
  getRootEl: (ctx) => dom$b.getById(ctx, dom$b.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom$b.getById(ctx, dom$b.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom$b.getById(ctx, dom$b.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom$b.getById(ctx, dom$b.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom$b.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom$b.getElements(ctx)[0],
  getRangeEl: (ctx) => dom$b.getById(ctx, dom$b.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom$b.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom$b.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
createProps$1()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
createProps$1()(["index", "name"]);
const [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});
const SwitchControl$1 = reactExports.forwardRef((props, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchControl$1.displayName = "SwitchControl";
const SwitchHiddenInput$1 = reactExports.forwardRef(
  (props, ref2) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps(switchContext.getHiddenInputProps(), props);
    const field = useFieldContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
SwitchHiddenInput$1.displayName = "SwitchHiddenInput";
const SwitchLabel$1 = reactExports.forwardRef((props, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchLabel$1.displayName = "SwitchLabel";
var anatomy$b = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts$6 = anatomy$b.build();
var dom$a = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `switch:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `switch:${ctx.id}:label`,
  getThumbId: (ctx) => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`,
  getControlId: (ctx) => ctx.ids?.control ?? `switch:${ctx.id}:control`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`,
  getRootEl: (ctx) => dom$a.getById(ctx, dom$a.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom$a.getById(ctx, dom$a.getHiddenInputId(ctx))
});
function connect$6(state, send, normalize2) {
  const disabled = state.context.isDisabled;
  const readOnly = state.context.readOnly;
  const checked = state.context.checked;
  const focused = !disabled && state.context.focused;
  const focusVisible = !disabled && state.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr$1(state.context.active),
    "data-focus": dataAttr$1(focused),
    "data-focus-visible": dataAttr$1(focusVisible),
    "data-readonly": dataAttr$1(readOnly),
    "data-hover": dataAttr$1(state.context.hovered),
    "data-disabled": dataAttr$1(disabled),
    "data-state": state.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr$1(state.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts$6.root.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom$a.getRootId(state.context),
        htmlFor: dom$a.getHiddenInputId(state.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom$a.getHiddenInputEl(state.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts$6.label.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom$a.getLabelId(state.context)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts$6.thumb.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom$a.getThumbId(state.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$6.control.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom$a.getControlId(state.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom$a.getHiddenInputId(state.context),
        type: "checkbox",
        required: state.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom$a.getLabelId(state.context),
        "aria-invalid": state.context.invalid,
        name: state.context.name,
        form: state.context.form,
        value: state.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not$4 } = guards;
function machine$5(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not$4("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not$4("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom$a.getRootEl(ctx2),
            keyboardNode: dom$a.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom$a.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom$a.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom$a.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set$3.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set$3.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom$a.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke$2 = {
  change: (ctx) => {
    ctx.onCheckedChange?.({ checked: ctx.checked });
  }
};
var set$3 = {
  checked: (ctx, checked) => {
    if (isEqual$1(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke$2.change(ctx);
  }
};
createProps$1()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
const useSwitch = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: reactExports.useId(),
    ids: {
      label: field?.ids.label,
      hiddenInput: field?.ids.control
    },
    dir,
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    invalid: field?.invalid,
    required: field?.required,
    getRootNode,
    checked: props.defaultChecked,
    ...props
  };
  const context2 = {
    ...initialContext,
    checked: props.checked,
    onCheckedChange: useEvent(props.onCheckedChange, { sync: true })
  };
  const [state, send] = useMachine(machine$5(initialContext), { context: context2 });
  return connect$6(state, send, normalizeProps);
};
const SwitchRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [switchProps, localProps] = createSplitProps()(props, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps(switchContext.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchProvider, { value: switchContext, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 }) });
});
SwitchRoot$1.displayName = "SwitchRoot";
const SwitchRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: api }, localProps] = createSplitProps()(props, ["value"]);
    const mergedProps = mergeProps(api.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchProvider, { value: api, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";
const SwitchThumb$1 = reactExports.forwardRef((props, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getThumbProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchThumb$1.displayName = "SwitchThumb";
const [AvatarProvider, useAvatarContext] = createContext({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});
const AvatarFallback$2 = reactExports.forwardRef((props, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getFallbackProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2 });
});
AvatarFallback$2.displayName = "AvatarFallback";
const AvatarImage$1 = reactExports.forwardRef((props, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getImageProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.img, { ...mergedProps, ref: ref2 });
});
AvatarImage$1.displayName = "AvatarImage";
var anatomy$a = createAnatomy("avatar").parts("root", "image", "fallback");
var parts$5 = anatomy$a.build();
var dom$9 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `avatar:${ctx.id}`,
  getImageId: (ctx) => ctx.ids?.image ?? `avatar:${ctx.id}:image`,
  getFallbackId: (ctx) => ctx.ids?.fallback ?? `avatar:${ctx.id}:fallback`,
  getRootEl: (ctx) => dom$9.getById(ctx, dom$9.getRootId(ctx)),
  getImageEl: (ctx) => dom$9.getById(ctx, dom$9.getImageId(ctx))
});
function connect$5(state, send, normalize2) {
  const loaded2 = state.matches("loaded");
  return {
    loaded: loaded2,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts$5.root.attrs,
        dir: state.context.dir,
        id: dom$9.getRootId(state.context)
      });
    },
    getImageProps() {
      return normalize2.img({
        ...parts$5.image.attrs,
        hidden: !loaded2,
        dir: state.context.dir,
        id: dom$9.getImageId(state.context),
        "data-state": loaded2 ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize2.element({
        ...parts$5.fallback.attrs,
        dir: state.context.dir,
        id: dom$9.getFallbackId(state.context),
        hidden: loaded2,
        "data-state": loaded2 ? "hidden" : "visible"
      });
    }
  };
}
function machine$4(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom$9.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom$9.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find(
                (node2) => node2.nodeType === Node.ELEMENT_NODE && node2.matches("[data-scope=avatar][data-part=image]")
              );
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          ctx2.onStatusChange?.({ status: "loaded" });
        },
        invokeOnError(ctx2) {
          ctx2.onStatusChange?.({ status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom$9.getImageEl(ctx2);
          if (imageEl?.complete) {
            const type2 = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type: type2, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
createProps$1()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
const useAvatar = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode,
    ...props
  };
  const context2 = {
    ...initialContext,
    onStatusChange: useEvent(props.onStatusChange)
  };
  const [state, send] = useMachine(machine$4(initialContext), { context: context2 });
  return connect$5(state, send, normalizeProps);
};
const AvatarRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [useAvatarProps, localProps] = createSplitProps()(props, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps(avatar.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarProvider, { value: avatar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
});
AvatarRoot$1.displayName = "AvatarRoot";
const AvatarRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: avatar }, localProps] = createSplitProps()(props, ["value"]);
    const mergedProps = mergeProps(avatar.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarProvider, { value: avatar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";
var anatomy$9 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
anatomy$9.build();
var dom$8 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `checkbox:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `checkbox:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `checkbox:${ctx.id}:control`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `checkbox:${ctx.id}:input`,
  getRootEl: (ctx) => dom$8.getById(ctx, dom$8.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom$8.getById(ctx, dom$8.getHiddenInputId(ctx))
});
createProps$1()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
const checkboxAnatomy = anatomy$9.extendWith("group");
const colorPickerAnatomy = anatomy$l.extendWith("view");
var anatomy$8 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
anatomy$8.build();
var dom$7 = createScope({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `hover-card:${ctx.id}:content`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`,
  getTriggerEl: (ctx) => dom$7.getById(ctx, dom$7.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$7.getById(ctx, dom$7.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$7.getById(ctx, dom$7.getPositionerId(ctx))
});
createProps$1()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
const [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});
const NumberInputControl$1 = reactExports.forwardRef(
  (props, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getControlProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputControl$1.displayName = "NumberInputControl";
const NumberInputDecrementTrigger$1 = reactExports.forwardRef((props, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getDecrementTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputDecrementTrigger$1.displayName = "NumberInputDecrementTrigger";
const NumberInputIncrementTrigger$1 = reactExports.forwardRef((props, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getIncrementTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputIncrementTrigger$1.displayName = "NumberInputIncrementTrigger";
const NumberInputInput$1 = reactExports.forwardRef(
  (props, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getInputProps(), props);
    const field = useFieldContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
NumberInputInput$1.displayName = "NumberInputInput";
const NumberInputLabel = reactExports.forwardRef(
  (props, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getLabelProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";
let $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p2) => ({
        ...p2,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p2) => ({
        ...p2,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
}
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}
const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
}
const $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
class $6c7bd7858deea686$var$NumberParserImpl {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
const $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n2) => symbolFormatter.formatToParts(n2));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p2) => p2.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p2) => p2.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p2) => p2.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p2) => p2.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value));
  let pluralPartsLiterals = pluralParts.flatMap((p2) => p2.filter((p3) => !$6c7bd7858deea686$var$nonLiteralParts.has(p3.type)).map((p3) => $6c7bd7858deea686$var$escapeRegex(p3.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a2, b2) => b2.length - a2.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d2, i2) => [
    d2,
    i2
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d2) => String(indexes.get(d2));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll) return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var anatomy$7 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts$4 = anatomy$7.build();
var dom$6 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `number-input:${ctx.id}`,
  getInputId: (ctx) => ctx.ids?.input ?? `number-input:${ctx.id}:input`,
  getIncrementTriggerId: (ctx) => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`,
  getDecrementTriggerId: (ctx) => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`,
  getScrubberId: (ctx) => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`,
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => ctx.ids?.label ?? `number-input:${ctx.id}:label`,
  getInputEl: (ctx) => dom$6.getById(ctx, dom$6.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom$6.getById(ctx, dom$6.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom$6.getById(ctx, dom$6.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom$6.getById(ctx, dom$6.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom$6.getDoc(ctx).getElementById(dom$6.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom$6.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom$6.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom$6.createVirtualCursor(ctx);
    return () => {
      dom$6.getCursorEl(ctx)?.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom$6.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousemoveValue(ctx, event) {
    const win = dom$6.getWin(ctx);
    const x2 = roundToDpr(event.movementX, win.devicePixelRatio);
    const y2 = roundToDpr(event.movementY, win.devicePixelRatio);
    let hint = x2 > 0 ? "increment" : x2 < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x2,
      y: ctx.scrubberCursorPoint.y + y2
    };
    const width = win.innerWidth;
    const half = roundToDpr(7.5, win.devicePixelRatio);
    point.x = wrap$2(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom$6.getDoc(ctx);
    const el2 = doc.createElement("div");
    el2.className = "scrubber--cursor";
    el2.id = dom$6.getCursorId(ctx);
    Object.assign(el2.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el2.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el2);
  }
});
function connect$4(state, send, normalize2) {
  const focused = state.hasTag("focus");
  const disabled = state.context.isDisabled;
  const readOnly = state.context.readOnly;
  const empty2 = state.context.isValueEmpty;
  const invalid = state.context.isOutOfRange || !!state.context.invalid;
  const isIncrementDisabled = disabled || !state.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state.context.canDecrement || readOnly;
  const translations = state.context.translations;
  return {
    focused,
    invalid,
    empty: empty2,
    value: state.context.formattedValue,
    valueAsNumber: state.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state.context.min });
    },
    focus() {
      dom$6.getInputEl(state.context)?.focus();
    },
    getRootProps() {
      return normalize2.element({
        id: dom$6.getRootId(state.context),
        ...parts$4.root.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr$1(disabled),
        "data-focus": dataAttr$1(focused),
        "data-invalid": dataAttr$1(invalid)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts$4.label.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr$1(disabled),
        "data-focus": dataAttr$1(focused),
        "data-invalid": dataAttr$1(invalid),
        id: dom$6.getLabelId(state.context),
        htmlFor: dom$6.getInputId(state.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$4.control.attrs,
        dir: state.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr$1(focused),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "aria-invalid": ariaAttr(state.context.invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts$4.valueText.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-focus": dataAttr$1(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts$4.input.attrs,
        dir: state.context.dir,
        name: state.context.name,
        form: state.context.form,
        id: dom$6.getInputId(state.context),
        role: "spinbutton",
        defaultValue: state.context.formattedValue,
        pattern: state.context.pattern,
        inputMode: state.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr$1(invalid),
        disabled,
        "data-disabled": dataAttr$1(disabled),
        readOnly: state.context.readOnly,
        required: state.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state.context.min,
        "aria-valuemax": state.context.max,
        "aria-valuenow": Number.isNaN(state.context.valueAsNumber) ? void 0 : state.context.valueAsNumber,
        "aria-valuetext": state.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send("INPUT.BLUR");
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * state.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[event.key];
          exec2?.(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize2.button({
        ...parts$4.decrementTrigger.attrs,
        dir: state.context.dir,
        id: dom$6.getDecrementTriggerId(state.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr$1(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom$6.getInputId(state.context),
        onPointerDown(event) {
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize2.button({
        ...parts$4.incrementTrigger.attrs,
        dir: state.context.dir,
        id: dom$6.getIncrementTriggerId(state.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr$1(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom$6.getInputId(state.context),
        onPointerDown(event) {
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize2.element({
        ...parts$4.scrubber.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr$1(disabled),
        id: dom$6.getScrubberId(state.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow$1(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref$1(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref$1(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions) return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value)) return "";
  if (!ctx.formatOptions) return value.toString();
  return ctx.formatter.format(value);
};
var { not: not$3, and: and$2 } = guards;
function machine$3(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isValueAtMin(ctx2.valueAsNumber, ctx2.min),
        isAtMax: (ctx2) => isValueAtMax(ctx2.valueAsNumber, ctx2.max),
        isOutOfRange: (ctx2) => !isValueWithinRange(ctx2.valueAsNumber, ctx2.min, ctx2.max),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => ctx2.translations.valueText?.(ctx2.value)
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.BLUR": [
              {
                guard: and$2("clampValueOnBlur", not$3("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and$2("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and$2(not$3("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and$2(not$3("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom$6.getInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set$2.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom$6.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom$6.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom$6.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom$6.getInputEl(ctx2);
          if (!inputEl || !dom$6.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari()) return;
          return requestPointerLock(dom$6.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom$6.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint) return;
            const value = dom$6.getMousemoveValue(ctx2, event);
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll(
            addDomEvent(doc, "mousemove", onMousemove, false),
            addDomEvent(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange) return;
          const inputEl = dom$6.getInputEl(ctx2);
          if (dom$6.isActiveElement(ctx2, inputEl)) return;
          raf$1(() => inputEl?.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = incrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set$2.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set$2.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clampValue(ctx2.valueAsNumber, ctx2.min, ctx2.max);
          set$2.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clampValue(parsedValue, ctx2.min, ctx2.max));
          set$2.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          const value = evt.target?.value ?? evt.value;
          set$2.value(ctx2, value);
        },
        clearValue(ctx2) {
          set$2.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set$2.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set$2.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          ctx2.onFocusChange?.({
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          ctx2.onFocusChange?.({
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          if (!ctx2.isOutOfRange) return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          ctx2.onValueInvalid?.({
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set$2.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom$6.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint) return;
          const { x: x2, y: y2 } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x2}px, ${y2}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale) return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a2, b2) => isEqual$1(a2, b2),
        scrubberCursorPoint: (a2, b2) => isEqual$1(a2, b2)
      }
    }
  );
}
var sync = {
  input(ctx, value) {
    const inputEl = dom$6.getInputEl(ctx);
    if (!inputEl) return;
    const sel = recordCursor(inputEl);
    raf$1(() => {
      setElementValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke$1 = {
  onChange: (ctx) => {
    ctx.onValueChange?.({
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set$2 = {
  value: (ctx, value) => {
    if (isEqual$1(ctx.value, value)) return;
    ctx.value = value;
    invoke$1.onChange(ctx);
  }
};
const useNumberInput = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: reactExports.useId(),
    ids: {
      label: field?.ids.label,
      input: field?.ids.control
    },
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    required: field?.required,
    invalid: field?.invalid,
    dir,
    locale,
    getRootNode,
    value: props.defaultValue,
    ...props
  };
  const context2 = {
    ...initialContext,
    value: props.value,
    onValueChange: useEvent(props.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props.onValueInvalid),
    onFocusChange: useEvent(props.onFocusChange)
  };
  const [state, send] = useMachine(machine$3(initialContext), { context: context2 });
  return connect$4(state, send, normalizeProps);
};
const NumberInputRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [useNumberInputProps, localProps] = createSplitProps()(props, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputProvider, { value: numberInput, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
});
NumberInputRoot$1.displayName = "NumberInputRoot";
const NumberInputRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: numberInput }, localProps] = createSplitProps()(props, [
      "value"
    ]);
    const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputProvider, { value: numberInput, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";
const NumberInputScrubber = reactExports.forwardRef(
  (props, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getScrubberProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";
const NumberInputValueText = reactExports.forwardRef(
  (props, ref2) => {
    const { children, ...localProps } = props;
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getValueTextProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2, children: children || numberInput.value });
  }
);
NumberInputValueText.displayName = "NumberInputValueText";
var anatomy$6 = createAnatomy("pinInput").parts("root", "label", "input", "control");
anatomy$6.build();
var dom$5 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `pin-input:${ctx.id}`,
  getInputId: (ctx, id2) => ctx.ids?.input?.(id2) ?? `pin-input:${ctx.id}:${id2}`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `pin-input:${ctx.id}:hidden`,
  getLabelId: (ctx) => ctx.ids?.label ?? `pin-input:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `pin-input:${ctx.id}:control`,
  getRootEl: (ctx) => dom$5.getById(ctx, dom$5.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom$5.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom$5.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id2) => dom$5.getById(ctx, dom$5.getInputId(ctx, id2)),
  getFocusedInputEl: (ctx) => dom$5.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom$5.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom$5.getById(ctx, dom$5.getHiddenInputId(ctx))
});
var anatomy$5 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
anatomy$5.build();
createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `progress-${ctx.id}`,
  getTrackId: (ctx) => ctx.ids?.track ?? `progress-${ctx.id}-track`,
  getLabelId: (ctx) => ctx.ids?.label ?? `progress-${ctx.id}-label`,
  getCircleId: (ctx) => ctx.ids?.circle ?? `progress-${ctx.id}-circle`
});
createProps$1()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange"
]);
var anatomy$4 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
anatomy$4.build();
var dom$4 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `qrcode:${ctx.id}:root`,
  getFrameId: (ctx) => ctx.ids?.frame ?? `qrcode:${ctx.id}:frame`,
  getFrameEl: (ctx) => dom$4.getById(ctx, dom$4.getFrameId(ctx))
});
createProps$1()([
  "ids",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange"
]);
const segmentGroupAnatomy = anatomy$f.rename("segment-group");
segmentGroupAnatomy.build();
const [TooltipProvider, useTooltipContext] = createContext({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});
const TooltipArrow$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow$1.displayName = "TooltipArrow";
const TooltipArrowTip$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowTipProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip$1.displayName = "TooltipArrowTip";
const TooltipContent$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(tooltip.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TooltipContent$1.displayName = "TooltipContent";
const TooltipPositioner$1 = reactExports.forwardRef(
  (props, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps(tooltip.getPositionerProps(), props);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner$1.displayName = "TooltipPositioner";
var anatomy$3 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts$3 = anatomy$3.build();
var dom$3 = createScope({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `tooltip:${ctx.id}:content`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,
  getTriggerEl: (ctx) => dom$3.getById(ctx, dom$3.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$3.getById(ctx, dom$3.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$3.getById(ctx, dom$3.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom$3.getById(ctx, dom$3.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect$3(state, send, normalize2) {
  const id2 = state.context.id;
  const hasAriaLabel = state.context.hasAriaLabel;
  const open = state.hasTag("open");
  const triggerId = dom$3.getTriggerId(state.context);
  const contentId = dom$3.getContentId(state.context);
  const disabled = state.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$3.trigger.attrs,
        id: triggerId,
        dir: state.context.dir,
        "data-expanded": dataAttr$1(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id2 === store.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state.context.closeOnPointerDown) return;
          if (id2 === store.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom$3.getArrowId(state.context),
        ...parts$3.arrow.attrs,
        dir: state.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts$3.arrowTip.attrs,
        dir: state.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom$3.getPositionerId(state.context),
        ...parts$3.positioner.attrs,
        dir: state.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$3.content.attrs,
        dir: state.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and$1, not: not$2 } = guards;
function machine$2(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        disabled: false,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and$1("noVisibleTooltip", not$2("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not$2("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom$3.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom$3.getPositionerEl(ctx2);
          return getPlacement(dom$3.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom$3.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom$3.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors$1(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll2 = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent(overflowParent, "scroll", onScroll2, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn?.());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe$1(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent(dom$3.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom$3.getPositionerEl(ctx2);
          getPlacement(dom$3.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
createProps$1()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
const useTooltip = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode,
    open: props.defaultOpen,
    "open.controlled": props.open !== void 0,
    ...props
  };
  const context2 = {
    ...initialContext,
    onOpenChange: useEvent(props.onOpenChange, { sync: true })
  };
  const [state, send] = useMachine(machine$2(initialContext), { context: context2 });
  return connect$3(state, send, normalizeProps);
};
const TooltipRoot$1 = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipRootProvider = (props) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipTrigger$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger$1.displayName = "TooltipTrigger";
const accordionAnatomy = anatomy$n.extendWith("itemBody");
const actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
const alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
const breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
const blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
const cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
const checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
const dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
const dialogAnatomy = anatomy$k.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const drawerAnatomy = anatomy$k.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const editableAnatomy = anatomy$j.extendWith("textarea");
const emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
const fieldAnatomy = fieldAnatomy$1.extendWith("requiredIndicator");
const fieldsetAnatomy = fieldsetAnatomy$1.extendWith("content");
const fileUploadAnatomy = anatomy$i.extendWith(
  "itemContent",
  "dropzoneContent"
);
const listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
const menuAnatomy = anatomy$h.extendWith("itemCommand");
const nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
const popoverAnatomy = anatomy$g.extendWith(
  "header",
  "body",
  "footer"
);
const radioGroupAnatomy = anatomy$f.extendWith(
  "itemAddon",
  "itemIndicator"
);
const radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
const ratingGroupAnatomy = anatomy$e.extendWith("itemIndicator");
const selectAnatomy = anatomy$d.extendWith("indicatorGroup");
const sliderAnatomy = anatomy$c.extendWith("markerIndicator");
const statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
const statusAnatomy = createAnatomy("status").parts("root", "indicator");
const stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
const switchAnatomy = anatomy$b.extendWith("indicator");
const tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
const toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
const tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
const tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
const timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
const accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});
const alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});
const avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy$a.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});
const blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});
const breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});
const cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});
const checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: checkmarkRecipe.variants?.size?.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: checkmarkRecipe.variants?.size?.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: checkmarkRecipe.variants?.size?.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: checkmarkRecipe.variants?.size?.lg
      }
    },
    variant: {
      outline: {
        control: checkmarkRecipe.variants?.variant?.outline
      },
      solid: {
        control: checkmarkRecipe.variants?.variant?.solid
      },
      subtle: {
        control: checkmarkRecipe.variants?.variant?.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8",
        borderColor: "border.subtle"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm"
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy$m.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});
const colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm"
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: inputRecipe.variants?.size?.["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: inputRecipe.variants?.size?.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: inputRecipe.variants?.size?.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: inputRecipe.variants?.size?.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: inputRecipe.variants?.size?.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: inputRecipe.variants?.size?.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: inputRecipe.variants?.size?.["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: inputRecipe.variants?.variant?.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: inputRecipe.variants?.variant?.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});
const dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});
const drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});
const sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
const editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});
const fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});
const hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy$8.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert",
          listStylePosition: "inside"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});
const menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});
const selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: selectSlotRecipe.variants?.variant.outline.trigger
      },
      subtle: {
        field: selectSlotRecipe.variants?.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});
function mapEntries(obj, f2) {
  const result = {};
  for (const key in obj) {
    const kv = f2(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}
const triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
const numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy$7.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const { variants, defaultVariants } = inputRecipe;
const pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy$6.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    }
  },
  variants: {
    size: mapEntries(variants.size, (key, value) => [key, { input: value }]),
    variant: mapEntries(variants.variant, (key, value) => [
      key,
      { input: value }
    ])
  },
  defaultVariants
});
const popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const progressSlotRecipe = defineSlotRecipe({
  slots: anatomy$5.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});
const progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy$5.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy$4.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: radiomarkRecipe.variants?.variant?.outline
      },
      subtle: {
        itemControl: radiomarkRecipe.variants?.variant?.subtle
      },
      solid: {
        itemControl: radiomarkRecipe.variants?.variant?.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: radiomarkRecipe.variants?.size?.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: radiomarkRecipe.variants?.size?.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: radiomarkRecipe.variants?.size?.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: radiomarkRecipe.variants?.size?.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});
const statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});
const switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});
const tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});
const badgeVariant = badgeRecipe.variants?.variant;
const tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant?.subtle
      },
      solid: {
        root: badgeVariant?.solid
      },
      outline: {
        root: badgeVariant?.outline
      },
      surface: {
        root: badgeVariant?.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});
const timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});
const tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy$3.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});
const slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};
const textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});
const animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});
const aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});
const blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});
const borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});
const colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});
const cursor = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});
const durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});
const easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});
const fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});
const fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});
const fallback = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
const fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback}`
  },
  body: {
    value: `Inter, ${fallback}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});
const keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});
const letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});
const lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});
const radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});
const spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});
const largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
const namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
const fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
const sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});
const zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});
const defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});
const defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
const defaultSystem = createSystem(defaultConfig);
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider, useStyles] = createContext$1({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider, useClassNames2] = createContext$1({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider2, usePropsContext2] = createContext$1({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult2(props) {
    const { unstyled, ...restProps } = props;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = slotRecipe.splitVariantProps(restProps);
    const styles2 = unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps);
    return {
      styles: styles2,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider2(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const props = mergeProps$1(defaultProps, usePropsContext2(), inProps);
      const { styles: styles2, classNames: classNames2, props: rootProps } = useRecipeResult2(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider2 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = reactExports.forwardRef((inProps, ref2) => {
      const props = mergeProps$1(defaultProps ?? {}, usePropsContext2(), inProps);
      const { styles: styles2, props: rootProps, classNames: classNames2 } = useRecipeResult2(props);
      const className = classNames2[slot];
      const element = /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ref: ref2,
          ...rootProps,
          css: [styles2[slot], props.css],
          className: cx(props.className, className)
        }
      ) }) });
      return options2?.wrapElement?.(element, props) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext2 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = reactExports.forwardRef((props, ref2) => {
      const styles2 = useStyles();
      const classNames2 = useClassNames2();
      const className = classNames2?.[slot];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...props,
          css: [slot ? styles2[slot] : void 0, props.css],
          ref: ref2,
          className: cx(props.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider,
    ClassNamesProvider,
    PropsProvider: PropsProvider2,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult2,
    withProvider: withProvider2,
    withContext: withContext2,
    withRootProvider: withRootProvider2,
    useStyles,
    useClassNames: useClassNames2
  };
};
const CheckIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
const ChevronUpIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m18 15-6-6-6 6" })
  }
);
const ChevronDownIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
const CheckCircleIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
const WarningIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
const CloseIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });
const {
  withProvider: withProvider$7,
  withContext: withContext$d,
  useStyles: useAvatarStyles,
  PropsProvider: PropsProvider$e
} = createSlotRecipeContext({ key: "avatar" });
withProvider$7(AvatarRootProvider, "root", { forwardAsChild: true });
const AvatarRoot = withProvider$7(
  AvatarRoot$1,
  "root",
  { forwardAsChild: true }
);
const AvatarPropsProvider = PropsProvider$e;
const AvatarFallback$1 = withContext$d(
  AvatarFallback$2,
  "fallback",
  { forwardAsChild: true }
);
const AvatarImage = withContext$d(
  AvatarImage$1,
  "image",
  {
    forwardAsChild: true,
    defaultProps: {
      draggable: "false",
      referrerPolicy: "no-referrer"
    }
  }
);
const AvatarIcon = reactExports.forwardRef(
  function AvatarIcon2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.svg,
      {
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0",
        viewBox: "0 0 24 24",
        height: "1.2em",
        width: "1.2em",
        ref: ref2,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 22H18V20C18 18.3431 16.6569 17 15 17H9C7.34315 17 6 18.3431 6 20V22H4V20C4 17.2386 6.23858 15 9 15H15C17.7614 15 20 17.2386 20 20V22ZM12 13C8.68629 13 6 10.3137 6 7C6 3.68629 8.68629 1 12 1C15.3137 1 18 3.68629 18 7C18 10.3137 15.3137 13 12 13ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" })
      }
    );
  }
);
const Box = chakra("div");
Box.displayName = "Box";
const Span = chakra("span");
const AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        transform: "translateX(-50%)"
      },
      vertical: {
        top: "50%",
        transform: "translateY(-50%)"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";
const { withContext: withContext$c, PropsProvider: PropsProvider$d } = createRecipeContext({
  key: "spinner"
});
const Spinner = withContext$c("span");
const Loader$2 = reactExports.forwardRef(
  function Loader2(props, ref2) {
    const {
      spinner = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props;
    if (!visible) return children;
    if (text) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Span, { ref: ref2, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Span, { ref: ref2, display: "contents", ...rest, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteCenter, { display: "inline-flex", children: spinner }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { opacity: 0, children })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { ref: ref2, display: "contents", ...rest, children });
  }
);
const { useRecipeResult: useRecipeResult$1, PropsProvider: PropsProvider$c, usePropsContext } = createRecipeContext(
  { key: "button" }
);
const Button$1 = reactExports.forwardRef(
  function Button2(inProps, ref2) {
    const propsContext = usePropsContext();
    const props = reactExports.useMemo(
      () => mergeProps$1(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult$1(props);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.button,
      {
        type: "button",
        ref: ref2,
        ...rest,
        disabled: loading || rest.disabled,
        className: cx(result.className, props.className),
        css: [result.styles, props.css],
        children: !props.asChild && loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Loader$2,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
const IconButton = reactExports.forwardRef(
  function IconButton2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref: ref2,
        ...props
      }
    );
  }
);
const dataAttr = (condition) => condition ? "" : void 0;
const StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
const Group = reactExports.memo(
  reactExports.forwardRef(function Group2(props, ref2) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap2,
      ...rest
    } = props;
    const count = reactExports.Children.count(children);
    const _children = reactExports.useMemo(() => {
      const childArray = reactExports.Children.toArray(children).filter(
        reactExports.isValidElement
      );
      return childArray.map((child, index) => {
        const childProps = child.props;
        return reactExports.cloneElement(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr(index === 0),
          "data-last": dataAttr(index === count - 1),
          "data-between": dataAttr(index > 0 && index < count - 1),
          style: {
            "--group-count": count,
            "--group-index": index,
            ...childProps?.style ?? {}
          }
        });
      });
    }, [children, count]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      StyledGroup,
      {
        ref: ref2,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap2,
        ...rest,
        children: _children
      }
    );
  })
);
const [ClipboardProvider, useClipboardContext] = createContext({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});
const ClipboardControl = reactExports.forwardRef((props, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ClipboardControl.displayName = "ClipboardControl";
const ClipboardIndicator$1 = reactExports.forwardRef(
  (props, ref2) => {
    const { children, copied, ...localProps } = props;
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps(
      clipboard.getIndicatorProps({ copied: clipboard.copied }),
      localProps
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2, children: clipboard.copied ? copied : children });
  }
);
ClipboardIndicator$1.displayName = "ClipboardIndicator";
const ClipboardInput$1 = reactExports.forwardRef((props, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getInputProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { ...mergedProps, ref: ref2 });
});
ClipboardInput$1.displayName = "ClipboardInput";
const ClipboardLabel$1 = reactExports.forwardRef((props, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 });
});
ClipboardLabel$1.displayName = "ClipboardLabel";
var anatomy$2 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts$2 = anatomy$2.build();
var dom$2 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `clip:${ctx.id}`,
  getInputId: (ctx) => ctx.ids?.input ?? `clip:${ctx.id}:input`,
  getLabelId: (ctx) => ctx.ids?.label ?? `clip:${ctx.id}:label`,
  getInputEl: (ctx) => dom$2.getById(ctx, dom$2.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText(dom$2.getDoc(ctx), ctx.value)
});
function createNode(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode(node2) {
  const win = getWindow$1(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node2);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  const win = doc.defaultView || window;
  if (win.navigator.clipboard?.writeText !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode(doc, text);
  doc.body.appendChild(node2);
  copyNode(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
function connect$2(state, send, normalize2) {
  const copied = state.matches("copied");
  return {
    copied,
    value: state.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts$2.root.attrs,
        "data-copied": dataAttr$1(copied),
        id: dom$2.getRootId(state.context)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts$2.label.attrs,
        htmlFor: dom$2.getInputId(state.context),
        "data-copied": dataAttr$1(copied),
        id: dom$2.getLabelId(state.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$2.control.attrs,
        "data-copied": dataAttr$1(copied)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts$2.input.attrs,
        defaultValue: state.context.value,
        "data-copied": dataAttr$1(copied),
        readOnly: true,
        "data-readonly": "true",
        id: dom$2.getInputId(state.context),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$2.trigger.attrs,
        type: "button",
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr$1(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props2) {
      return normalize2.element({
        ...parts$2.indicator.attrs,
        hidden: props2.copied !== copied
      });
    }
  };
}
function machine$1(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "clipboard",
      initial: "idle",
      context: {
        value: "",
        timeout: 3e3,
        ...ctx
      },
      watch: {
        value: ["syncInputElement"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.COPY": {
              target: "copied",
              actions: ["invokeOnCopy"]
            }
          }
        },
        copied: {
          after: {
            COPY_TIMEOUT: "idle"
          },
          on: {
            COPY: {
              target: "copied",
              actions: ["copyToClipboard", "invokeOnCopy"]
            },
            "INPUT.COPY": {
              actions: ["invokeOnCopy"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        copyToClipboard(ctx2) {
          dom$2.writeToClipboard(ctx2);
        },
        invokeOnCopy(ctx2) {
          ctx2.onStatusChange?.({ copied: true });
        },
        syncInputElement(ctx2) {
          dom$2.setValue(dom$2.getInputEl(ctx2), ctx2.value);
        }
      },
      delays: {
        COPY_TIMEOUT: (ctx2) => ctx2.timeout
      }
    }
  );
}
createProps$1()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
createProps$1()(["copied"]);
const useClipboard = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: reactExports.useId(),
    getRootNode,
    ...props
  };
  const context2 = {
    ...initialContext
  };
  const [state, send] = useMachine(machine$1(initialContext), { context: context2 });
  return connect$2(state, send, normalizeProps);
};
const ClipboardRoot$2 = reactExports.forwardRef((props, ref2) => {
  const [useClipboardProps, localProps] = createSplitProps()(props, [
    "id",
    "ids",
    "onStatusChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardProvider, { value: clipboard, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ref: ref2, ...mergedProps }) });
});
ClipboardRoot$2.displayName = "ClipboardRoot";
const ClipboardRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: clipboard }, localProps] = createSplitProps()(props, [
      "value"
    ]);
    const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardProvider, { value: clipboard, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ref: ref2, ...mergedProps }) });
  }
);
ClipboardRootProvider.displayName = "ClipboardRootProvider";
const ClipboardTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps(clipboard.getTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ClipboardTrigger$1.displayName = "ClipboardTrigger";
const ClipboardValueText = reactExports.forwardRef(
  (props, ref2) => {
    const clipboard = useClipboardContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...props, ref: ref2, children: props.children || clipboard.value });
  }
);
ClipboardValueText.displayName = "ClipboardValueText";
const {
  withProvider: withProvider$6,
  withContext: withContext$b,
  useStyles: useClipboardStyles,
  PropsProvider: PropsProvider$b
} = createSlotRecipeContext({ key: "clipboard" });
withProvider$6(ClipboardRootProvider, "root", { forwardAsChild: true });
const ClipboardRoot$1 = withProvider$6(
  ClipboardRoot$2,
  "root",
  { forwardAsChild: true }
);
const ClipboardTrigger = withContext$b(ClipboardTrigger$1, "trigger", { forwardAsChild: true });
withContext$b(ClipboardControl, "control", { forwardAsChild: true });
const ClipboardIndicator = withContext$b(ClipboardIndicator$1, "indicator", { forwardAsChild: true });
const ClipboardInput = withContext$b(ClipboardInput$1, "input", { forwardAsChild: true });
const ClipboardLabel = withContext$b(ClipboardLabel$1, "label", { forwardAsChild: true });
withContext$b(ClipboardValueText, "valueText", { forwardAsChild: true });
const {
  withRootProvider: withRootProvider$1,
  withContext: withContext$a,
  useStyles: useDrawerStyles,
  PropsProvider: PropsProvider$a
} = createSlotRecipeContext({ key: "drawer" });
withRootProvider$1(
  DialogRootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
const DrawerRoot$1 = withRootProvider$1(DialogRoot, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
const DrawerTrigger$1 = withContext$a(
  DialogTrigger,
  "trigger",
  { forwardAsChild: true }
);
const DrawerPositioner = withContext$a(DialogPositioner, "positioner", { forwardAsChild: true });
const DrawerContent$1 = withContext$a(
  DialogContent,
  "content",
  { forwardAsChild: true }
);
withContext$a(DialogDescription, "description", { forwardAsChild: true });
const DrawerTitle$1 = withContext$a(
  DialogTitle,
  "title",
  { forwardAsChild: true }
);
const DrawerCloseTrigger$1 = withContext$a(DialogCloseTrigger, "closeTrigger", { forwardAsChild: true });
const DrawerActionTrigger$1 = reactExports.forwardRef(function DrawerActionTrigger2(props, ref2) {
  const drawer = useDialogContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.button, { ...props, ref: ref2, onClick: () => drawer.setOpen(false) });
});
const DrawerBackdrop$1 = withContext$a(
  DialogBackdrop,
  "backdrop",
  { forwardAsChild: true }
);
const DrawerBody$1 = withContext$a(
  "div",
  "body"
);
const DrawerFooter$1 = withContext$a(
  "div",
  "footer"
);
const DrawerHeader$1 = withContext$a(
  "div",
  "header"
);
const { useRecipeResult, PropsProvider: PropsProvider$9 } = createRecipeContext({ key: "icon" });
const Icon = reactExports.forwardRef(
  function Icon2(props, ref2) {
    const {
      styles: styles2,
      className,
      props: otherProps
    } = useRecipeResult({ asChild: !props.as, ...props });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.svg,
      {
        ref: ref2,
        focusable: false,
        "aria-hidden": "true",
        ...otherProps,
        css: [styles2, props.css],
        className: cx(className, props.className)
      }
    );
  }
);
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path2 = reactExports.Children.toArray(options.path);
  const Comp = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon,
    {
      ref: ref2,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props,
      children: path2.length ? path2 : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}
const {
  withProvider: withProvider$5,
  withContext: withContext$9,
  useStyles: useFieldStyles,
  useClassNames,
  PropsProvider: PropsProvider$8
} = createSlotRecipeContext({ key: "field" });
const FieldRoot = withProvider$5(
  FieldRoot$1,
  "root",
  { forwardAsChild: true }
);
const FieldLabel = withContext$9(
  FieldLabel$1,
  "label",
  { forwardAsChild: true }
);
const FieldHelperText = withContext$9(FieldHelperText$1, "helperText", { forwardAsChild: true });
const FieldErrorText = withContext$9(
  FieldErrorText$1,
  "errorText",
  { forwardAsChild: true }
);
createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
const FieldRequiredIndicator = reactExports.forwardRef(function RequiredIndicator(props, ref2) {
  const { fallback: fallback2, children = "*", ...restProps } = props;
  const field = useFieldContext();
  const classNames2 = useClassNames();
  const styles2 = useFieldStyles();
  if (!field?.required) {
    return fallback2;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      ref: ref2,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames2.requiredIndicator, props.className),
      css: [styles2.requiredIndicator, props.css],
      children
    }
  );
});
const Flex = reactExports.forwardRef(
  function Flex2(props, ref2) {
    const {
      direction,
      align,
      justify,
      wrap: wrap2,
      basis,
      grow,
      shrink,
      inline,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap2,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props.css
        }
      }
    );
  }
);
const Image$1 = reactExports.forwardRef(
  function Image2(props, ref2) {
    const { align, fit = "cover", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.img,
      {
        ref: ref2,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props.className),
        ...rest
      }
    );
  }
);
const { withContext: withContext$8, PropsProvider: PropsProvider$7 } = createRecipeContext({
  key: "input"
});
const Input = withContext$8(FieldInput);
const InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.subtle",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});
const {
  withProvider: withProvider$4,
  withContext: withContext$7,
  useStyles: useNumberInputStyles,
  PropsProvider: PropsProvider$6
} = createSlotRecipeContext({ key: "numberInput" });
withProvider$4(NumberInputRootProvider, "root", { forwardAsChild: true });
const NumberInputRoot = withProvider$4(NumberInputRoot$1, "root", { forwardAsChild: true });
const NumberInputControl = withContext$7(NumberInputControl$1, "control", { forwardAsChild: true });
withContext$7(NumberInputLabel, "label", { forwardAsChild: true });
const NumberInputInput = withContext$7(NumberInputInput$1, "input", { forwardAsChild: true });
const NumberInputIncrementTrigger = withContext$7(NumberInputIncrementTrigger$1, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUpIcon, {}) }
});
const NumberInputDecrementTrigger = withContext$7(NumberInputDecrementTrigger$1, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {}) }
});
withContext$7(NumberInputScrubber, "scrubber", { forwardAsChild: true });
withContext$7(NumberInputValueText, "valueText", { forwardAsChild: true });
const Portal = (props) => {
  const { children, disabled } = props;
  const [container, setContainer] = reactExports.useState(props.container?.current);
  const isServer = reactExports.useSyncExternalStore(
    subscribe,
    () => false,
    () => true
  );
  const { getRootNode } = useEnvironmentContext();
  reactExports.useEffect(() => {
    setContainer(() => props.container?.current);
  }, [props.container]);
  if (isServer || disabled) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: reactExports.Children.map(children, (child) => reactDomExports.createPortal(child, mountNode)) });
};
const getPortalNode = (cb2) => {
  const node2 = cb2?.();
  const rootNode = node2.getRootNode();
  if (isShadowRoot$1(rootNode)) return rootNode;
  return getDocument(node2).body;
};
const subscribe = () => () => {
};
const {
  withProvider: withProvider$3,
  withContext: withContext$6,
  useStyles: useSelectStyles,
  PropsProvider: PropsProvider$5
} = createSlotRecipeContext({ key: "select" });
withProvider$3(SelectRootProvider, "root", {
  forwardAsChild: true
});
const SelectRoot$1 = withProvider$3(
  SelectRoot$2,
  "root",
  { forwardAsChild: true }
);
const SelectTrigger$1 = withContext$6(
  SelectTrigger$2,
  "trigger",
  { forwardAsChild: true }
);
const SelectPositioner = withContext$6(SelectPositioner$1, "positioner", { forwardAsChild: true });
const SelectContent$1 = withContext$6(
  SelectContent$2,
  "content",
  { forwardAsChild: true }
);
const SelectValueText$1 = withContext$6(SelectValueText$2, "valueText", { forwardAsChild: true });
const SelectClearTrigger$1 = withContext$6(SelectClearTrigger$2, "clearTrigger", { forwardAsChild: true });
const SelectItemGroup = withContext$6(SelectItemGroup$1, "itemGroup", { forwardAsChild: true });
const SelectItemGroupLabel = withContext$6(SelectItemGroupLabel$1, "itemGroupLabel", { forwardAsChild: true });
const SelectItem$1 = withContext$6(
  SelectItem$2,
  "item",
  { forwardAsChild: true }
);
withContext$6(
  SelectItemText,
  "itemText",
  { forwardAsChild: true }
);
const SelectItemIndicator = withContext$6(SelectItemIndicator$1, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {})
  }
});
const SelectIndicatorGroup = withContext$6("div", "indicatorGroup");
const SelectIndicator = withContext$6(SelectIndicator$1, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {})
  }
});
const SelectControl = withContext$6(
  SelectControl$1,
  "control",
  { forwardAsChild: true }
);
withContext$6(
  SelectLabel,
  "label",
  { forwardAsChild: true }
);
const SelectContext = SelectContext$1;
const SelectHiddenSelect = SelectHiddenSelect$1;
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles2 = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles2[value])
  };
}
function getValidChildren(children) {
  return reactExports.Children.toArray(children).filter(
    (child) => reactExports.isValidElement(child)
  );
}
const Stack = reactExports.forwardRef(
  function Stack2(props, ref2) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap2,
      children,
      separator,
      className,
      ...rest
    } = props;
    const separatorStyle = reactExports.useMemo(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = reactExports.useMemo(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = reactExports.cloneElement(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref: ref2,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap2,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);
const HStack = reactExports.forwardRef(
  function HStack2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "row", ref: ref2 });
  }
);
const VStack = reactExports.forwardRef(
  function VStack2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "column", ref: ref2 });
  }
);
const {
  withProvider: withProvider$2,
  withContext: withContext$5,
  useStyles: useSwitchStyles,
  PropsProvider: PropsProvider$4
} = createSlotRecipeContext({ key: "switch" });
withProvider$2(SwitchRootProvider, "root", { forwardAsChild: true });
const SwitchRoot = withProvider$2(
  SwitchRoot$1,
  "root",
  { forwardAsChild: true }
);
const SwitchLabel = withContext$5(
  SwitchLabel$1,
  "label",
  { forwardAsChild: true }
);
const SwitchControl = withContext$5(
  SwitchControl$1,
  "control",
  { forwardAsChild: true }
);
const SwitchThumb = withContext$5(
  SwitchThumb$1,
  "thumb",
  { forwardAsChild: true }
);
const SwitchIndicator = reactExports.forwardRef(function SwitchIndicator2(props, ref2) {
  const api = useSwitchContext();
  const styles2 = useSwitchStyles();
  const { fallback: fallback2, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      ref: ref2,
      "data-checked": dataAttr(api.checked),
      ...rest,
      css: [styles2.indicator, props.css],
      children: api.checked ? children : fallback2
    }
  );
});
const SwitchThumbIndicator = reactExports.forwardRef(function SwitchThumbIndicator2(props, ref2) {
  const api = useSwitchContext();
  const { fallback: fallback2, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { ref: ref2, "data-checked": dataAttr(api.checked), ...rest, children: api.checked ? children : fallback2 });
});
const SwitchHiddenInput = SwitchHiddenInput$1;
function useDebounce(value, delay2) {
  const [debouncedValue, setDebouncedValue] = reactExports.useState(value);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay2);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay2]);
  return debouncedValue;
}
const [TabsProvider, useTabsContext] = createContext({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});
const TabContent = reactExports.forwardRef((props, ref2) => {
  const [contentProps, localProps] = createSplitProps()(props, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: useDebounce(tabs.value === props.value, 0),
    immediate: true
  });
  const mergedProps = mergeProps(
    tabs.getContentProps(contentProps),
    presence.getPresenceProps(),
    localProps
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: presence.unmounted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) }) });
});
TabContent.displayName = "TabContent";
const TabIndicator = reactExports.forwardRef((props, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TabIndicator.displayName = "TabIndicator";
const TabList = reactExports.forwardRef((props, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getListProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TabList.displayName = "TabList";
const TabTrigger = reactExports.forwardRef((props, ref2) => {
  const [tabProps, localProps] = createSplitProps()(props, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getTriggerProps(tabProps), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
TabTrigger.displayName = "TabTrigger";
var anatomy$1 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts$1 = anatomy$1.build();
var dom$1 = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `tabs:${ctx.id}`,
  getListId: (ctx) => ctx.ids?.list ?? `tabs:${ctx.id}:list`,
  getContentId: (ctx, id2) => ctx.ids?.content ?? `tabs:${ctx.id}:content-${id2}`,
  getTriggerId: (ctx, id2) => ctx.ids?.trigger ?? `tabs:${ctx.id}:trigger-${id2}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`,
  getListEl: (ctx) => dom$1.getById(ctx, dom$1.getListId(ctx)),
  getContentEl: (ctx, id2) => dom$1.getById(ctx, dom$1.getContentId(ctx, id2)),
  getTriggerEl: (ctx, id2) => dom$1.getById(ctx, dom$1.getTriggerId(ctx, id2)),
  getIndicatorEl: (ctx) => dom$1.getById(ctx, dom$1.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom$1.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom$1.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom$1.getElements(ctx)),
  getLastTriggerEl: (ctx) => last(dom$1.getElements(ctx)),
  getNextTriggerEl: (ctx, id2) => nextById(dom$1.getElements(ctx), dom$1.getTriggerId(ctx, id2), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id2) => prevById(dom$1.getElements(ctx), dom$1.getTriggerId(ctx, id2), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value) return;
    return dom$1.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value) return;
    return dom$1.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el2) => {
    return {
      left: el2?.offsetLeft ?? 0,
      top: el2?.offsetTop ?? 0,
      width: el2?.offsetWidth ?? 0,
      height: el2?.offsetHeight ?? 0
    };
  },
  getRectById: (ctx, id2) => {
    const tab = itemById(dom$1.getElements(ctx), dom$1.getTriggerId(ctx, id2));
    return dom$1.resolveRect(dom$1.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect$1(state, send, normalize2) {
  const translations = state.context.translations;
  const focused = state.matches("focused");
  const isVertical = state.context.orientation === "vertical";
  const isHorizontal = state.context.orientation === "horizontal";
  const composite = state.context.composite;
  const indicator = state.context.indicatorState;
  function getTriggerState(props2) {
    return {
      selected: state.context.value === props2.value,
      focused: state.context.focusedValue === props2.value,
      disabled: !!props2.disabled
    };
  }
  return {
    value: state.context.value,
    focusedValue: state.context.focusedValue,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id2 = dom$1.getTriggerId(state.context, value);
      send({ type: "SET_INDICATOR_RECT", id: id2 });
    },
    syncTabIndex() {
      send("SYNC_TAB_INDEX");
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      dom$1.getSelectedTriggerEl(state.context)?.focus();
    },
    getRootProps() {
      return normalize2.element({
        ...parts$1.root.attrs,
        id: dom$1.getRootId(state.context),
        "data-orientation": state.context.orientation,
        "data-focus": dataAttr$1(focused),
        dir: state.context.dir
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts$1.list.attrs,
        id: dom$1.getListId(state.context),
        role: "tablist",
        dir: state.context.dir,
        "data-focus": dataAttr$1(focused),
        "aria-orientation": state.context.orientation,
        "data-orientation": state.context.orientation,
        "aria-label": translations?.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey(event, state.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props2) {
      const { value, disabled } = props2;
      const triggerState = getTriggerState(props2);
      return normalize2.button({
        ...parts$1.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state.context.dir,
        "data-orientation": state.context.orientation,
        "data-disabled": dataAttr$1(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr$1(triggerState.selected),
        "data-focus": dataAttr$1(triggerState.focused),
        "aria-controls": triggerState.selected ? dom$1.getContentId(state.context, value) : void 0,
        "data-ownedby": dom$1.getListId(state.context),
        "data-ssr": dataAttr$1(state.context.ssr),
        id: dom$1.getTriggerId(state.context, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (target?.getAttribute("role") !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props2) {
      const { value } = props2;
      const selected = state.context.value === value;
      return normalize2.element({
        ...parts$1.content.attrs,
        dir: state.context.dir,
        id: dom$1.getContentId(state.context, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": dom$1.getTriggerId(state.context, value),
        role: "tabpanel",
        "data-ownedby": dom$1.getListId(state.context),
        "data-selected": dataAttr$1(selected),
        "data-orientation": state.context.orientation,
        hidden: !selected
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        id: dom$1.getIndicatorId(state.context),
        ...parts$1.indicator.attrs,
        dir: state.context.dir,
        "data-orientation": state.context.orientation,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": indicator.rect?.left,
          "--top": indicator.rect?.top,
          "--width": indicator.rect?.width,
          "--height": indicator.rect?.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicator.transition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not$1 } = guards;
function machine(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        loopFocus: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        focusedValue: ctx.value ?? null,
        ssr: true,
        indicatorState: {
          rendered: false,
          transition: false,
          rect: { left: "0px", top: "0px", width: "0px", height: "0px" }
        }
      },
      watch: {
        value: ["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        },
        SYNC_TAB_INDEX: {
          actions: "syncTabIndex"
        }
      },
      created: ["syncFocusedValue"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "syncTabIndex", "syncSsr"],
      exit: ["cleanupObserver"],
      states: {
        idle: {
          on: {
            TAB_FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            },
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_PREV: [
              {
                guard: "selectOnFocus",
                actions: ["focusPrevTab", "selectFocusedTab"]
              },
              {
                actions: "focusPrevTab"
              }
            ],
            ARROW_NEXT: [
              {
                guard: "selectOnFocus",
                actions: ["focusNextTab", "selectFocusedTab"]
              },
              {
                actions: "focusNextTab"
              }
            ],
            HOME: [
              {
                guard: "selectOnFocus",
                actions: ["focusFirstTab", "selectFocusedTab"]
              },
              {
                actions: "focusFirstTab"
              }
            ],
            END: [
              {
                guard: "selectOnFocus",
                actions: ["focusLastTab", "selectFocusedTab"]
              },
              {
                actions: "focusLastTab"
              }
            ],
            ENTER: {
              guard: not$1("selectOnFocus"),
              actions: "selectFocusedTab"
            },
            TAB_FOCUS: {
              actions: ["setFocusedValue"]
            },
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        syncFocusedValue(ctx2) {
          if (ctx2.value != null && ctx2.focusedValue == null) {
            ctx2.focusedValue = ctx2.value;
          }
        },
        selectFocusedTab(ctx2) {
          raf$1(() => {
            const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
            const value = nullable ? null : ctx2.focusedValue;
            set$1.value(ctx2, value);
          });
        },
        setFocusedValue(ctx2, evt) {
          if (evt.value == null) return;
          set$1.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set$1.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
          const value = nullable ? null : evt.value;
          set$1.value(ctx2, value);
        },
        clearValue(ctx2) {
          set$1.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf$1(() => {
            dom$1.getFirstTriggerEl(ctx2)?.focus();
          });
        },
        focusLastTab(ctx2) {
          raf$1(() => {
            dom$1.getLastTriggerEl(ctx2)?.focus();
          });
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom$1.getNextTriggerEl(ctx2, ctx2.focusedValue);
          raf$1(() => {
            if (ctx2.composite) {
              triggerEl?.focus();
            } else if (triggerEl?.dataset.value != null) {
              set$1.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom$1.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          raf$1(() => {
            if (ctx2.composite) {
              triggerEl?.focus();
            } else if (triggerEl?.dataset.value != null) {
              set$1.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        checkRenderedElements(ctx2) {
          ctx2.indicatorState.rendered = !!dom$1.getIndicatorEl(ctx2);
        },
        syncTabIndex(ctx2) {
          raf$1(() => {
            const contentEl = dom$1.getSelectedContentEl(ctx2);
            if (!contentEl) return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        allowIndicatorTransition(ctx2) {
          ctx2.indicatorState.transition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom$1.getTriggerEl(ctx2, value);
          if (!triggerEl) return;
          ctx2.indicatorState.rect = dom$1.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.indicatorState.transition = false;
          });
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          const value = ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom$1.getSelectedTriggerEl(ctx2);
          if (!triggerEl) return;
          ctx2.indicatorCleanup = trackElementRect(triggerEl, {
            getRect(el2) {
              return dom$1.getOffsetRect(el2);
            },
            onChange(rect) {
              ctx2.indicatorState.rect = dom$1.resolveRect(rect);
              nextTick(() => {
                ctx2.indicatorState.transition = false;
              });
            }
          });
        },
        navigateIfNeeded(ctx2) {
          const triggerEl = dom$1.getSelectedTriggerEl(ctx2);
          if (!isAnchorElement(triggerEl)) return;
          ctx2.navigate({ value: ctx2.value, node: triggerEl });
        }
      }
    }
  );
}
var invoke = {
  change: (ctx) => {
    if (ctx.value == null) return;
    ctx.onValueChange?.({ value: ctx.value });
  },
  focusChange: (ctx) => {
    if (ctx.focusedValue == null) return;
    ctx.onFocusChange?.({ focusedValue: ctx.focusedValue });
  }
};
var set$1 = {
  value: (ctx, value) => {
    if (isEqual$1(value, ctx.value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual$1(value, ctx.focusedValue)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
createProps$1()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value"
]);
createProps$1()(["disabled", "value"]);
createProps$1()(["value"]);
const useTabs = (props = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode,
    value: props.defaultValue,
    ...props
  };
  const context2 = {
    ...initialContext,
    value: props.value,
    onValueChange: useEvent(props.onValueChange, { sync: true }),
    onFocusChange: useEvent(props.onFocusChange)
  };
  const [state, send] = useMachine(machine(initialContext), { context: context2 });
  return connect$1(state, send, normalizeProps);
};
const TabsRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [useTabsProps, localprops] = createSplitProps()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRoot$1.displayName = "TabsRoot";
const TabsRootProvider = reactExports.forwardRef((props, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [{ value: tabs }, localprops] = createSplitProps()(tabsProps, ["value"]);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";
const {
  withProvider: withProvider$1,
  withContext: withContext$4,
  useStyles: useTabsStyles,
  PropsProvider: PropsProvider$3
} = createSlotRecipeContext({ key: "tabs" });
withProvider$1(TabsRootProvider, "root", { forwardAsChild: true });
const TabsRoot = withProvider$1(
  TabsRoot$1,
  "root",
  { forwardAsChild: true }
);
const TabsTrigger = withContext$4(
  TabTrigger,
  "trigger",
  { forwardAsChild: true }
);
const TabsContent = withContext$4(
  TabContent,
  "content",
  { forwardAsChild: true }
);
const TabsContentGroup = withContext$4("div", "contentGroup");
const TabsList = withContext$4(
  TabList,
  "list",
  { forwardAsChild: true }
);
withContext$4(
  TabIndicator,
  "indicator",
  { forwardAsChild: true }
);
const { withContext: withContext$3, PropsProvider: PropsProvider$2 } = createRecipeContext({
  key: "textarea"
});
const Textarea = withContext$3(
  FieldTextarea
);
var anatomy = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts = anatomy.build();
var dom = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type2) {
  return duration ?? defaultTimeouts[type2] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  const offset2 = ctx.offsets;
  const computedOffset = typeof offset2 === "string" ? { left: offset2, right: offset2, bottom: offset2, top: offset2 } : offset2;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles2 = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${ctx.heights[0]?.height || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles2.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles2.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles2.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles2.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles2.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles2;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles2 = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles2, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles2;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles2 = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles2, overrides);
  if (ctx.frontmost && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles2;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize2) {
  function getState() {
    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible(id2) {
    const toasts = getState().context.toasts;
    if (!toasts.length) return false;
    return !!toasts.find((toast) => toast.id == id2);
  }
  function create2(options) {
    const uid2 = `toast:${uuid()}`;
    const id2 = options.id ? options.id : uid2;
    if (isVisible(id2)) return id2;
    send({ type: "ADD_TOAST", toast: { ...options, id: id2 } });
    return id2;
  }
  function update2(id2, options) {
    if (!isVisible(id2)) return id2;
    send({ type: "UPDATE_TOAST", id: id2, toast: options });
    return id2;
  }
  function upsert(options) {
    const { id: id2 } = options;
    const visible = id2 ? isVisible(id2) : false;
    if (visible && id2 != null) {
      return update2(id2, options);
    } else {
      return create2(options);
    }
  }
  function dismiss(id2) {
    if (id2 == null) {
      send("DISMISS_ALL");
    } else if (isVisible(id2)) {
      send({ type: "DISMISS_TOAST", id: id2 });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible,
    create: create2,
    update: update2,
    upsert,
    dismiss,
    remove(id2) {
      if (id2 == null) {
        send("REMOVE_ALL");
      } else if (isVisible(id2)) {
        send({ type: "REMOVE_TOAST", id: id2 });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise2, options, shared = {}) {
      const id2 = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn(promise2).then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id: id2, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id: id2, type: "error" });
      }).finally(() => {
        options.finally?.();
      });
      return id2;
    },
    pause(id2) {
      if (id2 == null) {
        send("PAUSE_ALL");
      } else if (isVisible(id2)) {
        send({ type: "PAUSE_TOAST", id: id2 });
      }
    },
    resume(id2) {
      if (id2 == null) {
        send("RESUME_ALL");
      } else if (isVisible(id2)) {
        send({ type: "RESUME_TOAST", id: id2 });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state = getState();
      const hotkeyLabel = state.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts.group.attrs,
        dir: state.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state = getState();
      return subscribe$1(state.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not, and, or } = guards;
function createToastMachine(options) {
  const { type: type2 = "info", duration, id: id2 = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact$2(restProps);
  const computedDuration = getToastDuration(duration, type2);
  return createMachine(
    {
      id: id2,
      context: {
        id: id2,
        type: type2,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type2 === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf$1(() => {
            const rootEl = dom.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup?.();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => evt.toast?.type === "loading",
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => evt.toast?.type != null && evt.toast.type !== ctx2.type,
        hasDurationChanged: (ctx2, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx2.duration
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf$1(() => {
            const rootEl = dom.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          ctx2.onStatusChange?.({ status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          ctx2.onStatusChange?.({ status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          ctx2.onStatusChange?.({ status: "visible" });
        },
        setContext(ctx2, evt) {
          const duration2 = evt.toast?.duration;
          const type22 = evt.toast?.type ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type22);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact$2(userContext);
  return createMachine(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed) return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle) return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            ctx2._cleanup?.();
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          ctx2._cleanup?.();
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            dom.getRegionEl(ctx2, ctx2.placement)?.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1) return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev2, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex) return prev2;
              return prev2 + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target) return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref$1(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect(state, send, normalize2) {
  const visible = state.hasTag("visible");
  const paused = state.hasTag("paused");
  const placement = state.context.placement;
  const type2 = state.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type: type2,
    title: state.context.title,
    description: state.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        dir: state.context.dir,
        id: dom.getRootId(state.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type2,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr$1(state.context.mounted),
        "data-paused": dataAttr$1(paused),
        "data-first": dataAttr$1(state.context.frontmost),
        "data-sibling": dataAttr$1(!state.context.frontmost),
        "data-stack": dataAttr$1(state.context.stacked),
        "data-overlap": dataAttr$1(!state.context.stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": state.context.description ? dom.getDescriptionId(state.context) : void 0,
        "aria-labelledby": state.context.title ? dom.getTitleId(state.context) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(state.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts.title.attrs,
        id: dom.getTitleId(state.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts.description.attrs,
        id: dom.getDescriptionId(state.context)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          state.context.action?.onClick?.();
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: dom.getCloseTriggerId(state.context),
        ...parts.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};
const createToaster = (props) => {
  const machine2 = group.machine({ id: "1", ...props });
  const api = group.connect(machine2, machine2.send, normalizeProps);
  return { ...api, machine: machine2 };
};
const [ToastProvider, useToastContext] = createContext({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});
const ToastActionTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getActionTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastActionTrigger$1.displayName = "ToastActionTrigger";
const ToastCloseTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getCloseTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastCloseTrigger$1.displayName = "ToastCloseTrigger";
const ToastDescription$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getDescriptionProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ToastDescription$1.displayName = "ToastDescription";
const ToastRoot$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getRootProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...mergedProps, ref: ref2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostBeforeProps() }),
    props.children,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot$1.displayName = "ToastRoot";
const ToastTitle$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ToastTitle$1.displayName = "ToastTitle";
const Toaster$2 = reactExports.forwardRef((props, ref2) => {
  const { toaster: toaster2, children, ...rest } = props;
  const [state, send] = useMachine(toaster2.machine);
  const placement = state.context.placement;
  const api = group.connect(state, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps(api.getGroupProps({ placement }), rest);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2, children: toasts.map((toast2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster$2.displayName = "Toaster";
const ToastActor = (props) => {
  const [state, send] = useActor(props.value);
  const api = connect(state, send, normalizeProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { value: api, children: props.children(state.context) });
};
const {
  withProvider,
  withContext: withContext$2,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
const Toaster$1 = chakra(
  Toaster$2,
  {},
  { forwardAsChild: true }
);
const ToastRoot = withProvider(
  ToastRoot$1,
  "root",
  { forwardAsChild: true }
);
const ToastCloseTrigger = withContext$2(ToastCloseTrigger$1, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
  }
});
const ToastTitle = withContext$2(
  ToastTitle$1,
  "title",
  { forwardAsChild: true }
);
const ToastDescription = withContext$2(ToastDescription$1, "description", { forwardAsChild: true });
const ToastActionTrigger = withContext$2(ToastActionTrigger$1, "actionTrigger", { forwardAsChild: true });
const iconMap = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
const ToastIndicator = reactExports.forwardRef(
  function ToastIndicator2(props, ref2) {
    const api = useToastContext();
    const styles2 = useToastStyles();
    const Component = iconMap[api.type];
    if (!Component) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref: ref2, ...props, css: [styles2.indicator, props.css] });
  }
);
const {
  withRootProvider,
  withContext: withContext$1,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider$1
} = createSlotRecipeContext({ key: "tooltip" });
withRootProvider(
  TooltipRootProvider
);
const TooltipRoot = withRootProvider(TooltipRoot$1);
const TooltipTrigger = withContext$1(TooltipTrigger$1, "trigger", { forwardAsChild: true });
const TooltipPositioner = withContext$1(TooltipPositioner$1, "positioner", { forwardAsChild: true });
const TooltipContent = withContext$1(
  TooltipContent$1,
  "content",
  { forwardAsChild: true }
);
const TooltipArrow = withContext$1(
  TooltipArrow$1,
  "arrow",
  { forwardAsChild: true }
);
const TooltipArrowTip = withContext$1(TooltipArrowTip$1, "arrowTip", { forwardAsChild: true });
const { withContext, PropsProvider } = createRecipeContext({
  key: "text"
});
const Text$1 = withContext("p");
const canvasStyles = {
  background: {
    container: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: "auto"
    },
    image: {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      objectFit: "cover",
      zIndex: 1
    },
    video: {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      objectFit: "cover",
      zIndex: 1,
      transform: "scaleX(-1)"
    }
  },
  canvas: {
    container: {
      position: "relative",
      width: "100%",
      height: "100%",
      zIndex: "1",
      pointerEvents: "auto"
    }
  },
  subtitle: {
    container: {
      position: "absolute",
      bottom: "30px",
      left: "50%",
      transform: "translateX(-50%)",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      padding: "15px 30px",
      borderRadius: "12px",
      minWidth: "60%",
      maxWidth: "95%",
      zIndex: 2
    },
    text: {
      color: "white",
      fontSize: "1.5rem",
      textAlign: "center",
      lineHeight: "1.4",
      whiteSpace: "pre-wrap"
    }
  },
  wsStatus: {
    container: {
      position: "absolute",
      top: "20px",
      left: "20px",
      zIndex: 2,
      padding: "8px 16px",
      borderRadius: "20px",
      fontSize: "14px",
      fontWeight: "medium",
      color: "white",
      transition: "all 0.2s",
      cursor: "pointer",
      userSelect: "none",
      _hover: {
        opacity: 0.8
      }
    }
  }
};
const toaster = createToaster({
  placement: "top-end",
  pauseOnPageIdle: true,
  max: 5
});
function Toaster() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster$1, { toaster, insetInline: { mdDown: "4" }, children: (toast) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastRoot, { width: { md: "sm" }, children: [
    toast.type === "loading" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm", color: "blue.solid" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToastIndicator, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: "1", flex: "1", maxWidth: "100%", children: [
      toast.title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: toast.title }),
      toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: toast.description })
    ] }),
    toast.action && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActionTrigger, { children: toast.action.label }),
    toast.meta?.closable && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastCloseTrigger, {})
  ] }) }) });
}
const DEFAULT_CAMERA_CONFIG = {
  width: 320,
  height: 240
};
const CameraContext = reactExports.createContext(null);
function CameraProvider({ children }) {
  const [isStreaming, setIsStreaming] = reactExports.useState(false);
  const [isBackgroundStreaming, setIsBackgroundStreaming] = reactExports.useState(false);
  const [cameraConfig, setCameraConfig] = reactExports.useState(
    DEFAULT_CAMERA_CONFIG
  );
  const streamRef = reactExports.useRef(null);
  const backgroundStreamRef = reactExports.useRef(null);
  const videoRef = reactExports.useRef(null);
  const startCamera = reactExports.useCallback(async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error("Camera API is not supported on this device");
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasCamera = devices.some((device) => device.kind === "videoinput");
      if (!hasCamera) {
        throw new Error("No camera found on this device");
      }
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: cameraConfig.width },
          height: { ideal: cameraConfig.height }
        }
      });
      streamRef.current = stream;
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }
      setIsStreaming(true);
    } catch (err) {
      console.error("Failed to start camera:", err);
      toaster.create({
        title: `Failed to start camera: ${err}`,
        type: "error",
        duration: 2e3
      });
      throw err;
    }
  }, [cameraConfig]);
  const stopCamera = reactExports.useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
      setIsStreaming(false);
    }
  }, []);
  const startBackgroundCamera = reactExports.useCallback(async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error("Camera API is not supported on this device");
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasCamera = devices.some((device) => device.kind === "videoinput");
      if (!hasCamera) {
        throw new Error("No camera found on this device");
      }
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: cameraConfig.width },
          height: { ideal: cameraConfig.height }
        }
      });
      backgroundStreamRef.current = stream;
      setIsBackgroundStreaming(true);
    } catch (err) {
      console.error("Failed to start background camera:", err);
      toaster.create({
        title: `Failed to start background camera: ${err}`,
        type: "error",
        duration: 2e3
      });
      throw err;
    }
  }, [cameraConfig]);
  const stopBackgroundCamera = reactExports.useCallback(() => {
    if (backgroundStreamRef.current) {
      backgroundStreamRef.current.getTracks().forEach((track) => track.stop());
      backgroundStreamRef.current = null;
      setIsBackgroundStreaming(false);
    }
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      isStreaming,
      stream: streamRef.current,
      startCamera,
      stopCamera,
      cameraConfig,
      setCameraConfig,
      videoRef,
      backgroundStream: backgroundStreamRef.current,
      startBackgroundCamera,
      stopBackgroundCamera,
      isBackgroundStreaming
    }),
    [isStreaming, startCamera, stopCamera, cameraConfig, isBackgroundStreaming, startBackgroundCamera, stopBackgroundCamera]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CameraContext.Provider, { value: contextValue, children });
}
function useCamera() {
  const context2 = reactExports.useContext(CameraContext);
  if (!context2) {
    throw new Error("useCamera must be used within a CameraProvider");
  }
  return context2;
}
function useLocalStorage(key, initialValue, options) {
  const [storedValue, setStoredValue] = reactExports.useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      const parsedValue = item ? JSON.parse(item) : initialValue;
      return parsedValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      const filteredValue = options?.filter ? options.filter(valueToStore) : valueToStore;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(filteredValue));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  return [storedValue, setValue];
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl2) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl2(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$2 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    return clearTimeout(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$4() {
}
function errorContext(cb2) {
  {
    cb2();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next2, error, complete) {
    return new SafeSubscriber(next2, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$4,
  error: defaultErrorHandler,
  complete: noop$4
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity$1(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity$1;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe2) {
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject2) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject2(err);
            subscriber.unsubscribe();
          }
        },
        error: reject2,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject2) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject2(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$2.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
class WebSocketService {
  static instance;
  ws = null;
  messageSubject = new Subject();
  stateSubject = new Subject();
  currentState = "CLOSED";
  static getInstance() {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }
  initializeConnection() {
    this.sendMessage({
      type: "fetch-backgrounds"
    });
    this.sendMessage({
      type: "fetch-configs"
    });
    this.sendMessage({
      type: "fetch-history-list"
    });
    this.sendMessage({
      type: "create-new-history"
    });
  }
  connect(url2) {
    if (this.ws?.readyState === WebSocket.CONNECTING || this.ws?.readyState === WebSocket.OPEN) {
      this.disconnect();
    }
    try {
      this.ws = new WebSocket(url2);
      this.currentState = "CONNECTING";
      this.stateSubject.next("CONNECTING");
      this.ws.onopen = () => {
        this.currentState = "OPEN";
        this.stateSubject.next("OPEN");
        this.initializeConnection();
      };
      this.ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.messageSubject.next(message);
        } catch (error) {
          console.error("Failed to parse WebSocket message:", error);
          toaster.create({
            title: `Failed to parse WebSocket message: ${error}`,
            type: "error",
            duration: 2e3
          });
        }
      };
      this.ws.onclose = () => {
        this.currentState = "CLOSED";
        this.stateSubject.next("CLOSED");
      };
      this.ws.onerror = () => {
        this.currentState = "CLOSED";
        this.stateSubject.next("CLOSED");
      };
    } catch (error) {
      console.error("Failed to connect to WebSocket:", error);
      this.currentState = "CLOSED";
      this.stateSubject.next("CLOSED");
    }
  }
  sendMessage(message) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket is not open. Unable to send message:", message);
      toaster.create({
        title: "WebSocket is not open.",
        type: "error",
        duration: 2e3
      });
    }
  }
  onMessage(callback) {
    return this.messageSubject.subscribe(callback);
  }
  onStateChange(callback) {
    return this.stateSubject.subscribe(callback);
  }
  disconnect() {
    this.ws?.close();
    this.ws = null;
  }
  getCurrentState() {
    return this.currentState;
  }
}
const wsService = WebSocketService.getInstance();
const getDefaultWsUrl = () => {
  const isHttps = window.location.protocol === "https:";
  const hostname = window.location.hostname;
  const port = "12393";
  if (isHttps) {
    if (hostname !== "localhost" && hostname !== "127.0.0.1") {
      return `wss://${hostname}/client-ws`;
    }
    return `wss://${hostname}:${port}/client-ws`;
  }
  if (hostname === "localhost" || hostname === "127.0.0.1") {
    return `ws://127.0.0.1:${port}/client-ws`;
  }
  return `ws://${hostname}:${port}/client-ws`;
};
const getDefaultBaseUrl = () => {
  const isHttps = window.location.protocol === "https:";
  const hostname = window.location.hostname;
  const port = "12393";
  if (hostname === "itcometrue.academy") {
    return `https://${hostname}`;
  }
  if (isHttps) {
    if (hostname === "localhost" || hostname === "127.0.0.1") {
      return `https://${hostname}:${port}`;
    }
    return `https://${hostname}`;
  }
  if (hostname === "localhost" || hostname === "127.0.0.1") {
    return `http://127.0.0.1:${port}`;
  }
  return `http://${hostname}:${port}`;
};
const DEFAULT_WS_URL = getDefaultWsUrl();
const DEFAULT_BASE_URL = getDefaultBaseUrl();
const WebSocketContext = React.createContext({
  sendMessage: wsService.sendMessage.bind(wsService),
  wsState: "CLOSED",
  reconnect: () => wsService.connect(DEFAULT_WS_URL),
  wsUrl: DEFAULT_WS_URL,
  setWsUrl: () => {
  },
  baseUrl: DEFAULT_BASE_URL,
  setBaseUrl: () => {
  }
});
function useWebSocket() {
  const context2 = reactExports.useContext(WebSocketContext);
  if (!context2) {
    throw new Error("useWebSocket must be used within a WebSocketProvider");
  }
  return context2;
}
const defaultWsUrl = DEFAULT_WS_URL;
const defaultBaseUrl = DEFAULT_BASE_URL;
const BgUrlContext = reactExports.createContext(null);
function BgUrlProvider({ children }) {
  const { baseUrl } = useWebSocket();
  const DEFAULT_BACKGROUND = `${baseUrl}/bg/ceiling-window-room-night.jpeg`;
  const [backgroundUrl, setBackgroundUrl] = useLocalStorage(
    "backgroundUrl",
    DEFAULT_BACKGROUND
  );
  const [backgroundFiles, setBackgroundFiles] = reactExports.useState([]);
  const resetBackground = reactExports.useCallback(() => {
    setBackgroundUrl(DEFAULT_BACKGROUND);
  }, [setBackgroundUrl, DEFAULT_BACKGROUND]);
  const addBackgroundFile = reactExports.useCallback((file) => {
    setBackgroundFiles((prev2) => [...prev2, file]);
  }, []);
  const removeBackgroundFile = reactExports.useCallback((name2) => {
    setBackgroundFiles((prev2) => prev2.filter((file) => file.name !== name2));
  }, []);
  const isDefaultBackground = reactExports.useMemo(
    () => backgroundUrl === DEFAULT_BACKGROUND,
    [backgroundUrl, DEFAULT_BACKGROUND]
  );
  const [useCameraBackground, setUseCameraBackground] = reactExports.useState(false);
  const contextValue = reactExports.useMemo(() => ({
    backgroundUrl,
    setBackgroundUrl,
    backgroundFiles,
    setBackgroundFiles,
    resetBackground,
    addBackgroundFile,
    removeBackgroundFile,
    isDefaultBackground,
    useCameraBackground,
    setUseCameraBackground
  }), [backgroundUrl, setBackgroundUrl, backgroundFiles, resetBackground, addBackgroundFile, removeBackgroundFile, isDefaultBackground, useCameraBackground]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BgUrlContext.Provider, { value: contextValue, children });
}
function useBgUrl() {
  const context2 = reactExports.useContext(BgUrlContext);
  if (!context2) {
    throw new Error("useBgUrl must be used within a BgUrlProvider");
  }
  return context2;
}
const Background = reactExports.memo(({ children }) => {
  const videoRef = reactExports.useRef(null);
  const {
    backgroundStream,
    isBackgroundStreaming,
    startBackgroundCamera,
    stopBackgroundCamera
  } = useCamera();
  const { useCameraBackground, backgroundUrl } = useBgUrl();
  reactExports.useEffect(() => {
    if (useCameraBackground) {
      startBackgroundCamera();
    } else {
      stopBackgroundCamera();
    }
  }, [useCameraBackground, startBackgroundCamera, stopBackgroundCamera]);
  reactExports.useEffect(() => {
    if (videoRef.current && backgroundStream) {
      videoRef.current.srcObject = backgroundStream;
    }
  }, [backgroundStream]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...canvasStyles.background.container, children: [
    useCameraBackground ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        ref: videoRef,
        autoPlay: true,
        playsInline: true,
        muted: true,
        style: {
          ...canvasStyles.background.video,
          display: isBackgroundStreaming ? "block" : "none",
          transform: "scaleX(-1)"
        }
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Image$1,
      {
        ...canvasStyles.background.image,
        src: backgroundUrl,
        alt: "background"
      }
    ),
    children
  ] });
});
Background.displayName = "Background";
const DEFAULT_SUBTITLE = {
  text: "Hi, I'm some random AI VTuber. Who the hell are ya? Ahh, you must be amazed by my awesomeness, right? right?"
};
const SubtitleContext = reactExports.createContext(null);
const SubtitleProvider = reactExports.memo(({ children }) => {
  const [subtitleText, setSubtitleText] = reactExports.useState(DEFAULT_SUBTITLE.text);
  const [showSubtitle, setShowSubtitle] = reactExports.useState(true);
  const contextValue = reactExports.useMemo(
    () => ({
      subtitleText,
      setSubtitleText,
      showSubtitle,
      setShowSubtitle
    }),
    [subtitleText, showSubtitle]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleContext.Provider, { value: contextValue, children });
});
function useSubtitle() {
  const context2 = reactExports.useContext(SubtitleContext);
  if (!context2) {
    throw new Error("useSubtitle must be used within a SubtitleProvider");
  }
  return context2;
}
const useSubtitleDisplay = () => {
  const context2 = useSubtitle();
  const subtitleText = reactExports.useMemo(() => {
    if (!context2) return null;
    return context2.subtitleText;
  }, [context2?.subtitleText]);
  return {
    subtitleText,
    isLoaded: !!context2
  };
};
const SubtitleText = reactExports.memo(({ text }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...canvasStyles.subtitle.text, children: text }));
SubtitleText.displayName = "SubtitleText";
const Subtitle = reactExports.memo(() => {
  const { subtitleText, isLoaded } = useSubtitleDisplay();
  const { showSubtitle } = useSubtitle();
  if (!isLoaded || !subtitleText || !showSubtitle) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...canvasStyles.subtitle.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleText, { text: subtitleText }) });
});
Subtitle.displayName = "Subtitle";
const useWSStatus = () => {
  const { wsState, reconnect } = useWebSocket();
  const handleClick = reactExports.useCallback(() => {
    if (wsState !== "OPEN" && wsState !== "CONNECTING") {
      reconnect();
    }
  }, [wsState, reconnect]);
  const statusInfo = reactExports.useMemo(() => {
    switch (wsState) {
      case "OPEN":
        return {
          color: "green.500",
          text: "Connected",
          isDisconnected: false,
          handleClick
        };
      case "CONNECTING":
        return {
          color: "yellow.500",
          text: "Connecting",
          isDisconnected: false,
          handleClick
        };
      default:
        return {
          color: "red.500",
          text: "Click to Reconnect",
          isDisconnected: true,
          handleClick
        };
    }
  }, [wsState, handleClick]);
  return statusInfo;
};
const StatusContent = ({ text }) => text;
const MemoizedStatusContent = reactExports.memo(StatusContent);
const WebSocketStatus = reactExports.memo(() => {
  const {
    color,
    text,
    handleClick,
    isDisconnected
  } = useWSStatus();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ...canvasStyles.wsStatus.container,
      backgroundColor: color,
      onClick: handleClick,
      cursor: isDisconnected ? "pointer" : "default",
      _hover: {
        opacity: isDisconnected ? 0.8 : 1
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedStatusContent, { text })
    }
  );
});
WebSocketStatus.displayName = "WebSocketStatus";
const DEFAULT_CONFIG$1 = {
  confName: "",
  confUid: "",
  configFiles: []
};
const ConfigContext = reactExports.createContext(null);
function CharacterConfigProvider({ children }) {
  const [confName, setConfName] = reactExports.useState(DEFAULT_CONFIG$1.confName);
  const [confUid, setConfUid] = reactExports.useState(DEFAULT_CONFIG$1.confUid);
  const [configFiles, setConfigFiles] = reactExports.useState(DEFAULT_CONFIG$1.configFiles);
  const getFilenameByName = reactExports.useCallback(
    (name2) => configFiles.find((config2) => config2.name === name2)?.filename,
    [configFiles]
  );
  const contextValue = reactExports.useMemo(
    () => ({
      confName,
      confUid,
      configFiles,
      setConfName,
      setConfUid,
      setConfigFiles,
      getFilenameByName
    }),
    [confName, confUid, configFiles, getFilenameByName]
  );
  reactExports.useEffect(() => {
    window.api?.updateConfigFiles?.(configFiles);
  }, [configFiles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigContext.Provider, { value: contextValue, children });
}
function useConfig() {
  const context2 = reactExports.useContext(ConfigContext);
  if (!context2) {
    throw new Error("useConfig must be used within a CharacterConfigProvider");
  }
  return context2;
}
const DEFAULT_CONFIG = {
  modelInfo: {
    scrollToResize: true
  },
  isLoading: false
};
const Live2DConfigContext = reactExports.createContext(null);
function Live2DConfigProvider({ children }) {
  const { confUid } = useConfig();
  const [isPet, setIsPet] = reactExports.useState(false);
  const [isLoading, setIsLoading] = reactExports.useState(DEFAULT_CONFIG.isLoading);
  reactExports.useEffect(() => {
    const unsubscribe = window.api?.onModeChanged((mode) => {
      setIsPet(mode === "pet");
    });
    return () => unsubscribe?.();
  }, []);
  const getStorageKey = (uid2, isPetMode) => `${uid2}_${isPetMode ? "pet" : "window"}`;
  const [modelInfo, setModelInfoState] = useLocalStorage(
    "modelInfo",
    DEFAULT_CONFIG.modelInfo,
    {
      filter: (value) => value ? { ...value, url: "" } : value
    }
  );
  const [scaleMemory, setScaleMemory] = useLocalStorage(
    "scale_memory",
    {}
  );
  const setModelInfo = (info) => {
    if (!info?.url) {
      return;
    }
    if (!confUid) {
      console.warn("Attempting to set model info without confUid");
      toaster.create({
        title: "Attempting to set model info without confUid",
        type: "error",
        duration: 2e3
      });
      return;
    }
    if (JSON.stringify(info) === JSON.stringify(modelInfo)) {
      return;
    }
    if (info) {
      const storageKey = getStorageKey(confUid, isPet);
      let finalScale;
      const storedScale = scaleMemory[storageKey];
      if (storedScale !== void 0) {
        finalScale = storedScale;
      } else {
        finalScale = Number(info.kScale || 1e-3);
        setScaleMemory((prev2) => ({
          ...prev2,
          [storageKey]: finalScale
        }));
      }
      console.log("finalScale", finalScale);
      setModelInfoState({
        ...info,
        kScale: finalScale,
        // use new settings to updata the local storage, or still use the stored settings
        pointerInteractive: "pointerInteractive" in info ? info.pointerInteractive : modelInfo?.pointerInteractive ?? false,
        scrollToResize: "scrollToResize" in info ? info.scrollToResize : modelInfo?.scrollToResize ?? true
      });
    } else {
      setModelInfoState(void 0);
    }
  };
  const updateModelScale = reactExports.useCallback(
    // Updates the Live2D model scale and persists it to local storage when scrolling in useLive2DResize
    (newScale) => {
      if (modelInfo) {
        const storageKey = getStorageKey(confUid, isPet);
        const fixedScale = Number(newScale.toFixed(8));
        setScaleMemory((prev2) => ({
          ...prev2,
          [storageKey]: fixedScale
        }));
        setModelInfoState({
          ...modelInfo,
          kScale: fixedScale
        });
      }
    },
    [modelInfo, confUid, isPet, setScaleMemory, setModelInfoState]
  );
  reactExports.useEffect(() => {
    if (modelInfo) {
      const storageKey = getStorageKey(confUid, isPet);
      const memorizedScale = scaleMemory[storageKey];
      if (memorizedScale !== void 0 && memorizedScale !== Number(modelInfo.kScale)) {
        setModelInfo({
          ...modelInfo,
          kScale: memorizedScale
        });
      }
    }
  }, [isPet, modelInfo]);
  const contextValue = reactExports.useMemo(
    () => ({
      modelInfo,
      setModelInfo,
      isLoading,
      setIsLoading,
      updateModelScale
    }),
    [modelInfo, isLoading, updateModelScale]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DConfigContext.Provider, { value: contextValue, children });
}
function useLive2DConfig() {
  const context2 = reactExports.useContext(Live2DConfigContext);
  if (!context2) {
    throw new Error("useLive2DConfig must be used within a Live2DConfigProvider");
  }
  return context2;
}
var dist = {};
var ortWeb_min = { exports: {} };
const backends = {};
const backendsSortedByPriority = [];
const registerBackend = (name2, backend, priority) => {
  if (backend && typeof backend.init === "function" && typeof backend.createSessionHandler === "function") {
    const currentBackend = backends[name2];
    if (currentBackend === void 0) {
      backends[name2] = { backend, priority };
    } else if (currentBackend.priority > priority) {
      return;
    } else if (currentBackend.priority === priority) {
      if (currentBackend.backend !== backend) {
        throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
      }
    }
    if (priority >= 0) {
      const i2 = backendsSortedByPriority.indexOf(name2);
      if (i2 !== -1) {
        backendsSortedByPriority.splice(i2, 1);
      }
      for (let i3 = 0; i3 < backendsSortedByPriority.length; i3++) {
        if (backends[backendsSortedByPriority[i3]].priority <= priority) {
          backendsSortedByPriority.splice(i3, 0, name2);
          return;
        }
      }
      backendsSortedByPriority.push(name2);
    }
    return;
  }
  throw new TypeError("not a valid backend");
};
const resolveBackend = async (backendHints) => {
  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
  const errors = [];
  for (const backendName of backendNames) {
    const backendInfo = backends[backendName];
    if (backendInfo) {
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        continue;
      }
      const isInitializing = !!backendInfo.initPromise;
      try {
        if (!isInitializing) {
          backendInfo.initPromise = backendInfo.backend.init();
        }
        await backendInfo.initPromise;
        backendInfo.initialized = true;
        return backendInfo.backend;
      } catch (e2) {
        if (!isInitializing) {
          errors.push({ name: backendName, err: e2 });
        }
        backendInfo.aborted = true;
      } finally {
        delete backendInfo.initPromise;
      }
    }
  }
  throw new Error(`no available backend found. ERR: ${errors.map((e2) => `[${e2.name}] ${e2.err}`).join(", ")}`);
};
class EnvImpl {
  constructor() {
    this.wasm = {};
    this.webgl = {};
    this.logLevelInternal = "warning";
  }
  // TODO standadize the getter and setter convention in env for other fields.
  set logLevel(value) {
    if (value === void 0) {
      return;
    }
    if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
      throw new Error(`Unsupported logging level: ${value}`);
    }
    this.logLevelInternal = value;
  }
  get logLevel() {
    return this.logLevelInternal;
  }
}
const env$1 = new EnvImpl();
const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && typeof BigInt64Array.from === "function";
const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && typeof BigUint64Array.from === "function";
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
  ["float32", Float32Array],
  ["uint8", Uint8Array],
  ["int8", Int8Array],
  ["uint16", Uint16Array],
  ["int16", Int16Array],
  ["int32", Int32Array],
  ["bool", Uint8Array],
  ["float64", Float64Array],
  ["uint32", Uint32Array]
]);
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
  [Float32Array, "float32"],
  [Uint8Array, "uint8"],
  [Int8Array, "int8"],
  [Uint16Array, "uint16"],
  [Int16Array, "int16"],
  [Int32Array, "int32"],
  [Float64Array, "float64"],
  [Uint32Array, "uint32"]
]);
if (isBigInt64ArrayAvailable) {
  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
}
if (isBigUint64ArrayAvailable) {
  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
}
const calculateSize = (dims) => {
  let size2 = 1;
  for (let i2 = 0; i2 < dims.length; i2++) {
    const dim = dims[i2];
    if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
      throw new TypeError(`dims[${i2}] must be an integer, got: ${dim}`);
    }
    if (dim < 0) {
      throw new RangeError(`dims[${i2}] must be a non-negative integer, got: ${dim}`);
    }
    size2 *= dim;
  }
  return size2;
};
let Tensor$1 = class Tensor2 {
  constructor(arg0, arg1, arg2) {
    let type2;
    let data;
    let dims;
    if (typeof arg0 === "string") {
      type2 = arg0;
      dims = arg2;
      if (arg0 === "string") {
        if (!Array.isArray(arg1)) {
          throw new TypeError("A string tensor's data must be a string array.");
        }
        data = arg1;
      } else {
        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
        if (typedArrayConstructor === void 0) {
          throw new TypeError(`Unsupported tensor type: ${arg0}.`);
        }
        if (Array.isArray(arg1)) {
          data = typedArrayConstructor.from(arg1);
        } else if (arg1 instanceof typedArrayConstructor) {
          data = arg1;
        } else {
          throw new TypeError(`A ${type2} tensor's data must be type of ${typedArrayConstructor}`);
        }
      }
    } else {
      dims = arg1;
      if (Array.isArray(arg0)) {
        if (arg0.length === 0) {
          throw new TypeError("Tensor type cannot be inferred from an empty array.");
        }
        const firstElementType = typeof arg0[0];
        if (firstElementType === "string") {
          type2 = "string";
          data = arg0;
        } else if (firstElementType === "boolean") {
          type2 = "bool";
          data = Uint8Array.from(arg0);
        } else {
          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
        }
      } else {
        const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
        if (mappedType === void 0) {
          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
        }
        type2 = mappedType;
        data = arg0;
      }
    }
    if (dims === void 0) {
      dims = [data.length];
    } else if (!Array.isArray(dims)) {
      throw new TypeError("A tensor's dims must be a number array");
    }
    const size2 = calculateSize(dims);
    if (size2 !== data.length) {
      throw new Error(`Tensor's size(${size2}) does not match data length(${data.length}).`);
    }
    this.dims = dims;
    this.type = type2;
    this.data = data;
    this.size = size2;
  }
  // #endregion
  /**
   * Create a new tensor object from image object
   *
   * @param buffer - Extracted image buffer data - assuming RGBA format
   * @param imageFormat - input image configuration - required configurations height, width, format
   * @param tensorFormat - output tensor configuration - Default is RGB format
   */
  static bufferToTensor(buffer, options) {
    if (buffer === void 0) {
      throw new Error("Image buffer must be defined");
    }
    if (options.height === void 0 || options.width === void 0) {
      throw new Error("Image height and width must be defined");
    }
    const { height, width } = options;
    const norm = options.norm;
    let normMean;
    let normBias;
    if (norm === void 0 || norm.mean === void 0) {
      normMean = 255;
    } else {
      normMean = norm.mean;
    }
    if (norm === void 0 || norm.bias === void 0) {
      normBias = 0;
    } else {
      normBias = norm.bias;
    }
    const inputformat = options.bitmapFormat !== void 0 ? options.bitmapFormat : "RGBA";
    const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
    const offset2 = height * width;
    const float32Data = outputformat === "RGBA" ? new Float32Array(offset2 * 4) : new Float32Array(offset2 * 3);
    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = offset2, bTensorPointer = offset2 * 2, aTensorPointer = -1;
    if (inputformat === "RGB") {
      step = 3;
      rImagePointer = 0;
      gImagePointer = 1;
      bImagePointer = 2;
      aImagePointer = -1;
    }
    if (outputformat === "RGBA") {
      aTensorPointer = offset2 * 3;
    } else if (outputformat === "RBG") {
      rTensorPointer = 0;
      bTensorPointer = offset2;
      gTensorPointer = offset2 * 2;
    } else if (outputformat === "BGR") {
      bTensorPointer = 0;
      gTensorPointer = offset2;
      rTensorPointer = offset2 * 2;
    }
    for (let i2 = 0; i2 < offset2; i2++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
      if (aTensorPointer !== -1 && aImagePointer !== -1) {
        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
      }
    }
    const outputTensor = outputformat === "RGBA" ? new Tensor2("float32", float32Data, [1, 4, height, width]) : new Tensor2("float32", float32Data, [1, 3, height, width]);
    return outputTensor;
  }
  static async fromImage(image, options) {
    const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
    const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
    const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
    const isURL = typeof String !== "undefined" && (image instanceof String || typeof image === "string");
    let data;
    let tensorConfig = {};
    if (isHTMLImageEle) {
      const canvas = document.createElement("canvas");
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let height = image.naturalHeight;
        let width = image.naturalWidth;
        if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        }
        if (options !== void 0) {
          tensorConfig = options;
          if (options.tensorFormat !== void 0) {
            throw new Error("Image input config format must be RGBA for HTMLImageElement");
          } else {
            tensorConfig.tensorFormat = "RGBA";
          }
          if (options.height !== void 0 && options.height !== height) {
            throw new Error("Image input config height doesn't match HTMLImageElement height");
          } else {
            tensorConfig.height = height;
          }
          if (options.width !== void 0 && options.width !== width) {
            throw new Error("Image input config width doesn't match HTMLImageElement width");
          } else {
            tensorConfig.width = width;
          }
        } else {
          tensorConfig.tensorFormat = "RGBA";
          tensorConfig.height = height;
          tensorConfig.width = width;
        }
        canvas.width = width;
        canvas.height = height;
        pixels2DContext.drawImage(image, 0, 0, width, height);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isImageDataEle) {
      const format2 = "RGBA";
      let height;
      let width;
      if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
        height = options.resizedHeight;
        width = options.resizedWidth;
      } else {
        height = image.height;
        width = image.width;
      }
      if (options !== void 0) {
        tensorConfig = options;
        if (options.bitmapFormat !== void 0 && options.bitmapFormat !== format2) {
          throw new Error("Image input config format must be RGBA for ImageData");
        } else {
          tensorConfig.bitmapFormat = "RGBA";
        }
      } else {
        tensorConfig.bitmapFormat = "RGBA";
      }
      tensorConfig.height = height;
      tensorConfig.width = width;
      if (options !== void 0) {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;
        const pixels2DContext = tempCanvas.getContext("2d");
        if (pixels2DContext != null) {
          pixels2DContext.putImageData(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else {
        data = image.data;
      }
    } else if (isImageBitmap) {
      if (options === void 0) {
        throw new Error("Please provide image config with format for Imagebitmap");
      }
      if (options.bitmapFormat !== void 0) {
        throw new Error("Image input config format must be defined for ImageBitmap");
      }
      const pixels2DContext = document.createElement("canvas").getContext("2d");
      if (pixels2DContext != null) {
        const height = image.height;
        const width = image.width;
        pixels2DContext.drawImage(image, 0, 0, width, height);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
        if (options !== void 0) {
          if (options.height !== void 0 && options.height !== height) {
            throw new Error("Image input config height doesn't match ImageBitmap height");
          } else {
            tensorConfig.height = height;
          }
          if (options.width !== void 0 && options.width !== width) {
            throw new Error("Image input config width doesn't match ImageBitmap width");
          } else {
            tensorConfig.width = width;
          }
        } else {
          tensorConfig.height = height;
          tensorConfig.width = width;
        }
        return Tensor2.bufferToTensor(data, tensorConfig);
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isURL) {
      return new Promise((resolve2, reject2) => {
        const canvas = document.createElement("canvas");
        const context2 = canvas.getContext("2d");
        if (!image || !context2) {
          return reject2();
        }
        const newImage = new Image();
        newImage.crossOrigin = "Anonymous";
        newImage.src = image;
        newImage.onload = () => {
          canvas.width = newImage.width;
          canvas.height = newImage.height;
          context2.drawImage(newImage, 0, 0, canvas.width, canvas.height);
          const img = context2.getImageData(0, 0, canvas.width, canvas.height);
          if (options !== void 0) {
            if (options.height !== void 0 && options.height !== canvas.height) {
              throw new Error("Image input config height doesn't match ImageBitmap height");
            } else {
              tensorConfig.height = canvas.height;
            }
            if (options.width !== void 0 && options.width !== canvas.width) {
              throw new Error("Image input config width doesn't match ImageBitmap width");
            } else {
              tensorConfig.width = canvas.width;
            }
          } else {
            tensorConfig.height = canvas.height;
            tensorConfig.width = canvas.width;
          }
          resolve2(Tensor2.bufferToTensor(img.data, tensorConfig));
        };
      });
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
    if (data !== void 0) {
      return Tensor2.bufferToTensor(data, tensorConfig);
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
  }
  toImageData(options) {
    var _a2, _b;
    const pixels2DContext = document.createElement("canvas").getContext("2d");
    let image;
    if (pixels2DContext != null) {
      const width = this.dims[3];
      const height = this.dims[2];
      const channels = this.dims[1];
      const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
      const normMean = options !== void 0 ? ((_a2 = options.norm) === null || _a2 === void 0 ? void 0 : _a2.mean) !== void 0 ? options.norm.mean : 255 : 255;
      const normBias = options !== void 0 ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== void 0 ? options.norm.bias : 0 : 0;
      const offset2 = height * width;
      if (options !== void 0) {
        if (options.height !== void 0 && options.height !== height) {
          throw new Error("Image output config height doesn't match tensor height");
        }
        if (options.width !== void 0 && options.width !== width) {
          throw new Error("Image output config width doesn't match tensor width");
        }
        if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
          throw new Error("Tensor format doesn't match input tensor dims");
        }
      }
      const step = 4;
      let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = offset2, bTensorPointer = offset2 * 2, aTensorPointer = -1;
      if (inputformat === "RGBA") {
        rTensorPointer = 0;
        gTensorPointer = offset2;
        bTensorPointer = offset2 * 2;
        aTensorPointer = offset2 * 3;
      } else if (inputformat === "RGB") {
        rTensorPointer = 0;
        gTensorPointer = offset2;
        bTensorPointer = offset2 * 2;
      } else if (inputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = offset2;
        gTensorPointer = offset2 * 2;
      }
      image = pixels2DContext.createImageData(width, height);
      for (let i2 = 0; i2 < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i2++) {
        image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean;
        image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean;
        image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean;
        image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean;
      }
    } else {
      throw new Error("Can not access image data");
    }
    return image;
  }
  // #endregion
  // #region tensor utilities
  reshape(dims) {
    return new Tensor2(this.type, this.data, dims);
  }
};
const Tensor = Tensor$1;
let InferenceSession$1 = class InferenceSession2 {
  constructor(handler) {
    this.handler = handler;
  }
  async run(feeds, arg1, arg2) {
    const fetches = {};
    let options = {};
    if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {
      throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
    }
    let isFetchesEmpty = true;
    if (typeof arg1 === "object") {
      if (arg1 === null) {
        throw new TypeError("Unexpected argument[1]: cannot be null.");
      }
      if (arg1 instanceof Tensor) {
        throw new TypeError("'fetches' cannot be a Tensor");
      }
      if (Array.isArray(arg1)) {
        if (arg1.length === 0) {
          throw new TypeError("'fetches' cannot be an empty array.");
        }
        isFetchesEmpty = false;
        for (const name2 of arg1) {
          if (typeof name2 !== "string") {
            throw new TypeError("'fetches' must be a string array or an object.");
          }
          if (this.outputNames.indexOf(name2) === -1) {
            throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
          }
          fetches[name2] = null;
        }
        if (typeof arg2 === "object" && arg2 !== null) {
          options = arg2;
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
      } else {
        let isFetches = false;
        const arg1Keys = Object.getOwnPropertyNames(arg1);
        for (const name2 of this.outputNames) {
          if (arg1Keys.indexOf(name2) !== -1) {
            const v2 = arg1[name2];
            if (v2 === null || v2 instanceof Tensor) {
              isFetches = true;
              isFetchesEmpty = false;
              fetches[name2] = v2;
            }
          }
        }
        if (isFetches) {
          if (typeof arg2 === "object" && arg2 !== null) {
            options = arg2;
          } else if (typeof arg2 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else {
          options = arg1;
        }
      }
    } else if (typeof arg1 !== "undefined") {
      throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
    }
    for (const name2 of this.inputNames) {
      if (typeof feeds[name2] === "undefined") {
        throw new Error(`input '${name2}' is missing in 'feeds'.`);
      }
    }
    if (isFetchesEmpty) {
      for (const name2 of this.outputNames) {
        fetches[name2] = null;
      }
    }
    const results = await this.handler.run(feeds, fetches, options);
    const returnValue = {};
    for (const key in results) {
      if (Object.hasOwnProperty.call(results, key)) {
        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);
      }
    }
    return returnValue;
  }
  static async create(arg0, arg1, arg2, arg3) {
    let filePathOrUint8Array;
    let options = {};
    if (typeof arg0 === "string") {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof Uint8Array) {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
      const buffer = arg0;
      let byteOffset = 0;
      let byteLength = arg0.byteLength;
      if (typeof arg1 === "object" && arg1 !== null) {
        options = arg1;
      } else if (typeof arg1 === "number") {
        byteOffset = arg1;
        if (!Number.isSafeInteger(byteOffset)) {
          throw new RangeError("'byteOffset' must be an integer.");
        }
        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
        }
        byteLength = arg0.byteLength - byteOffset;
        if (typeof arg2 === "number") {
          byteLength = arg2;
          if (!Number.isSafeInteger(byteLength)) {
            throw new RangeError("'byteLength' must be an integer.");
          }
          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
          }
          if (typeof arg3 === "object" && arg3 !== null) {
            options = arg3;
          } else if (typeof arg3 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'byteLength' must be a number.");
        }
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
    } else {
      throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
    }
    const eps = options.executionProviders || [];
    const backendHints = eps.map((i2) => typeof i2 === "string" ? i2 : i2.name);
    const backend = await resolveBackend(backendHints);
    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
    return new InferenceSession2(handler);
  }
  startProfiling() {
    this.handler.startProfiling();
  }
  endProfiling() {
    this.handler.endProfiling();
  }
  get inputNames() {
    return this.handler.inputNames;
  }
  get outputNames() {
    return this.handler.outputNames;
  }
};
const InferenceSession = InferenceSession$1;
const lib$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InferenceSession,
  Tensor,
  env: env$1,
  registerBackend
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(lib$1);
/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2(require$$0$1);
  }(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
    var __webpack_modules__ = { 3474: (t2, e2, n2) => {
      var _scriptDir, r2 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t3) {
        function e3() {
          return $2.buffer != C2 && H2($2.buffer), F2;
        }
        function r3() {
          return $2.buffer != C2 && H2($2.buffer), N2;
        }
        function i2() {
          return $2.buffer != C2 && H2($2.buffer), L2;
        }
        function o2() {
          return $2.buffer != C2 && H2($2.buffer), R2;
        }
        function a2() {
          return $2.buffer != C2 && H2($2.buffer), j2;
        }
        var s2, u2, c2;
        t3 = t3 || {}, s2 || (s2 = void 0 !== t3 ? t3 : {}), s2.ready = new Promise(function(t4, e4) {
          u2 = t4, c2 = e4;
        });
        var l2, p2, f2, d2, h2, g2, b2 = Object.assign({}, s2), m2 = "./this.program", y2 = (t4, e4) => {
          throw e4;
        }, _ = "object" == typeof window, v2 = "function" == typeof importScripts, w2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x2 = s2.ENVIRONMENT_IS_PTHREAD || false, T2 = "";
        function S2(t4) {
          return s2.locateFile ? s2.locateFile(t4, T2) : T2 + t4;
        }
        if (w2) {
          let e4;
          T2 = v2 ? n2(908).dirname(T2) + "/" : "//", g2 = () => {
            h2 || (d2 = n2(1384), h2 = n2(908));
          }, l2 = function(t4, e5) {
            return g2(), t4 = h2.normalize(t4), d2.readFileSync(t4, e5 ? void 0 : "utf8");
          }, f2 = (t4) => ((t4 = l2(t4, true)).buffer || (t4 = new Uint8Array(t4)), t4), p2 = (t4, e5, n3) => {
            g2(), t4 = h2.normalize(t4), d2.readFile(t4, function(t5, r4) {
              t5 ? n3(t5) : e5(r4.buffer);
            });
          }, 1 < process.argv.length && (m2 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t4) {
            if (!(t4 instanceof ut)) throw t4;
          }), process.on("unhandledRejection", function(t4) {
            throw t4;
          }), y2 = (t4, e5) => {
            if (J2()) throw process.exitCode = t4, e5;
            e5 instanceof ut || P2("exiting due to exception: " + e5), process.exit(t4);
          }, s2.inspect = function() {
            return "[Emscripten Module object]";
          };
          try {
            e4 = n2(9925);
          } catch (t4) {
            throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), t4;
          }
          n2.g.Worker = e4.Worker;
        } else (_ || v2) && (v2 ? T2 = self.location.href : "undefined" != typeof document && document.currentScript && (T2 = document.currentScript.src), _scriptDir && (T2 = _scriptDir), T2 = 0 !== T2.indexOf("blob:") ? T2.substr(0, T2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w2 || (l2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.send(null), e4.responseText;
        }, v2 && (f2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.responseType = "arraybuffer", e4.send(null), new Uint8Array(e4.response);
        }), p2 = (t4, e4, n3) => {
          var r4 = new XMLHttpRequest();
          r4.open("GET", t4, true), r4.responseType = "arraybuffer", r4.onload = () => {
            200 == r4.status || 0 == r4.status && r4.response ? e4(r4.response) : n3();
          }, r4.onerror = n3, r4.send(null);
        }));
        w2 && "undefined" == typeof performance && (n2.g.performance = n2(6953).performance);
        var O2 = console.log.bind(console), A2 = console.warn.bind(console);
        w2 && (g2(), O2 = (t4) => d2.writeSync(1, t4 + "\n"), A2 = (t4) => d2.writeSync(2, t4 + "\n"));
        var E2, I2 = s2.print || O2, P2 = s2.printErr || A2;
        Object.assign(s2, b2), b2 = null, s2.thisProgram && (m2 = s2.thisProgram), s2.quit && (y2 = s2.quit), s2.wasmBinary && (E2 = s2.wasmBinary);
        var D2 = s2.noExitRuntime || false;
        "object" != typeof WebAssembly && it("no native wasm support detected");
        var $2, k2, C2, F2, N2, L2, R2, j2, M2 = false, U2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function V2(t4, e4, n3) {
          var r4 = (e4 >>>= 0) + n3;
          for (n3 = e4; t4[n3] && !(n3 >= r4); ) ++n3;
          if (16 < n3 - e4 && t4.buffer && U2) return U2.decode(t4.buffer instanceof SharedArrayBuffer ? t4.slice(e4, n3) : t4.subarray(e4, n3));
          for (r4 = ""; e4 < n3; ) {
            var i3 = t4[e4++];
            if (128 & i3) {
              var o3 = 63 & t4[e4++];
              if (192 == (224 & i3)) r4 += String.fromCharCode((31 & i3) << 6 | o3);
              else {
                var a3 = 63 & t4[e4++];
                65536 > (i3 = 224 == (240 & i3) ? (15 & i3) << 12 | o3 << 6 | a3 : (7 & i3) << 18 | o3 << 12 | a3 << 6 | 63 & t4[e4++]) ? r4 += String.fromCharCode(i3) : (i3 -= 65536, r4 += String.fromCharCode(55296 | i3 >> 10, 56320 | 1023 & i3));
              }
            } else r4 += String.fromCharCode(i3);
          }
          return r4;
        }
        function B2(t4, e4) {
          return (t4 >>>= 0) ? V2(r3(), t4, e4) : "";
        }
        function z2(t4, e4, n3, r4) {
          if (!(0 < r4)) return 0;
          var i3 = n3 >>>= 0;
          r4 = n3 + r4 - 1;
          for (var o3 = 0; o3 < t4.length; ++o3) {
            var a3 = t4.charCodeAt(o3);
            if (55296 <= a3 && 57343 >= a3 && (a3 = 65536 + ((1023 & a3) << 10) | 1023 & t4.charCodeAt(++o3)), 127 >= a3) {
              if (n3 >= r4) break;
              e4[n3++ >>> 0] = a3;
            } else {
              if (2047 >= a3) {
                if (n3 + 1 >= r4) break;
                e4[n3++ >>> 0] = 192 | a3 >> 6;
              } else {
                if (65535 >= a3) {
                  if (n3 + 2 >= r4) break;
                  e4[n3++ >>> 0] = 224 | a3 >> 12;
                } else {
                  if (n3 + 3 >= r4) break;
                  e4[n3++ >>> 0] = 240 | a3 >> 18, e4[n3++ >>> 0] = 128 | a3 >> 12 & 63;
                }
                e4[n3++ >>> 0] = 128 | a3 >> 6 & 63;
              }
              e4[n3++ >>> 0] = 128 | 63 & a3;
            }
          }
          return e4[n3 >>> 0] = 0, n3 - i3;
        }
        function G2(t4) {
          for (var e4 = 0, n3 = 0; n3 < t4.length; ++n3) {
            var r4 = t4.charCodeAt(n3);
            127 >= r4 ? e4++ : 2047 >= r4 ? e4 += 2 : 55296 <= r4 && 57343 >= r4 ? (e4 += 4, ++n3) : e4 += 3;
          }
          return e4;
        }
        function H2(t4) {
          C2 = t4, s2.HEAP8 = F2 = new Int8Array(t4), s2.HEAP16 = new Int16Array(t4), s2.HEAP32 = L2 = new Int32Array(t4), s2.HEAPU8 = N2 = new Uint8Array(t4), s2.HEAPU16 = new Uint16Array(t4), s2.HEAPU32 = R2 = new Uint32Array(t4), s2.HEAPF32 = new Float32Array(t4), s2.HEAPF64 = j2 = new Float64Array(t4);
        }
        x2 && (C2 = s2.buffer);
        var W2 = s2.INITIAL_MEMORY || 16777216;
        if (x2) $2 = s2.wasmMemory, C2 = s2.buffer;
        else if (s2.wasmMemory) $2 = s2.wasmMemory;
        else if (!(($2 = new WebAssembly.Memory({ initial: W2 / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer)) throw P2("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w2 && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
        $2 && (C2 = $2.buffer), W2 = C2.byteLength, H2(C2);
        var q2, X2 = [], Y2 = [], K2 = [], Z2 = [];
        function J2() {
          return D2 || false;
        }
        function Q2() {
          var t4 = s2.preRun.shift();
          X2.unshift(t4);
        }
        var tt, et = 0, rt = null;
        function it(t4) {
          throw x2 ? postMessage({ cmd: "onAbort", arg: t4 }) : s2.onAbort && s2.onAbort(t4), P2(t4 = "Aborted(" + t4 + ")"), M2 = true, t4 = new WebAssembly.RuntimeError(t4 + ". Build with -sASSERTIONS for more info."), c2(t4), t4;
        }
        function ot() {
          return tt.startsWith("data:application/octet-stream;base64,");
        }
        function at() {
          var t4 = tt;
          try {
            if (t4 == tt && E2) return new Uint8Array(E2);
            if (f2) return f2(t4);
            throw "both async and sync fetching of the wasm failed";
          } catch (t5) {
            it(t5);
          }
        }
        tt = "ort-wasm-threaded.wasm", ot() || (tt = S2(tt));
        var st = {};
        function ut(t4) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + t4 + ")", this.status = t4;
        }
        function ct(t4) {
          (t4 = dt.Vb[t4]) || it(), dt.mc(t4);
        }
        function lt(t4) {
          var e4 = dt.Cc();
          if (!e4) return 6;
          dt.ac.push(e4), dt.Vb[t4.Ub] = e4, e4.Ub = t4.Ub;
          var n3 = { cmd: "run", start_routine: t4.Ic, arg: t4.zc, pthread_ptr: t4.Ub };
          return e4.$b = () => {
            n3.time = performance.now(), e4.postMessage(n3, t4.Nc);
          }, e4.loaded && (e4.$b(), delete e4.$b), 0;
        }
        function pt2(t4) {
          if (x2) return qt(1, 1, t4);
          J2() || (dt.oc(), s2.onExit && s2.onExit(t4), M2 = true), y2(t4, new ut(t4));
        }
        function ft(t4, e4) {
          if (!e4 && x2) throw bt(t4), "unwind";
          J2() || x2 || (me2(), ht(K2), be2(0), re2[1].length && ie2(1, 10), re2[2].length && ie2(2, 10), dt.oc()), pt2(t4);
        }
        var dt = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
          x2 && dt.Ec();
        }, Pc: function() {
        }, Ec: function() {
          dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D2 = false;
        }, nc: function() {
        }, oc: function() {
          for (var t4 of Object.values(dt.Vb)) dt.mc(t4);
          for (t4 of dt.Yb) t4.terminate();
          dt.Yb = [];
        }, mc: function(t4) {
          var e4 = t4.Ub;
          delete dt.Vb[e4], dt.Yb.push(t4), dt.ac.splice(dt.ac.indexOf(t4), 1), t4.Ub = 0, xe2(e4);
        }, Gc: function() {
        }, pc: function() {
          dt.qc.forEach((t4) => t4());
        }, Fc: function(t4, e4) {
          t4.onmessage = (n3) => {
            var r4 = (n3 = n3.data).cmd;
            if (t4.Ub && (dt.Bc = t4.Ub), n3.targetThread && n3.targetThread != de2()) {
              var i3 = dt.Vb[n3.Qc];
              i3 ? i3.postMessage(n3, n3.transferList) : P2('Internal error! Worker sent a message "' + r4 + '" to target pthread ' + n3.targetThread + ", but that thread no longer exists!");
            } else "processProxyingQueue" === r4 ? Vt(n3.queue) : "spawnThread" === r4 ? lt(n3) : "cleanupThread" === r4 ? ct(n3.thread) : "killThread" === r4 ? (n3 = n3.thread, r4 = dt.Vb[n3], delete dt.Vb[n3], r4.terminate(), xe2(n3), dt.ac.splice(dt.ac.indexOf(r4), 1), r4.Ub = 0) : "cancelThread" === r4 ? dt.Vb[n3.thread].postMessage({ cmd: "cancel" }) : "loaded" === r4 ? (t4.loaded = true, e4 && e4(t4), t4.$b && (t4.$b(), delete t4.$b)) : "print" === r4 ? I2("Thread " + n3.threadId + ": " + n3.text) : "printErr" === r4 ? P2("Thread " + n3.threadId + ": " + n3.text) : "alert" === r4 ? alert("Thread " + n3.threadId + ": " + n3.text) : "setimmediate" === n3.target ? t4.postMessage(n3) : "onAbort" === r4 ? s2.onAbort && s2.onAbort(n3.arg) : r4 && P2("worker sent an unknown command " + r4);
            dt.Bc = void 0;
          }, t4.onerror = (t5) => {
            throw P2("worker sent an error! " + t5.filename + ":" + t5.lineno + ": " + t5.message), t5;
          }, w2 && (t4.on("message", function(e5) {
            t4.onmessage({ data: e5 });
          }), t4.on("error", function(e5) {
            t4.onerror(e5);
          }), t4.on("detachedExit", function() {
          })), t4.postMessage({ cmd: "load", urlOrBlob: s2.mainScriptUrlOrBlob || _scriptDir, wasmMemory: $2, wasmModule: k2 });
        }, yc: function() {
          var t4 = S2("ort-wasm-threaded.worker.js");
          dt.Yb.push(new Worker(t4));
        }, Cc: function() {
          return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();
        } };
        function ht(t4) {
          for (; 0 < t4.length; ) t4.shift()(s2);
        }
        function gt(t4) {
          var e4 = Ae2();
          return t4 = t4(), Ee2(e4), t4;
        }
        function bt(t4) {
          if (x2) return qt(2, 0, t4);
          try {
            ft(t4);
          } catch (t5) {
            t5 instanceof ut || "unwind" == t5 || y2(1, t5);
          }
        }
        s2.PThread = dt, s2.establishStackSpace = function() {
          var t4 = de2(), e4 = i2()[t4 + 44 >> 2 >>> 0];
          t4 = i2()[t4 + 48 >> 2 >>> 0], Oe2(e4, e4 - t4), Ee2(e4);
        };
        var mt = [];
        function yt(t4) {
          var e4 = mt[t4];
          return e4 || (t4 >= mt.length && (mt.length = t4 + 1), mt[t4] = e4 = q2.get(t4)), e4;
        }
        s2.invokeEntryPoint = function(t4, e4) {
          t4 = yt(t4)(e4), J2() ? dt.nc(t4) : Te2(t4);
        };
        var _t, vt, wt = [], xt = 0, Tt = 0;
        function St(t4) {
          this.Zb = t4, this.Sb = t4 - 24, this.xc = function(t5) {
            o2()[this.Sb + 4 >> 2 >>> 0] = t5;
          }, this.bc = function() {
            return o2()[this.Sb + 4 >> 2 >>> 0];
          }, this.wc = function(t5) {
            o2()[this.Sb + 8 >> 2 >>> 0] = t5;
          }, this.Dc = function() {
            return o2()[this.Sb + 8 >> 2 >>> 0];
          }, this.rc = function() {
            i2()[this.Sb >> 2 >>> 0] = 0;
          }, this.hc = function(t5) {
            t5 = t5 ? 1 : 0, e3()[this.Sb + 12 >> 0 >>> 0] = t5;
          }, this.uc = function() {
            return 0 != e3()[this.Sb + 12 >> 0 >>> 0];
          }, this.ic = function(t5) {
            t5 = t5 ? 1 : 0, e3()[this.Sb + 13 >> 0 >>> 0] = t5;
          }, this.kc = function() {
            return 0 != e3()[this.Sb + 13 >> 0 >>> 0];
          }, this.fc = function(t5, e4) {
            this.cc(0), this.xc(t5), this.wc(e4), this.rc(), this.hc(false), this.ic(false);
          }, this.sc = function() {
            Atomics.add(i2(), this.Sb >> 2, 1);
          }, this.Hc = function() {
            return 1 === Atomics.sub(i2(), this.Sb >> 2, 1);
          }, this.cc = function(t5) {
            o2()[this.Sb + 16 >> 2 >>> 0] = t5;
          }, this.tc = function() {
            return o2()[this.Sb + 16 >> 2 >>> 0];
          }, this.vc = function() {
            if (De2(this.bc())) return o2()[this.Zb >> 2 >>> 0];
            var t5 = this.tc();
            return 0 !== t5 ? t5 : this.Zb;
          };
        }
        function Ot(t4) {
          return ge2(new St(t4).Sb);
        }
        function At(t4, e4, n3, r4) {
          return x2 ? qt(3, 1, t4, e4, n3, r4) : Et(t4, e4, n3, r4);
        }
        function Et(t4, e4, n3, r4) {
          if ("undefined" == typeof SharedArrayBuffer) return P2("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
          var i3 = [];
          return x2 && 0 === i3.length ? At(t4, e4, n3, r4) : (t4 = { Ic: n3, Ub: t4, zc: r4, Nc: i3 }, x2 ? (t4.Oc = "spawnThread", postMessage(t4, i3), 0) : lt(t4));
        }
        function It(t4, e4, n3) {
          return x2 ? qt(4, 1, t4, e4, n3) : 0;
        }
        function Pt(t4, e4) {
          if (x2) return qt(5, 1, t4, e4);
        }
        function Dt(t4, e4) {
          if (x2) return qt(6, 1, t4, e4);
        }
        function $t(t4, e4, n3) {
          if (x2) return qt(7, 1, t4, e4, n3);
        }
        function kt(t4, e4, n3) {
          return x2 ? qt(8, 1, t4, e4, n3) : 0;
        }
        function Ct(t4, e4) {
          if (x2) return qt(9, 1, t4, e4);
        }
        function Ft(t4, e4, n3) {
          if (x2) return qt(10, 1, t4, e4, n3);
        }
        function Nt(t4, e4, n3, r4) {
          if (x2) return qt(11, 1, t4, e4, n3, r4);
        }
        function Lt(t4, e4, n3, r4) {
          if (x2) return qt(12, 1, t4, e4, n3, r4);
        }
        function Rt(t4, e4, n3, r4) {
          if (x2) return qt(13, 1, t4, e4, n3, r4);
        }
        function jt(t4) {
          if (x2) return qt(14, 1, t4);
        }
        function Mt(t4, e4) {
          if (x2) return qt(15, 1, t4, e4);
        }
        function Ut(t4, e4, n3) {
          if (x2) return qt(16, 1, t4, e4, n3);
        }
        function Vt(t4) {
          Atomics.store(i2(), t4 >> 2, 1), de2() && we2(t4), Atomics.compareExchange(i2(), t4 >> 2, 1, 0);
        }
        function Bt(t4) {
          return o2()[t4 >>> 2] + 4294967296 * i2()[t4 + 4 >>> 2];
        }
        function zt(t4, e4, n3, r4, i3, o3) {
          return x2 ? qt(17, 1, t4, e4, n3, r4, i3, o3) : -52;
        }
        function Gt(t4, e4, n3, r4, i3, o3) {
          if (x2) return qt(18, 1, t4, e4, n3, r4, i3, o3);
        }
        function Ht(t4) {
          var n3 = G2(t4) + 1, r4 = he2(n3);
          return r4 && z2(t4, e3(), r4, n3), r4;
        }
        function Wt(t4, e4, n3) {
          function r4(t5) {
            return (t5 = t5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t5[1] : "GMT";
          }
          if (x2) return qt(19, 1, t4, e4, n3);
          var a3 = (/* @__PURE__ */ new Date()).getFullYear(), s3 = new Date(a3, 0, 1), u3 = new Date(a3, 6, 1);
          a3 = s3.getTimezoneOffset();
          var c3 = u3.getTimezoneOffset(), l3 = Math.max(a3, c3);
          i2()[t4 >> 2 >>> 0] = 60 * l3, i2()[e4 >> 2 >>> 0] = Number(a3 != c3), t4 = r4(s3), e4 = r4(u3), t4 = Ht(t4), e4 = Ht(e4), c3 < a3 ? (o2()[n3 >> 2 >>> 0] = t4, o2()[n3 + 4 >> 2 >>> 0] = e4) : (o2()[n3 >> 2 >>> 0] = e4, o2()[n3 + 4 >> 2 >>> 0] = t4);
        }
        function qt(t4, e4) {
          var n3 = arguments.length - 2, r4 = arguments;
          return gt(() => {
            for (var i3 = Ie2(8 * n3), o3 = i3 >> 3, s3 = 0; s3 < n3; s3++) {
              var u3 = r4[2 + s3];
              a2()[o3 + s3 >>> 0] = u3;
            }
            return ve2(t4, n3, i3, e4);
          });
        }
        s2.executeNotifiedProxyingQueue = Vt, vt = w2 ? () => {
          var t4 = process.hrtime();
          return 1e3 * t4[0] + t4[1] / 1e6;
        } : x2 ? () => performance.now() - s2.__performance_now_clock_drift : () => performance.now();
        var Xt, Yt = [], Kt = {};
        function Zt() {
          if (!Xt) {
            var t4, e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: m2 || "./this.program" };
            for (t4 in Kt) void 0 === Kt[t4] ? delete e4[t4] : e4[t4] = Kt[t4];
            var n3 = [];
            for (t4 in e4) n3.push(t4 + "=" + e4[t4]);
            Xt = n3;
          }
          return Xt;
        }
        function Jt(t4, n3) {
          if (x2) return qt(20, 1, t4, n3);
          var r4 = 0;
          return Zt().forEach(function(i3, a3) {
            var s3 = n3 + r4;
            for (a3 = o2()[t4 + 4 * a3 >> 2 >>> 0] = s3, s3 = 0; s3 < i3.length; ++s3) e3()[a3++ >> 0 >>> 0] = i3.charCodeAt(s3);
            e3()[a3 >> 0 >>> 0] = 0, r4 += i3.length + 1;
          }), 0;
        }
        function Qt(t4, e4) {
          if (x2) return qt(21, 1, t4, e4);
          var n3 = Zt();
          o2()[t4 >> 2 >>> 0] = n3.length;
          var r4 = 0;
          return n3.forEach(function(t5) {
            r4 += t5.length + 1;
          }), o2()[e4 >> 2 >>> 0] = r4, 0;
        }
        function te2(t4) {
          return x2 ? qt(22, 1, t4) : 52;
        }
        function ee2(t4, e4, n3, r4) {
          return x2 ? qt(23, 1, t4, e4, n3, r4) : 52;
        }
        function ne2(t4, e4, n3, r4, i3) {
          return x2 ? qt(24, 1, t4, e4, n3, r4, i3) : 70;
        }
        var re2 = [null, [], []];
        function ie2(t4, e4) {
          var n3 = re2[t4];
          0 === e4 || 10 === e4 ? ((1 === t4 ? I2 : P2)(V2(n3, 0)), n3.length = 0) : n3.push(e4);
        }
        function oe2(t4, e4, n3, i3) {
          if (x2) return qt(25, 1, t4, e4, n3, i3);
          for (var a3 = 0, s3 = 0; s3 < n3; s3++) {
            var u3 = o2()[e4 >> 2 >>> 0], c3 = o2()[e4 + 4 >> 2 >>> 0];
            e4 += 8;
            for (var l3 = 0; l3 < c3; l3++) ie2(t4, r3()[u3 + l3 >>> 0]);
            a3 += c3;
          }
          return o2()[i3 >> 2 >>> 0] = a3, 0;
        }
        var ae2 = 0;
        function se2(t4) {
          return 0 == t4 % 4 && (0 != t4 % 100 || 0 == t4 % 400);
        }
        var ue2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ce2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function le2(t4, n3, r4, o3) {
          function a3(t5, e4, n4) {
            for (t5 = "number" == typeof t5 ? t5.toString() : t5 || ""; t5.length < e4; ) t5 = n4[0] + t5;
            return t5;
          }
          function s3(t5, e4) {
            return a3(t5, e4, "0");
          }
          function u3(t5, e4) {
            function n4(t6) {
              return 0 > t6 ? -1 : 0 < t6 ? 1 : 0;
            }
            var r5;
            return 0 === (r5 = n4(t5.getFullYear() - e4.getFullYear())) && 0 === (r5 = n4(t5.getMonth() - e4.getMonth())) && (r5 = n4(t5.getDate() - e4.getDate())), r5;
          }
          function c3(t5) {
            switch (t5.getDay()) {
              case 0:
                return new Date(t5.getFullYear() - 1, 11, 29);
              case 1:
                return t5;
              case 2:
                return new Date(t5.getFullYear(), 0, 3);
              case 3:
                return new Date(t5.getFullYear(), 0, 2);
              case 4:
                return new Date(t5.getFullYear(), 0, 1);
              case 5:
                return new Date(t5.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(t5.getFullYear() - 1, 11, 30);
            }
          }
          function l3(t5) {
            var e4 = t5.Wb;
            for (t5 = new Date(new Date(t5.Xb + 1900, 0, 1).getTime()); 0 < e4; ) {
              var n4 = t5.getMonth(), r5 = (se2(t5.getFullYear()) ? ue2 : ce2)[n4];
              if (!(e4 > r5 - t5.getDate())) {
                t5.setDate(t5.getDate() + e4);
                break;
              }
              e4 -= r5 - t5.getDate() + 1, t5.setDate(1), 11 > n4 ? t5.setMonth(n4 + 1) : (t5.setMonth(0), t5.setFullYear(t5.getFullYear() + 1));
            }
            return n4 = new Date(t5.getFullYear() + 1, 0, 4), e4 = c3(new Date(t5.getFullYear(), 0, 4)), n4 = c3(n4), 0 >= u3(e4, t5) ? 0 >= u3(n4, t5) ? t5.getFullYear() + 1 : t5.getFullYear() : t5.getFullYear() - 1;
          }
          var p3 = i2()[o3 + 40 >> 2 >>> 0];
          for (var f3 in o3 = { Lc: i2()[o3 >> 2 >>> 0], Kc: i2()[o3 + 4 >> 2 >>> 0], dc: i2()[o3 + 8 >> 2 >>> 0], jc: i2()[o3 + 12 >> 2 >>> 0], ec: i2()[o3 + 16 >> 2 >>> 0], Xb: i2()[o3 + 20 >> 2 >>> 0], Tb: i2()[o3 + 24 >> 2 >>> 0], Wb: i2()[o3 + 28 >> 2 >>> 0], Rc: i2()[o3 + 32 >> 2 >>> 0], Jc: i2()[o3 + 36 >> 2 >>> 0], Mc: p3 ? B2(p3) : "" }, r4 = B2(r4), p3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) r4 = r4.replace(new RegExp(f3, "g"), p3[f3]);
          var d3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h3 = "January February March April May June July August September October November December".split(" ");
          for (f3 in p3 = { "%a": function(t5) {
            return d3[t5.Tb].substring(0, 3);
          }, "%A": function(t5) {
            return d3[t5.Tb];
          }, "%b": function(t5) {
            return h3[t5.ec].substring(0, 3);
          }, "%B": function(t5) {
            return h3[t5.ec];
          }, "%C": function(t5) {
            return s3((t5.Xb + 1900) / 100 | 0, 2);
          }, "%d": function(t5) {
            return s3(t5.jc, 2);
          }, "%e": function(t5) {
            return a3(t5.jc, 2, " ");
          }, "%g": function(t5) {
            return l3(t5).toString().substring(2);
          }, "%G": function(t5) {
            return l3(t5);
          }, "%H": function(t5) {
            return s3(t5.dc, 2);
          }, "%I": function(t5) {
            return 0 == (t5 = t5.dc) ? t5 = 12 : 12 < t5 && (t5 -= 12), s3(t5, 2);
          }, "%j": function(t5) {
            for (var e4 = 0, n4 = 0; n4 <= t5.ec - 1; e4 += (se2(t5.Xb + 1900) ? ue2 : ce2)[n4++]) ;
            return s3(t5.jc + e4, 3);
          }, "%m": function(t5) {
            return s3(t5.ec + 1, 2);
          }, "%M": function(t5) {
            return s3(t5.Kc, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(t5) {
            return 0 <= t5.dc && 12 > t5.dc ? "AM" : "PM";
          }, "%S": function(t5) {
            return s3(t5.Lc, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(t5) {
            return t5.Tb || 7;
          }, "%U": function(t5) {
            return s3(Math.floor((t5.Wb + 7 - t5.Tb) / 7), 2);
          }, "%V": function(t5) {
            var e4 = Math.floor((t5.Wb + 7 - (t5.Tb + 6) % 7) / 7);
            if (2 >= (t5.Tb + 371 - t5.Wb - 2) % 7 && e4++, e4) 53 == e4 && (4 == (n4 = (t5.Tb + 371 - t5.Wb) % 7) || 3 == n4 && se2(t5.Xb) || (e4 = 1));
            else {
              e4 = 52;
              var n4 = (t5.Tb + 7 - t5.Wb - 1) % 7;
              (4 == n4 || 5 == n4 && se2(t5.Xb % 400 - 1)) && e4++;
            }
            return s3(e4, 2);
          }, "%w": function(t5) {
            return t5.Tb;
          }, "%W": function(t5) {
            return s3(Math.floor((t5.Wb + 7 - (t5.Tb + 6) % 7) / 7), 2);
          }, "%y": function(t5) {
            return (t5.Xb + 1900).toString().substring(2);
          }, "%Y": function(t5) {
            return t5.Xb + 1900;
          }, "%z": function(t5) {
            var e4 = 0 <= (t5 = t5.Jc);
            return t5 = Math.abs(t5) / 60, (e4 ? "+" : "-") + String("0000" + (t5 / 60 * 100 + t5 % 60)).slice(-4);
          }, "%Z": function(t5) {
            return t5.Mc;
          }, "%%": function() {
            return "%";
          } }, r4 = r4.replace(/%%/g, "\0\0"), p3) r4.includes(f3) && (r4 = r4.replace(new RegExp(f3, "g"), p3[f3](o3)));
          return f3 = function(t5) {
            var e4 = Array(G2(t5) + 1);
            return z2(t5, e4, 0, e4.length), e4;
          }(r4 = r4.replace(/\0\0/g, "%")), f3.length > n3 ? 0 : (function(t5, n4) {
            e3().set(t5, n4 >>> 0);
          }(f3, t4), f3.length - 1);
        }
        dt.fc();
        var pe2 = [null, pt2, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te2, ee2, ne2, oe2], fe2 = { b: function(t4) {
          return he2(t4 + 24) + 24;
        }, n: function(t4) {
          return (t4 = new St(t4)).uc() || (t4.hc(true), xt--), t4.ic(false), wt.push(t4), t4.sc(), t4.vc();
        }, ma: function(t4) {
          throw P2("Unexpected exception thrown, this is not properly supported - aborting"), M2 = true, t4;
        }, x: function() {
          Se2(0);
          var t4 = wt.pop();
          if (t4.Hc() && !t4.kc()) {
            var e4 = t4.Dc();
            e4 && yt(e4)(t4.Zb), Ot(t4.Zb);
          }
          Tt = 0;
        }, e: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (Pe2(o3, n3, e4.Sb + 16)) return ae2 = o3, t4;
          }
          return ae2 = n3, t4;
        }, l: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (Pe2(o3, n3, e4.Sb + 16)) return ae2 = o3, t4;
          }
          return ae2 = n3, t4;
        }, h: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (Pe2(o3, n3, e4.Sb + 16)) return ae2 = o3, t4;
          }
          return ae2 = n3, t4;
        }, t: Ot, M: function() {
          var t4 = wt.pop();
          t4 || it("no exception to throw");
          var e4 = t4.Zb;
          throw t4.kc() || (wt.push(t4), t4.ic(true), t4.hc(false), xt++), Tt = e4, e4;
        }, c: function(t4, e4, n3) {
          throw new St(t4).fc(e4, n3), Tt = t4, xt++, t4;
        }, pa: function() {
          return xt;
        }, Fa: function(t4) {
          ye2(t4, !v2, 1, !_), dt.pc();
        }, T: function(t4) {
          x2 ? postMessage({ cmd: "cleanupThread", thread: t4 }) : ct(t4);
        }, xa: Et, j: function(t4) {
          throw Tt || (Tt = t4), t4;
        }, H: It, Ma: Pt, ua: Dt, wa: $t, oa: kt, Ka: Ct, Ca: Ft, Ja: Nt, V: Lt, va: Rt, sa: jt, La: Mt, ta: Ut, Ta: function() {
        }, X: function() {
          it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, Ua: function() {
          it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, W: function() {
          return Date.now();
        }, ya: function() {
          return 2097152;
        }, Oa: function() {
          return true;
        }, za: function(t4, e4, n3, r4) {
          if (t4 == e4) setTimeout(() => Vt(r4));
          else if (x2) postMessage({ targetThread: t4, cmd: "processProxyingQueue", queue: r4 });
          else {
            if (!(t4 = dt.Vb[t4])) return;
            t4.postMessage({ cmd: "processProxyingQueue", queue: r4 });
          }
          return 1;
        }, Ea: function() {
          return -1;
        }, Pa: function(t4, e4) {
          t4 = new Date(1e3 * Bt(t4)), i2()[e4 >> 2 >>> 0] = t4.getUTCSeconds(), i2()[e4 + 4 >> 2 >>> 0] = t4.getUTCMinutes(), i2()[e4 + 8 >> 2 >>> 0] = t4.getUTCHours(), i2()[e4 + 12 >> 2 >>> 0] = t4.getUTCDate(), i2()[e4 + 16 >> 2 >>> 0] = t4.getUTCMonth(), i2()[e4 + 20 >> 2 >>> 0] = t4.getUTCFullYear() - 1900, i2()[e4 + 24 >> 2 >>> 0] = t4.getUTCDay(), t4 = (t4.getTime() - Date.UTC(t4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i2()[e4 + 28 >> 2 >>> 0] = t4;
        }, Qa: function(t4, e4) {
          t4 = new Date(1e3 * Bt(t4)), i2()[e4 >> 2 >>> 0] = t4.getSeconds(), i2()[e4 + 4 >> 2 >>> 0] = t4.getMinutes(), i2()[e4 + 8 >> 2 >>> 0] = t4.getHours(), i2()[e4 + 12 >> 2 >>> 0] = t4.getDate(), i2()[e4 + 16 >> 2 >>> 0] = t4.getMonth(), i2()[e4 + 20 >> 2 >>> 0] = t4.getFullYear() - 1900, i2()[e4 + 24 >> 2 >>> 0] = t4.getDay();
          var n3 = new Date(t4.getFullYear(), 0, 1), r4 = (t4.getTime() - n3.getTime()) / 864e5 | 0;
          i2()[e4 + 28 >> 2 >>> 0] = r4, i2()[e4 + 36 >> 2 >>> 0] = -60 * t4.getTimezoneOffset(), r4 = new Date(t4.getFullYear(), 6, 1).getTimezoneOffset(), t4 = 0 | (r4 != (n3 = n3.getTimezoneOffset()) && t4.getTimezoneOffset() == Math.min(n3, r4)), i2()[e4 + 32 >> 2 >>> 0] = t4;
        }, Ra: function(t4) {
          var e4 = new Date(i2()[t4 + 20 >> 2 >>> 0] + 1900, i2()[t4 + 16 >> 2 >>> 0], i2()[t4 + 12 >> 2 >>> 0], i2()[t4 + 8 >> 2 >>> 0], i2()[t4 + 4 >> 2 >>> 0], i2()[t4 >> 2 >>> 0], 0), n3 = i2()[t4 + 32 >> 2 >>> 0], r4 = e4.getTimezoneOffset(), o3 = new Date(e4.getFullYear(), 0, 1), a3 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset(), s3 = o3.getTimezoneOffset(), u3 = Math.min(s3, a3);
          return 0 > n3 ? i2()[t4 + 32 >> 2 >>> 0] = Number(a3 != s3 && u3 == r4) : 0 < n3 != (u3 == r4) && (a3 = Math.max(s3, a3), e4.setTime(e4.getTime() + 6e4 * ((0 < n3 ? u3 : a3) - r4))), i2()[t4 + 24 >> 2 >>> 0] = e4.getDay(), n3 = (e4.getTime() - o3.getTime()) / 864e5 | 0, i2()[t4 + 28 >> 2 >>> 0] = n3, i2()[t4 >> 2 >>> 0] = e4.getSeconds(), i2()[t4 + 4 >> 2 >>> 0] = e4.getMinutes(), i2()[t4 + 8 >> 2 >>> 0] = e4.getHours(), i2()[t4 + 12 >> 2 >>> 0] = e4.getDate(), i2()[t4 + 16 >> 2 >>> 0] = e4.getMonth(), e4.getTime() / 1e3 | 0;
        }, Aa: zt, Ba: Gt, Sa: function t4(e4, n3, r4) {
          t4.Ac || (t4.Ac = true, Wt(e4, n3, r4));
        }, y: function() {
          it("");
        }, U: function() {
          if (!w2 && !v2) {
            var t4 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
            _t || (_t = {}), _t[t4] || (_t[t4] = 1, w2 && (t4 = "warning: " + t4), P2(t4));
          }
        }, ra: function() {
          return 4294901760;
        }, B: vt, Ia: function(t4, e4, n3) {
          r3().copyWithin(t4 >>> 0, e4 >>> 0, e4 + n3 >>> 0);
        }, F: function() {
          return w2 ? n2(3993).cpus().length : navigator.hardwareConcurrency;
        }, Da: function(t4, e4, n3) {
          Yt.length = e4, n3 >>= 3;
          for (var r4 = 0; r4 < e4; r4++) Yt[r4] = a2()[n3 + r4 >>> 0];
          return (0 > t4 ? st[-t4 - 1] : pe2[t4]).apply(null, Yt);
        }, qa: function(t4) {
          var e4 = r3().length;
          if ((t4 >>>= 0) <= e4 || 4294901760 < t4) return false;
          for (var n3 = 1; 4 >= n3; n3 *= 2) {
            var i3 = e4 * (1 + 0.2 / n3);
            i3 = Math.min(i3, t4 + 100663296);
            var o3 = Math;
            i3 = Math.max(t4, i3), o3 = o3.min.call(o3, 4294901760, i3 + (65536 - i3 % 65536) % 65536);
            t: {
              try {
                $2.grow(o3 - C2.byteLength + 65535 >>> 16), H2($2.buffer);
                var a3 = 1;
                break t;
              } catch (t5) {
              }
              a3 = void 0;
            }
            if (a3) return true;
          }
          return false;
        }, Na: function() {
          throw "unwind";
        }, Ga: Jt, Ha: Qt, J: ft, I: te2, S: ee2, ga: ne2, R: oe2, d: function() {
          return ae2;
        }, na: function t4(r4, i3) {
          t4.lc || (t4.lc = function() {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
              var t5 = new Uint8Array(1);
              return () => (crypto.getRandomValues(t5), t5[0]);
            }
            if (w2) try {
              var e4 = n2(Object(function() {
                var t6 = new Error("Cannot find module 'crypto'");
                throw t6.code = "MODULE_NOT_FOUND", t6;
              }()));
              return () => e4.randomBytes(1)[0];
            } catch (t6) {
            }
            return () => it("randomDevice");
          }());
          for (var o3 = 0; o3 < i3; o3++) e3()[r4 + o3 >> 0 >>> 0] = t4.lc();
          return 0;
        }, ia: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ja: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, K: function(t4) {
          var e4 = Ae2();
          try {
            return yt(t4)();
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, f: function(t4, e4) {
          var n3 = Ae2();
          try {
            return yt(t4)(e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, P: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Q: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, k: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, p: function(t4, e4, n3, r4) {
          var i3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, q: function(t4, e4, n3, r4, i3) {
          var o3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3);
          } catch (t5) {
            if (Ee2(o3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, N: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (Ee2(a3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, s: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (Ee2(a3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, w: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (Ee2(s3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, L: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, E: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3) {
          var f3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3);
          } catch (t5) {
            if (Ee2(f3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, aa: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Ae2();
          try {
            return Me2(t4, e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, _: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Ae2();
          try {
            return ke2(t4, e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (Ee2(s3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Z: function(t4, e4, n3, r4, i3) {
          var o3 = Ae2();
          try {
            return Ue2(t4, e4, n3, r4, i3);
          } catch (t5) {
            if (Ee2(o3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ca: function(t4, e4, n3, r4) {
          var i3 = Ae2();
          try {
            return Re2(t4, e4, n3, r4);
          } catch (t5) {
            if (Ee2(i3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, $: function(t4) {
          var e4 = Ae2();
          try {
            return $e2(t4);
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ba: function(t4, e4) {
          var n3 = Ae2();
          try {
            return je2(t4, e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Y: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return Ce2(t4, e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, g: function(t4) {
          var e4 = Ae2();
          try {
            yt(t4)();
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, r: function(t4, e4) {
          var n3 = Ae2();
          try {
            yt(t4)(e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, i: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ha: function(t4, e4, n3, r4) {
          var i3 = Ae2();
          try {
            yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, m: function(t4, e4, n3, r4) {
          var i3 = Ae2();
          try {
            yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, v: function(t4, e4, n3, r4, i3) {
          var o3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3);
          } catch (t5) {
            if (Ee2(o3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, u: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (Ee2(a3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, O: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (Ee2(s3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, A: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ka: function(t4, e4, n3, r4, i3, o3, a3, s3, u3) {
          var c3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3, a3, s3, u3);
          } catch (t5) {
            if (Ee2(c3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, C: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3) {
          var p3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3);
          } catch (t5) {
            if (Ee2(p3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, D: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3, f3, d3, h3, g3) {
          var b3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3, f3, d3, h3, g3);
          } catch (t5) {
            if (Ee2(b3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, fa: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Ae2();
          try {
            Fe2(t4, e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, da: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3) {
          var f3 = Ae2();
          try {
            Le2(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3);
          } catch (t5) {
            if (Ee2(f3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ea: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Ae2();
          try {
            Ne2(t4, e4, n3, r4, i3, o3);
          } catch (t5) {
            if (Ee2(a3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, o: function(t4) {
          return t4;
        }, a: $2 || s2.wasmMemory, G: function(t4) {
          ae2 = t4;
        }, la: le2, z: function(t4, e4, n3, r4) {
          return le2(t4, e4, n3, r4);
        } };
        !function() {
          function t4(t5, e5) {
            s2.asm = t5.exports, dt.qc.push(s2.asm.sb), q2 = s2.asm.ub, Y2.unshift(s2.asm.Va), k2 = e5, x2 || (et--, s2.monitorRunDependencies && s2.monitorRunDependencies(et), 0 == et && (rt && (t5 = rt, rt = null, t5())));
          }
          function e4(e5) {
            t4(e5.instance, e5.module);
          }
          function n3(t5) {
            return function() {
              if (!E2 && (_ || v2)) {
                if ("function" == typeof fetch && !tt.startsWith("file://")) return fetch(tt, { credentials: "same-origin" }).then(function(t6) {
                  if (!t6.ok) throw "failed to load wasm binary file at '" + tt + "'";
                  return t6.arrayBuffer();
                }).catch(function() {
                  return at();
                });
                if (p2) return new Promise(function(t6, e5) {
                  p2(tt, function(e6) {
                    t6(new Uint8Array(e6));
                  }, e5);
                });
              }
              return Promise.resolve().then(function() {
                return at();
              });
            }().then(function(t6) {
              return WebAssembly.instantiate(t6, r4);
            }).then(function(t6) {
              return t6;
            }).then(t5, function(t6) {
              P2("failed to asynchronously prepare wasm: " + t6), it(t6);
            });
          }
          var r4 = { a: fe2 };
          if (x2 || (et++, s2.monitorRunDependencies && s2.monitorRunDependencies(et)), s2.instantiateWasm) try {
            return s2.instantiateWasm(r4, t4);
          } catch (t5) {
            return P2("Module.instantiateWasm callback failed with error: " + t5), false;
          }
          (E2 || "function" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith("file://") || w2 || "function" != typeof fetch ? n3(e4) : fetch(tt, { credentials: "same-origin" }).then(function(t5) {
            return WebAssembly.instantiateStreaming(t5, r4).then(e4, function(t6) {
              return P2("wasm streaming compile failed: " + t6), P2("falling back to ArrayBuffer instantiation"), n3(e4);
            });
          })).catch(c2);
        }(), s2.___wasm_call_ctors = function() {
          return (s2.___wasm_call_ctors = s2.asm.Va).apply(null, arguments);
        }, s2._OrtInit = function() {
          return (s2._OrtInit = s2.asm.Wa).apply(null, arguments);
        }, s2._OrtCreateSessionOptions = function() {
          return (s2._OrtCreateSessionOptions = s2.asm.Xa).apply(null, arguments);
        }, s2._OrtAppendExecutionProvider = function() {
          return (s2._OrtAppendExecutionProvider = s2.asm.Ya).apply(null, arguments);
        }, s2._OrtAddSessionConfigEntry = function() {
          return (s2._OrtAddSessionConfigEntry = s2.asm.Za).apply(null, arguments);
        }, s2._OrtReleaseSessionOptions = function() {
          return (s2._OrtReleaseSessionOptions = s2.asm._a).apply(null, arguments);
        }, s2._OrtCreateSession = function() {
          return (s2._OrtCreateSession = s2.asm.$a).apply(null, arguments);
        }, s2._OrtReleaseSession = function() {
          return (s2._OrtReleaseSession = s2.asm.ab).apply(null, arguments);
        }, s2._OrtGetInputCount = function() {
          return (s2._OrtGetInputCount = s2.asm.bb).apply(null, arguments);
        }, s2._OrtGetOutputCount = function() {
          return (s2._OrtGetOutputCount = s2.asm.cb).apply(null, arguments);
        }, s2._OrtGetInputName = function() {
          return (s2._OrtGetInputName = s2.asm.db).apply(null, arguments);
        }, s2._OrtGetOutputName = function() {
          return (s2._OrtGetOutputName = s2.asm.eb).apply(null, arguments);
        }, s2._OrtFree = function() {
          return (s2._OrtFree = s2.asm.fb).apply(null, arguments);
        }, s2._OrtCreateTensor = function() {
          return (s2._OrtCreateTensor = s2.asm.gb).apply(null, arguments);
        }, s2._OrtGetTensorData = function() {
          return (s2._OrtGetTensorData = s2.asm.hb).apply(null, arguments);
        }, s2._OrtReleaseTensor = function() {
          return (s2._OrtReleaseTensor = s2.asm.ib).apply(null, arguments);
        }, s2._OrtCreateRunOptions = function() {
          return (s2._OrtCreateRunOptions = s2.asm.jb).apply(null, arguments);
        }, s2._OrtAddRunConfigEntry = function() {
          return (s2._OrtAddRunConfigEntry = s2.asm.kb).apply(null, arguments);
        }, s2._OrtReleaseRunOptions = function() {
          return (s2._OrtReleaseRunOptions = s2.asm.lb).apply(null, arguments);
        }, s2._OrtRun = function() {
          return (s2._OrtRun = s2.asm.mb).apply(null, arguments);
        }, s2._OrtEndProfiling = function() {
          return (s2._OrtEndProfiling = s2.asm.nb).apply(null, arguments);
        };
        var de2 = s2._pthread_self = function() {
          return (de2 = s2._pthread_self = s2.asm.ob).apply(null, arguments);
        }, he2 = s2._malloc = function() {
          return (he2 = s2._malloc = s2.asm.pb).apply(null, arguments);
        }, ge2 = s2._free = function() {
          return (ge2 = s2._free = s2.asm.qb).apply(null, arguments);
        }, be2 = s2._fflush = function() {
          return (be2 = s2._fflush = s2.asm.rb).apply(null, arguments);
        };
        s2.__emscripten_tls_init = function() {
          return (s2.__emscripten_tls_init = s2.asm.sb).apply(null, arguments);
        };
        var me2 = s2.___funcs_on_exit = function() {
          return (me2 = s2.___funcs_on_exit = s2.asm.tb).apply(null, arguments);
        }, ye2 = s2.__emscripten_thread_init = function() {
          return (ye2 = s2.__emscripten_thread_init = s2.asm.vb).apply(null, arguments);
        };
        s2.__emscripten_thread_crashed = function() {
          return (s2.__emscripten_thread_crashed = s2.asm.wb).apply(null, arguments);
        };
        var _e, ve2 = s2._emscripten_run_in_main_runtime_thread_js = function() {
          return (ve2 = s2._emscripten_run_in_main_runtime_thread_js = s2.asm.xb).apply(null, arguments);
        }, we2 = s2.__emscripten_proxy_execute_task_queue = function() {
          return (we2 = s2.__emscripten_proxy_execute_task_queue = s2.asm.yb).apply(null, arguments);
        }, xe2 = s2.__emscripten_thread_free_data = function() {
          return (xe2 = s2.__emscripten_thread_free_data = s2.asm.zb).apply(null, arguments);
        }, Te2 = s2.__emscripten_thread_exit = function() {
          return (Te2 = s2.__emscripten_thread_exit = s2.asm.Ab).apply(null, arguments);
        }, Se2 = s2._setThrew = function() {
          return (Se2 = s2._setThrew = s2.asm.Bb).apply(null, arguments);
        }, Oe2 = s2._emscripten_stack_set_limits = function() {
          return (Oe2 = s2._emscripten_stack_set_limits = s2.asm.Cb).apply(null, arguments);
        }, Ae2 = s2.stackSave = function() {
          return (Ae2 = s2.stackSave = s2.asm.Db).apply(null, arguments);
        }, Ee2 = s2.stackRestore = function() {
          return (Ee2 = s2.stackRestore = s2.asm.Eb).apply(null, arguments);
        }, Ie2 = s2.stackAlloc = function() {
          return (Ie2 = s2.stackAlloc = s2.asm.Fb).apply(null, arguments);
        }, Pe2 = s2.___cxa_can_catch = function() {
          return (Pe2 = s2.___cxa_can_catch = s2.asm.Gb).apply(null, arguments);
        }, De2 = s2.___cxa_is_pointer_type = function() {
          return (De2 = s2.___cxa_is_pointer_type = s2.asm.Hb).apply(null, arguments);
        }, $e2 = s2.dynCall_j = function() {
          return ($e2 = s2.dynCall_j = s2.asm.Ib).apply(null, arguments);
        }, ke2 = s2.dynCall_iiiiij = function() {
          return (ke2 = s2.dynCall_iiiiij = s2.asm.Jb).apply(null, arguments);
        }, Ce2 = s2.dynCall_jii = function() {
          return (Ce2 = s2.dynCall_jii = s2.asm.Kb).apply(null, arguments);
        }, Fe2 = s2.dynCall_viiiiij = function() {
          return (Fe2 = s2.dynCall_viiiiij = s2.asm.Lb).apply(null, arguments);
        }, Ne2 = s2.dynCall_vjji = function() {
          return (Ne2 = s2.dynCall_vjji = s2.asm.Mb).apply(null, arguments);
        }, Le2 = s2.dynCall_viiijjjii = function() {
          return (Le2 = s2.dynCall_viiijjjii = s2.asm.Nb).apply(null, arguments);
        }, Re2 = s2.dynCall_iij = function() {
          return (Re2 = s2.dynCall_iij = s2.asm.Ob).apply(null, arguments);
        }, je2 = s2.dynCall_ji = function() {
          return (je2 = s2.dynCall_ji = s2.asm.Pb).apply(null, arguments);
        }, Me2 = s2.dynCall_iiiiiij = function() {
          return (Me2 = s2.dynCall_iiiiiij = s2.asm.Qb).apply(null, arguments);
        }, Ue2 = s2.dynCall_iiij = function() {
          return (Ue2 = s2.dynCall_iiij = s2.asm.Rb).apply(null, arguments);
        };
        function Ve2() {
          function t4() {
            if (!_e && (_e = true, s2.calledRun = true, !M2) && (x2 || ht(Y2), u2(s2), s2.onRuntimeInitialized && s2.onRuntimeInitialized(), !x2)) {
              if (s2.postRun) for ("function" == typeof s2.postRun && (s2.postRun = [s2.postRun]); s2.postRun.length; ) {
                var t5 = s2.postRun.shift();
                Z2.unshift(t5);
              }
              ht(Z2);
            }
          }
          if (!(0 < et)) if (x2) u2(s2), x2 || ht(Y2), postMessage({ cmd: "loaded" });
          else {
            if (s2.preRun) for ("function" == typeof s2.preRun && (s2.preRun = [s2.preRun]); s2.preRun.length; ) Q2();
            ht(X2), 0 < et || (s2.setStatus ? (s2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                s2.setStatus("");
              }, 1), t4();
            }, 1)) : t4());
          }
        }
        if (s2.UTF8ToString = B2, s2.stringToUTF8 = function(t4, e4, n3) {
          return z2(t4, r3(), e4, n3);
        }, s2.lengthBytesUTF8 = G2, s2.keepRuntimeAlive = J2, s2.wasmMemory = $2, s2.stackSave = Ae2, s2.stackRestore = Ee2, s2.stackAlloc = Ie2, s2.ExitStatus = ut, s2.PThread = dt, rt = function t4() {
          _e || Ve2(), _e || (rt = t4);
        }, s2.preInit) for ("function" == typeof s2.preInit && (s2.preInit = [s2.preInit]); 0 < s2.preInit.length; ) s2.preInit.pop()();
        return Ve2(), t3.ready;
      });
      t2.exports = r2;
    }, 932: (t2, e2, n2) => {
      var _scriptDir, r2 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t3) {
        var e3, r3, i2;
        t3 = t3 || {}, e3 || (e3 = void 0 !== t3 ? t3 : {}), e3.ready = new Promise(function(t4, e4) {
          r3 = t4, i2 = e4;
        });
        var o2, a2, s2, u2, c2, l2, p2 = Object.assign({}, e3), f2 = "./this.program", d2 = (t4, e4) => {
          throw e4;
        }, h2 = "object" == typeof window, g2 = "function" == typeof importScripts, b2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m2 = "";
        b2 ? (m2 = g2 ? n2(908).dirname(m2) + "/" : "//", l2 = () => {
          c2 || (u2 = n2(1384), c2 = n2(908));
        }, o2 = function(t4, e4) {
          return l2(), t4 = c2.normalize(t4), u2.readFileSync(t4, e4 ? void 0 : "utf8");
        }, s2 = (t4) => ((t4 = o2(t4, true)).buffer || (t4 = new Uint8Array(t4)), t4), a2 = (t4, e4, n3) => {
          l2(), t4 = c2.normalize(t4), u2.readFile(t4, function(t5, r4) {
            t5 ? n3(t5) : e4(r4.buffer);
          });
        }, 1 < process.argv.length && (f2 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t4) {
          if (!(t4 instanceof K2)) throw t4;
        }), process.on("unhandledRejection", function(t4) {
          throw t4;
        }), d2 = (t4, e4) => {
          if (w2 || 0 < U2) throw process.exitCode = t4, e4;
          e4 instanceof K2 || v2("exiting due to exception: " + e4), process.exit(t4);
        }, e3.inspect = function() {
          return "[Emscripten Module object]";
        }) : (h2 || g2) && (g2 ? m2 = self.location.href : "undefined" != typeof document && document.currentScript && (m2 = document.currentScript.src), _scriptDir && (m2 = _scriptDir), m2 = 0 !== m2.indexOf("blob:") ? m2.substr(0, m2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.send(null), e4.responseText;
        }, g2 && (s2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.responseType = "arraybuffer", e4.send(null), new Uint8Array(e4.response);
        }), a2 = (t4, e4, n3) => {
          var r4 = new XMLHttpRequest();
          r4.open("GET", t4, true), r4.responseType = "arraybuffer", r4.onload = () => {
            200 == r4.status || 0 == r4.status && r4.response ? e4(r4.response) : n3();
          }, r4.onerror = n3, r4.send(null);
        });
        var y2, _ = e3.print || console.log.bind(console), v2 = e3.printErr || console.warn.bind(console);
        Object.assign(e3, p2), p2 = null, e3.thisProgram && (f2 = e3.thisProgram), e3.quit && (d2 = e3.quit), e3.wasmBinary && (y2 = e3.wasmBinary);
        var w2 = e3.noExitRuntime || false;
        "object" != typeof WebAssembly && W2("no native wasm support detected");
        var x2, T2, S2, O2, A2, E2, I2 = false, P2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function D2(t4, e4, n3) {
          var r4 = (e4 >>>= 0) + n3;
          for (n3 = e4; t4[n3] && !(n3 >= r4); ) ++n3;
          if (16 < n3 - e4 && t4.buffer && P2) return P2.decode(t4.subarray(e4, n3));
          for (r4 = ""; e4 < n3; ) {
            var i3 = t4[e4++];
            if (128 & i3) {
              var o3 = 63 & t4[e4++];
              if (192 == (224 & i3)) r4 += String.fromCharCode((31 & i3) << 6 | o3);
              else {
                var a3 = 63 & t4[e4++];
                65536 > (i3 = 224 == (240 & i3) ? (15 & i3) << 12 | o3 << 6 | a3 : (7 & i3) << 18 | o3 << 12 | a3 << 6 | 63 & t4[e4++]) ? r4 += String.fromCharCode(i3) : (i3 -= 65536, r4 += String.fromCharCode(55296 | i3 >> 10, 56320 | 1023 & i3));
              }
            } else r4 += String.fromCharCode(i3);
          }
          return r4;
        }
        function $2(t4, e4) {
          return (t4 >>>= 0) ? D2(O2, t4, e4) : "";
        }
        function k2(t4, e4, n3, r4) {
          if (!(0 < r4)) return 0;
          var i3 = n3 >>>= 0;
          r4 = n3 + r4 - 1;
          for (var o3 = 0; o3 < t4.length; ++o3) {
            var a3 = t4.charCodeAt(o3);
            if (55296 <= a3 && 57343 >= a3 && (a3 = 65536 + ((1023 & a3) << 10) | 1023 & t4.charCodeAt(++o3)), 127 >= a3) {
              if (n3 >= r4) break;
              e4[n3++ >>> 0] = a3;
            } else {
              if (2047 >= a3) {
                if (n3 + 1 >= r4) break;
                e4[n3++ >>> 0] = 192 | a3 >> 6;
              } else {
                if (65535 >= a3) {
                  if (n3 + 2 >= r4) break;
                  e4[n3++ >>> 0] = 224 | a3 >> 12;
                } else {
                  if (n3 + 3 >= r4) break;
                  e4[n3++ >>> 0] = 240 | a3 >> 18, e4[n3++ >>> 0] = 128 | a3 >> 12 & 63;
                }
                e4[n3++ >>> 0] = 128 | a3 >> 6 & 63;
              }
              e4[n3++ >>> 0] = 128 | 63 & a3;
            }
          }
          return e4[n3 >>> 0] = 0, n3 - i3;
        }
        function C2(t4) {
          for (var e4 = 0, n3 = 0; n3 < t4.length; ++n3) {
            var r4 = t4.charCodeAt(n3);
            127 >= r4 ? e4++ : 2047 >= r4 ? e4 += 2 : 55296 <= r4 && 57343 >= r4 ? (e4 += 4, ++n3) : e4 += 3;
          }
          return e4;
        }
        function F2() {
          var t4 = x2.buffer;
          T2 = t4, e3.HEAP8 = S2 = new Int8Array(t4), e3.HEAP16 = new Int16Array(t4), e3.HEAP32 = A2 = new Int32Array(t4), e3.HEAPU8 = O2 = new Uint8Array(t4), e3.HEAPU16 = new Uint16Array(t4), e3.HEAPU32 = E2 = new Uint32Array(t4), e3.HEAPF32 = new Float32Array(t4), e3.HEAPF64 = new Float64Array(t4);
        }
        var N2, L2 = [], R2 = [], j2 = [], M2 = [], U2 = 0;
        function V2() {
          var t4 = e3.preRun.shift();
          L2.unshift(t4);
        }
        var B2, z2 = 0, H2 = null;
        function W2(t4) {
          throw e3.onAbort && e3.onAbort(t4), v2(t4 = "Aborted(" + t4 + ")"), I2 = true, t4 = new WebAssembly.RuntimeError(t4 + ". Build with -sASSERTIONS for more info."), i2(t4), t4;
        }
        function q2() {
          return B2.startsWith("data:application/octet-stream;base64,");
        }
        if (B2 = "ort-wasm.wasm", !q2()) {
          var X2 = B2;
          B2 = e3.locateFile ? e3.locateFile(X2, m2) : m2 + X2;
        }
        function Y2() {
          var t4 = B2;
          try {
            if (t4 == B2 && y2) return new Uint8Array(y2);
            if (s2) return s2(t4);
            throw "both async and sync fetching of the wasm failed";
          } catch (t5) {
            W2(t5);
          }
        }
        function K2(t4) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + t4 + ")", this.status = t4;
        }
        function Z2(t4) {
          for (; 0 < t4.length; ) t4.shift()(e3);
        }
        var J2 = [], Q2 = 0, tt = 0;
        function et(t4) {
          this.Db = t4, this.zb = t4 - 24, this.Ub = function(t5) {
            E2[this.zb + 4 >> 2 >>> 0] = t5;
          }, this.Eb = function() {
            return E2[this.zb + 4 >> 2 >>> 0];
          }, this.Sb = function(t5) {
            E2[this.zb + 8 >> 2 >>> 0] = t5;
          }, this.Wb = function() {
            return E2[this.zb + 8 >> 2 >>> 0];
          }, this.Tb = function() {
            A2[this.zb >> 2 >>> 0] = 0;
          }, this.Ib = function(t5) {
            S2[this.zb + 12 >> 0 >>> 0] = t5 ? 1 : 0;
          }, this.Pb = function() {
            return 0 != S2[this.zb + 12 >> 0 >>> 0];
          }, this.Jb = function(t5) {
            S2[this.zb + 13 >> 0 >>> 0] = t5 ? 1 : 0;
          }, this.Lb = function() {
            return 0 != S2[this.zb + 13 >> 0 >>> 0];
          }, this.Rb = function(t5, e4) {
            this.Fb(0), this.Ub(t5), this.Sb(e4), this.Tb(), this.Ib(false), this.Jb(false);
          }, this.Nb = function() {
            A2[this.zb >> 2 >>> 0] += 1;
          }, this.Xb = function() {
            var t5 = A2[this.zb >> 2 >>> 0];
            return A2[this.zb >> 2 >>> 0] = t5 - 1, 1 === t5;
          }, this.Fb = function(t5) {
            E2[this.zb + 16 >> 2 >>> 0] = t5;
          }, this.Ob = function() {
            return E2[this.zb + 16 >> 2 >>> 0];
          }, this.Qb = function() {
            if (Et(this.Eb())) return E2[this.Db >> 2 >>> 0];
            var t5 = this.Ob();
            return 0 !== t5 ? t5 : this.Db;
          };
        }
        function nt(t4) {
          return _t(new et(t4).zb);
        }
        var rt = [];
        function it(t4) {
          var e4 = rt[t4];
          return e4 || (t4 >= rt.length && (rt.length = t4 + 1), rt[t4] = e4 = N2.get(t4)), e4;
        }
        function ot(t4) {
          var e4 = C2(t4) + 1, n3 = yt(e4);
          return n3 && k2(t4, S2, n3, e4), n3;
        }
        var at = {};
        function st() {
          if (!ut) {
            var t4, e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: f2 || "./this.program" };
            for (t4 in at) void 0 === at[t4] ? delete e4[t4] : e4[t4] = at[t4];
            var n3 = [];
            for (t4 in e4) n3.push(t4 + "=" + e4[t4]);
            ut = n3;
          }
          return ut;
        }
        var ut, ct = [null, [], []];
        function lt(t4, e4) {
          var n3 = ct[t4];
          0 === e4 || 10 === e4 ? ((1 === t4 ? _ : v2)(D2(n3, 0)), n3.length = 0) : n3.push(e4);
        }
        var pt2 = 0;
        function ft(t4) {
          return 0 == t4 % 4 && (0 != t4 % 100 || 0 == t4 % 400);
        }
        var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function gt(t4, e4, n3, r4) {
          function i3(t5, e5, n4) {
            for (t5 = "number" == typeof t5 ? t5.toString() : t5 || ""; t5.length < e5; ) t5 = n4[0] + t5;
            return t5;
          }
          function o3(t5, e5) {
            return i3(t5, e5, "0");
          }
          function a3(t5, e5) {
            function n4(t6) {
              return 0 > t6 ? -1 : 0 < t6 ? 1 : 0;
            }
            var r5;
            return 0 === (r5 = n4(t5.getFullYear() - e5.getFullYear())) && 0 === (r5 = n4(t5.getMonth() - e5.getMonth())) && (r5 = n4(t5.getDate() - e5.getDate())), r5;
          }
          function s3(t5) {
            switch (t5.getDay()) {
              case 0:
                return new Date(t5.getFullYear() - 1, 11, 29);
              case 1:
                return t5;
              case 2:
                return new Date(t5.getFullYear(), 0, 3);
              case 3:
                return new Date(t5.getFullYear(), 0, 2);
              case 4:
                return new Date(t5.getFullYear(), 0, 1);
              case 5:
                return new Date(t5.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(t5.getFullYear() - 1, 11, 30);
            }
          }
          function u3(t5) {
            var e5 = t5.Bb;
            for (t5 = new Date(new Date(t5.Cb + 1900, 0, 1).getTime()); 0 < e5; ) {
              var n4 = t5.getMonth(), r5 = (ft(t5.getFullYear()) ? dt : ht)[n4];
              if (!(e5 > r5 - t5.getDate())) {
                t5.setDate(t5.getDate() + e5);
                break;
              }
              e5 -= r5 - t5.getDate() + 1, t5.setDate(1), 11 > n4 ? t5.setMonth(n4 + 1) : (t5.setMonth(0), t5.setFullYear(t5.getFullYear() + 1));
            }
            return n4 = new Date(t5.getFullYear() + 1, 0, 4), e5 = s3(new Date(t5.getFullYear(), 0, 4)), n4 = s3(n4), 0 >= a3(e5, t5) ? 0 >= a3(n4, t5) ? t5.getFullYear() + 1 : t5.getFullYear() : t5.getFullYear() - 1;
          }
          var c3 = A2[r4 + 40 >> 2 >>> 0];
          for (var l3 in r4 = { $b: A2[r4 >> 2 >>> 0], Zb: A2[r4 + 4 >> 2 >>> 0], Gb: A2[r4 + 8 >> 2 >>> 0], Kb: A2[r4 + 12 >> 2 >>> 0], Hb: A2[r4 + 16 >> 2 >>> 0], Cb: A2[r4 + 20 >> 2 >>> 0], Ab: A2[r4 + 24 >> 2 >>> 0], Bb: A2[r4 + 28 >> 2 >>> 0], bc: A2[r4 + 32 >> 2 >>> 0], Yb: A2[r4 + 36 >> 2 >>> 0], ac: c3 ? $2(c3) : "" }, n3 = $2(n3), c3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) n3 = n3.replace(new RegExp(l3, "g"), c3[l3]);
          var p3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f3 = "January February March April May June July August September October November December".split(" ");
          for (l3 in c3 = { "%a": function(t5) {
            return p3[t5.Ab].substring(0, 3);
          }, "%A": function(t5) {
            return p3[t5.Ab];
          }, "%b": function(t5) {
            return f3[t5.Hb].substring(0, 3);
          }, "%B": function(t5) {
            return f3[t5.Hb];
          }, "%C": function(t5) {
            return o3((t5.Cb + 1900) / 100 | 0, 2);
          }, "%d": function(t5) {
            return o3(t5.Kb, 2);
          }, "%e": function(t5) {
            return i3(t5.Kb, 2, " ");
          }, "%g": function(t5) {
            return u3(t5).toString().substring(2);
          }, "%G": function(t5) {
            return u3(t5);
          }, "%H": function(t5) {
            return o3(t5.Gb, 2);
          }, "%I": function(t5) {
            return 0 == (t5 = t5.Gb) ? t5 = 12 : 12 < t5 && (t5 -= 12), o3(t5, 2);
          }, "%j": function(t5) {
            for (var e5 = 0, n4 = 0; n4 <= t5.Hb - 1; e5 += (ft(t5.Cb + 1900) ? dt : ht)[n4++]) ;
            return o3(t5.Kb + e5, 3);
          }, "%m": function(t5) {
            return o3(t5.Hb + 1, 2);
          }, "%M": function(t5) {
            return o3(t5.Zb, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(t5) {
            return 0 <= t5.Gb && 12 > t5.Gb ? "AM" : "PM";
          }, "%S": function(t5) {
            return o3(t5.$b, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(t5) {
            return t5.Ab || 7;
          }, "%U": function(t5) {
            return o3(Math.floor((t5.Bb + 7 - t5.Ab) / 7), 2);
          }, "%V": function(t5) {
            var e5 = Math.floor((t5.Bb + 7 - (t5.Ab + 6) % 7) / 7);
            if (2 >= (t5.Ab + 371 - t5.Bb - 2) % 7 && e5++, e5) 53 == e5 && (4 == (n4 = (t5.Ab + 371 - t5.Bb) % 7) || 3 == n4 && ft(t5.Cb) || (e5 = 1));
            else {
              e5 = 52;
              var n4 = (t5.Ab + 7 - t5.Bb - 1) % 7;
              (4 == n4 || 5 == n4 && ft(t5.Cb % 400 - 1)) && e5++;
            }
            return o3(e5, 2);
          }, "%w": function(t5) {
            return t5.Ab;
          }, "%W": function(t5) {
            return o3(Math.floor((t5.Bb + 7 - (t5.Ab + 6) % 7) / 7), 2);
          }, "%y": function(t5) {
            return (t5.Cb + 1900).toString().substring(2);
          }, "%Y": function(t5) {
            return t5.Cb + 1900;
          }, "%z": function(t5) {
            var e5 = 0 <= (t5 = t5.Yb);
            return t5 = Math.abs(t5) / 60, (e5 ? "+" : "-") + String("0000" + (t5 / 60 * 100 + t5 % 60)).slice(-4);
          }, "%Z": function(t5) {
            return t5.ac;
          }, "%%": function() {
            return "%";
          } }, n3 = n3.replace(/%%/g, "\0\0"), c3) n3.includes(l3) && (n3 = n3.replace(new RegExp(l3, "g"), c3[l3](r4)));
          return l3 = function(t5) {
            var e5 = Array(C2(t5) + 1);
            return k2(t5, e5, 0, e5.length), e5;
          }(n3 = n3.replace(/\0\0/g, "%")), l3.length > e4 ? 0 : (S2.set(l3, t4 >>> 0), l3.length - 1);
        }
        var bt = { a: function(t4) {
          return yt(t4 + 24) + 24;
        }, m: function(t4) {
          return (t4 = new et(t4)).Pb() || (t4.Ib(true), Q2--), t4.Jb(false), J2.push(t4), t4.Nb(), t4.Qb();
        }, ia: function(t4) {
          throw v2("Unexpected exception thrown, this is not properly supported - aborting"), I2 = true, t4;
        }, w: function() {
          xt(0);
          var t4 = J2.pop();
          if (t4.Xb() && !t4.Lb()) {
            var e4 = t4.Wb();
            e4 && it(e4)(t4.Db), nt(t4.Db);
          }
          tt = 0;
        }, d: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (At(o3, n3, e4.zb + 16)) return pt2 = o3, t4;
          }
          return pt2 = n3, t4;
        }, k: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (At(o3, n3, e4.zb + 16)) return pt2 = o3, t4;
          }
          return pt2 = n3, t4;
        }, g: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i3 = 0; i3 < r4.length; i3++) {
            var o3 = r4[i3];
            if (0 === o3 || o3 === n3) break;
            if (At(o3, n3, e4.zb + 16)) return pt2 = o3, t4;
          }
          return pt2 = n3, t4;
        }, s: nt, L: function() {
          var t4 = J2.pop();
          t4 || W2("no exception to throw");
          var e4 = t4.Db;
          throw t4.Lb() || (J2.push(t4), t4.Jb(true), t4.Ib(false), Q2++), tt = e4, e4;
        }, b: function(t4, e4, n3) {
          throw new et(t4).Rb(e4, n3), tt = t4, Q2++, t4;
        }, la: function() {
          return Q2;
        }, i: function(t4) {
          throw tt || (tt = t4), t4;
        }, H: function() {
          return 0;
        }, Ba: function() {
        }, pa: function() {
        }, ra: function() {
        }, ka: function() {
          return 0;
        }, za: function() {
        }, ua: function() {
        }, ya: function() {
        }, R: function() {
        }, qa: function() {
        }, na: function() {
        }, Aa: function() {
        }, oa: function() {
        }, Ha: function() {
        }, Ja: function() {
          W2("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, Ia: function() {
          W2("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, S: function() {
          return Date.now();
        }, Ca: function() {
          return true;
        }, Da: function(t4, e4) {
          t4 = new Date(1e3 * (E2[t4 >>> 2] + 4294967296 * A2[t4 + 4 >>> 2])), A2[e4 >> 2 >>> 0] = t4.getUTCSeconds(), A2[e4 + 4 >> 2 >>> 0] = t4.getUTCMinutes(), A2[e4 + 8 >> 2 >>> 0] = t4.getUTCHours(), A2[e4 + 12 >> 2 >>> 0] = t4.getUTCDate(), A2[e4 + 16 >> 2 >>> 0] = t4.getUTCMonth(), A2[e4 + 20 >> 2 >>> 0] = t4.getUTCFullYear() - 1900, A2[e4 + 24 >> 2 >>> 0] = t4.getUTCDay(), A2[e4 + 28 >> 2 >>> 0] = (t4.getTime() - Date.UTC(t4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
        }, Ea: function(t4, e4) {
          t4 = new Date(1e3 * (E2[t4 >>> 2] + 4294967296 * A2[t4 + 4 >>> 2])), A2[e4 >> 2 >>> 0] = t4.getSeconds(), A2[e4 + 4 >> 2 >>> 0] = t4.getMinutes(), A2[e4 + 8 >> 2 >>> 0] = t4.getHours(), A2[e4 + 12 >> 2 >>> 0] = t4.getDate(), A2[e4 + 16 >> 2 >>> 0] = t4.getMonth(), A2[e4 + 20 >> 2 >>> 0] = t4.getFullYear() - 1900, A2[e4 + 24 >> 2 >>> 0] = t4.getDay();
          var n3 = new Date(t4.getFullYear(), 0, 1);
          A2[e4 + 28 >> 2 >>> 0] = (t4.getTime() - n3.getTime()) / 864e5 | 0, A2[e4 + 36 >> 2 >>> 0] = -60 * t4.getTimezoneOffset();
          var r4 = new Date(t4.getFullYear(), 6, 1).getTimezoneOffset();
          n3 = n3.getTimezoneOffset(), A2[e4 + 32 >> 2 >>> 0] = 0 | (r4 != n3 && t4.getTimezoneOffset() == Math.min(n3, r4));
        }, Fa: function(t4) {
          var e4 = new Date(A2[t4 + 20 >> 2 >>> 0] + 1900, A2[t4 + 16 >> 2 >>> 0], A2[t4 + 12 >> 2 >>> 0], A2[t4 + 8 >> 2 >>> 0], A2[t4 + 4 >> 2 >>> 0], A2[t4 >> 2 >>> 0], 0), n3 = A2[t4 + 32 >> 2 >>> 0], r4 = e4.getTimezoneOffset(), i3 = new Date(e4.getFullYear(), 0, 1), o3 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset(), a3 = i3.getTimezoneOffset(), s3 = Math.min(a3, o3);
          return 0 > n3 ? A2[t4 + 32 >> 2 >>> 0] = Number(o3 != a3 && s3 == r4) : 0 < n3 != (s3 == r4) && (o3 = Math.max(a3, o3), e4.setTime(e4.getTime() + 6e4 * ((0 < n3 ? s3 : o3) - r4))), A2[t4 + 24 >> 2 >>> 0] = e4.getDay(), A2[t4 + 28 >> 2 >>> 0] = (e4.getTime() - i3.getTime()) / 864e5 | 0, A2[t4 >> 2 >>> 0] = e4.getSeconds(), A2[t4 + 4 >> 2 >>> 0] = e4.getMinutes(), A2[t4 + 8 >> 2 >>> 0] = e4.getHours(), A2[t4 + 12 >> 2 >>> 0] = e4.getDate(), A2[t4 + 16 >> 2 >>> 0] = e4.getMonth(), e4.getTime() / 1e3 | 0;
        }, sa: function() {
          return -52;
        }, ta: function() {
        }, Ga: function t4(e4, n3, r4) {
          t4.Vb || (t4.Vb = true, function(t5, e5, n4) {
            function r5(t6) {
              return (t6 = t6.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t6[1] : "GMT";
            }
            var i3 = (/* @__PURE__ */ new Date()).getFullYear(), o3 = new Date(i3, 0, 1), a3 = new Date(i3, 6, 1);
            i3 = o3.getTimezoneOffset();
            var s3 = a3.getTimezoneOffset();
            A2[t5 >> 2 >>> 0] = 60 * Math.max(i3, s3), A2[e5 >> 2 >>> 0] = Number(i3 != s3), t5 = r5(o3), e5 = r5(a3), t5 = ot(t5), e5 = ot(e5), s3 < i3 ? (E2[n4 >> 2 >>> 0] = t5, E2[n4 + 4 >> 2 >>> 0] = e5) : (E2[n4 >> 2 >>> 0] = e5, E2[n4 + 4 >> 2 >>> 0] = t5);
          }(e4, n3, r4));
        }, B: function() {
          W2("");
        }, ma: function() {
          return 4294901760;
        }, I: b2 ? () => {
          var t4 = process.hrtime();
          return 1e3 * t4[0] + t4[1] / 1e6;
        } : () => performance.now(), xa: function(t4, e4, n3) {
          O2.copyWithin(t4 >>> 0, e4 >>> 0, e4 + n3 >>> 0);
        }, G: function(t4) {
          var e4 = O2.length;
          if (4294901760 < (t4 >>>= 0)) return false;
          for (var n3 = 1; 4 >= n3; n3 *= 2) {
            var r4 = e4 * (1 + 0.2 / n3);
            r4 = Math.min(r4, t4 + 100663296);
            var i3 = Math;
            r4 = Math.max(t4, r4), i3 = i3.min.call(i3, 4294901760, r4 + (65536 - r4 % 65536) % 65536);
            t: {
              try {
                x2.grow(i3 - T2.byteLength + 65535 >>> 16), F2();
                var o3 = 1;
                break t;
              } catch (t5) {
              }
              o3 = void 0;
            }
            if (o3) return true;
          }
          return false;
        }, va: function(t4, e4) {
          var n3 = 0;
          return st().forEach(function(r4, i3) {
            var o3 = e4 + n3;
            for (i3 = E2[t4 + 4 * i3 >> 2 >>> 0] = o3, o3 = 0; o3 < r4.length; ++o3) S2[i3++ >> 0 >>> 0] = r4.charCodeAt(o3);
            S2[i3 >> 0 >>> 0] = 0, n3 += r4.length + 1;
          }), 0;
        }, wa: function(t4, e4) {
          var n3 = st();
          E2[t4 >> 2 >>> 0] = n3.length;
          var r4 = 0;
          return n3.forEach(function(t5) {
            r4 += t5.length + 1;
          }), E2[e4 >> 2 >>> 0] = r4, 0;
        }, ba: function(t4) {
          w2 || 0 < U2 || (wt(), Z2(j2), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w2 || 0 < U2 || (e3.onExit && e3.onExit(t4), I2 = true), d2(t4, new K2(t4));
        }, E: function() {
          return 52;
        }, Q: function() {
          return 52;
        }, ca: function() {
          return 70;
        }, P: function(t4, e4, n3, r4) {
          for (var i3 = 0, o3 = 0; o3 < n3; o3++) {
            var a3 = E2[e4 >> 2 >>> 0], s3 = E2[e4 + 4 >> 2 >>> 0];
            e4 += 8;
            for (var u3 = 0; u3 < s3; u3++) lt(t4, O2[a3 + u3 >>> 0]);
            i3 += s3;
          }
          return E2[r4 >> 2 >>> 0] = i3, 0;
        }, c: function() {
          return pt2;
        }, ja: function t4(e4, r4) {
          t4.Mb || (t4.Mb = function() {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
              var t5 = new Uint8Array(1);
              return () => (crypto.getRandomValues(t5), t5[0]);
            }
            if (b2) try {
              var e5 = n2(Object(function() {
                var t6 = new Error("Cannot find module 'crypto'");
                throw t6.code = "MODULE_NOT_FOUND", t6;
              }()));
              return () => e5.randomBytes(1)[0];
            } catch (t6) {
            }
            return () => W2("randomDevice");
          }());
          for (var i3 = 0; i3 < r4; i3++) S2[e4 + i3 >> 0 >>> 0] = t4.Mb();
          return 0;
        }, ea: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, fa: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, J: function(t4) {
          var e4 = Tt();
          try {
            return it(t4)();
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, e: function(t4, e4) {
          var n3 = Tt();
          try {
            return it(t4)(e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, N: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, O: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, j: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, o: function(t4, e4, n3, r4) {
          var i3 = Tt();
          try {
            return it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, p: function(t4, e4, n3, r4, i3) {
          var o3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3);
          } catch (t5) {
            if (St(o3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, M: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (St(a3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, r: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (St(a3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, v: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (St(s3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, K: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, D: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3) {
          var f3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3);
          } catch (t5) {
            if (St(f3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, X: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Tt();
          try {
            return Lt(t4, e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, V: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Tt();
          try {
            return Pt(t4, e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (St(s3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, U: function(t4, e4, n3, r4, i3) {
          var o3 = Tt();
          try {
            return Rt(t4, e4, n3, r4, i3);
          } catch (t5) {
            if (St(o3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, Z: function(t4, e4, n3, r4) {
          var i3 = Tt();
          try {
            return Ft(t4, e4, n3, r4);
          } catch (t5) {
            if (St(i3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, W: function(t4) {
          var e4 = Tt();
          try {
            return It(t4);
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, Y: function(t4, e4) {
          var n3 = Tt();
          try {
            return Nt(t4, e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, T: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return Dt(t4, e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, f: function(t4) {
          var e4 = Tt();
          try {
            it(t4)();
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, q: function(t4, e4) {
          var n3 = Tt();
          try {
            it(t4)(e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, h: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, da: function(t4, e4, n3, r4) {
          var i3 = Tt();
          try {
            it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, l: function(t4, e4, n3, r4) {
          var i3 = Tt();
          try {
            it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, t: function(t4, e4, n3, r4, i3) {
          var o3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3);
          } catch (t5) {
            if (St(o3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, u: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3);
          } catch (t5) {
            if (St(a3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, x: function(t4, e4, n3, r4, i3, o3, a3) {
          var s3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3, a3);
          } catch (t5) {
            if (St(s3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, z: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, ga: function(t4, e4, n3, r4, i3, o3, a3, s3, u3) {
          var c3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3, a3, s3, u3);
          } catch (t5) {
            if (St(c3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, A: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3) {
          var p3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3);
          } catch (t5) {
            if (St(p3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, C: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3, f3, d3, h3, g3) {
          var b3 = Tt();
          try {
            it(t4)(e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3, f3, d3, h3, g3);
          } catch (t5) {
            if (St(b3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, aa: function(t4, e4, n3, r4, i3, o3, a3, s3) {
          var u3 = Tt();
          try {
            $t(t4, e4, n3, r4, i3, o3, a3, s3);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, _: function(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3) {
          var f3 = Tt();
          try {
            Ct(t4, e4, n3, r4, i3, o3, a3, s3, u3, c3, l3, p3);
          } catch (t5) {
            if (St(f3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, $: function(t4, e4, n3, r4, i3, o3) {
          var a3 = Tt();
          try {
            kt(t4, e4, n3, r4, i3, o3);
          } catch (t5) {
            if (St(a3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, n: function(t4) {
          return t4;
        }, F: function(t4) {
          pt2 = t4;
        }, ha: gt, y: function(t4, e4, n3, r4) {
          return gt(t4, e4, n3, r4);
        } };
        !function() {
          function t4(t5) {
            e3.asm = t5.exports, x2 = e3.asm.Ka, F2(), N2 = e3.asm.ib, R2.unshift(e3.asm.La), z2--, e3.monitorRunDependencies && e3.monitorRunDependencies(z2), 0 == z2 && (H2 && (t5 = H2, H2 = null, t5()));
          }
          function n3(e4) {
            t4(e4.instance);
          }
          function r4(t5) {
            return function() {
              if (!y2 && (h2 || g2)) {
                if ("function" == typeof fetch && !B2.startsWith("file://")) return fetch(B2, { credentials: "same-origin" }).then(function(t6) {
                  if (!t6.ok) throw "failed to load wasm binary file at '" + B2 + "'";
                  return t6.arrayBuffer();
                }).catch(function() {
                  return Y2();
                });
                if (a2) return new Promise(function(t6, e4) {
                  a2(B2, function(e5) {
                    t6(new Uint8Array(e5));
                  }, e4);
                });
              }
              return Promise.resolve().then(function() {
                return Y2();
              });
            }().then(function(t6) {
              return WebAssembly.instantiate(t6, o3);
            }).then(function(t6) {
              return t6;
            }).then(t5, function(t6) {
              v2("failed to asynchronously prepare wasm: " + t6), W2(t6);
            });
          }
          var o3 = { a: bt };
          if (z2++, e3.monitorRunDependencies && e3.monitorRunDependencies(z2), e3.instantiateWasm) try {
            return e3.instantiateWasm(o3, t4);
          } catch (t5) {
            return v2("Module.instantiateWasm callback failed with error: " + t5), false;
          }
          (y2 || "function" != typeof WebAssembly.instantiateStreaming || q2() || B2.startsWith("file://") || b2 || "function" != typeof fetch ? r4(n3) : fetch(B2, { credentials: "same-origin" }).then(function(t5) {
            return WebAssembly.instantiateStreaming(t5, o3).then(n3, function(t6) {
              return v2("wasm streaming compile failed: " + t6), v2("falling back to ArrayBuffer instantiation"), r4(n3);
            });
          })).catch(i2);
        }(), e3.___wasm_call_ctors = function() {
          return (e3.___wasm_call_ctors = e3.asm.La).apply(null, arguments);
        }, e3._OrtInit = function() {
          return (e3._OrtInit = e3.asm.Ma).apply(null, arguments);
        }, e3._OrtCreateSessionOptions = function() {
          return (e3._OrtCreateSessionOptions = e3.asm.Na).apply(null, arguments);
        }, e3._OrtAppendExecutionProvider = function() {
          return (e3._OrtAppendExecutionProvider = e3.asm.Oa).apply(null, arguments);
        }, e3._OrtAddSessionConfigEntry = function() {
          return (e3._OrtAddSessionConfigEntry = e3.asm.Pa).apply(null, arguments);
        }, e3._OrtReleaseSessionOptions = function() {
          return (e3._OrtReleaseSessionOptions = e3.asm.Qa).apply(null, arguments);
        }, e3._OrtCreateSession = function() {
          return (e3._OrtCreateSession = e3.asm.Ra).apply(null, arguments);
        }, e3._OrtReleaseSession = function() {
          return (e3._OrtReleaseSession = e3.asm.Sa).apply(null, arguments);
        }, e3._OrtGetInputCount = function() {
          return (e3._OrtGetInputCount = e3.asm.Ta).apply(null, arguments);
        }, e3._OrtGetOutputCount = function() {
          return (e3._OrtGetOutputCount = e3.asm.Ua).apply(null, arguments);
        }, e3._OrtGetInputName = function() {
          return (e3._OrtGetInputName = e3.asm.Va).apply(null, arguments);
        }, e3._OrtGetOutputName = function() {
          return (e3._OrtGetOutputName = e3.asm.Wa).apply(null, arguments);
        }, e3._OrtFree = function() {
          return (e3._OrtFree = e3.asm.Xa).apply(null, arguments);
        }, e3._OrtCreateTensor = function() {
          return (e3._OrtCreateTensor = e3.asm.Ya).apply(null, arguments);
        }, e3._OrtGetTensorData = function() {
          return (e3._OrtGetTensorData = e3.asm.Za).apply(null, arguments);
        }, e3._OrtReleaseTensor = function() {
          return (e3._OrtReleaseTensor = e3.asm._a).apply(null, arguments);
        }, e3._OrtCreateRunOptions = function() {
          return (e3._OrtCreateRunOptions = e3.asm.$a).apply(null, arguments);
        }, e3._OrtAddRunConfigEntry = function() {
          return (e3._OrtAddRunConfigEntry = e3.asm.ab).apply(null, arguments);
        }, e3._OrtReleaseRunOptions = function() {
          return (e3._OrtReleaseRunOptions = e3.asm.bb).apply(null, arguments);
        }, e3._OrtRun = function() {
          return (e3._OrtRun = e3.asm.cb).apply(null, arguments);
        }, e3._OrtEndProfiling = function() {
          return (e3._OrtEndProfiling = e3.asm.db).apply(null, arguments);
        };
        var mt, yt = e3._malloc = function() {
          return (yt = e3._malloc = e3.asm.eb).apply(null, arguments);
        }, _t = e3._free = function() {
          return (_t = e3._free = e3.asm.fb).apply(null, arguments);
        }, vt = e3._fflush = function() {
          return (vt = e3._fflush = e3.asm.gb).apply(null, arguments);
        }, wt = e3.___funcs_on_exit = function() {
          return (wt = e3.___funcs_on_exit = e3.asm.hb).apply(null, arguments);
        }, xt = e3._setThrew = function() {
          return (xt = e3._setThrew = e3.asm.jb).apply(null, arguments);
        }, Tt = e3.stackSave = function() {
          return (Tt = e3.stackSave = e3.asm.kb).apply(null, arguments);
        }, St = e3.stackRestore = function() {
          return (St = e3.stackRestore = e3.asm.lb).apply(null, arguments);
        }, Ot = e3.stackAlloc = function() {
          return (Ot = e3.stackAlloc = e3.asm.mb).apply(null, arguments);
        }, At = e3.___cxa_can_catch = function() {
          return (At = e3.___cxa_can_catch = e3.asm.nb).apply(null, arguments);
        }, Et = e3.___cxa_is_pointer_type = function() {
          return (Et = e3.___cxa_is_pointer_type = e3.asm.ob).apply(null, arguments);
        }, It = e3.dynCall_j = function() {
          return (It = e3.dynCall_j = e3.asm.pb).apply(null, arguments);
        }, Pt = e3.dynCall_iiiiij = function() {
          return (Pt = e3.dynCall_iiiiij = e3.asm.qb).apply(null, arguments);
        }, Dt = e3.dynCall_jii = function() {
          return (Dt = e3.dynCall_jii = e3.asm.rb).apply(null, arguments);
        }, $t = e3.dynCall_viiiiij = function() {
          return ($t = e3.dynCall_viiiiij = e3.asm.sb).apply(null, arguments);
        }, kt = e3.dynCall_vjji = function() {
          return (kt = e3.dynCall_vjji = e3.asm.tb).apply(null, arguments);
        }, Ct = e3.dynCall_viiijjjii = function() {
          return (Ct = e3.dynCall_viiijjjii = e3.asm.ub).apply(null, arguments);
        }, Ft = e3.dynCall_iij = function() {
          return (Ft = e3.dynCall_iij = e3.asm.vb).apply(null, arguments);
        }, Nt = e3.dynCall_ji = function() {
          return (Nt = e3.dynCall_ji = e3.asm.wb).apply(null, arguments);
        }, Lt = e3.dynCall_iiiiiij = function() {
          return (Lt = e3.dynCall_iiiiiij = e3.asm.xb).apply(null, arguments);
        }, Rt = e3.dynCall_iiij = function() {
          return (Rt = e3.dynCall_iiij = e3.asm.yb).apply(null, arguments);
        };
        function jt() {
          function t4() {
            if (!mt && (mt = true, e3.calledRun = true, !I2)) {
              if (Z2(R2), r3(e3), e3.onRuntimeInitialized && e3.onRuntimeInitialized(), e3.postRun) for ("function" == typeof e3.postRun && (e3.postRun = [e3.postRun]); e3.postRun.length; ) {
                var t5 = e3.postRun.shift();
                M2.unshift(t5);
              }
              Z2(M2);
            }
          }
          if (!(0 < z2)) {
            if (e3.preRun) for ("function" == typeof e3.preRun && (e3.preRun = [e3.preRun]); e3.preRun.length; ) V2();
            Z2(L2), 0 < z2 || (e3.setStatus ? (e3.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                e3.setStatus("");
              }, 1), t4();
            }, 1)) : t4());
          }
        }
        if (e3.UTF8ToString = $2, e3.stringToUTF8 = function(t4, e4, n3) {
          return k2(t4, O2, e4, n3);
        }, e3.lengthBytesUTF8 = C2, e3.stackSave = Tt, e3.stackRestore = St, e3.stackAlloc = Ot, H2 = function t4() {
          mt || jt(), mt || (H2 = t4);
        }, e3.preInit) for ("function" == typeof e3.preInit && (e3.preInit = [e3.preInit]); 0 < e3.preInit.length; ) e3.preInit.pop()();
        return jt(), t3.ready;
      });
      t2.exports = r2;
    }, 4537: (t2) => {
      t2.exports = function(t3, e2) {
        for (var n2 = new Array(arguments.length - 1), r2 = 0, i2 = 2, o2 = true; i2 < arguments.length; ) n2[r2++] = arguments[i2++];
        return new Promise(function(i3, a2) {
          n2[r2] = function(t4) {
            if (o2) if (o2 = false, t4) a2(t4);
            else {
              for (var e3 = new Array(arguments.length - 1), n3 = 0; n3 < e3.length; ) e3[n3++] = arguments[n3];
              i3.apply(null, e3);
            }
          };
          try {
            t3.apply(e2 || null, n2);
          } catch (t4) {
            o2 && (o2 = false, a2(t4));
          }
        });
      };
    }, 7419: (t2, e2) => {
      var n2 = e2;
      n2.length = function(t3) {
        var e3 = t3.length;
        if (!e3) return 0;
        for (var n3 = 0; --e3 % 4 > 1 && "=" === t3.charAt(e3); ) ++n3;
        return Math.ceil(3 * t3.length) / 4 - n3;
      };
      for (var r2 = new Array(64), i2 = new Array(123), o2 = 0; o2 < 64; ) i2[r2[o2] = o2 < 26 ? o2 + 65 : o2 < 52 ? o2 + 71 : o2 < 62 ? o2 - 4 : o2 - 59 | 43] = o2++;
      n2.encode = function(t3, e3, n3) {
        for (var i3, o3 = null, a3 = [], s2 = 0, u2 = 0; e3 < n3; ) {
          var c2 = t3[e3++];
          switch (u2) {
            case 0:
              a3[s2++] = r2[c2 >> 2], i3 = (3 & c2) << 4, u2 = 1;
              break;
            case 1:
              a3[s2++] = r2[i3 | c2 >> 4], i3 = (15 & c2) << 2, u2 = 2;
              break;
            case 2:
              a3[s2++] = r2[i3 | c2 >> 6], a3[s2++] = r2[63 & c2], u2 = 0;
          }
          s2 > 8191 && ((o3 || (o3 = [])).push(String.fromCharCode.apply(String, a3)), s2 = 0);
        }
        return u2 && (a3[s2++] = r2[i3], a3[s2++] = 61, 1 === u2 && (a3[s2++] = 61)), o3 ? (s2 && o3.push(String.fromCharCode.apply(String, a3.slice(0, s2))), o3.join("")) : String.fromCharCode.apply(String, a3.slice(0, s2));
      };
      var a2 = "invalid encoding";
      n2.decode = function(t3, e3, n3) {
        for (var r3, o3 = n3, s2 = 0, u2 = 0; u2 < t3.length; ) {
          var c2 = t3.charCodeAt(u2++);
          if (61 === c2 && s2 > 1) break;
          if (void 0 === (c2 = i2[c2])) throw Error(a2);
          switch (s2) {
            case 0:
              r3 = c2, s2 = 1;
              break;
            case 1:
              e3[n3++] = r3 << 2 | (48 & c2) >> 4, r3 = c2, s2 = 2;
              break;
            case 2:
              e3[n3++] = (15 & r3) << 4 | (60 & c2) >> 2, r3 = c2, s2 = 3;
              break;
            case 3:
              e3[n3++] = (3 & r3) << 6 | c2, s2 = 0;
          }
        }
        if (1 === s2) throw Error(a2);
        return n3 - o3;
      }, n2.test = function(t3) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t3);
      };
    }, 9211: (t2) => {
      function e2() {
        this._listeners = {};
      }
      t2.exports = e2, e2.prototype.on = function(t3, e3, n2) {
        return (this._listeners[t3] || (this._listeners[t3] = [])).push({ fn: e3, ctx: n2 || this }), this;
      }, e2.prototype.off = function(t3, e3) {
        if (void 0 === t3) this._listeners = {};
        else if (void 0 === e3) this._listeners[t3] = [];
        else for (var n2 = this._listeners[t3], r2 = 0; r2 < n2.length; ) n2[r2].fn === e3 ? n2.splice(r2, 1) : ++r2;
        return this;
      }, e2.prototype.emit = function(t3) {
        var e3 = this._listeners[t3];
        if (e3) {
          for (var n2 = [], r2 = 1; r2 < arguments.length; ) n2.push(arguments[r2++]);
          for (r2 = 0; r2 < e3.length; ) e3[r2].fn.apply(e3[r2++].ctx, n2);
        }
        return this;
      };
    }, 945: (t2) => {
      function e2(t3) {
        return "undefined" != typeof Float32Array ? function() {
          var e3 = new Float32Array([-0]), n3 = new Uint8Array(e3.buffer), r3 = 128 === n3[3];
          function i3(t4, r4, i4) {
            e3[0] = t4, r4[i4] = n3[0], r4[i4 + 1] = n3[1], r4[i4 + 2] = n3[2], r4[i4 + 3] = n3[3];
          }
          function o3(t4, r4, i4) {
            e3[0] = t4, r4[i4] = n3[3], r4[i4 + 1] = n3[2], r4[i4 + 2] = n3[1], r4[i4 + 3] = n3[0];
          }
          function a2(t4, r4) {
            return n3[0] = t4[r4], n3[1] = t4[r4 + 1], n3[2] = t4[r4 + 2], n3[3] = t4[r4 + 3], e3[0];
          }
          function s2(t4, r4) {
            return n3[3] = t4[r4], n3[2] = t4[r4 + 1], n3[1] = t4[r4 + 2], n3[0] = t4[r4 + 3], e3[0];
          }
          t3.writeFloatLE = r3 ? i3 : o3, t3.writeFloatBE = r3 ? o3 : i3, t3.readFloatLE = r3 ? a2 : s2, t3.readFloatBE = r3 ? s2 : a2;
        }() : function() {
          function e3(t4, e4, n3, r3) {
            var i3 = e4 < 0 ? 1 : 0;
            if (i3 && (e4 = -e4), 0 === e4) t4(1 / e4 > 0 ? 0 : 2147483648, n3, r3);
            else if (isNaN(e4)) t4(2143289344, n3, r3);
            else if (e4 > 34028234663852886e22) t4((i3 << 31 | 2139095040) >>> 0, n3, r3);
            else if (e4 < 11754943508222875e-54) t4((i3 << 31 | Math.round(e4 / 1401298464324817e-60)) >>> 0, n3, r3);
            else {
              var o3 = Math.floor(Math.log(e4) / Math.LN2);
              t4((i3 << 31 | o3 + 127 << 23 | 8388607 & Math.round(e4 * Math.pow(2, -o3) * 8388608)) >>> 0, n3, r3);
            }
          }
          function a2(t4, e4, n3) {
            var r3 = t4(e4, n3), i3 = 2 * (r3 >> 31) + 1, o3 = r3 >>> 23 & 255, a3 = 8388607 & r3;
            return 255 === o3 ? a3 ? NaN : i3 * (1 / 0) : 0 === o3 ? 1401298464324817e-60 * i3 * a3 : i3 * Math.pow(2, o3 - 150) * (a3 + 8388608);
          }
          t3.writeFloatLE = e3.bind(null, n2), t3.writeFloatBE = e3.bind(null, r2), t3.readFloatLE = a2.bind(null, i2), t3.readFloatBE = a2.bind(null, o2);
        }(), "undefined" != typeof Float64Array ? function() {
          var e3 = new Float64Array([-0]), n3 = new Uint8Array(e3.buffer), r3 = 128 === n3[7];
          function i3(t4, r4, i4) {
            e3[0] = t4, r4[i4] = n3[0], r4[i4 + 1] = n3[1], r4[i4 + 2] = n3[2], r4[i4 + 3] = n3[3], r4[i4 + 4] = n3[4], r4[i4 + 5] = n3[5], r4[i4 + 6] = n3[6], r4[i4 + 7] = n3[7];
          }
          function o3(t4, r4, i4) {
            e3[0] = t4, r4[i4] = n3[7], r4[i4 + 1] = n3[6], r4[i4 + 2] = n3[5], r4[i4 + 3] = n3[4], r4[i4 + 4] = n3[3], r4[i4 + 5] = n3[2], r4[i4 + 6] = n3[1], r4[i4 + 7] = n3[0];
          }
          function a2(t4, r4) {
            return n3[0] = t4[r4], n3[1] = t4[r4 + 1], n3[2] = t4[r4 + 2], n3[3] = t4[r4 + 3], n3[4] = t4[r4 + 4], n3[5] = t4[r4 + 5], n3[6] = t4[r4 + 6], n3[7] = t4[r4 + 7], e3[0];
          }
          function s2(t4, r4) {
            return n3[7] = t4[r4], n3[6] = t4[r4 + 1], n3[5] = t4[r4 + 2], n3[4] = t4[r4 + 3], n3[3] = t4[r4 + 4], n3[2] = t4[r4 + 5], n3[1] = t4[r4 + 6], n3[0] = t4[r4 + 7], e3[0];
          }
          t3.writeDoubleLE = r3 ? i3 : o3, t3.writeDoubleBE = r3 ? o3 : i3, t3.readDoubleLE = r3 ? a2 : s2, t3.readDoubleBE = r3 ? s2 : a2;
        }() : function() {
          function e3(t4, e4, n3, r3, i3, o3) {
            var a3 = r3 < 0 ? 1 : 0;
            if (a3 && (r3 = -r3), 0 === r3) t4(0, i3, o3 + e4), t4(1 / r3 > 0 ? 0 : 2147483648, i3, o3 + n3);
            else if (isNaN(r3)) t4(0, i3, o3 + e4), t4(2146959360, i3, o3 + n3);
            else if (r3 > 17976931348623157e292) t4(0, i3, o3 + e4), t4((a3 << 31 | 2146435072) >>> 0, i3, o3 + n3);
            else {
              var s2;
              if (r3 < 22250738585072014e-324) t4((s2 = r3 / 5e-324) >>> 0, i3, o3 + e4), t4((a3 << 31 | s2 / 4294967296) >>> 0, i3, o3 + n3);
              else {
                var u2 = Math.floor(Math.log(r3) / Math.LN2);
                1024 === u2 && (u2 = 1023), t4(4503599627370496 * (s2 = r3 * Math.pow(2, -u2)) >>> 0, i3, o3 + e4), t4((a3 << 31 | u2 + 1023 << 20 | 1048576 * s2 & 1048575) >>> 0, i3, o3 + n3);
              }
            }
          }
          function a2(t4, e4, n3, r3, i3) {
            var o3 = t4(r3, i3 + e4), a3 = t4(r3, i3 + n3), s2 = 2 * (a3 >> 31) + 1, u2 = a3 >>> 20 & 2047, c2 = 4294967296 * (1048575 & a3) + o3;
            return 2047 === u2 ? c2 ? NaN : s2 * (1 / 0) : 0 === u2 ? 5e-324 * s2 * c2 : s2 * Math.pow(2, u2 - 1075) * (c2 + 4503599627370496);
          }
          t3.writeDoubleLE = e3.bind(null, n2, 0, 4), t3.writeDoubleBE = e3.bind(null, r2, 4, 0), t3.readDoubleLE = a2.bind(null, i2, 0, 4), t3.readDoubleBE = a2.bind(null, o2, 4, 0);
        }(), t3;
      }
      function n2(t3, e3, n3) {
        e3[n3] = 255 & t3, e3[n3 + 1] = t3 >>> 8 & 255, e3[n3 + 2] = t3 >>> 16 & 255, e3[n3 + 3] = t3 >>> 24;
      }
      function r2(t3, e3, n3) {
        e3[n3] = t3 >>> 24, e3[n3 + 1] = t3 >>> 16 & 255, e3[n3 + 2] = t3 >>> 8 & 255, e3[n3 + 3] = 255 & t3;
      }
      function i2(t3, e3) {
        return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16 | t3[e3 + 3] << 24) >>> 0;
      }
      function o2(t3, e3) {
        return (t3[e3] << 24 | t3[e3 + 1] << 16 | t3[e3 + 2] << 8 | t3[e3 + 3]) >>> 0;
      }
      t2.exports = e2(e2);
    }, 7199: (module) => {
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length)) return mod;
        } catch (t2) {
        }
        return null;
      }
      module.exports = inquire;
    }, 6662: (t2) => {
      t2.exports = function(t3, e2, n2) {
        var r2 = n2 || 8192, i2 = r2 >>> 1, o2 = null, a2 = r2;
        return function(n3) {
          if (n3 < 1 || n3 > i2) return t3(n3);
          a2 + n3 > r2 && (o2 = t3(r2), a2 = 0);
          var s2 = e2.call(o2, a2, a2 += n3);
          return 7 & a2 && (a2 = 1 + (7 | a2)), s2;
        };
      };
    }, 4997: (t2, e2) => {
      var n2 = e2;
      n2.length = function(t3) {
        for (var e3 = 0, n3 = 0, r2 = 0; r2 < t3.length; ++r2) (n3 = t3.charCodeAt(r2)) < 128 ? e3 += 1 : n3 < 2048 ? e3 += 2 : 55296 == (64512 & n3) && 56320 == (64512 & t3.charCodeAt(r2 + 1)) ? (++r2, e3 += 4) : e3 += 3;
        return e3;
      }, n2.read = function(t3, e3, n3) {
        if (n3 - e3 < 1) return "";
        for (var r2, i2 = null, o2 = [], a2 = 0; e3 < n3; ) (r2 = t3[e3++]) < 128 ? o2[a2++] = r2 : r2 > 191 && r2 < 224 ? o2[a2++] = (31 & r2) << 6 | 63 & t3[e3++] : r2 > 239 && r2 < 365 ? (r2 = ((7 & r2) << 18 | (63 & t3[e3++]) << 12 | (63 & t3[e3++]) << 6 | 63 & t3[e3++]) - 65536, o2[a2++] = 55296 + (r2 >> 10), o2[a2++] = 56320 + (1023 & r2)) : o2[a2++] = (15 & r2) << 12 | (63 & t3[e3++]) << 6 | 63 & t3[e3++], a2 > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, o2)), a2 = 0);
        return i2 ? (a2 && i2.push(String.fromCharCode.apply(String, o2.slice(0, a2))), i2.join("")) : String.fromCharCode.apply(String, o2.slice(0, a2));
      }, n2.write = function(t3, e3, n3) {
        for (var r2, i2, o2 = n3, a2 = 0; a2 < t3.length; ++a2) (r2 = t3.charCodeAt(a2)) < 128 ? e3[n3++] = r2 : r2 < 2048 ? (e3[n3++] = r2 >> 6 | 192, e3[n3++] = 63 & r2 | 128) : 55296 == (64512 & r2) && 56320 == (64512 & (i2 = t3.charCodeAt(a2 + 1))) ? (r2 = 65536 + ((1023 & r2) << 10) + (1023 & i2), ++a2, e3[n3++] = r2 >> 18 | 240, e3[n3++] = r2 >> 12 & 63 | 128, e3[n3++] = r2 >> 6 & 63 | 128, e3[n3++] = 63 & r2 | 128) : (e3[n3++] = r2 >> 12 | 224, e3[n3++] = r2 >> 6 & 63 | 128, e3[n3++] = 63 & r2 | 128);
        return n3 - o2;
      };
    }, 3442: (t2, e2) => {
      e2.__esModule = true;
      var n2 = function() {
        function t3(e3) {
          if (!e3) throw new TypeError("Invalid argument; `value` has no value.");
          this.value = t3.EMPTY, e3 && t3.isGuid(e3) && (this.value = e3);
        }
        return t3.isGuid = function(e3) {
          var n3 = e3.toString();
          return e3 && (e3 instanceof t3 || t3.validator.test(n3));
        }, t3.create = function() {
          return new t3([t3.gen(2), t3.gen(1), t3.gen(1), t3.gen(1), t3.gen(3)].join("-"));
        }, t3.createEmpty = function() {
          return new t3("emptyguid");
        }, t3.parse = function(e3) {
          return new t3(e3);
        }, t3.raw = function() {
          return [t3.gen(2), t3.gen(1), t3.gen(1), t3.gen(1), t3.gen(3)].join("-");
        }, t3.gen = function(t4) {
          for (var e3 = "", n3 = 0; n3 < t4; n3++) e3 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
          return e3;
        }, t3.prototype.equals = function(e3) {
          return t3.isGuid(e3) && this.value === e3.toString();
        }, t3.prototype.isEmpty = function() {
          return this.value === t3.EMPTY;
        }, t3.prototype.toString = function() {
          return this.value;
        }, t3.prototype.toJSON = function() {
          return { value: this.value };
        }, t3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), t3.EMPTY = "00000000-0000-0000-0000-000000000000", t3;
      }();
      e2.Guid = n2;
    }, 3720: (t2) => {
      t2.exports = n2;
      var e2 = null;
      try {
        e2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (t3) {
      }
      function n2(t3, e3, n3) {
        this.low = 0 | t3, this.high = 0 | e3, this.unsigned = !!n3;
      }
      function r2(t3) {
        return true === (t3 && t3.__isLong__);
      }
      n2.prototype.__isLong__, Object.defineProperty(n2.prototype, "__isLong__", { value: true }), n2.isLong = r2;
      var i2 = {}, o2 = {};
      function a2(t3, e3) {
        var n3, r3, a3;
        return e3 ? (a3 = 0 <= (t3 >>>= 0) && t3 < 256) && (r3 = o2[t3]) ? r3 : (n3 = u2(t3, (0 | t3) < 0 ? -1 : 0, true), a3 && (o2[t3] = n3), n3) : (a3 = -128 <= (t3 |= 0) && t3 < 128) && (r3 = i2[t3]) ? r3 : (n3 = u2(t3, t3 < 0 ? -1 : 0, false), a3 && (i2[t3] = n3), n3);
      }
      function s2(t3, e3) {
        if (isNaN(t3)) return e3 ? m2 : b2;
        if (e3) {
          if (t3 < 0) return m2;
          if (t3 >= d2) return x2;
        } else {
          if (t3 <= -9223372036854776e3) return T2;
          if (t3 + 1 >= h2) return w2;
        }
        return t3 < 0 ? s2(-t3, e3).neg() : u2(t3 % f2 | 0, t3 / f2 | 0, e3);
      }
      function u2(t3, e3, r3) {
        return new n2(t3, e3, r3);
      }
      n2.fromInt = a2, n2.fromNumber = s2, n2.fromBits = u2;
      var c2 = Math.pow;
      function l2(t3, e3, n3) {
        if (0 === t3.length) throw Error("empty string");
        if ("NaN" === t3 || "Infinity" === t3 || "+Infinity" === t3 || "-Infinity" === t3) return b2;
        if ("number" == typeof e3 ? (n3 = e3, e3 = false) : e3 = !!e3, (n3 = n3 || 10) < 2 || 36 < n3) throw RangeError("radix");
        var r3;
        if ((r3 = t3.indexOf("-")) > 0) throw Error("interior hyphen");
        if (0 === r3) return l2(t3.substring(1), e3, n3).neg();
        for (var i3 = s2(c2(n3, 8)), o3 = b2, a3 = 0; a3 < t3.length; a3 += 8) {
          var u3 = Math.min(8, t3.length - a3), p3 = parseInt(t3.substring(a3, a3 + u3), n3);
          if (u3 < 8) {
            var f3 = s2(c2(n3, u3));
            o3 = o3.mul(f3).add(s2(p3));
          } else o3 = (o3 = o3.mul(i3)).add(s2(p3));
        }
        return o3.unsigned = e3, o3;
      }
      function p2(t3, e3) {
        return "number" == typeof t3 ? s2(t3, e3) : "string" == typeof t3 ? l2(t3, e3) : u2(t3.low, t3.high, "boolean" == typeof e3 ? e3 : t3.unsigned);
      }
      n2.fromString = l2, n2.fromValue = p2;
      var f2 = 4294967296, d2 = f2 * f2, h2 = d2 / 2, g2 = a2(1 << 24), b2 = a2(0);
      n2.ZERO = b2;
      var m2 = a2(0, true);
      n2.UZERO = m2;
      var y2 = a2(1);
      n2.ONE = y2;
      var _ = a2(1, true);
      n2.UONE = _;
      var v2 = a2(-1);
      n2.NEG_ONE = v2;
      var w2 = u2(-1, 2147483647, false);
      n2.MAX_VALUE = w2;
      var x2 = u2(-1, -1, true);
      n2.MAX_UNSIGNED_VALUE = x2;
      var T2 = u2(0, -2147483648, false);
      n2.MIN_VALUE = T2;
      var S2 = n2.prototype;
      S2.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, S2.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * f2 + (this.low >>> 0) : this.high * f2 + (this.low >>> 0);
      }, S2.toString = function(t3) {
        if ((t3 = t3 || 10) < 2 || 36 < t3) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(T2)) {
            var e3 = s2(t3), n3 = this.div(e3), r3 = n3.mul(e3).sub(this);
            return n3.toString(t3) + r3.toInt().toString(t3);
          }
          return "-" + this.neg().toString(t3);
        }
        for (var i3 = s2(c2(t3, 6), this.unsigned), o3 = this, a3 = ""; ; ) {
          var u3 = o3.div(i3), l3 = (o3.sub(u3.mul(i3)).toInt() >>> 0).toString(t3);
          if ((o3 = u3).isZero()) return l3 + a3;
          for (; l3.length < 6; ) l3 = "0" + l3;
          a3 = "" + l3 + a3;
        }
      }, S2.getHighBits = function() {
        return this.high;
      }, S2.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      }, S2.getLowBits = function() {
        return this.low;
      }, S2.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      }, S2.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(T2) ? 64 : this.neg().getNumBitsAbs();
        for (var t3 = 0 != this.high ? this.high : this.low, e3 = 31; e3 > 0 && 0 == (t3 & 1 << e3); e3--) ;
        return 0 != this.high ? e3 + 33 : e3 + 1;
      }, S2.isZero = function() {
        return 0 === this.high && 0 === this.low;
      }, S2.eqz = S2.isZero, S2.isNegative = function() {
        return !this.unsigned && this.high < 0;
      }, S2.isPositive = function() {
        return this.unsigned || this.high >= 0;
      }, S2.isOdd = function() {
        return 1 == (1 & this.low);
      }, S2.isEven = function() {
        return 0 == (1 & this.low);
      }, S2.equals = function(t3) {
        return r2(t3) || (t3 = p2(t3)), (this.unsigned === t3.unsigned || this.high >>> 31 != 1 || t3.high >>> 31 != 1) && this.high === t3.high && this.low === t3.low;
      }, S2.eq = S2.equals, S2.notEquals = function(t3) {
        return !this.eq(t3);
      }, S2.neq = S2.notEquals, S2.ne = S2.notEquals, S2.lessThan = function(t3) {
        return this.comp(t3) < 0;
      }, S2.lt = S2.lessThan, S2.lessThanOrEqual = function(t3) {
        return this.comp(t3) <= 0;
      }, S2.lte = S2.lessThanOrEqual, S2.le = S2.lessThanOrEqual, S2.greaterThan = function(t3) {
        return this.comp(t3) > 0;
      }, S2.gt = S2.greaterThan, S2.greaterThanOrEqual = function(t3) {
        return this.comp(t3) >= 0;
      }, S2.gte = S2.greaterThanOrEqual, S2.ge = S2.greaterThanOrEqual, S2.compare = function(t3) {
        if (r2(t3) || (t3 = p2(t3)), this.eq(t3)) return 0;
        var e3 = this.isNegative(), n3 = t3.isNegative();
        return e3 && !n3 ? -1 : !e3 && n3 ? 1 : this.unsigned ? t3.high >>> 0 > this.high >>> 0 || t3.high === this.high && t3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t3).isNegative() ? -1 : 1;
      }, S2.comp = S2.compare, S2.negate = function() {
        return !this.unsigned && this.eq(T2) ? T2 : this.not().add(y2);
      }, S2.neg = S2.negate, S2.add = function(t3) {
        r2(t3) || (t3 = p2(t3));
        var e3 = this.high >>> 16, n3 = 65535 & this.high, i3 = this.low >>> 16, o3 = 65535 & this.low, a3 = t3.high >>> 16, s3 = 65535 & t3.high, c3 = t3.low >>> 16, l3 = 0, f3 = 0, d3 = 0, h3 = 0;
        return d3 += (h3 += o3 + (65535 & t3.low)) >>> 16, f3 += (d3 += i3 + c3) >>> 16, l3 += (f3 += n3 + s3) >>> 16, l3 += e3 + a3, u2((d3 &= 65535) << 16 | (h3 &= 65535), (l3 &= 65535) << 16 | (f3 &= 65535), this.unsigned);
      }, S2.subtract = function(t3) {
        return r2(t3) || (t3 = p2(t3)), this.add(t3.neg());
      }, S2.sub = S2.subtract, S2.multiply = function(t3) {
        if (this.isZero()) return b2;
        if (r2(t3) || (t3 = p2(t3)), e2) return u2(e2.mul(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned);
        if (t3.isZero()) return b2;
        if (this.eq(T2)) return t3.isOdd() ? T2 : b2;
        if (t3.eq(T2)) return this.isOdd() ? T2 : b2;
        if (this.isNegative()) return t3.isNegative() ? this.neg().mul(t3.neg()) : this.neg().mul(t3).neg();
        if (t3.isNegative()) return this.mul(t3.neg()).neg();
        if (this.lt(g2) && t3.lt(g2)) return s2(this.toNumber() * t3.toNumber(), this.unsigned);
        var n3 = this.high >>> 16, i3 = 65535 & this.high, o3 = this.low >>> 16, a3 = 65535 & this.low, c3 = t3.high >>> 16, l3 = 65535 & t3.high, f3 = t3.low >>> 16, d3 = 65535 & t3.low, h3 = 0, m3 = 0, y3 = 0, _2 = 0;
        return y3 += (_2 += a3 * d3) >>> 16, m3 += (y3 += o3 * d3) >>> 16, y3 &= 65535, m3 += (y3 += a3 * f3) >>> 16, h3 += (m3 += i3 * d3) >>> 16, m3 &= 65535, h3 += (m3 += o3 * f3) >>> 16, m3 &= 65535, h3 += (m3 += a3 * l3) >>> 16, h3 += n3 * d3 + i3 * f3 + o3 * l3 + a3 * c3, u2((y3 &= 65535) << 16 | (_2 &= 65535), (h3 &= 65535) << 16 | (m3 &= 65535), this.unsigned);
      }, S2.mul = S2.multiply, S2.divide = function(t3) {
        if (r2(t3) || (t3 = p2(t3)), t3.isZero()) throw Error("division by zero");
        var n3, i3, o3;
        if (e2) return this.unsigned || -2147483648 !== this.high || -1 !== t3.low || -1 !== t3.high ? u2((this.unsigned ? e2.div_u : e2.div_s)(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? m2 : b2;
        if (this.unsigned) {
          if (t3.unsigned || (t3 = t3.toUnsigned()), t3.gt(this)) return m2;
          if (t3.gt(this.shru(1))) return _;
          o3 = m2;
        } else {
          if (this.eq(T2)) return t3.eq(y2) || t3.eq(v2) ? T2 : t3.eq(T2) ? y2 : (n3 = this.shr(1).div(t3).shl(1)).eq(b2) ? t3.isNegative() ? y2 : v2 : (i3 = this.sub(t3.mul(n3)), o3 = n3.add(i3.div(t3)));
          if (t3.eq(T2)) return this.unsigned ? m2 : b2;
          if (this.isNegative()) return t3.isNegative() ? this.neg().div(t3.neg()) : this.neg().div(t3).neg();
          if (t3.isNegative()) return this.div(t3.neg()).neg();
          o3 = b2;
        }
        for (i3 = this; i3.gte(t3); ) {
          n3 = Math.max(1, Math.floor(i3.toNumber() / t3.toNumber()));
          for (var a3 = Math.ceil(Math.log(n3) / Math.LN2), l3 = a3 <= 48 ? 1 : c2(2, a3 - 48), f3 = s2(n3), d3 = f3.mul(t3); d3.isNegative() || d3.gt(i3); ) d3 = (f3 = s2(n3 -= l3, this.unsigned)).mul(t3);
          f3.isZero() && (f3 = y2), o3 = o3.add(f3), i3 = i3.sub(d3);
        }
        return o3;
      }, S2.div = S2.divide, S2.modulo = function(t3) {
        return r2(t3) || (t3 = p2(t3)), e2 ? u2((this.unsigned ? e2.rem_u : e2.rem_s)(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned) : this.sub(this.div(t3).mul(t3));
      }, S2.mod = S2.modulo, S2.rem = S2.modulo, S2.not = function() {
        return u2(~this.low, ~this.high, this.unsigned);
      }, S2.and = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low & t3.low, this.high & t3.high, this.unsigned);
      }, S2.or = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low | t3.low, this.high | t3.high, this.unsigned);
      }, S2.xor = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low ^ t3.low, this.high ^ t3.high, this.unsigned);
      }, S2.shiftLeft = function(t3) {
        return r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63) ? this : t3 < 32 ? u2(this.low << t3, this.high << t3 | this.low >>> 32 - t3, this.unsigned) : u2(0, this.low << t3 - 32, this.unsigned);
      }, S2.shl = S2.shiftLeft, S2.shiftRight = function(t3) {
        return r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63) ? this : t3 < 32 ? u2(this.low >>> t3 | this.high << 32 - t3, this.high >> t3, this.unsigned) : u2(this.high >> t3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, S2.shr = S2.shiftRight, S2.shiftRightUnsigned = function(t3) {
        if (r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63)) return this;
        var e3 = this.high;
        return t3 < 32 ? u2(this.low >>> t3 | e3 << 32 - t3, e3 >>> t3, this.unsigned) : u2(32 === t3 ? e3 : e3 >>> t3 - 32, 0, this.unsigned);
      }, S2.shru = S2.shiftRightUnsigned, S2.shr_u = S2.shiftRightUnsigned, S2.toSigned = function() {
        return this.unsigned ? u2(this.low, this.high, false) : this;
      }, S2.toUnsigned = function() {
        return this.unsigned ? this : u2(this.low, this.high, true);
      }, S2.toBytes = function(t3) {
        return t3 ? this.toBytesLE() : this.toBytesBE();
      }, S2.toBytesLE = function() {
        var t3 = this.high, e3 = this.low;
        return [255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24, 255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24];
      }, S2.toBytesBE = function() {
        var t3 = this.high, e3 = this.low;
        return [t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3, e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
      }, n2.fromBytes = function(t3, e3, r3) {
        return r3 ? n2.fromBytesLE(t3, e3) : n2.fromBytesBE(t3, e3);
      }, n2.fromBytesLE = function(t3, e3) {
        return new n2(t3[0] | t3[1] << 8 | t3[2] << 16 | t3[3] << 24, t3[4] | t3[5] << 8 | t3[6] << 16 | t3[7] << 24, e3);
      }, n2.fromBytesBE = function(t3, e3) {
        return new n2(t3[4] << 24 | t3[5] << 16 | t3[6] << 8 | t3[7], t3[0] << 24 | t3[1] << 16 | t3[2] << 8 | t3[3], e3);
      };
    }, 1446: (t2, e2, n2) => {
      var r2, i2, o2, a2 = n2(2100), s2 = a2.Reader, u2 = a2.Writer, c2 = a2.util, l2 = a2.roots.default || (a2.roots.default = {});
      l2.onnx = ((o2 = {}).Version = (r2 = {}, (i2 = Object.create(r2))[r2[0] = "_START_VERSION"] = 0, i2[r2[1] = "IR_VERSION_2017_10_10"] = 1, i2[r2[2] = "IR_VERSION_2017_10_30"] = 2, i2[r2[3] = "IR_VERSION_2017_11_3"] = 3, i2[r2[4] = "IR_VERSION_2019_1_22"] = 4, i2[r2[5] = "IR_VERSION"] = 5, i2), o2.AttributeProto = function() {
        function t3(t4) {
          if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.name = "", t3.prototype.refAttrName = "", t3.prototype.docString = "", t3.prototype.type = 0, t3.prototype.f = 0, t3.prototype.i = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.s = c2.newBuffer([]), t3.prototype.t = null, t3.prototype.g = null, t3.prototype.floats = c2.emptyArray, t3.prototype.ints = c2.emptyArray, t3.prototype.strings = c2.emptyArray, t3.prototype.tensors = c2.emptyArray, t3.prototype.graphs = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.name && t4.hasOwnProperty("name") && e3.uint32(10).string(t4.name), null != t4.f && t4.hasOwnProperty("f") && e3.uint32(21).float(t4.f), null != t4.i && t4.hasOwnProperty("i") && e3.uint32(24).int64(t4.i), null != t4.s && t4.hasOwnProperty("s") && e3.uint32(34).bytes(t4.s), null != t4.t && t4.hasOwnProperty("t") && l2.onnx.TensorProto.encode(t4.t, e3.uint32(42).fork()).ldelim(), null != t4.g && t4.hasOwnProperty("g") && l2.onnx.GraphProto.encode(t4.g, e3.uint32(50).fork()).ldelim(), null != t4.floats && t4.floats.length) {
            e3.uint32(58).fork();
            for (var n3 = 0; n3 < t4.floats.length; ++n3) e3.float(t4.floats[n3]);
            e3.ldelim();
          }
          if (null != t4.ints && t4.ints.length) {
            for (e3.uint32(66).fork(), n3 = 0; n3 < t4.ints.length; ++n3) e3.int64(t4.ints[n3]);
            e3.ldelim();
          }
          if (null != t4.strings && t4.strings.length) for (n3 = 0; n3 < t4.strings.length; ++n3) e3.uint32(74).bytes(t4.strings[n3]);
          if (null != t4.tensors && t4.tensors.length) for (n3 = 0; n3 < t4.tensors.length; ++n3) l2.onnx.TensorProto.encode(t4.tensors[n3], e3.uint32(82).fork()).ldelim();
          if (null != t4.graphs && t4.graphs.length) for (n3 = 0; n3 < t4.graphs.length; ++n3) l2.onnx.GraphProto.encode(t4.graphs[n3], e3.uint32(90).fork()).ldelim();
          return null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(106).string(t4.docString), null != t4.type && t4.hasOwnProperty("type") && e3.uint32(160).int32(t4.type), null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && e3.uint32(170).string(t4.refAttrName), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.AttributeProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.name = t4.string();
                break;
              case 21:
                r3.refAttrName = t4.string();
                break;
              case 13:
                r3.docString = t4.string();
                break;
              case 20:
                r3.type = t4.int32();
                break;
              case 2:
                r3.f = t4.float();
                break;
              case 3:
                r3.i = t4.int64();
                break;
              case 4:
                r3.s = t4.bytes();
                break;
              case 5:
                r3.t = l2.onnx.TensorProto.decode(t4, t4.uint32());
                break;
              case 6:
                r3.g = l2.onnx.GraphProto.decode(t4, t4.uint32());
                break;
              case 7:
                if (r3.floats && r3.floats.length || (r3.floats = []), 2 == (7 & i3)) for (var o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.floats.push(t4.float());
                else r3.floats.push(t4.float());
                break;
              case 8:
                if (r3.ints && r3.ints.length || (r3.ints = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.ints.push(t4.int64());
                else r3.ints.push(t4.int64());
                break;
              case 9:
                r3.strings && r3.strings.length || (r3.strings = []), r3.strings.push(t4.bytes());
                break;
              case 10:
                r3.tensors && r3.tensors.length || (r3.tensors = []), r3.tensors.push(l2.onnx.TensorProto.decode(t4, t4.uint32()));
                break;
              case 11:
                r3.graphs && r3.graphs.length || (r3.graphs = []), r3.graphs.push(l2.onnx.GraphProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && !c2.isString(t4.refAttrName)) return "refAttrName: string expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.type && t4.hasOwnProperty("type")) switch (t4.type) {
            default:
              return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
          }
          if (null != t4.f && t4.hasOwnProperty("f") && "number" != typeof t4.f) return "f: number expected";
          if (null != t4.i && t4.hasOwnProperty("i") && !(c2.isInteger(t4.i) || t4.i && c2.isInteger(t4.i.low) && c2.isInteger(t4.i.high))) return "i: integer|Long expected";
          if (null != t4.s && t4.hasOwnProperty("s") && !(t4.s && "number" == typeof t4.s.length || c2.isString(t4.s))) return "s: buffer expected";
          if (null != t4.t && t4.hasOwnProperty("t") && (n3 = l2.onnx.TensorProto.verify(t4.t))) return "t." + n3;
          if (null != t4.g && t4.hasOwnProperty("g") && (n3 = l2.onnx.GraphProto.verify(t4.g))) return "g." + n3;
          if (null != t4.floats && t4.hasOwnProperty("floats")) {
            if (!Array.isArray(t4.floats)) return "floats: array expected";
            for (var e3 = 0; e3 < t4.floats.length; ++e3) if ("number" != typeof t4.floats[e3]) return "floats: number[] expected";
          }
          if (null != t4.ints && t4.hasOwnProperty("ints")) {
            if (!Array.isArray(t4.ints)) return "ints: array expected";
            for (e3 = 0; e3 < t4.ints.length; ++e3) if (!(c2.isInteger(t4.ints[e3]) || t4.ints[e3] && c2.isInteger(t4.ints[e3].low) && c2.isInteger(t4.ints[e3].high))) return "ints: integer|Long[] expected";
          }
          if (null != t4.strings && t4.hasOwnProperty("strings")) {
            if (!Array.isArray(t4.strings)) return "strings: array expected";
            for (e3 = 0; e3 < t4.strings.length; ++e3) if (!(t4.strings[e3] && "number" == typeof t4.strings[e3].length || c2.isString(t4.strings[e3]))) return "strings: buffer[] expected";
          }
          if (null != t4.tensors && t4.hasOwnProperty("tensors")) {
            if (!Array.isArray(t4.tensors)) return "tensors: array expected";
            for (e3 = 0; e3 < t4.tensors.length; ++e3) if (n3 = l2.onnx.TensorProto.verify(t4.tensors[e3])) return "tensors." + n3;
          }
          if (null != t4.graphs && t4.hasOwnProperty("graphs")) {
            if (!Array.isArray(t4.graphs)) return "graphs: array expected";
            for (e3 = 0; e3 < t4.graphs.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.GraphProto.verify(t4.graphs[e3])) return "graphs." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.AttributeProto) return t4;
          var e3 = new l2.onnx.AttributeProto();
          switch (null != t4.name && (e3.name = String(t4.name)), null != t4.refAttrName && (e3.refAttrName = String(t4.refAttrName)), null != t4.docString && (e3.docString = String(t4.docString)), t4.type) {
            case "UNDEFINED":
            case 0:
              e3.type = 0;
              break;
            case "FLOAT":
            case 1:
              e3.type = 1;
              break;
            case "INT":
            case 2:
              e3.type = 2;
              break;
            case "STRING":
            case 3:
              e3.type = 3;
              break;
            case "TENSOR":
            case 4:
              e3.type = 4;
              break;
            case "GRAPH":
            case 5:
              e3.type = 5;
              break;
            case "FLOATS":
            case 6:
              e3.type = 6;
              break;
            case "INTS":
            case 7:
              e3.type = 7;
              break;
            case "STRINGS":
            case 8:
              e3.type = 8;
              break;
            case "TENSORS":
            case 9:
              e3.type = 9;
              break;
            case "GRAPHS":
            case 10:
              e3.type = 10;
          }
          if (null != t4.f && (e3.f = Number(t4.f)), null != t4.i && (c2.Long ? (e3.i = c2.Long.fromValue(t4.i)).unsigned = false : "string" == typeof t4.i ? e3.i = parseInt(t4.i, 10) : "number" == typeof t4.i ? e3.i = t4.i : "object" == typeof t4.i && (e3.i = new c2.LongBits(t4.i.low >>> 0, t4.i.high >>> 0).toNumber())), null != t4.s && ("string" == typeof t4.s ? c2.base64.decode(t4.s, e3.s = c2.newBuffer(c2.base64.length(t4.s)), 0) : t4.s.length && (e3.s = t4.s)), null != t4.t) {
            if ("object" != typeof t4.t) throw TypeError(".onnx.AttributeProto.t: object expected");
            e3.t = l2.onnx.TensorProto.fromObject(t4.t);
          }
          if (null != t4.g) {
            if ("object" != typeof t4.g) throw TypeError(".onnx.AttributeProto.g: object expected");
            e3.g = l2.onnx.GraphProto.fromObject(t4.g);
          }
          if (t4.floats) {
            if (!Array.isArray(t4.floats)) throw TypeError(".onnx.AttributeProto.floats: array expected");
            e3.floats = [];
            for (var n3 = 0; n3 < t4.floats.length; ++n3) e3.floats[n3] = Number(t4.floats[n3]);
          }
          if (t4.ints) {
            if (!Array.isArray(t4.ints)) throw TypeError(".onnx.AttributeProto.ints: array expected");
            for (e3.ints = [], n3 = 0; n3 < t4.ints.length; ++n3) c2.Long ? (e3.ints[n3] = c2.Long.fromValue(t4.ints[n3])).unsigned = false : "string" == typeof t4.ints[n3] ? e3.ints[n3] = parseInt(t4.ints[n3], 10) : "number" == typeof t4.ints[n3] ? e3.ints[n3] = t4.ints[n3] : "object" == typeof t4.ints[n3] && (e3.ints[n3] = new c2.LongBits(t4.ints[n3].low >>> 0, t4.ints[n3].high >>> 0).toNumber());
          }
          if (t4.strings) {
            if (!Array.isArray(t4.strings)) throw TypeError(".onnx.AttributeProto.strings: array expected");
            for (e3.strings = [], n3 = 0; n3 < t4.strings.length; ++n3) "string" == typeof t4.strings[n3] ? c2.base64.decode(t4.strings[n3], e3.strings[n3] = c2.newBuffer(c2.base64.length(t4.strings[n3])), 0) : t4.strings[n3].length && (e3.strings[n3] = t4.strings[n3]);
          }
          if (t4.tensors) {
            if (!Array.isArray(t4.tensors)) throw TypeError(".onnx.AttributeProto.tensors: array expected");
            for (e3.tensors = [], n3 = 0; n3 < t4.tensors.length; ++n3) {
              if ("object" != typeof t4.tensors[n3]) throw TypeError(".onnx.AttributeProto.tensors: object expected");
              e3.tensors[n3] = l2.onnx.TensorProto.fromObject(t4.tensors[n3]);
            }
          }
          if (t4.graphs) {
            if (!Array.isArray(t4.graphs)) throw TypeError(".onnx.AttributeProto.graphs: array expected");
            for (e3.graphs = [], n3 = 0; n3 < t4.graphs.length; ++n3) {
              if ("object" != typeof t4.graphs[n3]) throw TypeError(".onnx.AttributeProto.graphs: object expected");
              e3.graphs[n3] = l2.onnx.GraphProto.fromObject(t4.graphs[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.floats = [], n3.ints = [], n3.strings = [], n3.tensors = [], n3.graphs = []), e3.defaults) {
            if (n3.name = "", n3.f = 0, c2.Long) {
              var r3 = new c2.Long(0, 0, false);
              n3.i = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
            } else n3.i = e3.longs === String ? "0" : 0;
            e3.bytes === String ? n3.s = "" : (n3.s = [], e3.bytes !== Array && (n3.s = c2.newBuffer(n3.s))), n3.t = null, n3.g = null, n3.docString = "", n3.type = e3.enums === String ? "UNDEFINED" : 0, n3.refAttrName = "";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.f && t4.hasOwnProperty("f") && (n3.f = e3.json && !isFinite(t4.f) ? String(t4.f) : t4.f), null != t4.i && t4.hasOwnProperty("i") && ("number" == typeof t4.i ? n3.i = e3.longs === String ? String(t4.i) : t4.i : n3.i = e3.longs === String ? c2.Long.prototype.toString.call(t4.i) : e3.longs === Number ? new c2.LongBits(t4.i.low >>> 0, t4.i.high >>> 0).toNumber() : t4.i), null != t4.s && t4.hasOwnProperty("s") && (n3.s = e3.bytes === String ? c2.base64.encode(t4.s, 0, t4.s.length) : e3.bytes === Array ? Array.prototype.slice.call(t4.s) : t4.s), null != t4.t && t4.hasOwnProperty("t") && (n3.t = l2.onnx.TensorProto.toObject(t4.t, e3)), null != t4.g && t4.hasOwnProperty("g") && (n3.g = l2.onnx.GraphProto.toObject(t4.g, e3)), t4.floats && t4.floats.length) {
            n3.floats = [];
            for (var i3 = 0; i3 < t4.floats.length; ++i3) n3.floats[i3] = e3.json && !isFinite(t4.floats[i3]) ? String(t4.floats[i3]) : t4.floats[i3];
          }
          if (t4.ints && t4.ints.length) for (n3.ints = [], i3 = 0; i3 < t4.ints.length; ++i3) "number" == typeof t4.ints[i3] ? n3.ints[i3] = e3.longs === String ? String(t4.ints[i3]) : t4.ints[i3] : n3.ints[i3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.ints[i3]) : e3.longs === Number ? new c2.LongBits(t4.ints[i3].low >>> 0, t4.ints[i3].high >>> 0).toNumber() : t4.ints[i3];
          if (t4.strings && t4.strings.length) for (n3.strings = [], i3 = 0; i3 < t4.strings.length; ++i3) n3.strings[i3] = e3.bytes === String ? c2.base64.encode(t4.strings[i3], 0, t4.strings[i3].length) : e3.bytes === Array ? Array.prototype.slice.call(t4.strings[i3]) : t4.strings[i3];
          if (t4.tensors && t4.tensors.length) for (n3.tensors = [], i3 = 0; i3 < t4.tensors.length; ++i3) n3.tensors[i3] = l2.onnx.TensorProto.toObject(t4.tensors[i3], e3);
          if (t4.graphs && t4.graphs.length) for (n3.graphs = [], i3 = 0; i3 < t4.graphs.length; ++i3) n3.graphs[i3] = l2.onnx.GraphProto.toObject(t4.graphs[i3], e3);
          return null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.type && t4.hasOwnProperty("type") && (n3.type = e3.enums === String ? l2.onnx.AttributeProto.AttributeType[t4.type] : t4.type), null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && (n3.refAttrName = t4.refAttrName), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3.AttributeType = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "UNDEFINED"] = 0, e3[t4[1] = "FLOAT"] = 1, e3[t4[2] = "INT"] = 2, e3[t4[3] = "STRING"] = 3, e3[t4[4] = "TENSOR"] = 4, e3[t4[5] = "GRAPH"] = 5, e3[t4[6] = "FLOATS"] = 6, e3[t4[7] = "INTS"] = 7, e3[t4[8] = "STRINGS"] = 8, e3[t4[9] = "TENSORS"] = 9, e3[t4[10] = "GRAPHS"] = 10, e3;
        }(), t3;
      }(), o2.ValueInfoProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.name = "", t3.prototype.type = null, t3.prototype.docString = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.name && t4.hasOwnProperty("name") && e3.uint32(10).string(t4.name), null != t4.type && t4.hasOwnProperty("type") && l2.onnx.TypeProto.encode(t4.type, e3.uint32(18).fork()).ldelim(), null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(26).string(t4.docString), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.ValueInfoProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.name = t4.string();
                break;
              case 2:
                r3.type = l2.onnx.TypeProto.decode(t4, t4.uint32());
                break;
              case 3:
                r3.docString = t4.string();
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.type && t4.hasOwnProperty("type")) {
            var e3 = l2.onnx.TypeProto.verify(t4.type);
            if (e3) return "type." + e3;
          }
          return null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString) ? "docString: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.ValueInfoProto) return t4;
          var e3 = new l2.onnx.ValueInfoProto();
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.type) {
            if ("object" != typeof t4.type) throw TypeError(".onnx.ValueInfoProto.type: object expected");
            e3.type = l2.onnx.TypeProto.fromObject(t4.type);
          }
          return null != t4.docString && (e3.docString = String(t4.docString)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          return e3.defaults && (n3.name = "", n3.type = null, n3.docString = ""), null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.type && t4.hasOwnProperty("type") && (n3.type = l2.onnx.TypeProto.toObject(t4.type, e3)), null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.NodeProto = function() {
        function t3(t4) {
          if (this.input = [], this.output = [], this.attribute = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.input = c2.emptyArray, t3.prototype.output = c2.emptyArray, t3.prototype.name = "", t3.prototype.opType = "", t3.prototype.domain = "", t3.prototype.attribute = c2.emptyArray, t3.prototype.docString = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.input && t4.input.length) for (var n3 = 0; n3 < t4.input.length; ++n3) e3.uint32(10).string(t4.input[n3]);
          if (null != t4.output && t4.output.length) for (n3 = 0; n3 < t4.output.length; ++n3) e3.uint32(18).string(t4.output[n3]);
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(26).string(t4.name), null != t4.opType && t4.hasOwnProperty("opType") && e3.uint32(34).string(t4.opType), null != t4.attribute && t4.attribute.length) for (n3 = 0; n3 < t4.attribute.length; ++n3) l2.onnx.AttributeProto.encode(t4.attribute[n3], e3.uint32(42).fork()).ldelim();
          return null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(50).string(t4.docString), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(58).string(t4.domain), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.NodeProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.input && r3.input.length || (r3.input = []), r3.input.push(t4.string());
                break;
              case 2:
                r3.output && r3.output.length || (r3.output = []), r3.output.push(t4.string());
                break;
              case 3:
                r3.name = t4.string();
                break;
              case 4:
                r3.opType = t4.string();
                break;
              case 7:
                r3.domain = t4.string();
                break;
              case 5:
                r3.attribute && r3.attribute.length || (r3.attribute = []), r3.attribute.push(l2.onnx.AttributeProto.decode(t4, t4.uint32()));
                break;
              case 6:
                r3.docString = t4.string();
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.input && t4.hasOwnProperty("input")) {
            if (!Array.isArray(t4.input)) return "input: array expected";
            for (var e3 = 0; e3 < t4.input.length; ++e3) if (!c2.isString(t4.input[e3])) return "input: string[] expected";
          }
          if (null != t4.output && t4.hasOwnProperty("output")) {
            if (!Array.isArray(t4.output)) return "output: array expected";
            for (e3 = 0; e3 < t4.output.length; ++e3) if (!c2.isString(t4.output[e3])) return "output: string[] expected";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.opType && t4.hasOwnProperty("opType") && !c2.isString(t4.opType)) return "opType: string expected";
          if (null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain)) return "domain: string expected";
          if (null != t4.attribute && t4.hasOwnProperty("attribute")) {
            if (!Array.isArray(t4.attribute)) return "attribute: array expected";
            for (e3 = 0; e3 < t4.attribute.length; ++e3) {
              var n3 = l2.onnx.AttributeProto.verify(t4.attribute[e3]);
              if (n3) return "attribute." + n3;
            }
          }
          return null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString) ? "docString: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.NodeProto) return t4;
          var e3 = new l2.onnx.NodeProto();
          if (t4.input) {
            if (!Array.isArray(t4.input)) throw TypeError(".onnx.NodeProto.input: array expected");
            e3.input = [];
            for (var n3 = 0; n3 < t4.input.length; ++n3) e3.input[n3] = String(t4.input[n3]);
          }
          if (t4.output) {
            if (!Array.isArray(t4.output)) throw TypeError(".onnx.NodeProto.output: array expected");
            for (e3.output = [], n3 = 0; n3 < t4.output.length; ++n3) e3.output[n3] = String(t4.output[n3]);
          }
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.opType && (e3.opType = String(t4.opType)), null != t4.domain && (e3.domain = String(t4.domain)), t4.attribute) {
            if (!Array.isArray(t4.attribute)) throw TypeError(".onnx.NodeProto.attribute: array expected");
            for (e3.attribute = [], n3 = 0; n3 < t4.attribute.length; ++n3) {
              if ("object" != typeof t4.attribute[n3]) throw TypeError(".onnx.NodeProto.attribute: object expected");
              e3.attribute[n3] = l2.onnx.AttributeProto.fromObject(t4.attribute[n3]);
            }
          }
          return null != t4.docString && (e3.docString = String(t4.docString)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.input = [], n3.output = [], n3.attribute = []), e3.defaults && (n3.name = "", n3.opType = "", n3.docString = "", n3.domain = ""), t4.input && t4.input.length) {
            n3.input = [];
            for (var r3 = 0; r3 < t4.input.length; ++r3) n3.input[r3] = t4.input[r3];
          }
          if (t4.output && t4.output.length) for (n3.output = [], r3 = 0; r3 < t4.output.length; ++r3) n3.output[r3] = t4.output[r3];
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.opType && t4.hasOwnProperty("opType") && (n3.opType = t4.opType), t4.attribute && t4.attribute.length) for (n3.attribute = [], r3 = 0; r3 < t4.attribute.length; ++r3) n3.attribute[r3] = l2.onnx.AttributeProto.toObject(t4.attribute[r3], e3);
          return null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.ModelProto = function() {
        function t3(t4) {
          if (this.opsetImport = [], this.metadataProps = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.irVersion = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.opsetImport = c2.emptyArray, t3.prototype.producerName = "", t3.prototype.producerVersion = "", t3.prototype.domain = "", t3.prototype.modelVersion = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.docString = "", t3.prototype.graph = null, t3.prototype.metadataProps = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.irVersion && t4.hasOwnProperty("irVersion") && e3.uint32(8).int64(t4.irVersion), null != t4.producerName && t4.hasOwnProperty("producerName") && e3.uint32(18).string(t4.producerName), null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && e3.uint32(26).string(t4.producerVersion), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(34).string(t4.domain), null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && e3.uint32(40).int64(t4.modelVersion), null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(50).string(t4.docString), null != t4.graph && t4.hasOwnProperty("graph") && l2.onnx.GraphProto.encode(t4.graph, e3.uint32(58).fork()).ldelim(), null != t4.opsetImport && t4.opsetImport.length) for (var n3 = 0; n3 < t4.opsetImport.length; ++n3) l2.onnx.OperatorSetIdProto.encode(t4.opsetImport[n3], e3.uint32(66).fork()).ldelim();
          if (null != t4.metadataProps && t4.metadataProps.length) for (n3 = 0; n3 < t4.metadataProps.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.metadataProps[n3], e3.uint32(114).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.ModelProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.irVersion = t4.int64();
                break;
              case 8:
                r3.opsetImport && r3.opsetImport.length || (r3.opsetImport = []), r3.opsetImport.push(l2.onnx.OperatorSetIdProto.decode(t4, t4.uint32()));
                break;
              case 2:
                r3.producerName = t4.string();
                break;
              case 3:
                r3.producerVersion = t4.string();
                break;
              case 4:
                r3.domain = t4.string();
                break;
              case 5:
                r3.modelVersion = t4.int64();
                break;
              case 6:
                r3.docString = t4.string();
                break;
              case 7:
                r3.graph = l2.onnx.GraphProto.decode(t4, t4.uint32());
                break;
              case 14:
                r3.metadataProps && r3.metadataProps.length || (r3.metadataProps = []), r3.metadataProps.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.irVersion && t4.hasOwnProperty("irVersion") && !(c2.isInteger(t4.irVersion) || t4.irVersion && c2.isInteger(t4.irVersion.low) && c2.isInteger(t4.irVersion.high))) return "irVersion: integer|Long expected";
          if (null != t4.opsetImport && t4.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(t4.opsetImport)) return "opsetImport: array expected";
            for (var e3 = 0; e3 < t4.opsetImport.length; ++e3) if (n3 = l2.onnx.OperatorSetIdProto.verify(t4.opsetImport[e3])) return "opsetImport." + n3;
          }
          if (null != t4.producerName && t4.hasOwnProperty("producerName") && !c2.isString(t4.producerName)) return "producerName: string expected";
          if (null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && !c2.isString(t4.producerVersion)) return "producerVersion: string expected";
          if (null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain)) return "domain: string expected";
          if (null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && !(c2.isInteger(t4.modelVersion) || t4.modelVersion && c2.isInteger(t4.modelVersion.low) && c2.isInteger(t4.modelVersion.high))) return "modelVersion: integer|Long expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.graph && t4.hasOwnProperty("graph") && (n3 = l2.onnx.GraphProto.verify(t4.graph))) return "graph." + n3;
          if (null != t4.metadataProps && t4.hasOwnProperty("metadataProps")) {
            if (!Array.isArray(t4.metadataProps)) return "metadataProps: array expected";
            for (e3 = 0; e3 < t4.metadataProps.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.StringStringEntryProto.verify(t4.metadataProps[e3])) return "metadataProps." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.ModelProto) return t4;
          var e3 = new l2.onnx.ModelProto();
          if (null != t4.irVersion && (c2.Long ? (e3.irVersion = c2.Long.fromValue(t4.irVersion)).unsigned = false : "string" == typeof t4.irVersion ? e3.irVersion = parseInt(t4.irVersion, 10) : "number" == typeof t4.irVersion ? e3.irVersion = t4.irVersion : "object" == typeof t4.irVersion && (e3.irVersion = new c2.LongBits(t4.irVersion.low >>> 0, t4.irVersion.high >>> 0).toNumber())), t4.opsetImport) {
            if (!Array.isArray(t4.opsetImport)) throw TypeError(".onnx.ModelProto.opsetImport: array expected");
            e3.opsetImport = [];
            for (var n3 = 0; n3 < t4.opsetImport.length; ++n3) {
              if ("object" != typeof t4.opsetImport[n3]) throw TypeError(".onnx.ModelProto.opsetImport: object expected");
              e3.opsetImport[n3] = l2.onnx.OperatorSetIdProto.fromObject(t4.opsetImport[n3]);
            }
          }
          if (null != t4.producerName && (e3.producerName = String(t4.producerName)), null != t4.producerVersion && (e3.producerVersion = String(t4.producerVersion)), null != t4.domain && (e3.domain = String(t4.domain)), null != t4.modelVersion && (c2.Long ? (e3.modelVersion = c2.Long.fromValue(t4.modelVersion)).unsigned = false : "string" == typeof t4.modelVersion ? e3.modelVersion = parseInt(t4.modelVersion, 10) : "number" == typeof t4.modelVersion ? e3.modelVersion = t4.modelVersion : "object" == typeof t4.modelVersion && (e3.modelVersion = new c2.LongBits(t4.modelVersion.low >>> 0, t4.modelVersion.high >>> 0).toNumber())), null != t4.docString && (e3.docString = String(t4.docString)), null != t4.graph) {
            if ("object" != typeof t4.graph) throw TypeError(".onnx.ModelProto.graph: object expected");
            e3.graph = l2.onnx.GraphProto.fromObject(t4.graph);
          }
          if (t4.metadataProps) {
            if (!Array.isArray(t4.metadataProps)) throw TypeError(".onnx.ModelProto.metadataProps: array expected");
            for (e3.metadataProps = [], n3 = 0; n3 < t4.metadataProps.length; ++n3) {
              if ("object" != typeof t4.metadataProps[n3]) throw TypeError(".onnx.ModelProto.metadataProps: object expected");
              e3.metadataProps[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.metadataProps[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.opsetImport = [], n3.metadataProps = []), e3.defaults) {
            if (c2.Long) {
              var r3 = new c2.Long(0, 0, false);
              n3.irVersion = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
            } else n3.irVersion = e3.longs === String ? "0" : 0;
            n3.producerName = "", n3.producerVersion = "", n3.domain = "", c2.Long ? (r3 = new c2.Long(0, 0, false), n3.modelVersion = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3) : n3.modelVersion = e3.longs === String ? "0" : 0, n3.docString = "", n3.graph = null;
          }
          if (null != t4.irVersion && t4.hasOwnProperty("irVersion") && ("number" == typeof t4.irVersion ? n3.irVersion = e3.longs === String ? String(t4.irVersion) : t4.irVersion : n3.irVersion = e3.longs === String ? c2.Long.prototype.toString.call(t4.irVersion) : e3.longs === Number ? new c2.LongBits(t4.irVersion.low >>> 0, t4.irVersion.high >>> 0).toNumber() : t4.irVersion), null != t4.producerName && t4.hasOwnProperty("producerName") && (n3.producerName = t4.producerName), null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && (n3.producerVersion = t4.producerVersion), null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && ("number" == typeof t4.modelVersion ? n3.modelVersion = e3.longs === String ? String(t4.modelVersion) : t4.modelVersion : n3.modelVersion = e3.longs === String ? c2.Long.prototype.toString.call(t4.modelVersion) : e3.longs === Number ? new c2.LongBits(t4.modelVersion.low >>> 0, t4.modelVersion.high >>> 0).toNumber() : t4.modelVersion), null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.graph && t4.hasOwnProperty("graph") && (n3.graph = l2.onnx.GraphProto.toObject(t4.graph, e3)), t4.opsetImport && t4.opsetImport.length) {
            n3.opsetImport = [];
            for (var i3 = 0; i3 < t4.opsetImport.length; ++i3) n3.opsetImport[i3] = l2.onnx.OperatorSetIdProto.toObject(t4.opsetImport[i3], e3);
          }
          if (t4.metadataProps && t4.metadataProps.length) for (n3.metadataProps = [], i3 = 0; i3 < t4.metadataProps.length; ++i3) n3.metadataProps[i3] = l2.onnx.StringStringEntryProto.toObject(t4.metadataProps[i3], e3);
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.StringStringEntryProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.key = "", t3.prototype.value = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.key && t4.hasOwnProperty("key") && e3.uint32(10).string(t4.key), null != t4.value && t4.hasOwnProperty("value") && e3.uint32(18).string(t4.value), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.StringStringEntryProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.key = t4.string();
                break;
              case 2:
                r3.value = t4.string();
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.key && t4.hasOwnProperty("key") && !c2.isString(t4.key) ? "key: string expected" : null != t4.value && t4.hasOwnProperty("value") && !c2.isString(t4.value) ? "value: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.StringStringEntryProto) return t4;
          var e3 = new l2.onnx.StringStringEntryProto();
          return null != t4.key && (e3.key = String(t4.key)), null != t4.value && (e3.value = String(t4.value)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          return e3.defaults && (n3.key = "", n3.value = ""), null != t4.key && t4.hasOwnProperty("key") && (n3.key = t4.key), null != t4.value && t4.hasOwnProperty("value") && (n3.value = t4.value), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.TensorAnnotation = function() {
        function t3(t4) {
          if (this.quantParameterTensorNames = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.tensorName = "", t3.prototype.quantParameterTensorNames = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.tensorName && t4.hasOwnProperty("tensorName") && e3.uint32(10).string(t4.tensorName), null != t4.quantParameterTensorNames && t4.quantParameterTensorNames.length) for (var n3 = 0; n3 < t4.quantParameterTensorNames.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.quantParameterTensorNames[n3], e3.uint32(18).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorAnnotation(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.tensorName = t4.string();
                break;
              case 2:
                r3.quantParameterTensorNames && r3.quantParameterTensorNames.length || (r3.quantParameterTensorNames = []), r3.quantParameterTensorNames.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.tensorName && t4.hasOwnProperty("tensorName") && !c2.isString(t4.tensorName)) return "tensorName: string expected";
          if (null != t4.quantParameterTensorNames && t4.hasOwnProperty("quantParameterTensorNames")) {
            if (!Array.isArray(t4.quantParameterTensorNames)) return "quantParameterTensorNames: array expected";
            for (var e3 = 0; e3 < t4.quantParameterTensorNames.length; ++e3) {
              var n3 = l2.onnx.StringStringEntryProto.verify(t4.quantParameterTensorNames[e3]);
              if (n3) return "quantParameterTensorNames." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorAnnotation) return t4;
          var e3 = new l2.onnx.TensorAnnotation();
          if (null != t4.tensorName && (e3.tensorName = String(t4.tensorName)), t4.quantParameterTensorNames) {
            if (!Array.isArray(t4.quantParameterTensorNames)) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
            e3.quantParameterTensorNames = [];
            for (var n3 = 0; n3 < t4.quantParameterTensorNames.length; ++n3) {
              if ("object" != typeof t4.quantParameterTensorNames[n3]) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
              e3.quantParameterTensorNames[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.quantParameterTensorNames[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.quantParameterTensorNames = []), e3.defaults && (n3.tensorName = ""), null != t4.tensorName && t4.hasOwnProperty("tensorName") && (n3.tensorName = t4.tensorName), t4.quantParameterTensorNames && t4.quantParameterTensorNames.length) {
            n3.quantParameterTensorNames = [];
            for (var r3 = 0; r3 < t4.quantParameterTensorNames.length; ++r3) n3.quantParameterTensorNames[r3] = l2.onnx.StringStringEntryProto.toObject(t4.quantParameterTensorNames[r3], e3);
          }
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.GraphProto = function() {
        function t3(t4) {
          if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.node = c2.emptyArray, t3.prototype.name = "", t3.prototype.initializer = c2.emptyArray, t3.prototype.docString = "", t3.prototype.input = c2.emptyArray, t3.prototype.output = c2.emptyArray, t3.prototype.valueInfo = c2.emptyArray, t3.prototype.quantizationAnnotation = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.node && t4.node.length) for (var n3 = 0; n3 < t4.node.length; ++n3) l2.onnx.NodeProto.encode(t4.node[n3], e3.uint32(10).fork()).ldelim();
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(18).string(t4.name), null != t4.initializer && t4.initializer.length) for (n3 = 0; n3 < t4.initializer.length; ++n3) l2.onnx.TensorProto.encode(t4.initializer[n3], e3.uint32(42).fork()).ldelim();
          if (null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(82).string(t4.docString), null != t4.input && t4.input.length) for (n3 = 0; n3 < t4.input.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.input[n3], e3.uint32(90).fork()).ldelim();
          if (null != t4.output && t4.output.length) for (n3 = 0; n3 < t4.output.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.output[n3], e3.uint32(98).fork()).ldelim();
          if (null != t4.valueInfo && t4.valueInfo.length) for (n3 = 0; n3 < t4.valueInfo.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.valueInfo[n3], e3.uint32(106).fork()).ldelim();
          if (null != t4.quantizationAnnotation && t4.quantizationAnnotation.length) for (n3 = 0; n3 < t4.quantizationAnnotation.length; ++n3) l2.onnx.TensorAnnotation.encode(t4.quantizationAnnotation[n3], e3.uint32(114).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.GraphProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.node && r3.node.length || (r3.node = []), r3.node.push(l2.onnx.NodeProto.decode(t4, t4.uint32()));
                break;
              case 2:
                r3.name = t4.string();
                break;
              case 5:
                r3.initializer && r3.initializer.length || (r3.initializer = []), r3.initializer.push(l2.onnx.TensorProto.decode(t4, t4.uint32()));
                break;
              case 10:
                r3.docString = t4.string();
                break;
              case 11:
                r3.input && r3.input.length || (r3.input = []), r3.input.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 12:
                r3.output && r3.output.length || (r3.output = []), r3.output.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 13:
                r3.valueInfo && r3.valueInfo.length || (r3.valueInfo = []), r3.valueInfo.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 14:
                r3.quantizationAnnotation && r3.quantizationAnnotation.length || (r3.quantizationAnnotation = []), r3.quantizationAnnotation.push(l2.onnx.TensorAnnotation.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.node && t4.hasOwnProperty("node")) {
            if (!Array.isArray(t4.node)) return "node: array expected";
            for (var e3 = 0; e3 < t4.node.length; ++e3) if (n3 = l2.onnx.NodeProto.verify(t4.node[e3])) return "node." + n3;
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.initializer && t4.hasOwnProperty("initializer")) {
            if (!Array.isArray(t4.initializer)) return "initializer: array expected";
            for (e3 = 0; e3 < t4.initializer.length; ++e3) if (n3 = l2.onnx.TensorProto.verify(t4.initializer[e3])) return "initializer." + n3;
          }
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.input && t4.hasOwnProperty("input")) {
            if (!Array.isArray(t4.input)) return "input: array expected";
            for (e3 = 0; e3 < t4.input.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.input[e3])) return "input." + n3;
          }
          if (null != t4.output && t4.hasOwnProperty("output")) {
            if (!Array.isArray(t4.output)) return "output: array expected";
            for (e3 = 0; e3 < t4.output.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.output[e3])) return "output." + n3;
          }
          if (null != t4.valueInfo && t4.hasOwnProperty("valueInfo")) {
            if (!Array.isArray(t4.valueInfo)) return "valueInfo: array expected";
            for (e3 = 0; e3 < t4.valueInfo.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.valueInfo[e3])) return "valueInfo." + n3;
          }
          if (null != t4.quantizationAnnotation && t4.hasOwnProperty("quantizationAnnotation")) {
            if (!Array.isArray(t4.quantizationAnnotation)) return "quantizationAnnotation: array expected";
            for (e3 = 0; e3 < t4.quantizationAnnotation.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.TensorAnnotation.verify(t4.quantizationAnnotation[e3])) return "quantizationAnnotation." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.GraphProto) return t4;
          var e3 = new l2.onnx.GraphProto();
          if (t4.node) {
            if (!Array.isArray(t4.node)) throw TypeError(".onnx.GraphProto.node: array expected");
            e3.node = [];
            for (var n3 = 0; n3 < t4.node.length; ++n3) {
              if ("object" != typeof t4.node[n3]) throw TypeError(".onnx.GraphProto.node: object expected");
              e3.node[n3] = l2.onnx.NodeProto.fromObject(t4.node[n3]);
            }
          }
          if (null != t4.name && (e3.name = String(t4.name)), t4.initializer) {
            if (!Array.isArray(t4.initializer)) throw TypeError(".onnx.GraphProto.initializer: array expected");
            for (e3.initializer = [], n3 = 0; n3 < t4.initializer.length; ++n3) {
              if ("object" != typeof t4.initializer[n3]) throw TypeError(".onnx.GraphProto.initializer: object expected");
              e3.initializer[n3] = l2.onnx.TensorProto.fromObject(t4.initializer[n3]);
            }
          }
          if (null != t4.docString && (e3.docString = String(t4.docString)), t4.input) {
            if (!Array.isArray(t4.input)) throw TypeError(".onnx.GraphProto.input: array expected");
            for (e3.input = [], n3 = 0; n3 < t4.input.length; ++n3) {
              if ("object" != typeof t4.input[n3]) throw TypeError(".onnx.GraphProto.input: object expected");
              e3.input[n3] = l2.onnx.ValueInfoProto.fromObject(t4.input[n3]);
            }
          }
          if (t4.output) {
            if (!Array.isArray(t4.output)) throw TypeError(".onnx.GraphProto.output: array expected");
            for (e3.output = [], n3 = 0; n3 < t4.output.length; ++n3) {
              if ("object" != typeof t4.output[n3]) throw TypeError(".onnx.GraphProto.output: object expected");
              e3.output[n3] = l2.onnx.ValueInfoProto.fromObject(t4.output[n3]);
            }
          }
          if (t4.valueInfo) {
            if (!Array.isArray(t4.valueInfo)) throw TypeError(".onnx.GraphProto.valueInfo: array expected");
            for (e3.valueInfo = [], n3 = 0; n3 < t4.valueInfo.length; ++n3) {
              if ("object" != typeof t4.valueInfo[n3]) throw TypeError(".onnx.GraphProto.valueInfo: object expected");
              e3.valueInfo[n3] = l2.onnx.ValueInfoProto.fromObject(t4.valueInfo[n3]);
            }
          }
          if (t4.quantizationAnnotation) {
            if (!Array.isArray(t4.quantizationAnnotation)) throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
            for (e3.quantizationAnnotation = [], n3 = 0; n3 < t4.quantizationAnnotation.length; ++n3) {
              if ("object" != typeof t4.quantizationAnnotation[n3]) throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
              e3.quantizationAnnotation[n3] = l2.onnx.TensorAnnotation.fromObject(t4.quantizationAnnotation[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.node = [], n3.initializer = [], n3.input = [], n3.output = [], n3.valueInfo = [], n3.quantizationAnnotation = []), e3.defaults && (n3.name = "", n3.docString = ""), t4.node && t4.node.length) {
            n3.node = [];
            for (var r3 = 0; r3 < t4.node.length; ++r3) n3.node[r3] = l2.onnx.NodeProto.toObject(t4.node[r3], e3);
          }
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), t4.initializer && t4.initializer.length) for (n3.initializer = [], r3 = 0; r3 < t4.initializer.length; ++r3) n3.initializer[r3] = l2.onnx.TensorProto.toObject(t4.initializer[r3], e3);
          if (null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), t4.input && t4.input.length) for (n3.input = [], r3 = 0; r3 < t4.input.length; ++r3) n3.input[r3] = l2.onnx.ValueInfoProto.toObject(t4.input[r3], e3);
          if (t4.output && t4.output.length) for (n3.output = [], r3 = 0; r3 < t4.output.length; ++r3) n3.output[r3] = l2.onnx.ValueInfoProto.toObject(t4.output[r3], e3);
          if (t4.valueInfo && t4.valueInfo.length) for (n3.valueInfo = [], r3 = 0; r3 < t4.valueInfo.length; ++r3) n3.valueInfo[r3] = l2.onnx.ValueInfoProto.toObject(t4.valueInfo[r3], e3);
          if (t4.quantizationAnnotation && t4.quantizationAnnotation.length) for (n3.quantizationAnnotation = [], r3 = 0; r3 < t4.quantizationAnnotation.length; ++r3) n3.quantizationAnnotation[r3] = l2.onnx.TensorAnnotation.toObject(t4.quantizationAnnotation[r3], e3);
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2.TensorProto = function() {
        function t3(t4) {
          if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.dims = c2.emptyArray, t3.prototype.dataType = 0, t3.prototype.segment = null, t3.prototype.floatData = c2.emptyArray, t3.prototype.int32Data = c2.emptyArray, t3.prototype.stringData = c2.emptyArray, t3.prototype.int64Data = c2.emptyArray, t3.prototype.name = "", t3.prototype.docString = "", t3.prototype.rawData = c2.newBuffer([]), t3.prototype.externalData = c2.emptyArray, t3.prototype.dataLocation = 0, t3.prototype.doubleData = c2.emptyArray, t3.prototype.uint64Data = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.dims && t4.dims.length) {
            e3.uint32(10).fork();
            for (var n3 = 0; n3 < t4.dims.length; ++n3) e3.int64(t4.dims[n3]);
            e3.ldelim();
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && e3.uint32(16).int32(t4.dataType), null != t4.segment && t4.hasOwnProperty("segment") && l2.onnx.TensorProto.Segment.encode(t4.segment, e3.uint32(26).fork()).ldelim(), null != t4.floatData && t4.floatData.length) {
            for (e3.uint32(34).fork(), n3 = 0; n3 < t4.floatData.length; ++n3) e3.float(t4.floatData[n3]);
            e3.ldelim();
          }
          if (null != t4.int32Data && t4.int32Data.length) {
            for (e3.uint32(42).fork(), n3 = 0; n3 < t4.int32Data.length; ++n3) e3.int32(t4.int32Data[n3]);
            e3.ldelim();
          }
          if (null != t4.stringData && t4.stringData.length) for (n3 = 0; n3 < t4.stringData.length; ++n3) e3.uint32(50).bytes(t4.stringData[n3]);
          if (null != t4.int64Data && t4.int64Data.length) {
            for (e3.uint32(58).fork(), n3 = 0; n3 < t4.int64Data.length; ++n3) e3.int64(t4.int64Data[n3]);
            e3.ldelim();
          }
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(66).string(t4.name), null != t4.rawData && t4.hasOwnProperty("rawData") && e3.uint32(74).bytes(t4.rawData), null != t4.doubleData && t4.doubleData.length) {
            for (e3.uint32(82).fork(), n3 = 0; n3 < t4.doubleData.length; ++n3) e3.double(t4.doubleData[n3]);
            e3.ldelim();
          }
          if (null != t4.uint64Data && t4.uint64Data.length) {
            for (e3.uint32(90).fork(), n3 = 0; n3 < t4.uint64Data.length; ++n3) e3.uint64(t4.uint64Data[n3]);
            e3.ldelim();
          }
          if (null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(98).string(t4.docString), null != t4.externalData && t4.externalData.length) for (n3 = 0; n3 < t4.externalData.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.externalData[n3], e3.uint32(106).fork()).ldelim();
          return null != t4.dataLocation && t4.hasOwnProperty("dataLocation") && e3.uint32(112).int32(t4.dataLocation), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                if (r3.dims && r3.dims.length || (r3.dims = []), 2 == (7 & i3)) for (var o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.dims.push(t4.int64());
                else r3.dims.push(t4.int64());
                break;
              case 2:
                r3.dataType = t4.int32();
                break;
              case 3:
                r3.segment = l2.onnx.TensorProto.Segment.decode(t4, t4.uint32());
                break;
              case 4:
                if (r3.floatData && r3.floatData.length || (r3.floatData = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.floatData.push(t4.float());
                else r3.floatData.push(t4.float());
                break;
              case 5:
                if (r3.int32Data && r3.int32Data.length || (r3.int32Data = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.int32Data.push(t4.int32());
                else r3.int32Data.push(t4.int32());
                break;
              case 6:
                r3.stringData && r3.stringData.length || (r3.stringData = []), r3.stringData.push(t4.bytes());
                break;
              case 7:
                if (r3.int64Data && r3.int64Data.length || (r3.int64Data = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.int64Data.push(t4.int64());
                else r3.int64Data.push(t4.int64());
                break;
              case 8:
                r3.name = t4.string();
                break;
              case 12:
                r3.docString = t4.string();
                break;
              case 9:
                r3.rawData = t4.bytes();
                break;
              case 13:
                r3.externalData && r3.externalData.length || (r3.externalData = []), r3.externalData.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              case 14:
                r3.dataLocation = t4.int32();
                break;
              case 10:
                if (r3.doubleData && r3.doubleData.length || (r3.doubleData = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.doubleData.push(t4.double());
                else r3.doubleData.push(t4.double());
                break;
              case 11:
                if (r3.uint64Data && r3.uint64Data.length || (r3.uint64Data = []), 2 == (7 & i3)) for (o3 = t4.uint32() + t4.pos; t4.pos < o3; ) r3.uint64Data.push(t4.uint64());
                else r3.uint64Data.push(t4.uint64());
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.dims && t4.hasOwnProperty("dims")) {
            if (!Array.isArray(t4.dims)) return "dims: array expected";
            for (var e3 = 0; e3 < t4.dims.length; ++e3) if (!(c2.isInteger(t4.dims[e3]) || t4.dims[e3] && c2.isInteger(t4.dims[e3].low) && c2.isInteger(t4.dims[e3].high))) return "dims: integer|Long[] expected";
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && !c2.isInteger(t4.dataType)) return "dataType: integer expected";
          if (null != t4.segment && t4.hasOwnProperty("segment") && (n3 = l2.onnx.TensorProto.Segment.verify(t4.segment))) return "segment." + n3;
          if (null != t4.floatData && t4.hasOwnProperty("floatData")) {
            if (!Array.isArray(t4.floatData)) return "floatData: array expected";
            for (e3 = 0; e3 < t4.floatData.length; ++e3) if ("number" != typeof t4.floatData[e3]) return "floatData: number[] expected";
          }
          if (null != t4.int32Data && t4.hasOwnProperty("int32Data")) {
            if (!Array.isArray(t4.int32Data)) return "int32Data: array expected";
            for (e3 = 0; e3 < t4.int32Data.length; ++e3) if (!c2.isInteger(t4.int32Data[e3])) return "int32Data: integer[] expected";
          }
          if (null != t4.stringData && t4.hasOwnProperty("stringData")) {
            if (!Array.isArray(t4.stringData)) return "stringData: array expected";
            for (e3 = 0; e3 < t4.stringData.length; ++e3) if (!(t4.stringData[e3] && "number" == typeof t4.stringData[e3].length || c2.isString(t4.stringData[e3]))) return "stringData: buffer[] expected";
          }
          if (null != t4.int64Data && t4.hasOwnProperty("int64Data")) {
            if (!Array.isArray(t4.int64Data)) return "int64Data: array expected";
            for (e3 = 0; e3 < t4.int64Data.length; ++e3) if (!(c2.isInteger(t4.int64Data[e3]) || t4.int64Data[e3] && c2.isInteger(t4.int64Data[e3].low) && c2.isInteger(t4.int64Data[e3].high))) return "int64Data: integer|Long[] expected";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.rawData && t4.hasOwnProperty("rawData") && !(t4.rawData && "number" == typeof t4.rawData.length || c2.isString(t4.rawData))) return "rawData: buffer expected";
          if (null != t4.externalData && t4.hasOwnProperty("externalData")) {
            if (!Array.isArray(t4.externalData)) return "externalData: array expected";
            for (e3 = 0; e3 < t4.externalData.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.StringStringEntryProto.verify(t4.externalData[e3])) return "externalData." + n3;
            }
          }
          if (null != t4.dataLocation && t4.hasOwnProperty("dataLocation")) switch (t4.dataLocation) {
            default:
              return "dataLocation: enum value expected";
            case 0:
            case 1:
          }
          if (null != t4.doubleData && t4.hasOwnProperty("doubleData")) {
            if (!Array.isArray(t4.doubleData)) return "doubleData: array expected";
            for (e3 = 0; e3 < t4.doubleData.length; ++e3) if ("number" != typeof t4.doubleData[e3]) return "doubleData: number[] expected";
          }
          if (null != t4.uint64Data && t4.hasOwnProperty("uint64Data")) {
            if (!Array.isArray(t4.uint64Data)) return "uint64Data: array expected";
            for (e3 = 0; e3 < t4.uint64Data.length; ++e3) if (!(c2.isInteger(t4.uint64Data[e3]) || t4.uint64Data[e3] && c2.isInteger(t4.uint64Data[e3].low) && c2.isInteger(t4.uint64Data[e3].high))) return "uint64Data: integer|Long[] expected";
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorProto) return t4;
          var e3 = new l2.onnx.TensorProto();
          if (t4.dims) {
            if (!Array.isArray(t4.dims)) throw TypeError(".onnx.TensorProto.dims: array expected");
            e3.dims = [];
            for (var n3 = 0; n3 < t4.dims.length; ++n3) c2.Long ? (e3.dims[n3] = c2.Long.fromValue(t4.dims[n3])).unsigned = false : "string" == typeof t4.dims[n3] ? e3.dims[n3] = parseInt(t4.dims[n3], 10) : "number" == typeof t4.dims[n3] ? e3.dims[n3] = t4.dims[n3] : "object" == typeof t4.dims[n3] && (e3.dims[n3] = new c2.LongBits(t4.dims[n3].low >>> 0, t4.dims[n3].high >>> 0).toNumber());
          }
          if (null != t4.dataType && (e3.dataType = 0 | t4.dataType), null != t4.segment) {
            if ("object" != typeof t4.segment) throw TypeError(".onnx.TensorProto.segment: object expected");
            e3.segment = l2.onnx.TensorProto.Segment.fromObject(t4.segment);
          }
          if (t4.floatData) {
            if (!Array.isArray(t4.floatData)) throw TypeError(".onnx.TensorProto.floatData: array expected");
            for (e3.floatData = [], n3 = 0; n3 < t4.floatData.length; ++n3) e3.floatData[n3] = Number(t4.floatData[n3]);
          }
          if (t4.int32Data) {
            if (!Array.isArray(t4.int32Data)) throw TypeError(".onnx.TensorProto.int32Data: array expected");
            for (e3.int32Data = [], n3 = 0; n3 < t4.int32Data.length; ++n3) e3.int32Data[n3] = 0 | t4.int32Data[n3];
          }
          if (t4.stringData) {
            if (!Array.isArray(t4.stringData)) throw TypeError(".onnx.TensorProto.stringData: array expected");
            for (e3.stringData = [], n3 = 0; n3 < t4.stringData.length; ++n3) "string" == typeof t4.stringData[n3] ? c2.base64.decode(t4.stringData[n3], e3.stringData[n3] = c2.newBuffer(c2.base64.length(t4.stringData[n3])), 0) : t4.stringData[n3].length && (e3.stringData[n3] = t4.stringData[n3]);
          }
          if (t4.int64Data) {
            if (!Array.isArray(t4.int64Data)) throw TypeError(".onnx.TensorProto.int64Data: array expected");
            for (e3.int64Data = [], n3 = 0; n3 < t4.int64Data.length; ++n3) c2.Long ? (e3.int64Data[n3] = c2.Long.fromValue(t4.int64Data[n3])).unsigned = false : "string" == typeof t4.int64Data[n3] ? e3.int64Data[n3] = parseInt(t4.int64Data[n3], 10) : "number" == typeof t4.int64Data[n3] ? e3.int64Data[n3] = t4.int64Data[n3] : "object" == typeof t4.int64Data[n3] && (e3.int64Data[n3] = new c2.LongBits(t4.int64Data[n3].low >>> 0, t4.int64Data[n3].high >>> 0).toNumber());
          }
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.docString && (e3.docString = String(t4.docString)), null != t4.rawData && ("string" == typeof t4.rawData ? c2.base64.decode(t4.rawData, e3.rawData = c2.newBuffer(c2.base64.length(t4.rawData)), 0) : t4.rawData.length && (e3.rawData = t4.rawData)), t4.externalData) {
            if (!Array.isArray(t4.externalData)) throw TypeError(".onnx.TensorProto.externalData: array expected");
            for (e3.externalData = [], n3 = 0; n3 < t4.externalData.length; ++n3) {
              if ("object" != typeof t4.externalData[n3]) throw TypeError(".onnx.TensorProto.externalData: object expected");
              e3.externalData[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.externalData[n3]);
            }
          }
          switch (t4.dataLocation) {
            case "DEFAULT":
            case 0:
              e3.dataLocation = 0;
              break;
            case "EXTERNAL":
            case 1:
              e3.dataLocation = 1;
          }
          if (t4.doubleData) {
            if (!Array.isArray(t4.doubleData)) throw TypeError(".onnx.TensorProto.doubleData: array expected");
            for (e3.doubleData = [], n3 = 0; n3 < t4.doubleData.length; ++n3) e3.doubleData[n3] = Number(t4.doubleData[n3]);
          }
          if (t4.uint64Data) {
            if (!Array.isArray(t4.uint64Data)) throw TypeError(".onnx.TensorProto.uint64Data: array expected");
            for (e3.uint64Data = [], n3 = 0; n3 < t4.uint64Data.length; ++n3) c2.Long ? (e3.uint64Data[n3] = c2.Long.fromValue(t4.uint64Data[n3])).unsigned = true : "string" == typeof t4.uint64Data[n3] ? e3.uint64Data[n3] = parseInt(t4.uint64Data[n3], 10) : "number" == typeof t4.uint64Data[n3] ? e3.uint64Data[n3] = t4.uint64Data[n3] : "object" == typeof t4.uint64Data[n3] && (e3.uint64Data[n3] = new c2.LongBits(t4.uint64Data[n3].low >>> 0, t4.uint64Data[n3].high >>> 0).toNumber(true));
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.dims = [], n3.floatData = [], n3.int32Data = [], n3.stringData = [], n3.int64Data = [], n3.doubleData = [], n3.uint64Data = [], n3.externalData = []), e3.defaults && (n3.dataType = 0, n3.segment = null, n3.name = "", e3.bytes === String ? n3.rawData = "" : (n3.rawData = [], e3.bytes !== Array && (n3.rawData = c2.newBuffer(n3.rawData))), n3.docString = "", n3.dataLocation = e3.enums === String ? "DEFAULT" : 0), t4.dims && t4.dims.length) {
            n3.dims = [];
            for (var r3 = 0; r3 < t4.dims.length; ++r3) "number" == typeof t4.dims[r3] ? n3.dims[r3] = e3.longs === String ? String(t4.dims[r3]) : t4.dims[r3] : n3.dims[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.dims[r3]) : e3.longs === Number ? new c2.LongBits(t4.dims[r3].low >>> 0, t4.dims[r3].high >>> 0).toNumber() : t4.dims[r3];
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && (n3.dataType = t4.dataType), null != t4.segment && t4.hasOwnProperty("segment") && (n3.segment = l2.onnx.TensorProto.Segment.toObject(t4.segment, e3)), t4.floatData && t4.floatData.length) for (n3.floatData = [], r3 = 0; r3 < t4.floatData.length; ++r3) n3.floatData[r3] = e3.json && !isFinite(t4.floatData[r3]) ? String(t4.floatData[r3]) : t4.floatData[r3];
          if (t4.int32Data && t4.int32Data.length) for (n3.int32Data = [], r3 = 0; r3 < t4.int32Data.length; ++r3) n3.int32Data[r3] = t4.int32Data[r3];
          if (t4.stringData && t4.stringData.length) for (n3.stringData = [], r3 = 0; r3 < t4.stringData.length; ++r3) n3.stringData[r3] = e3.bytes === String ? c2.base64.encode(t4.stringData[r3], 0, t4.stringData[r3].length) : e3.bytes === Array ? Array.prototype.slice.call(t4.stringData[r3]) : t4.stringData[r3];
          if (t4.int64Data && t4.int64Data.length) for (n3.int64Data = [], r3 = 0; r3 < t4.int64Data.length; ++r3) "number" == typeof t4.int64Data[r3] ? n3.int64Data[r3] = e3.longs === String ? String(t4.int64Data[r3]) : t4.int64Data[r3] : n3.int64Data[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.int64Data[r3]) : e3.longs === Number ? new c2.LongBits(t4.int64Data[r3].low >>> 0, t4.int64Data[r3].high >>> 0).toNumber() : t4.int64Data[r3];
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.rawData && t4.hasOwnProperty("rawData") && (n3.rawData = e3.bytes === String ? c2.base64.encode(t4.rawData, 0, t4.rawData.length) : e3.bytes === Array ? Array.prototype.slice.call(t4.rawData) : t4.rawData), t4.doubleData && t4.doubleData.length) for (n3.doubleData = [], r3 = 0; r3 < t4.doubleData.length; ++r3) n3.doubleData[r3] = e3.json && !isFinite(t4.doubleData[r3]) ? String(t4.doubleData[r3]) : t4.doubleData[r3];
          if (t4.uint64Data && t4.uint64Data.length) for (n3.uint64Data = [], r3 = 0; r3 < t4.uint64Data.length; ++r3) "number" == typeof t4.uint64Data[r3] ? n3.uint64Data[r3] = e3.longs === String ? String(t4.uint64Data[r3]) : t4.uint64Data[r3] : n3.uint64Data[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.uint64Data[r3]) : e3.longs === Number ? new c2.LongBits(t4.uint64Data[r3].low >>> 0, t4.uint64Data[r3].high >>> 0).toNumber(true) : t4.uint64Data[r3];
          if (null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), t4.externalData && t4.externalData.length) for (n3.externalData = [], r3 = 0; r3 < t4.externalData.length; ++r3) n3.externalData[r3] = l2.onnx.StringStringEntryProto.toObject(t4.externalData[r3], e3);
          return null != t4.dataLocation && t4.hasOwnProperty("dataLocation") && (n3.dataLocation = e3.enums === String ? l2.onnx.TensorProto.DataLocation[t4.dataLocation] : t4.dataLocation), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3.DataType = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "UNDEFINED"] = 0, e3[t4[1] = "FLOAT"] = 1, e3[t4[2] = "UINT8"] = 2, e3[t4[3] = "INT8"] = 3, e3[t4[4] = "UINT16"] = 4, e3[t4[5] = "INT16"] = 5, e3[t4[6] = "INT32"] = 6, e3[t4[7] = "INT64"] = 7, e3[t4[8] = "STRING"] = 8, e3[t4[9] = "BOOL"] = 9, e3[t4[10] = "FLOAT16"] = 10, e3[t4[11] = "DOUBLE"] = 11, e3[t4[12] = "UINT32"] = 12, e3[t4[13] = "UINT64"] = 13, e3[t4[14] = "COMPLEX64"] = 14, e3[t4[15] = "COMPLEX128"] = 15, e3[t4[16] = "BFLOAT16"] = 16, e3;
        }(), t3.Segment = function() {
          function t4(t5) {
            if (t5) for (var e3 = Object.keys(t5), n3 = 0; n3 < e3.length; ++n3) null != t5[e3[n3]] && (this[e3[n3]] = t5[e3[n3]]);
          }
          return t4.prototype.begin = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.prototype.end = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.create = function(e3) {
            return new t4(e3);
          }, t4.encode = function(t5, e3) {
            return e3 || (e3 = u2.create()), null != t5.begin && t5.hasOwnProperty("begin") && e3.uint32(8).int64(t5.begin), null != t5.end && t5.hasOwnProperty("end") && e3.uint32(16).int64(t5.end), e3;
          }, t4.encodeDelimited = function(t5, e3) {
            return this.encode(t5, e3).ldelim();
          }, t4.decode = function(t5, e3) {
            t5 instanceof s2 || (t5 = s2.create(t5));
            for (var n3 = void 0 === e3 ? t5.len : t5.pos + e3, r3 = new l2.onnx.TensorProto.Segment(); t5.pos < n3; ) {
              var i3 = t5.uint32();
              switch (i3 >>> 3) {
                case 1:
                  r3.begin = t5.int64();
                  break;
                case 2:
                  r3.end = t5.int64();
                  break;
                default:
                  t5.skipType(7 & i3);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s2 || (t5 = new s2(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            return "object" != typeof t5 || null === t5 ? "object expected" : null != t5.begin && t5.hasOwnProperty("begin") && !(c2.isInteger(t5.begin) || t5.begin && c2.isInteger(t5.begin.low) && c2.isInteger(t5.begin.high)) ? "begin: integer|Long expected" : null != t5.end && t5.hasOwnProperty("end") && !(c2.isInteger(t5.end) || t5.end && c2.isInteger(t5.end.low) && c2.isInteger(t5.end.high)) ? "end: integer|Long expected" : null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TensorProto.Segment) return t5;
            var e3 = new l2.onnx.TensorProto.Segment();
            return null != t5.begin && (c2.Long ? (e3.begin = c2.Long.fromValue(t5.begin)).unsigned = false : "string" == typeof t5.begin ? e3.begin = parseInt(t5.begin, 10) : "number" == typeof t5.begin ? e3.begin = t5.begin : "object" == typeof t5.begin && (e3.begin = new c2.LongBits(t5.begin.low >>> 0, t5.begin.high >>> 0).toNumber())), null != t5.end && (c2.Long ? (e3.end = c2.Long.fromValue(t5.end)).unsigned = false : "string" == typeof t5.end ? e3.end = parseInt(t5.end, 10) : "number" == typeof t5.end ? e3.end = t5.end : "object" == typeof t5.end && (e3.end = new c2.LongBits(t5.end.low >>> 0, t5.end.high >>> 0).toNumber())), e3;
          }, t4.toObject = function(t5, e3) {
            e3 || (e3 = {});
            var n3 = {};
            if (e3.defaults) {
              if (c2.Long) {
                var r3 = new c2.Long(0, 0, false);
                n3.begin = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
              } else n3.begin = e3.longs === String ? "0" : 0;
              c2.Long ? (r3 = new c2.Long(0, 0, false), n3.end = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3) : n3.end = e3.longs === String ? "0" : 0;
            }
            return null != t5.begin && t5.hasOwnProperty("begin") && ("number" == typeof t5.begin ? n3.begin = e3.longs === String ? String(t5.begin) : t5.begin : n3.begin = e3.longs === String ? c2.Long.prototype.toString.call(t5.begin) : e3.longs === Number ? new c2.LongBits(t5.begin.low >>> 0, t5.begin.high >>> 0).toNumber() : t5.begin), null != t5.end && t5.hasOwnProperty("end") && ("number" == typeof t5.end ? n3.end = e3.longs === String ? String(t5.end) : t5.end : n3.end = e3.longs === String ? c2.Long.prototype.toString.call(t5.end) : e3.longs === Number ? new c2.LongBits(t5.end.low >>> 0, t5.end.high >>> 0).toNumber() : t5.end), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a2.util.toJSONOptions);
          }, t4;
        }(), t3.DataLocation = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "DEFAULT"] = 0, e3[t4[1] = "EXTERNAL"] = 1, e3;
        }(), t3;
      }(), o2.TensorShapeProto = function() {
        function t3(t4) {
          if (this.dim = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.dim = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.dim && t4.dim.length) for (var n3 = 0; n3 < t4.dim.length; ++n3) l2.onnx.TensorShapeProto.Dimension.encode(t4.dim[n3], e3.uint32(10).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorShapeProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            i3 >>> 3 == 1 ? (r3.dim && r3.dim.length || (r3.dim = []), r3.dim.push(l2.onnx.TensorShapeProto.Dimension.decode(t4, t4.uint32()))) : t4.skipType(7 & i3);
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.dim && t4.hasOwnProperty("dim")) {
            if (!Array.isArray(t4.dim)) return "dim: array expected";
            for (var e3 = 0; e3 < t4.dim.length; ++e3) {
              var n3 = l2.onnx.TensorShapeProto.Dimension.verify(t4.dim[e3]);
              if (n3) return "dim." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorShapeProto) return t4;
          var e3 = new l2.onnx.TensorShapeProto();
          if (t4.dim) {
            if (!Array.isArray(t4.dim)) throw TypeError(".onnx.TensorShapeProto.dim: array expected");
            e3.dim = [];
            for (var n3 = 0; n3 < t4.dim.length; ++n3) {
              if ("object" != typeof t4.dim[n3]) throw TypeError(".onnx.TensorShapeProto.dim: object expected");
              e3.dim[n3] = l2.onnx.TensorShapeProto.Dimension.fromObject(t4.dim[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.dim = []), t4.dim && t4.dim.length) {
            n3.dim = [];
            for (var r3 = 0; r3 < t4.dim.length; ++r3) n3.dim[r3] = l2.onnx.TensorShapeProto.Dimension.toObject(t4.dim[r3], e3);
          }
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3.Dimension = function() {
          function t4(t5) {
            if (t5) for (var e4 = Object.keys(t5), n3 = 0; n3 < e4.length; ++n3) null != t5[e4[n3]] && (this[e4[n3]] = t5[e4[n3]]);
          }
          var e3;
          return t4.prototype.dimValue = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.prototype.dimParam = "", t4.prototype.denotation = "", Object.defineProperty(t4.prototype, "value", { get: c2.oneOfGetter(e3 = ["dimValue", "dimParam"]), set: c2.oneOfSetter(e3) }), t4.create = function(e4) {
            return new t4(e4);
          }, t4.encode = function(t5, e4) {
            return e4 || (e4 = u2.create()), null != t5.dimValue && t5.hasOwnProperty("dimValue") && e4.uint32(8).int64(t5.dimValue), null != t5.dimParam && t5.hasOwnProperty("dimParam") && e4.uint32(18).string(t5.dimParam), null != t5.denotation && t5.hasOwnProperty("denotation") && e4.uint32(26).string(t5.denotation), e4;
          }, t4.encodeDelimited = function(t5, e4) {
            return this.encode(t5, e4).ldelim();
          }, t4.decode = function(t5, e4) {
            t5 instanceof s2 || (t5 = s2.create(t5));
            for (var n3 = void 0 === e4 ? t5.len : t5.pos + e4, r3 = new l2.onnx.TensorShapeProto.Dimension(); t5.pos < n3; ) {
              var i3 = t5.uint32();
              switch (i3 >>> 3) {
                case 1:
                  r3.dimValue = t5.int64();
                  break;
                case 2:
                  r3.dimParam = t5.string();
                  break;
                case 3:
                  r3.denotation = t5.string();
                  break;
                default:
                  t5.skipType(7 & i3);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s2 || (t5 = new s2(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            if ("object" != typeof t5 || null === t5) return "object expected";
            var e4 = {};
            if (null != t5.dimValue && t5.hasOwnProperty("dimValue") && (e4.value = 1, !(c2.isInteger(t5.dimValue) || t5.dimValue && c2.isInteger(t5.dimValue.low) && c2.isInteger(t5.dimValue.high)))) return "dimValue: integer|Long expected";
            if (null != t5.dimParam && t5.hasOwnProperty("dimParam")) {
              if (1 === e4.value) return "value: multiple values";
              if (e4.value = 1, !c2.isString(t5.dimParam)) return "dimParam: string expected";
            }
            return null != t5.denotation && t5.hasOwnProperty("denotation") && !c2.isString(t5.denotation) ? "denotation: string expected" : null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TensorShapeProto.Dimension) return t5;
            var e4 = new l2.onnx.TensorShapeProto.Dimension();
            return null != t5.dimValue && (c2.Long ? (e4.dimValue = c2.Long.fromValue(t5.dimValue)).unsigned = false : "string" == typeof t5.dimValue ? e4.dimValue = parseInt(t5.dimValue, 10) : "number" == typeof t5.dimValue ? e4.dimValue = t5.dimValue : "object" == typeof t5.dimValue && (e4.dimValue = new c2.LongBits(t5.dimValue.low >>> 0, t5.dimValue.high >>> 0).toNumber())), null != t5.dimParam && (e4.dimParam = String(t5.dimParam)), null != t5.denotation && (e4.denotation = String(t5.denotation)), e4;
          }, t4.toObject = function(t5, e4) {
            e4 || (e4 = {});
            var n3 = {};
            return e4.defaults && (n3.denotation = ""), null != t5.dimValue && t5.hasOwnProperty("dimValue") && ("number" == typeof t5.dimValue ? n3.dimValue = e4.longs === String ? String(t5.dimValue) : t5.dimValue : n3.dimValue = e4.longs === String ? c2.Long.prototype.toString.call(t5.dimValue) : e4.longs === Number ? new c2.LongBits(t5.dimValue.low >>> 0, t5.dimValue.high >>> 0).toNumber() : t5.dimValue, e4.oneofs && (n3.value = "dimValue")), null != t5.dimParam && t5.hasOwnProperty("dimParam") && (n3.dimParam = t5.dimParam, e4.oneofs && (n3.value = "dimParam")), null != t5.denotation && t5.hasOwnProperty("denotation") && (n3.denotation = t5.denotation), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a2.util.toJSONOptions);
          }, t4;
        }(), t3;
      }(), o2.TypeProto = function() {
        function t3(t4) {
          if (t4) for (var e4 = Object.keys(t4), n3 = 0; n3 < e4.length; ++n3) null != t4[e4[n3]] && (this[e4[n3]] = t4[e4[n3]]);
        }
        var e3;
        return t3.prototype.tensorType = null, t3.prototype.denotation = "", Object.defineProperty(t3.prototype, "value", { get: c2.oneOfGetter(e3 = ["tensorType"]), set: c2.oneOfSetter(e3) }), t3.create = function(e4) {
          return new t3(e4);
        }, t3.encode = function(t4, e4) {
          return e4 || (e4 = u2.create()), null != t4.tensorType && t4.hasOwnProperty("tensorType") && l2.onnx.TypeProto.Tensor.encode(t4.tensorType, e4.uint32(10).fork()).ldelim(), null != t4.denotation && t4.hasOwnProperty("denotation") && e4.uint32(50).string(t4.denotation), e4;
        }, t3.encodeDelimited = function(t4, e4) {
          return this.encode(t4, e4).ldelim();
        }, t3.decode = function(t4, e4) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e4 ? t4.len : t4.pos + e4, r3 = new l2.onnx.TypeProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.tensorType = l2.onnx.TypeProto.Tensor.decode(t4, t4.uint32());
                break;
              case 6:
                r3.denotation = t4.string();
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.tensorType && t4.hasOwnProperty("tensorType")) {
            var e4 = l2.onnx.TypeProto.Tensor.verify(t4.tensorType);
            if (e4) return "tensorType." + e4;
          }
          return null != t4.denotation && t4.hasOwnProperty("denotation") && !c2.isString(t4.denotation) ? "denotation: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TypeProto) return t4;
          var e4 = new l2.onnx.TypeProto();
          if (null != t4.tensorType) {
            if ("object" != typeof t4.tensorType) throw TypeError(".onnx.TypeProto.tensorType: object expected");
            e4.tensorType = l2.onnx.TypeProto.Tensor.fromObject(t4.tensorType);
          }
          return null != t4.denotation && (e4.denotation = String(t4.denotation)), e4;
        }, t3.toObject = function(t4, e4) {
          e4 || (e4 = {});
          var n3 = {};
          return e4.defaults && (n3.denotation = ""), null != t4.tensorType && t4.hasOwnProperty("tensorType") && (n3.tensorType = l2.onnx.TypeProto.Tensor.toObject(t4.tensorType, e4), e4.oneofs && (n3.value = "tensorType")), null != t4.denotation && t4.hasOwnProperty("denotation") && (n3.denotation = t4.denotation), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3.Tensor = function() {
          function t4(t5) {
            if (t5) for (var e4 = Object.keys(t5), n3 = 0; n3 < e4.length; ++n3) null != t5[e4[n3]] && (this[e4[n3]] = t5[e4[n3]]);
          }
          return t4.prototype.elemType = 0, t4.prototype.shape = null, t4.create = function(e4) {
            return new t4(e4);
          }, t4.encode = function(t5, e4) {
            return e4 || (e4 = u2.create()), null != t5.elemType && t5.hasOwnProperty("elemType") && e4.uint32(8).int32(t5.elemType), null != t5.shape && t5.hasOwnProperty("shape") && l2.onnx.TensorShapeProto.encode(t5.shape, e4.uint32(18).fork()).ldelim(), e4;
          }, t4.encodeDelimited = function(t5, e4) {
            return this.encode(t5, e4).ldelim();
          }, t4.decode = function(t5, e4) {
            t5 instanceof s2 || (t5 = s2.create(t5));
            for (var n3 = void 0 === e4 ? t5.len : t5.pos + e4, r3 = new l2.onnx.TypeProto.Tensor(); t5.pos < n3; ) {
              var i3 = t5.uint32();
              switch (i3 >>> 3) {
                case 1:
                  r3.elemType = t5.int32();
                  break;
                case 2:
                  r3.shape = l2.onnx.TensorShapeProto.decode(t5, t5.uint32());
                  break;
                default:
                  t5.skipType(7 & i3);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s2 || (t5 = new s2(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            if ("object" != typeof t5 || null === t5) return "object expected";
            if (null != t5.elemType && t5.hasOwnProperty("elemType") && !c2.isInteger(t5.elemType)) return "elemType: integer expected";
            if (null != t5.shape && t5.hasOwnProperty("shape")) {
              var e4 = l2.onnx.TensorShapeProto.verify(t5.shape);
              if (e4) return "shape." + e4;
            }
            return null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TypeProto.Tensor) return t5;
            var e4 = new l2.onnx.TypeProto.Tensor();
            if (null != t5.elemType && (e4.elemType = 0 | t5.elemType), null != t5.shape) {
              if ("object" != typeof t5.shape) throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
              e4.shape = l2.onnx.TensorShapeProto.fromObject(t5.shape);
            }
            return e4;
          }, t4.toObject = function(t5, e4) {
            e4 || (e4 = {});
            var n3 = {};
            return e4.defaults && (n3.elemType = 0, n3.shape = null), null != t5.elemType && t5.hasOwnProperty("elemType") && (n3.elemType = t5.elemType), null != t5.shape && t5.hasOwnProperty("shape") && (n3.shape = l2.onnx.TensorShapeProto.toObject(t5.shape, e4)), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a2.util.toJSONOptions);
          }, t4;
        }(), t3;
      }(), o2.OperatorSetIdProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.domain = "", t3.prototype.version = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(10).string(t4.domain), null != t4.version && t4.hasOwnProperty("version") && e3.uint32(16).int64(t4.version), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s2 || (t4 = s2.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.OperatorSetIdProto(); t4.pos < n3; ) {
            var i3 = t4.uint32();
            switch (i3 >>> 3) {
              case 1:
                r3.domain = t4.string();
                break;
              case 2:
                r3.version = t4.int64();
                break;
              default:
                t4.skipType(7 & i3);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s2 || (t4 = new s2(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain) ? "domain: string expected" : null != t4.version && t4.hasOwnProperty("version") && !(c2.isInteger(t4.version) || t4.version && c2.isInteger(t4.version.low) && c2.isInteger(t4.version.high)) ? "version: integer|Long expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.OperatorSetIdProto) return t4;
          var e3 = new l2.onnx.OperatorSetIdProto();
          return null != t4.domain && (e3.domain = String(t4.domain)), null != t4.version && (c2.Long ? (e3.version = c2.Long.fromValue(t4.version)).unsigned = false : "string" == typeof t4.version ? e3.version = parseInt(t4.version, 10) : "number" == typeof t4.version ? e3.version = t4.version : "object" == typeof t4.version && (e3.version = new c2.LongBits(t4.version.low >>> 0, t4.version.high >>> 0).toNumber())), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if (e3.defaults) if (n3.domain = "", c2.Long) {
            var r3 = new c2.Long(0, 0, false);
            n3.version = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
          } else n3.version = e3.longs === String ? "0" : 0;
          return null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), null != t4.version && t4.hasOwnProperty("version") && ("number" == typeof t4.version ? n3.version = e3.longs === String ? String(t4.version) : t4.version : n3.version = e3.longs === String ? c2.Long.prototype.toString.call(t4.version) : e3.longs === Number ? new c2.LongBits(t4.version.low >>> 0, t4.version.high >>> 0).toNumber() : t4.version), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a2.util.toJSONOptions);
        }, t3;
      }(), o2), t2.exports = l2;
    }, 2100: (t2, e2, n2) => {
      t2.exports = n2(9482);
    }, 9482: (t2, e2, n2) => {
      var r2 = e2;
      function i2() {
        r2.util._configure(), r2.Writer._configure(r2.BufferWriter), r2.Reader._configure(r2.BufferReader);
      }
      r2.build = "minimal", r2.Writer = n2(1173), r2.BufferWriter = n2(3155), r2.Reader = n2(1408), r2.BufferReader = n2(593), r2.util = n2(9693), r2.rpc = n2(5994), r2.roots = n2(5054), r2.configure = i2, i2();
    }, 1408: (t2, e2, n2) => {
      t2.exports = u2;
      var r2, i2 = n2(9693), o2 = i2.LongBits, a2 = i2.utf8;
      function s2(t3, e3) {
        return RangeError("index out of range: " + t3.pos + " + " + (e3 || 1) + " > " + t3.len);
      }
      function u2(t3) {
        this.buf = t3, this.pos = 0, this.len = t3.length;
      }
      var c2, l2 = "undefined" != typeof Uint8Array ? function(t3) {
        if (t3 instanceof Uint8Array || Array.isArray(t3)) return new u2(t3);
        throw Error("illegal buffer");
      } : function(t3) {
        if (Array.isArray(t3)) return new u2(t3);
        throw Error("illegal buffer");
      }, p2 = function() {
        return i2.Buffer ? function(t3) {
          return (u2.create = function(t4) {
            return i2.Buffer.isBuffer(t4) ? new r2(t4) : l2(t4);
          })(t3);
        } : l2;
      };
      function f2() {
        var t3 = new o2(0, 0), e3 = 0;
        if (!(this.len - this.pos > 4)) {
          for (; e3 < 3; ++e3) {
            if (this.pos >= this.len) throw s2(this);
            if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * e3) >>> 0, this.buf[this.pos++] < 128) return t3;
          }
          return t3.lo = (t3.lo | (127 & this.buf[this.pos++]) << 7 * e3) >>> 0, t3;
        }
        for (; e3 < 4; ++e3) if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * e3) >>> 0, this.buf[this.pos++] < 128) return t3;
        if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t3.hi = (t3.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t3;
        if (e3 = 0, this.len - this.pos > 4) {
          for (; e3 < 5; ++e3) if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * e3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
        } else for (; e3 < 5; ++e3) {
          if (this.pos >= this.len) throw s2(this);
          if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * e3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
        }
        throw Error("invalid varint encoding");
      }
      function d2(t3, e3) {
        return (t3[e3 - 4] | t3[e3 - 3] << 8 | t3[e3 - 2] << 16 | t3[e3 - 1] << 24) >>> 0;
      }
      function h2() {
        if (this.pos + 8 > this.len) throw s2(this, 8);
        return new o2(d2(this.buf, this.pos += 4), d2(this.buf, this.pos += 4));
      }
      u2.create = p2(), u2.prototype._slice = i2.Array.prototype.subarray || i2.Array.prototype.slice, u2.prototype.uint32 = (c2 = 4294967295, function() {
        if (c2 = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c2;
        if ((this.pos += 5) > this.len) throw this.pos = this.len, s2(this, 10);
        return c2;
      }), u2.prototype.int32 = function() {
        return 0 | this.uint32();
      }, u2.prototype.sint32 = function() {
        var t3 = this.uint32();
        return t3 >>> 1 ^ -(1 & t3) | 0;
      }, u2.prototype.bool = function() {
        return 0 !== this.uint32();
      }, u2.prototype.fixed32 = function() {
        if (this.pos + 4 > this.len) throw s2(this, 4);
        return d2(this.buf, this.pos += 4);
      }, u2.prototype.sfixed32 = function() {
        if (this.pos + 4 > this.len) throw s2(this, 4);
        return 0 | d2(this.buf, this.pos += 4);
      }, u2.prototype.float = function() {
        if (this.pos + 4 > this.len) throw s2(this, 4);
        var t3 = i2.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, t3;
      }, u2.prototype.double = function() {
        if (this.pos + 8 > this.len) throw s2(this, 4);
        var t3 = i2.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, t3;
      }, u2.prototype.bytes = function() {
        var t3 = this.uint32(), e3 = this.pos, n3 = this.pos + t3;
        if (n3 > this.len) throw s2(this, t3);
        return this.pos += t3, Array.isArray(this.buf) ? this.buf.slice(e3, n3) : e3 === n3 ? new this.buf.constructor(0) : this._slice.call(this.buf, e3, n3);
      }, u2.prototype.string = function() {
        var t3 = this.bytes();
        return a2.read(t3, 0, t3.length);
      }, u2.prototype.skip = function(t3) {
        if ("number" == typeof t3) {
          if (this.pos + t3 > this.len) throw s2(this, t3);
          this.pos += t3;
        } else do {
          if (this.pos >= this.len) throw s2(this);
        } while (128 & this.buf[this.pos++]);
        return this;
      }, u2.prototype.skipType = function(t3) {
        switch (t3) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; 4 != (t3 = 7 & this.uint32()); ) this.skipType(t3);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + t3 + " at offset " + this.pos);
        }
        return this;
      }, u2._configure = function(t3) {
        r2 = t3, u2.create = p2(), r2._configure();
        var e3 = i2.Long ? "toLong" : "toNumber";
        i2.merge(u2.prototype, { int64: function() {
          return f2.call(this)[e3](false);
        }, uint64: function() {
          return f2.call(this)[e3](true);
        }, sint64: function() {
          return f2.call(this).zzDecode()[e3](false);
        }, fixed64: function() {
          return h2.call(this)[e3](true);
        }, sfixed64: function() {
          return h2.call(this)[e3](false);
        } });
      };
    }, 593: (t2, e2, n2) => {
      t2.exports = o2;
      var r2 = n2(1408);
      (o2.prototype = Object.create(r2.prototype)).constructor = o2;
      var i2 = n2(9693);
      function o2(t3) {
        r2.call(this, t3);
      }
      o2._configure = function() {
        i2.Buffer && (o2.prototype._slice = i2.Buffer.prototype.slice);
      }, o2.prototype.string = function() {
        var t3 = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t3, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t3, this.len));
      }, o2._configure();
    }, 5054: (t2) => {
      t2.exports = {};
    }, 5994: (t2, e2, n2) => {
      e2.Service = n2(7948);
    }, 7948: (t2, e2, n2) => {
      t2.exports = i2;
      var r2 = n2(9693);
      function i2(t3, e3, n3) {
        if ("function" != typeof t3) throw TypeError("rpcImpl must be a function");
        r2.EventEmitter.call(this), this.rpcImpl = t3, this.requestDelimited = Boolean(e3), this.responseDelimited = Boolean(n3);
      }
      (i2.prototype = Object.create(r2.EventEmitter.prototype)).constructor = i2, i2.prototype.rpcCall = function t3(e3, n3, i3, o2, a2) {
        if (!o2) throw TypeError("request must be specified");
        var s2 = this;
        if (!a2) return r2.asPromise(t3, s2, e3, n3, i3, o2);
        if (s2.rpcImpl) try {
          return s2.rpcImpl(e3, n3[s2.requestDelimited ? "encodeDelimited" : "encode"](o2).finish(), function(t4, n4) {
            if (t4) return s2.emit("error", t4, e3), a2(t4);
            if (null !== n4) {
              if (!(n4 instanceof i3)) try {
                n4 = i3[s2.responseDelimited ? "decodeDelimited" : "decode"](n4);
              } catch (t5) {
                return s2.emit("error", t5, e3), a2(t5);
              }
              return s2.emit("data", n4, e3), a2(null, n4);
            }
            s2.end(true);
          });
        } catch (t4) {
          return s2.emit("error", t4, e3), void setTimeout(function() {
            a2(t4);
          }, 0);
        }
        else setTimeout(function() {
          a2(Error("already ended"));
        }, 0);
      }, i2.prototype.end = function(t3) {
        return this.rpcImpl && (t3 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
      };
    }, 1945: (t2, e2, n2) => {
      t2.exports = i2;
      var r2 = n2(9693);
      function i2(t3, e3) {
        this.lo = t3 >>> 0, this.hi = e3 >>> 0;
      }
      var o2 = i2.zero = new i2(0, 0);
      o2.toNumber = function() {
        return 0;
      }, o2.zzEncode = o2.zzDecode = function() {
        return this;
      }, o2.length = function() {
        return 1;
      };
      var a2 = i2.zeroHash = "\0\0\0\0\0\0\0\0";
      i2.fromNumber = function(t3) {
        if (0 === t3) return o2;
        var e3 = t3 < 0;
        e3 && (t3 = -t3);
        var n3 = t3 >>> 0, r3 = (t3 - n3) / 4294967296 >>> 0;
        return e3 && (r3 = ~r3 >>> 0, n3 = ~n3 >>> 0, ++n3 > 4294967295 && (n3 = 0, ++r3 > 4294967295 && (r3 = 0))), new i2(n3, r3);
      }, i2.from = function(t3) {
        if ("number" == typeof t3) return i2.fromNumber(t3);
        if (r2.isString(t3)) {
          if (!r2.Long) return i2.fromNumber(parseInt(t3, 10));
          t3 = r2.Long.fromString(t3);
        }
        return t3.low || t3.high ? new i2(t3.low >>> 0, t3.high >>> 0) : o2;
      }, i2.prototype.toNumber = function(t3) {
        if (!t3 && this.hi >>> 31) {
          var e3 = 1 + ~this.lo >>> 0, n3 = ~this.hi >>> 0;
          return e3 || (n3 = n3 + 1 >>> 0), -(e3 + 4294967296 * n3);
        }
        return this.lo + 4294967296 * this.hi;
      }, i2.prototype.toLong = function(t3) {
        return r2.Long ? new r2.Long(0 | this.lo, 0 | this.hi, Boolean(t3)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t3) };
      };
      var s2 = String.prototype.charCodeAt;
      i2.fromHash = function(t3) {
        return t3 === a2 ? o2 : new i2((s2.call(t3, 0) | s2.call(t3, 1) << 8 | s2.call(t3, 2) << 16 | s2.call(t3, 3) << 24) >>> 0, (s2.call(t3, 4) | s2.call(t3, 5) << 8 | s2.call(t3, 6) << 16 | s2.call(t3, 7) << 24) >>> 0);
      }, i2.prototype.toHash = function() {
        return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
      }, i2.prototype.zzEncode = function() {
        var t3 = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t3) >>> 0, this.lo = (this.lo << 1 ^ t3) >>> 0, this;
      }, i2.prototype.zzDecode = function() {
        var t3 = -(1 & this.lo);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t3) >>> 0, this.hi = (this.hi >>> 1 ^ t3) >>> 0, this;
      }, i2.prototype.length = function() {
        var t3 = this.lo, e3 = (this.lo >>> 28 | this.hi << 4) >>> 0, n3 = this.hi >>> 24;
        return 0 === n3 ? 0 === e3 ? t3 < 16384 ? t3 < 128 ? 1 : 2 : t3 < 2097152 ? 3 : 4 : e3 < 16384 ? e3 < 128 ? 5 : 6 : e3 < 2097152 ? 7 : 8 : n3 < 128 ? 9 : 10;
      };
    }, 9693: function(t2, e2, n2) {
      var r2 = e2;
      function i2(t3, e3, n3) {
        for (var r3 = Object.keys(e3), i3 = 0; i3 < r3.length; ++i3) void 0 !== t3[r3[i3]] && n3 || (t3[r3[i3]] = e3[r3[i3]]);
        return t3;
      }
      function o2(t3) {
        function e3(t4, n3) {
          if (!(this instanceof e3)) return new e3(t4, n3);
          Object.defineProperty(this, "message", { get: function() {
            return t4;
          } }), Error.captureStackTrace ? Error.captureStackTrace(this, e3) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n3 && i2(this, n3);
        }
        return (e3.prototype = Object.create(Error.prototype)).constructor = e3, Object.defineProperty(e3.prototype, "name", { get: function() {
          return t3;
        } }), e3.prototype.toString = function() {
          return this.name + ": " + this.message;
        }, e3;
      }
      r2.asPromise = n2(4537), r2.base64 = n2(7419), r2.EventEmitter = n2(9211), r2.float = n2(945), r2.inquire = n2(7199), r2.utf8 = n2(4997), r2.pool = n2(6662), r2.LongBits = n2(1945), r2.isNode = Boolean(void 0 !== n2.g && n2.g && n2.g.process && n2.g.process.versions && n2.g.process.versions.node), r2.global = r2.isNode && n2.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r2.emptyArray = Object.freeze ? Object.freeze([]) : [], r2.emptyObject = Object.freeze ? Object.freeze({}) : {}, r2.isInteger = Number.isInteger || function(t3) {
        return "number" == typeof t3 && isFinite(t3) && Math.floor(t3) === t3;
      }, r2.isString = function(t3) {
        return "string" == typeof t3 || t3 instanceof String;
      }, r2.isObject = function(t3) {
        return t3 && "object" == typeof t3;
      }, r2.isset = r2.isSet = function(t3, e3) {
        var n3 = t3[e3];
        return !(null == n3 || !t3.hasOwnProperty(e3)) && ("object" != typeof n3 || (Array.isArray(n3) ? n3.length : Object.keys(n3).length) > 0);
      }, r2.Buffer = function() {
        try {
          var t3 = r2.inquire("buffer").Buffer;
          return t3.prototype.utf8Write ? t3 : null;
        } catch (t4) {
          return null;
        }
      }(), r2._Buffer_from = null, r2._Buffer_allocUnsafe = null, r2.newBuffer = function(t3) {
        return "number" == typeof t3 ? r2.Buffer ? r2._Buffer_allocUnsafe(t3) : new r2.Array(t3) : r2.Buffer ? r2._Buffer_from(t3) : "undefined" == typeof Uint8Array ? t3 : new Uint8Array(t3);
      }, r2.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r2.Long = r2.global.dcodeIO && r2.global.dcodeIO.Long || r2.global.Long || r2.inquire("long"), r2.key2Re = /^true|false|0|1$/, r2.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r2.longToHash = function(t3) {
        return t3 ? r2.LongBits.from(t3).toHash() : r2.LongBits.zeroHash;
      }, r2.longFromHash = function(t3, e3) {
        var n3 = r2.LongBits.fromHash(t3);
        return r2.Long ? r2.Long.fromBits(n3.lo, n3.hi, e3) : n3.toNumber(Boolean(e3));
      }, r2.merge = i2, r2.lcFirst = function(t3) {
        return t3.charAt(0).toLowerCase() + t3.substring(1);
      }, r2.newError = o2, r2.ProtocolError = o2("ProtocolError"), r2.oneOfGetter = function(t3) {
        for (var e3 = {}, n3 = 0; n3 < t3.length; ++n3) e3[t3[n3]] = 1;
        return function() {
          for (var t4 = Object.keys(this), n4 = t4.length - 1; n4 > -1; --n4) if (1 === e3[t4[n4]] && void 0 !== this[t4[n4]] && null !== this[t4[n4]]) return t4[n4];
        };
      }, r2.oneOfSetter = function(t3) {
        return function(e3) {
          for (var n3 = 0; n3 < t3.length; ++n3) t3[n3] !== e3 && delete this[t3[n3]];
        };
      }, r2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r2._configure = function() {
        var t3 = r2.Buffer;
        t3 ? (r2._Buffer_from = t3.from !== Uint8Array.from && t3.from || function(e3, n3) {
          return new t3(e3, n3);
        }, r2._Buffer_allocUnsafe = t3.allocUnsafe || function(e3) {
          return new t3(e3);
        }) : r2._Buffer_from = r2._Buffer_allocUnsafe = null;
      };
    }, 1173: (t2, e2, n2) => {
      t2.exports = p2;
      var r2, i2 = n2(9693), o2 = i2.LongBits, a2 = i2.base64, s2 = i2.utf8;
      function u2(t3, e3, n3) {
        this.fn = t3, this.len = e3, this.next = void 0, this.val = n3;
      }
      function c2() {
      }
      function l2(t3) {
        this.head = t3.head, this.tail = t3.tail, this.len = t3.len, this.next = t3.states;
      }
      function p2() {
        this.len = 0, this.head = new u2(c2, 0, 0), this.tail = this.head, this.states = null;
      }
      var f2 = function() {
        return i2.Buffer ? function() {
          return (p2.create = function() {
            return new r2();
          })();
        } : function() {
          return new p2();
        };
      };
      function d2(t3, e3, n3) {
        e3[n3] = 255 & t3;
      }
      function h2(t3, e3) {
        this.len = t3, this.next = void 0, this.val = e3;
      }
      function g2(t3, e3, n3) {
        for (; t3.hi; ) e3[n3++] = 127 & t3.lo | 128, t3.lo = (t3.lo >>> 7 | t3.hi << 25) >>> 0, t3.hi >>>= 7;
        for (; t3.lo > 127; ) e3[n3++] = 127 & t3.lo | 128, t3.lo = t3.lo >>> 7;
        e3[n3++] = t3.lo;
      }
      function b2(t3, e3, n3) {
        e3[n3] = 255 & t3, e3[n3 + 1] = t3 >>> 8 & 255, e3[n3 + 2] = t3 >>> 16 & 255, e3[n3 + 3] = t3 >>> 24;
      }
      p2.create = f2(), p2.alloc = function(t3) {
        return new i2.Array(t3);
      }, i2.Array !== Array && (p2.alloc = i2.pool(p2.alloc, i2.Array.prototype.subarray)), p2.prototype._push = function(t3, e3, n3) {
        return this.tail = this.tail.next = new u2(t3, e3, n3), this.len += e3, this;
      }, h2.prototype = Object.create(u2.prototype), h2.prototype.fn = function(t3, e3, n3) {
        for (; t3 > 127; ) e3[n3++] = 127 & t3 | 128, t3 >>>= 7;
        e3[n3] = t3;
      }, p2.prototype.uint32 = function(t3) {
        return this.len += (this.tail = this.tail.next = new h2((t3 >>>= 0) < 128 ? 1 : t3 < 16384 ? 2 : t3 < 2097152 ? 3 : t3 < 268435456 ? 4 : 5, t3)).len, this;
      }, p2.prototype.int32 = function(t3) {
        return t3 < 0 ? this._push(g2, 10, o2.fromNumber(t3)) : this.uint32(t3);
      }, p2.prototype.sint32 = function(t3) {
        return this.uint32((t3 << 1 ^ t3 >> 31) >>> 0);
      }, p2.prototype.uint64 = function(t3) {
        var e3 = o2.from(t3);
        return this._push(g2, e3.length(), e3);
      }, p2.prototype.int64 = p2.prototype.uint64, p2.prototype.sint64 = function(t3) {
        var e3 = o2.from(t3).zzEncode();
        return this._push(g2, e3.length(), e3);
      }, p2.prototype.bool = function(t3) {
        return this._push(d2, 1, t3 ? 1 : 0);
      }, p2.prototype.fixed32 = function(t3) {
        return this._push(b2, 4, t3 >>> 0);
      }, p2.prototype.sfixed32 = p2.prototype.fixed32, p2.prototype.fixed64 = function(t3) {
        var e3 = o2.from(t3);
        return this._push(b2, 4, e3.lo)._push(b2, 4, e3.hi);
      }, p2.prototype.sfixed64 = p2.prototype.fixed64, p2.prototype.float = function(t3) {
        return this._push(i2.float.writeFloatLE, 4, t3);
      }, p2.prototype.double = function(t3) {
        return this._push(i2.float.writeDoubleLE, 8, t3);
      };
      var m2 = i2.Array.prototype.set ? function(t3, e3, n3) {
        e3.set(t3, n3);
      } : function(t3, e3, n3) {
        for (var r3 = 0; r3 < t3.length; ++r3) e3[n3 + r3] = t3[r3];
      };
      p2.prototype.bytes = function(t3) {
        var e3 = t3.length >>> 0;
        if (!e3) return this._push(d2, 1, 0);
        if (i2.isString(t3)) {
          var n3 = p2.alloc(e3 = a2.length(t3));
          a2.decode(t3, n3, 0), t3 = n3;
        }
        return this.uint32(e3)._push(m2, e3, t3);
      }, p2.prototype.string = function(t3) {
        var e3 = s2.length(t3);
        return e3 ? this.uint32(e3)._push(s2.write, e3, t3) : this._push(d2, 1, 0);
      }, p2.prototype.fork = function() {
        return this.states = new l2(this), this.head = this.tail = new u2(c2, 0, 0), this.len = 0, this;
      }, p2.prototype.reset = function() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u2(c2, 0, 0), this.len = 0), this;
      }, p2.prototype.ldelim = function() {
        var t3 = this.head, e3 = this.tail, n3 = this.len;
        return this.reset().uint32(n3), n3 && (this.tail.next = t3.next, this.tail = e3, this.len += n3), this;
      }, p2.prototype.finish = function() {
        for (var t3 = this.head.next, e3 = this.constructor.alloc(this.len), n3 = 0; t3; ) t3.fn(t3.val, e3, n3), n3 += t3.len, t3 = t3.next;
        return e3;
      }, p2._configure = function(t3) {
        r2 = t3, p2.create = f2(), r2._configure();
      };
    }, 3155: (t2, e2, n2) => {
      t2.exports = o2;
      var r2 = n2(1173);
      (o2.prototype = Object.create(r2.prototype)).constructor = o2;
      var i2 = n2(9693);
      function o2() {
        r2.call(this);
      }
      function a2(t3, e3, n3) {
        t3.length < 40 ? i2.utf8.write(t3, e3, n3) : e3.utf8Write ? e3.utf8Write(t3, n3) : e3.write(t3, n3);
      }
      o2._configure = function() {
        o2.alloc = i2._Buffer_allocUnsafe, o2.writeBytesBuffer = i2.Buffer && i2.Buffer.prototype instanceof Uint8Array && "set" === i2.Buffer.prototype.set.name ? function(t3, e3, n3) {
          e3.set(t3, n3);
        } : function(t3, e3, n3) {
          if (t3.copy) t3.copy(e3, n3, 0, t3.length);
          else for (var r3 = 0; r3 < t3.length; ) e3[n3++] = t3[r3++];
        };
      }, o2.prototype.bytes = function(t3) {
        i2.isString(t3) && (t3 = i2._Buffer_from(t3, "base64"));
        var e3 = t3.length >>> 0;
        return this.uint32(e3), e3 && this._push(o2.writeBytesBuffer, e3, t3), this;
      }, o2.prototype.string = function(t3) {
        var e3 = i2.Buffer.byteLength(t3);
        return this.uint32(e3), e3 && this._push(a2, e3, t3), this;
      }, o2._configure();
    }, 7714: (t2, e2, n2) => {
      e2.R = void 0;
      const r2 = n2(6919), i2 = n2(7448);
      e2.R = new class {
        async init() {
        }
        async createSessionHandler(t3, e3) {
          const n3 = new r2.Session(e3);
          return await n3.loadModel(t3), new i2.OnnxjsSessionHandler(n3);
        }
      }();
    }, 4200: (t2, e2, n2) => {
      e2.c8 = e2.rX = void 0;
      const r2 = n2(1670), i2 = n2(5381), o2 = n2(2157), a2 = n2(2306);
      e2.rX = () => {
        if (("number" != typeof r2.env.wasm.initTimeout || r2.env.wasm.initTimeout < 0) && (r2.env.wasm.initTimeout = 0), "boolean" != typeof r2.env.wasm.simd && (r2.env.wasm.simd = true), "boolean" != typeof r2.env.wasm.proxy && (r2.env.wasm.proxy = false), "number" != typeof r2.env.wasm.numThreads || !Number.isInteger(r2.env.wasm.numThreads) || r2.env.wasm.numThreads <= 0) {
          const t3 = "undefined" == typeof navigator ? (0, i2.cpus)().length : navigator.hardwareConcurrency;
          r2.env.wasm.numThreads = Math.min(4, Math.ceil((t3 || 1) / 2));
        }
      }, e2.c8 = new class {
        async init() {
          (0, e2.rX)(), await (0, o2.initWasm)();
        }
        async createSessionHandler(t3, e3) {
          const n3 = new a2.OnnxruntimeWebAssemblySessionHandler();
          return await n3.loadModel(t3, e3), Promise.resolve(n3);
        }
      }();
    }, 6018: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i3 = Object.getOwnPropertyDescriptor(e3, n3);
        i3 && !("get" in i3 ? !e3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i3);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i2 = this && this.__exportStar || function(t3, e3) {
        for (var n3 in t3) "default" === n3 || Object.prototype.hasOwnProperty.call(e3, n3) || r2(e3, t3, n3);
      };
      Object.defineProperty(e2, "__esModule", { value: true }), i2(n2(1670), e2);
      const o2 = n2(1670);
      {
        const t3 = n2(7714).R;
        (0, o2.registerBackend)("webgl", t3, -10);
      }
      {
        const t3 = n2(4200).c8;
        (0, o2.registerBackend)("cpu", t3, 10), (0, o2.registerBackend)("wasm", t3, 10), (0, o2.registerBackend)("xnnpack", t3, 9);
      }
    }, 246: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createAttributeWithCacheKey = void 0;
      class n2 {
        constructor(t3) {
          Object.assign(this, t3);
        }
        get cacheKey() {
          return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t3) => `${this[t3]}`).join(";")), this._cacheKey;
        }
      }
      e2.createAttributeWithCacheKey = (t3) => new n2(t3);
    }, 7778: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Attribute = void 0;
      const r2 = n2(1446), i2 = n2(9395), o2 = n2(9162), a2 = n2(2517);
      var s2 = i2.onnxruntime.experimental.fbs;
      class u2 {
        constructor(t3) {
          if (this._attributes = /* @__PURE__ */ new Map(), null != t3) {
            for (const e3 of t3) e3 instanceof r2.onnx.AttributeProto ? this._attributes.set(e3.name, [u2.getValue(e3), u2.getType(e3)]) : e3 instanceof s2.Attribute && this._attributes.set(e3.name(), [u2.getValue(e3), u2.getType(e3)]);
            if (this._attributes.size < t3.length) throw new Error("duplicated attribute names");
          }
        }
        set(t3, e3, n3) {
          this._attributes.set(t3, [n3, e3]);
        }
        delete(t3) {
          this._attributes.delete(t3);
        }
        getFloat(t3, e3) {
          return this.get(t3, "float", e3);
        }
        getInt(t3, e3) {
          return this.get(t3, "int", e3);
        }
        getString(t3, e3) {
          return this.get(t3, "string", e3);
        }
        getTensor(t3, e3) {
          return this.get(t3, "tensor", e3);
        }
        getFloats(t3, e3) {
          return this.get(t3, "floats", e3);
        }
        getInts(t3, e3) {
          return this.get(t3, "ints", e3);
        }
        getStrings(t3, e3) {
          return this.get(t3, "strings", e3);
        }
        getTensors(t3, e3) {
          return this.get(t3, "tensors", e3);
        }
        get(t3, e3, n3) {
          const r3 = this._attributes.get(t3);
          if (void 0 === r3) {
            if (void 0 !== n3) return n3;
            throw new Error(`required attribute not found: ${t3}`);
          }
          if (r3[1] !== e3) throw new Error(`type mismatch: expected ${e3} but got ${r3[1]}`);
          return r3[0];
        }
        static getType(t3) {
          const e3 = t3 instanceof r2.onnx.AttributeProto ? t3.type : t3.type();
          switch (e3) {
            case r2.onnx.AttributeProto.AttributeType.FLOAT:
              return "float";
            case r2.onnx.AttributeProto.AttributeType.INT:
              return "int";
            case r2.onnx.AttributeProto.AttributeType.STRING:
              return "string";
            case r2.onnx.AttributeProto.AttributeType.TENSOR:
              return "tensor";
            case r2.onnx.AttributeProto.AttributeType.FLOATS:
              return "floats";
            case r2.onnx.AttributeProto.AttributeType.INTS:
              return "ints";
            case r2.onnx.AttributeProto.AttributeType.STRINGS:
              return "strings";
            case r2.onnx.AttributeProto.AttributeType.TENSORS:
              return "tensors";
            default:
              throw new Error(`attribute type is not supported yet: ${r2.onnx.AttributeProto.AttributeType[e3]}`);
          }
        }
        static getValue(t3) {
          const e3 = t3 instanceof r2.onnx.AttributeProto ? t3.type : t3.type();
          if (e3 === r2.onnx.AttributeProto.AttributeType.GRAPH || e3 === r2.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error("graph attribute is not supported yet");
          const n3 = this.getValueNoCheck(t3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.INT && a2.LongUtil.isLong(n3)) return a2.LongUtil.longToNumber(n3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.INTS) {
            const t4 = n3, e4 = new Array(t4.length);
            for (let n4 = 0; n4 < t4.length; n4++) {
              const r3 = t4[n4];
              e4[n4] = a2.LongUtil.longToNumber(r3);
            }
            return e4;
          }
          if (e3 === r2.onnx.AttributeProto.AttributeType.TENSOR) return t3 instanceof r2.onnx.AttributeProto ? o2.Tensor.fromProto(n3) : o2.Tensor.fromOrtTensor(n3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.TENSORS) {
            if (t3 instanceof r2.onnx.AttributeProto) return n3.map((t4) => o2.Tensor.fromProto(t4));
            if (t3 instanceof s2.Attribute) return n3.map((t4) => o2.Tensor.fromOrtTensor(t4));
          }
          if (e3 === r2.onnx.AttributeProto.AttributeType.STRING && t3 instanceof r2.onnx.AttributeProto) {
            const t4 = n3;
            return (0, a2.decodeUtf8String)(t4);
          }
          return e3 === r2.onnx.AttributeProto.AttributeType.STRINGS && t3 instanceof r2.onnx.AttributeProto ? n3.map(a2.decodeUtf8String) : n3;
        }
        static getValueNoCheck(t3) {
          return t3 instanceof r2.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t3) : this.getValueNoCheckFromOrtFormat(t3);
        }
        static getValueNoCheckFromOnnxFormat(t3) {
          switch (t3.type) {
            case r2.onnx.AttributeProto.AttributeType.FLOAT:
              return t3.f;
            case r2.onnx.AttributeProto.AttributeType.INT:
              return t3.i;
            case r2.onnx.AttributeProto.AttributeType.STRING:
              return t3.s;
            case r2.onnx.AttributeProto.AttributeType.TENSOR:
              return t3.t;
            case r2.onnx.AttributeProto.AttributeType.GRAPH:
              return t3.g;
            case r2.onnx.AttributeProto.AttributeType.FLOATS:
              return t3.floats;
            case r2.onnx.AttributeProto.AttributeType.INTS:
              return t3.ints;
            case r2.onnx.AttributeProto.AttributeType.STRINGS:
              return t3.strings;
            case r2.onnx.AttributeProto.AttributeType.TENSORS:
              return t3.tensors;
            case r2.onnx.AttributeProto.AttributeType.GRAPHS:
              return t3.graphs;
            default:
              throw new Error(`unsupported attribute type: ${r2.onnx.AttributeProto.AttributeType[t3.type]}`);
          }
        }
        static getValueNoCheckFromOrtFormat(t3) {
          switch (t3.type()) {
            case s2.AttributeType.FLOAT:
              return t3.f();
            case s2.AttributeType.INT:
              return t3.i();
            case s2.AttributeType.STRING:
              return t3.s();
            case s2.AttributeType.TENSOR:
              return t3.t();
            case s2.AttributeType.GRAPH:
              return t3.g();
            case s2.AttributeType.FLOATS:
              return t3.floatsArray();
            case s2.AttributeType.INTS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.intsLength(); n3++) e3.push(t3.ints(n3));
              return e3;
            }
            case s2.AttributeType.STRINGS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.stringsLength(); n3++) e3.push(t3.strings(n3));
              return e3;
            }
            case s2.AttributeType.TENSORS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.tensorsLength(); n3++) e3.push(t3.tensors(n3));
              return e3;
            }
            default:
              throw new Error(`unsupported attribute type: ${s2.AttributeType[t3.type()]}`);
          }
        }
      }
      e2.Attribute = u2;
    }, 7091: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.resolveBackend = e2.backend = void 0;
      const r2 = n2(5038), i2 = /* @__PURE__ */ new Map();
      async function o2(t3) {
        const n3 = e2.backend;
        if (void 0 !== n3[t3] && function(t4) {
          const e3 = t4;
          return "initialize" in e3 && "function" == typeof e3.initialize && "createSessionHandler" in e3 && "function" == typeof e3.createSessionHandler && "dispose" in e3 && "function" == typeof e3.dispose;
        }(n3[t3])) {
          const e3 = n3[t3];
          let r3 = e3.initialize();
          if ("object" == typeof r3 && "then" in r3 && (r3 = await r3), r3) return i2.set(t3, e3), e3;
        }
      }
      e2.backend = { webgl: new r2.WebGLBackend() }, e2.resolveBackend = async function t3(e3) {
        if (!e3) return t3(["webgl"]);
        {
          const t4 = "string" == typeof e3 ? [e3] : e3;
          for (const e4 of t4) {
            const t5 = i2.get(e4);
            if (t5) return t5;
            const n3 = await o2(e4);
            if (n3) return n3;
          }
        }
        throw new Error("no available backend to use");
      };
    }, 5038: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLBackend = void 0;
      const r2 = n2(1670), i2 = n2(6231), o2 = n2(6416), a2 = n2(7305);
      e2.WebGLBackend = class {
        get contextId() {
          return r2.env.webgl.contextId;
        }
        set contextId(t3) {
          r2.env.webgl.contextId = t3;
        }
        get matmulMaxBatchSize() {
          return r2.env.webgl.matmulMaxBatchSize;
        }
        set matmulMaxBatchSize(t3) {
          r2.env.webgl.matmulMaxBatchSize = t3;
        }
        get textureCacheMode() {
          return r2.env.webgl.textureCacheMode;
        }
        set textureCacheMode(t3) {
          r2.env.webgl.textureCacheMode = t3;
        }
        get pack() {
          return r2.env.webgl.pack;
        }
        set pack(t3) {
          r2.env.webgl.pack = t3;
        }
        get async() {
          return r2.env.webgl.async;
        }
        set async(t3) {
          r2.env.webgl.async = t3;
        }
        initialize() {
          try {
            return this.glContext = (0, a2.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i2.Logger.setWithEnv(r2.env), i2.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
          } catch (t3) {
            return i2.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t3}`), false;
          }
        }
        createSessionHandler(t3) {
          return new o2.WebGLSessionHandler(this, t3);
        }
        dispose() {
          this.glContext.dispose();
        }
      };
    }, 5107: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.CoordsGlslLib = void 0;
      const r2 = n2(2517), i2 = n2(8520), o2 = n2(5060), a2 = n2(7859), s2 = n2(9390);
      class u2 extends i2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
        }
        getCustomTypes() {
          return {};
        }
        offsetToCoords() {
          return { offsetToCoords: new i2.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
        }
        coordsToOffset() {
          return { coordsToOffset: new i2.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
        }
        getOutputSamplingSnippet() {
          const t3 = this.context.outputTextureLayout;
          return t3.isPacked ? this.getPackedOutputSamplingSnippet(t3) : this.getUnpackedOutputSamplingSnippet(t3);
        }
        getPackedOutputSamplingSnippet(t3) {
          const e3 = t3.unpackedShape, n3 = [t3.width, t3.height], r3 = {}, a3 = "getOutputCoords";
          switch (e3.length) {
            case 0:
              r3[a3] = this.getOutputScalarCoords();
              break;
            case 1:
              r3[a3] = this.getOutputPacked1DCoords(e3, n3);
              break;
            case 2:
              r3[a3] = this.getOutputPacked2DCoords(e3, n3);
              break;
            case 3:
              r3[a3] = this.getOutputPacked3DCoords(e3, n3);
              break;
            default:
              r3[a3] = this.getOutputPackedNDCoords(e3, n3);
          }
          const s3 = `
      void setOutput(vec4 val) {
        ${(0, o2.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
          return r3.floatTextureSetRGBA = new i2.GlslLibRoutine(s3), r3;
        }
        getUnpackedOutputSamplingSnippet(t3) {
          const e3 = t3.unpackedShape, n3 = [t3.width, t3.height], r3 = {}, a3 = "getOutputCoords";
          switch (e3.length) {
            case 0:
              r3[a3] = this.getOutputScalarCoords();
              break;
            case 1:
              r3[a3] = this.getOutputUnpacked1DCoords(e3, n3);
              break;
            case 2:
              r3[a3] = this.getOutputUnpacked2DCoords(e3, n3);
              break;
            case 3:
              r3[a3] = this.getOutputUnpacked3DCoords(e3, n3);
              break;
            case 4:
              r3[a3] = this.getOutputUnpacked4DCoords(e3, n3);
              break;
            case 5:
              r3[a3] = this.getOutputUnpacked5DCoords(e3, n3);
              break;
            case 6:
              r3[a3] = this.getOutputUnpacked6DCoords(e3, n3);
              break;
            default:
              throw new Error(`Unsupported output dimensionality: ${e3.length}`);
          }
          const s3 = `
        void setOutput(float val) {
          ${(0, o2.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
          return r3.floatTextureSetR = new i2.GlslLibRoutine(s3), r3;
        }
        getOutputScalarCoords() {
          return new i2.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
        }
        getOutputPacked1DCoords(t3, e3) {
          const n3 = e3;
          let r3 = "";
          return 1 === n3[0] ? (r3 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n3[1]}.0);
          }
        `, new i2.GlslLibRoutine(r3)) : 1 === n3[1] ? (r3 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n3[0]}.0);
          }
        `, new i2.GlslLibRoutine(r3)) : (r3 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n3[0]}, ${n3[1]}));
          return 2 * (resTexRC.y * ${n3[0]} + resTexRC.x);
        }
      `, new i2.GlslLibRoutine(r3));
        }
        getOutputPacked2DCoords(t3, e3) {
          let n3 = "";
          if (r2.ArrayUtil.arraysEqual(t3, e3)) return n3 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e3[0]}, ${e3[1]}));
        }
      `, new i2.GlslLibRoutine(n3);
          const o3 = e3, a3 = Math.ceil(t3[1] / 2);
          return n3 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o3[0]}, ${o3[1]}));

          int index = resTexRC.y * ${o3[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a3}) * 2;
          int c = 2 * (index / ${a3});

          return ivec2(r, c);
        }
      `, new i2.GlslLibRoutine(n3);
        }
        getOutputPacked3DCoords(t3, e3) {
          const n3 = [e3[0], e3[1]], r3 = Math.ceil(t3[2] / 2), o3 = r3 * Math.ceil(t3[1] / 2), a3 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n3[0]}, ${n3[1]}));
          int index = resTexRC.y * ${n3[0]} + resTexRC.x;

          int b = index / ${o3};
          index -= b * ${o3};

          // reverse r and c order for packed texture
          int r = imod(index, ${r3}) * 2;
          int c = 2 * (index / ${r3});

          return ivec3(b, r, c);
        }
      `;
          return new i2.GlslLibRoutine(a3);
        }
        getOutputPackedNDCoords(t3, e3) {
          const n3 = [e3[0], e3[1]], r3 = Math.ceil(t3[t3.length - 1] / 2), o3 = r3 * Math.ceil(t3[t3.length - 2] / 2);
          let a3 = o3, s3 = "", u3 = "b, r, c";
          for (let e4 = 2; e4 < t3.length - 1; e4++) a3 *= t3[t3.length - e4 - 1], s3 = `
      int b${e4} = index / ${a3};
      index -= b${e4} * ${a3};
    ` + s3, u3 = `b${e4}, ` + u3;
          const c2 = `
      ivec${t3.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n3[0]}, ${n3[1]}));
        int index = resTexRC.y * ${n3[0]} + resTexRC.x;

        ${s3}

        int b = index / ${o3};
        index -= b * ${o3};

        // reverse r and c order for packed texture
        int r = imod(index, ${r3}) * 2;
        int c = 2 * (index / ${r3});

        return ivec${t3.length}(${u3});
      }
    `;
          return new i2.GlslLibRoutine(c2);
        }
        getOutputUnpacked1DCoords(t3, e3) {
          const n3 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          return resTexRC.y * ${e3[0]} + resTexRC.x;
        }
      `;
          return new i2.GlslLibRoutine(n3);
        }
        getOutputUnpacked2DCoords(t3, e3) {
          const n3 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          int r = index / ${t3[1]};
          int c = index - r * ${t3[1]};
          return ivec2(r, c);
        }
      `;
          return new i2.GlslLibRoutine(n3);
        }
        getOutputUnpacked3DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o3 = null;
          r3 < 2 && (o3 = []), o3 = new Array(r3 - 1), o3[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o3[e4] = o3[e4 + 1] * t3[e4 + 1];
          const a3 = ["r", "c", "d"], s3 = o3.map((t4, e4) => `int ${a3[e4]} = index / ${t4}; ${e4 === o3.length - 1 ? `int ${a3[e4 + 1]} = index - ${a3[e4]} * ${t4}` : `index -= ${a3[e4]} * ${t4}`};`).join("");
          return n3 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s3}
          return ivec3(r, c, d);
        }
      `, new i2.GlslLibRoutine(n3);
        }
        getOutputUnpacked4DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o3 = null;
          r3 < 2 && (o3 = []), o3 = new Array(r3 - 1), o3[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o3[e4] = o3[e4 + 1] * t3[e4 + 1];
          const a3 = ["r", "c", "d", "d2"], s3 = o3.map((t4, e4) => `int ${a3[e4]} = index / ${t4}; ${e4 === o3.length - 1 ? `int ${a3[e4 + 1]} = index - ${a3[e4]} * ${t4}` : `index -= ${a3[e4]} * ${t4}`};`).join("");
          return n3 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s3}
          return ivec4(r, c, d, d2);
        }
      `, new i2.GlslLibRoutine(n3);
        }
        getOutputUnpacked5DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o3 = null;
          r3 < 2 && (o3 = []), o3 = new Array(r3 - 1), o3[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o3[e4] = o3[e4 + 1] * t3[e4 + 1];
          const a3 = ["r", "c", "d", "d2", "d3"], s3 = o3.map((t4, e4) => `int ${a3[e4]} = index / ${t4}; ${e4 === o3.length - 1 ? `int ${a3[e4 + 1]} = index - ${a3[e4]} * ${t4}` : `index -= ${a3[e4]} * ${t4}`};`).join("");
          return n3 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s3}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i2.GlslLibRoutine(n3);
        }
        getOutputUnpacked6DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o3 = null;
          r3 < 2 && (o3 = []), o3 = new Array(r3 - 1), o3[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o3[e4] = o3[e4 + 1] * t3[e4 + 1];
          const a3 = ["r", "c", "d", "d2", "d3", "d4"], s3 = o3.map((t4, e4) => `int ${a3[e4]} = index / ${t4}; ${e4 === o3.length - 1 ? `int ${a3[e4 + 1]} = index - ${a3[e4]} * ${t4}` : `index -= ${a3[e4]} * ${t4}`};`).join("");
          return n3 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e3[0]}, ${e3[1]}));
         int index = resTexRC.y * ${e3[0]} + resTexRC.x;
         ${s3}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i2.GlslLibRoutine(n3);
        }
        getCommonUtilFuncs() {
          const t3 = {};
          let e3 = "uvFromFlat";
          t3[e3] = new i2.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), e3 = "packedUVfrom1D", t3[e3] = new i2.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "packedUVfrom2D", t3[e3] = new i2.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "packedUVfrom3D", t3[e3] = new i2.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "sampleTexture";
          const n3 = (0, o2.getGlsl)(this.context.glContext.version);
          return t3[e3] = new i2.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n3.texture2D}(textureSampler, uv).r;
        }`), t3;
        }
        getInputsSamplingSnippets() {
          const t3 = {}, e3 = this.context.outputTextureLayout;
          return this.context.programInfo.inputNames.forEach((n3, r3) => {
            const i3 = this.context.inputTextureLayouts[r3], o3 = (0, s2.generateShaderFuncNameFromInputSamplerName)(n3);
            i3.isPacked ? t3[o3] = this.getPackedSamplerFromInput(o3, n3, i3) : t3[o3] = this.getUnpackedSamplerFromInput(o3, n3, i3);
            const a3 = (0, s2.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n3);
            i3.unpackedShape.length <= e3.unpackedShape.length && (i3.isPacked ? t3[a3] = this.getPackedSamplerAtOutputCoords(a3, i3, e3, n3) : t3[a3] = this.getUnpackedSamplerAtOutputCoords(a3, i3, e3, n3));
          }), t3;
        }
        getPackedSamplerAtOutputCoords(t3, e3, n3, o3) {
          const a3 = e3.unpackedShape, u3 = n3.unpackedShape, c2 = o3, l2 = (0, s2.generateShaderFuncNameFromInputSamplerName)(c2), p2 = a3.length, f2 = u3.length, d2 = r2.BroadcastUtil.getBroadcastDims(a3, u3), h2 = (0, s2.getCoordsDataType)(f2), g2 = f2 - p2;
          let b2;
          const m2 = (0, s2.getGlChannels)();
          b2 = 0 === p2 ? "" : f2 < 2 && d2.length >= 1 ? "coords = 0;" : d2.map((t4) => `coords.${m2[t4 + g2]} = 0;`).join("\n");
          let y2 = "";
          y2 = f2 < 2 && p2 > 0 ? "coords" : a3.map((t4, e4) => `coords.${m2[e4 + g2]}`).join(", ");
          let _ = "return outputValue;";
          const v2 = 1 === r2.ShapeUtil.size(a3), w2 = 1 === r2.ShapeUtil.size(u3);
          if (1 !== p2 || v2 || w2) {
            if (v2 && !w2) _ = 1 === f2 ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
            else if (d2.length) {
              const t4 = p2 - 2, e4 = p2 - 1;
              d2.indexOf(t4) > -1 && d2.indexOf(e4) > -1 ? _ = "return vec4(outputValue.x);" : d2.indexOf(t4) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d2.indexOf(e4) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
            }
          } else _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
          const x2 = `
      vec4 ${t3}() {
        ${h2} coords = getOutputCoords();
        
        int lastDim = coords.${m2[f2 - 1]};
        coords.${m2[f2 - 1]} = coords.${m2[f2 - 2]};
        coords.${m2[f2 - 2]} = lastDim;
      
        ${b2}
        vec4 outputValue = ${l2}(${y2});
        ${_}
      }
    `;
          return new i2.GlslLibRoutine(x2, ["coordinates.getOutputCoords"]);
        }
        getUnpackedSamplerAtOutputCoords(t3, e3, n3, o3) {
          const a3 = [n3.width, n3.height], u3 = [e3.width, e3.height], c2 = e3.unpackedShape.length, l2 = n3.unpackedShape.length, p2 = e3.unpackedShape, f2 = n3.unpackedShape, d2 = (0, s2.generateShaderFuncNameFromInputSamplerName)(o3);
          if (c2 === l2 && r2.ArrayUtil.arraysEqual(u3, a3)) {
            const e4 = `
          float ${t3}() {
            return sampleTexture(${o3}, TexCoords);
          }
        `;
            return new i2.GlslLibRoutine(e4, ["coordinates.sampleTexture"]);
          }
          const h2 = (0, s2.getCoordsDataType)(l2), g2 = r2.BroadcastUtil.getBroadcastDims(p2, f2), b2 = l2 - c2;
          let m2;
          const y2 = (0, s2.getGlChannels)();
          m2 = 0 === c2 ? "" : l2 < 2 && g2.length >= 1 ? "coords = 0;" : g2.map((t4) => `coords.${y2[t4 + b2]} = 0;`).join("\n");
          let _ = "";
          _ = l2 < 2 && c2 > 0 ? "coords" : e3.unpackedShape.map((t4, e4) => `coords.${y2[e4 + b2]}`).join(", ");
          const v2 = `
        float ${t3}() {
          ${h2} coords = getOutputCoords();
          ${m2}
          return ${d2}(${_});
        }
      `;
          return new i2.GlslLibRoutine(v2, ["coordinates.getOutputCoords"]);
        }
        getPackedSamplerFromInput(t3, e3, n3) {
          switch (n3.unpackedShape.length) {
            case 0:
              return this.getPackedSamplerScalar(t3, e3);
            case 1:
              return this.getPackedSampler1D(t3, e3, n3);
            case 2:
              return this.getPackedSampler2D(t3, e3, n3);
            case 3:
              return this.getPackedSampler3D(t3, e3, n3);
            default:
              return this.getPackedSamplerND(t3, e3, n3);
          }
        }
        getUnpackedSamplerFromInput(t3, e3, n3) {
          const r3 = n3.unpackedShape;
          switch (r3.length) {
            case 0:
              return this.getUnpackedSamplerScalar(t3, e3, n3);
            case 1:
              return this.getUnpackedSampler1D(t3, e3, n3);
            case 2:
              return this.getUnpackedSampler2D(t3, e3, n3);
            case 3:
              return this.getUnpackedSampler3D(t3, e3, n3);
            case 4:
              return this.getUnpackedSampler4D(t3, e3, n3);
            case 5:
              return this.getUnpackedSampler5D(t3, e3, n3);
            case 6:
              return this.getUnpackedSampler6D(t3, e3, n3);
            default:
              throw new Error(`Unsupported dimension ${r3.length}-D`);
          }
        }
        getPackedSamplerScalar(t3, e3) {
          const n3 = `
          vec4 ${t3}() {
            return ${(0, o2.getGlsl)(this.context.glContext.version).texture2D}(${e3}, halfCR);
          }
        `;
          return new i2.GlslLibRoutine(n3);
        }
        getPackedSampler1D(t3, e3, n3) {
          const r3 = [n3.width, n3.height], a3 = [r3[1], r3[0]], s3 = (0, o2.getGlsl)(this.context.glContext.version), u3 = `vec4 ${t3}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a3[0]}, ${a3[1]}, index);
      return ${s3.texture2D}(${e3}, uv);
    }`;
          return new i2.GlslLibRoutine(u3, ["coordinates.packedUVfrom1D"]);
        }
        getPackedSampler2D(t3, e3, n3) {
          const a3 = n3.unpackedShape, s3 = [n3.width, n3.height], u3 = (0, o2.getGlsl)(this.context.glContext.version), c2 = s3[0], l2 = s3[1];
          if (null != s3 && r2.ArrayUtil.arraysEqual(a3, s3)) {
            const n4 = `vec4 ${t3}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l2}.0, ${c2}.0);
        return ${u3.texture2D}(${e3}, uv);
      }`;
            return new i2.GlslLibRoutine(n4);
          }
          const p2 = s3, f2 = Math.ceil(a3[1] / 2), d2 = `vec4 ${t3}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p2[1]}, ${p2[0]}, ${f2}, row, col);
      return ${u3.texture2D}(${e3}, uv);
    }`;
          return new i2.GlslLibRoutine(d2, ["coordinates.packedUVfrom2D"]);
        }
        getPackedSampler3D(t3, e3, n3) {
          const r3 = n3.unpackedShape, a3 = [n3.width, n3.height], u3 = [a3[0], a3[1]], c2 = (0, o2.getGlsl)(this.context.glContext.version);
          if (1 === r3[0]) {
            const o3 = r3.slice(1), a4 = [1, 2], u4 = (0, s2.squeezeInputShape)(r3, o3), c3 = ["b", "row", "col"], l3 = JSON.parse(JSON.stringify(n3));
            l3.unpackedShape = u4;
            const p3 = this.getPackedSamplerFromInput(t3, e3, l3), f3 = `${p3.routineBody}
      vec4 ${t3}(int b, int row, int col) {
        return ${t3}(${(0, s2.getSqueezedParams)(c3, a4)});
      } `;
            return new i2.GlslLibRoutine(f3, p3.dependencies);
          }
          const l2 = u3[0], p2 = u3[1], f2 = Math.ceil(r3[2] / 2), d2 = `vec4 ${t3}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p2}, ${l2}, ${f2 * Math.ceil(r3[1] / 2)}, ${f2}, b, row, col);
      return ${c2.texture2D}(${e3}, uv);}`;
          return new i2.GlslLibRoutine(d2, ["coordinates.packedUVfrom3D"]);
        }
        getPackedSamplerND(t3, e3, n3) {
          const r3 = n3.unpackedShape, a3 = r3.length, s3 = [n3.width, n3.height], u3 = (0, o2.getGlsl)(this.context.glContext.version), c2 = [s3[0], s3[1]], l2 = c2[1], p2 = c2[0], f2 = Math.ceil(r3[a3 - 1] / 2);
          let d2 = f2 * Math.ceil(r3[a3 - 2] / 2), h2 = "int b, int row, int col", g2 = `b * ${d2} + (row / 2) * ${f2} + (col / 2)`;
          for (let t4 = 2; t4 < a3 - 1; t4++) h2 = `int b${t4}, ` + h2, d2 *= r3[a3 - t4 - 1], g2 = `b${t4} * ${d2} + ` + g2;
          const b2 = `vec4 ${t3}(${h2}) {
      int index = ${g2};
      int texR = index / ${p2};
      int texC = index - texR * ${p2};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p2}, ${l2});
      return ${u3.texture2D}(${e3}, uv);
    }`;
          return new i2.GlslLibRoutine(b2);
        }
        getUnpackedSamplerScalar(t3, e3, n3) {
          const [r3, o3] = [n3.width, n3.height];
          if (1 === r3 && 1 === o3) {
            const n4 = `
          float ${t3}() {
            return sampleTexture(${e3}, halfCR);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const a3 = `
        float ${t3}() {
          int offset_${e3} = coordsToOffset(TexCoords, ${r3}, ${o3});
          vec2 uv = uvFromFlat(${r3}, ${o3}, offset_${e3});
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i2.GlslLibRoutine(a3, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler1D(t3, e3, n3) {
          const r3 = n3.width, o3 = n3.height;
          if (1 === o3 && 1 === r3) {
            const n4 = `
        float ${t3}(int index) {
          return sampleTexture(${e3}, halfCR);
        }
      `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          if (1 === o3) {
            const n4 = `
          float ${t3}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r3}.0, 0.5);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          if (1 === r3) {
            const n4 = `
          float ${t3}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o3}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const a3 = `
        float ${t3}(int index) {
          vec2 uv = uvFromFlat(${r3}, ${o3}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i2.GlslLibRoutine(a3, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        getUnpackedSampler2D(t3, e3, n3) {
          const o3 = n3.unpackedShape, u3 = [n3.height, n3.width];
          if (null != u3 && r2.ArrayUtil.arraysEqual(o3, u3)) {
            const n4 = `
          float ${t3}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u3[1]}.0, ${u3[0]}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const { newShape: c2, keptDims: l2 } = (0, a2.squeezeShape)(o3), p2 = c2;
          if (p2.length < o3.length) {
            const r3 = (0, s2.squeezeInputShape)(o3, p2), a3 = JSON.parse(JSON.stringify(n3));
            a3.unpackedShape = r3;
            const u4 = ["col", "row"], c3 = `
          ${this.getUnpackedSamplerFromInput(t3, e3, a3).routineBody}
          float ${t3}(int row, int col) {
            return ${t3}(${(0, s2.getSqueezedParams)(u4, l2)});
          }
        `;
            return new i2.GlslLibRoutine(c3, ["coordinates.sampleTexture"]);
          }
          const f2 = u3[1], d2 = u3[0];
          if (1 === d2) {
            const n4 = `
          float ${t3}(int row, int col) {
            int offset_${e3} = coordsToOffset(TexCoords, ${f2}, ${d2});
            float index = dot(vec3(row, col, offset_${e3}), vec3(${o3[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f2}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          if (1 === f2) {
            const n4 = `
          float ${t3}(int row, int col) {
            int offset_${e3} = coordsToOffset(TexCoords, ${f2}, ${d2});
            float index = dot(vec3(row, col, offset_${e3}), vec3(${o3[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${d2}.0, 0.5);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i2.GlslLibRoutine(n4, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          const h2 = `
        float ${t3}(int row, int col) {
          int index = col * ${o3[1]} + row;
          vec2 uv = uvFromFlat(${f2}, ${d2}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i2.GlslLibRoutine(h2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler3D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o3 = r3[1] * r3[2], u3 = r3[2], { newShape: c2, keptDims: l2 } = (0, a2.squeezeShape)(r3), p2 = c2;
          if (p2.length < r3.length) {
            const o4 = (0, s2.squeezeInputShape)(r3, p2), a3 = ["batch", "col", "row"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o4;
            const c3 = this.getUnpackedSamplerFromInput(t3, e3, u4), f3 = l2.reverse(), d2 = `
          ${c3.routineBody}
          float ${t3}(int batch, int row, int col) {
            return ${t3}(${(0, s2.getSqueezedParams)(a3, f3)});
          }
        `;
            return new i2.GlslLibRoutine(d2, c3.dependencies);
          }
          const f2 = `
          float ${t3}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o3} + col * ${u3} + row;
            vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
            return sampleTexture(${e3}, uv);
          }
      `;
          return new i2.GlslLibRoutine(f2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler4D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o3 = r3[3], a3 = r3[2] * o3, s3 = `
        float ${t3}(int row, int col, int depth, int depth2) {
          int index = row * ${r3[1] * a3} + col * ${a3} +
              depth2 * ${o3} + depth;
          vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i2.GlslLibRoutine(s3, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        getUnpackedSampler5D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o3 = r3[4], u3 = r3[3] * o3, c2 = r3[2] * u3, l2 = r3[1] * c2, { newShape: p2, keptDims: f2 } = (0, a2.squeezeShape)(r3);
          if (p2.length < r3.length) {
            const o4 = (0, s2.squeezeInputShape)(r3, p2), a3 = ["row", "col", "depth", "depth2", "depth3"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o4;
            const c3 = `
          ${this.getUnpackedSamplerFromInput(t3, e3, u4).routineBody}
          float ${t3}(int row, int col, int depth, int depth2, int depth3) {
            return ${t3}(${(0, s2.getSqueezedParams)(a3, f2)});
          }
        `;
            return new i2.GlslLibRoutine(c3, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const d2 = `
        float ${t3}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l2} + col * ${c2} + depth * ${u3} +
          depth3 * ${o3} + depth2;
          vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i2.GlslLibRoutine(d2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        getUnpackedSampler6D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o3 = r3[5], u3 = r3[4] * o3, c2 = r3[3] * u3, l2 = r3[2] * c2, p2 = r3[1] * l2, { newShape: f2, keptDims: d2 } = (0, a2.squeezeShape)(r3);
          if (f2.length < r3.length) {
            const o4 = (0, s2.squeezeInputShape)(r3, f2), a3 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o4;
            const c3 = `
            ${this.getUnpackedSamplerFromInput(t3, e3, u4).routineBody}
            float ${t3}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t3}(${(0, s2.getSqueezedParams)(a3, d2)});
            }
          `;
            return new i2.GlslLibRoutine(c3, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const h2 = `
          float ${t3}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p2} + col * ${l2} + depth * ${c2} +
            depth2 * ${u3} + depth3 * ${o3} + depth4;
            vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
            return sampleTexture(${e3}, uv);
          }
        `;
          return new i2.GlslLibRoutine(h2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        toVec() {
          const t3 = this.context.outputTextureLayout, e3 = t3.shape.length, n3 = t3.strides, r3 = t3.width, o3 = t3.height, a3 = [];
          for (let t4 = 0; t4 < e3 - 1; ++t4) a3.push(`
        c[${t4}] = offset / ${n3[t4]};`), a3.push(`
        offset -= c[${t4}] * ${n3[t4]};`);
          a3.push(`
        c[${e3 - 1}] = offset;`);
          const s3 = `
      void toVec(vec2 texCoords, out int c[${e3}]) {
        int offset = coordsToOffset(texCoords, ${r3}, ${o3});
        ${a3.join("")}
      }
      void toVec(int offset, out int c[${e3}]) {
        ${a3.join("")}
      }
    `;
          return { toVec: new i2.GlslLibRoutine(s3, ["coordinates.coordsToOffset"]) };
        }
        valueFrom() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const r3 = this.context.inputTextureLayouts[n3], o3 = (r3.unpackedShape.length > 0 ? r3.unpackedShape : r3.shape).length;
            let a3 = `_${e3}`;
            t3[a3] = new i2.GlslLibRoutine(this.getValueFromSingle(e3, o3, r3.width, r3.height, false), [`shapeUtils.indicesToOffset${a3}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a3 += "_T", t3[a3] = new i2.GlslLibRoutine(this.getValueFromSingle(e3, o3, r3.width, r3.height, true), [`shapeUtils.indicesToOffset${a3}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
          }), t3;
        }
        getValueFromSingle(t3, e3, n3, r3, i3) {
          let a3 = `_${t3}`;
          return i3 && (a3 += "_T"), `
        float ${a3}(int m[${e3}]) {
          int offset = indicesToOffset${a3}(m);
          vec2 coords = offsetToCoords(offset, ${n3}, ${r3});
          float value = getColorAsFloat(${(0, o2.getGlsl)(this.context.glContext.version).texture2D}(${t3}, coords));
          return value;
        }
        `;
        }
        getPackedValueFrom(t3, e3, n3, r3, i3) {
          let a3 = `_${t3}_Pack`;
          return i3 && (a3 += "_T"), `
        vec4 ${a3}(int m[${e3}]) {
          int offset = indicesToOffset_${t3}(m);
          vec2 coords = offsetToCoords(offset, ${n3}, ${r3});
          return ${(0, o2.getGlsl)(this.context.glContext.version).texture2D}(${t3}, coords);
        }
        `;
        }
      }
      e2.CoordsGlslLib = u2;
    }, 8520: (t2, e2) => {
      var n2;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TopologicalSortGlslRoutines = e2.GlslLibRoutineNode = e2.GlslLibRoutine = e2.GlslLib = e2.GlslContext = e2.FunctionType = void 0, (n2 = e2.FunctionType || (e2.FunctionType = {}))[n2.ValueBased = 0] = "ValueBased", n2[n2.Positional = 1] = "Positional", e2.GlslContext = class {
        constructor(t3, e3, n3, r2) {
          this.glContext = t3, this.programInfo = e3, this.inputTextureLayouts = n3, this.outputTextureLayout = r2;
        }
      }, e2.GlslLib = class {
        constructor(t3) {
          this.context = t3;
        }
      }, e2.GlslLibRoutine = class {
        constructor(t3, e3) {
          this.routineBody = t3, this.dependencies = e3;
        }
      }, e2.GlslLibRoutineNode = class {
        constructor(t3, e3, n3) {
          this.name = t3, this.dependencies = n3 || [], e3 && (this.routineBody = e3);
        }
        addDependency(t3) {
          t3 && this.dependencies.push(t3);
        }
      }, e2.TopologicalSortGlslRoutines = class {
        static returnOrderedNodes(t3) {
          if (!t3 || 0 === t3.length) return [];
          if (1 === t3.length) return t3;
          const e3 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set(), r2 = new Array();
          return this.createOrderedNodes(t3, e3, n3, r2), r2;
        }
        static createOrderedNodes(t3, e3, n3, r2) {
          for (let i2 = 0; i2 < t3.length; ++i2) this.dfsTraverse(t3[i2], e3, n3, r2);
        }
        static dfsTraverse(t3, e3, n3, r2) {
          if (!t3 || n3.has(t3.name)) return;
          if (e3.has(t3.name)) throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
          e3.add(t3.name);
          const i2 = t3.dependencies;
          if (i2 && i2.length > 0) for (let t4 = 0; t4 < i2.length; ++t4) this.dfsTraverse(i2[t4], e3, n3, r2);
          r2.push(t3), n3.add(t3.name), e3.delete(t3.name);
        }
      };
    }, 7341: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.EncodingGlslLib = void 0;
      const r2 = n2(8520);
      class i2 extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
        }
        getCustomTypes() {
          return {};
        }
        encodeFloat32() {
          return { encode: new r2.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
        }
        decodeFloat32() {
          return { decode: new r2.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
        }
        encodeUint8() {
          const t3 = i2.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return { encode: new r2.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t3}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
        }
        decodeUint8() {
          const t3 = i2.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return { decode: new r2.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t3}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
        }
        static isLittleEndian() {
          const t3 = new ArrayBuffer(4), e3 = new Uint32Array(t3), n3 = new Uint8Array(t3);
          if (e3[0] = 3735928559, 239 === n3[0]) return true;
          if (222 === n3[0]) return false;
          throw new Error("unknown endianness");
        }
      }
      e2.EncodingGlslLib = i2;
    }, 9894: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.FragColorGlslLib = void 0;
      const r2 = n2(8520), i2 = n2(5060);
      class o2 extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
        }
        getCustomTypes() {
          return {};
        }
        setFragColor() {
          const t3 = (0, i2.getGlsl)(this.context.glContext.version);
          return { setFragColor: new r2.GlslLibRoutine(`
        void setFragColor(float value) {
            ${t3.output} = encode(value);
        }
        `, ["encoding.encode"]) };
        }
        getColorAsFloat() {
          return { getColorAsFloat: new r2.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
        }
      }
      e2.FragColorGlslLib = o2;
    }, 2848: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.replaceInlines = void 0;
      const n2 = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
      e2.replaceInlines = function(t3) {
        const e3 = {};
        let r2;
        for (; null !== (r2 = n2.exec(t3)); ) {
          const t4 = r2[3].split(",").map((t5) => {
            const e4 = t5.trim().split(" ");
            return e4 && 2 === e4.length ? { type: e4[0], name: e4[1] } : null;
          }).filter((t5) => null !== t5);
          e3[r2[2]] = { params: t4, body: r2[4] };
        }
        for (const n3 in e3) {
          const i2 = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n3), o2 = new RegExp(i2, "gm");
          for (; null !== (r2 = o2.exec(t3)); ) {
            const i3 = r2[1], o3 = r2[2], a2 = r2[3].split(","), s2 = i3 ? `${i3} ${o3};` : "";
            let u2 = e3[n3].body, c2 = "";
            e3[n3].params.forEach((t4, e4) => {
              t4 && (c2 += `${t4.type} ${t4.name} = ${a2[e4]};
`);
            }), u2 = `${c2}
 ${u2}`, u2 = u2.replace("return", `${o3} = `);
            const l2 = `
      ${s2}
      {
        ${u2}
      }
      `;
            t3 = t3.replace(r2[0], l2);
          }
        }
        return t3.replace(n2, "");
      };
    }, 8879: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.GlslPreprocessor = void 0;
      const r2 = n2(8520), i2 = n2(2848), o2 = n2(5483), a2 = n2(5060);
      e2.GlslPreprocessor = class {
        constructor(t3, e3, n3, i3) {
          this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r2.GlslContext(t3, e3, n3, i3), Object.keys(o2.glslRegistry).forEach((t4) => {
            const e4 = new o2.glslRegistry[t4](this.context);
            this.libs[t4] = e4;
          });
          const a3 = this.glslLibRoutineDependencyGraph;
          for (const t4 in this.libs) {
            const e4 = this.libs[t4].getFunctions();
            for (const n4 in e4) {
              const i4 = t4 + "." + n4;
              let o3;
              a3[i4] ? (o3 = a3[i4], o3.routineBody = e4[n4].routineBody) : (o3 = new r2.GlslLibRoutineNode(i4, e4[n4].routineBody), a3[i4] = o3);
              const s2 = e4[n4].dependencies;
              if (s2) for (let t5 = 0; t5 < s2.length; ++t5) if (a3[s2[t5]]) o3.addDependency(a3[s2[t5]]);
              else {
                const e5 = new r2.GlslLibRoutineNode(s2[t5]);
                a3[s2[t5]] = e5, o3.addDependency(e5);
              }
            }
          }
        }
        preprocess() {
          const t3 = this.context.programInfo;
          let e3 = t3.shaderSource;
          return this.context.programInfo.hasMain || (e3 = `${e3}
      ${(0, a2.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e3 = (0, i2.replaceInlines)(e3), `${(0, a2.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(t3.inputNames, t3.variables)}
    ${this.getImports(e3)}
    ${e3}`;
        }
        getImports(t3) {
          const e3 = this.selectGlslLibRoutinesToBeIncluded(t3);
          if (0 === e3.length) return "";
          let n3 = "";
          for (let t4 = 0; t4 < e3.length; ++t4) {
            if (!e3[t4].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${e3[t4].name}`);
            n3 += e3[t4].routineBody + "\n";
          }
          return n3;
        }
        selectGlslLibRoutinesToBeIncluded(t3) {
          const e3 = [];
          return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n3) => {
            const r3 = n3.split(".")[1];
            -1 !== t3.indexOf(r3) && e3.push(this.glslLibRoutineDependencyGraph[n3]);
          }), r2.TopologicalSortGlslRoutines.returnOrderedNodes(e3);
        }
        getUniforms(t3, e3) {
          const n3 = [];
          if (t3) for (const e4 of t3) n3.push(`uniform sampler2D ${e4};`);
          if (e3) for (const t4 of e3) n3.push(`uniform ${t4.type} ${t4.name}${t4.arrayLength ? `[${t4.arrayLength}]` : ""};`);
          return n3.join("\n");
        }
      };
    }, 5483: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.glslRegistry = void 0;
      const r2 = n2(5107), i2 = n2(7341), o2 = n2(9894), a2 = n2(2655), s2 = n2(3891);
      e2.glslRegistry = { encoding: i2.EncodingGlslLib, fragcolor: o2.FragColorGlslLib, vec: s2.VecGlslLib, shapeUtils: a2.ShapeUtilsGlslLib, coordinates: r2.CoordsGlslLib };
    }, 2655: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ShapeUtilsGlslLib = void 0;
      const r2 = n2(8520);
      class i2 extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
        }
        getCustomTypes() {
          return {};
        }
        bcastIndex() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = {};
          return this.context.programInfo.inputNames.forEach((n3, i3) => {
            const o2 = this.context.inputTextureLayouts[i3].unpackedShape;
            if (o2.length <= t3) {
              const i4 = o2.length, a2 = t3 - i4, s2 = `bcastIndices_${n3}`;
              let u2 = "";
              for (let t4 = 0; t4 < i4; ++t4) u2 += `
          realIndices[${t4}] = int( mod(float(bcastedIndices[${a2 + t4}]), ${o2[t4]}.0) );
          `;
              const c2 = `
        void ${s2} (int bcastedIndices[${t3}], out int realIndices[${i4}]) {
          ${u2}
        }
        `;
              e3[s2] = new r2.GlslLibRoutine(c2);
            }
          }), e3;
        }
        bcastMatmulIndex() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = {};
          return this.context.programInfo.inputNames.forEach((n3, i3) => {
            const o2 = this.context.inputTextureLayouts[i3].shape;
            if (!(o2.length < 2 || o2.length > t3)) {
              const i4 = o2.length, a2 = t3 - i4, s2 = `bcastMatmulIndices_${n3}`;
              let u2 = "";
              for (let t4 = 0; t4 < i4 - 2; ++t4) u2 += `
          realIndices[${t4}] = int( mod(float(bcastedIndices[${a2 + t4}]), ${o2[t4]}.0) );
          `;
              const c2 = `
        void ${s2}(int bcastedIndices[${t3}], out int realIndices[${i4}]) {
          ${u2}
          realIndices[${i4 - 1}] = bcastedIndices[${t3 - 1}];
          realIndices[${i4 - 2}] = bcastedIndices[${t3 - 2}];
        }
        `;
              e3[s2] = new r2.GlslLibRoutine(c2);
            }
          }), e3;
        }
        indicesToOffset() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const o2 = this.context.inputTextureLayouts[n3].shape, a2 = this.context.inputTextureLayouts[n3].strides, s2 = o2.length;
            let u2 = `indicesToOffset_${e3}`;
            t3[u2] = new r2.GlslLibRoutine(i2.indexToOffsetSingle(u2, s2, a2)), u2 = `indicesToOffset_${e3}_T`, t3[u2] = new r2.GlslLibRoutine(i2.indexToOffsetSingle(u2, s2, a2.slice().reverse()));
          }), t3;
        }
        static indexToOffsetSingle(t3, e3, n3) {
          let r3 = "";
          for (let t4 = e3 - 1; t4 >= 0; --t4) r3 += `
        offset += indices[${t4}] * ${n3[t4]};
        `;
          return `
      int ${t3}(int indices[${e3}]) {
        int offset = 0;
        ${r3}
        return offset;
      }
      `;
        }
        offsetToIndices() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const o2 = this.context.inputTextureLayouts[n3].shape, a2 = this.context.inputTextureLayouts[n3].strides, s2 = o2.length;
            let u2 = `offsetToIndices_${e3}`;
            t3[u2] = new r2.GlslLibRoutine(i2.offsetToIndicesSingle(u2, s2, a2)), u2 = `offsetToIndices_${e3}_T`, t3[u2] = new r2.GlslLibRoutine(i2.offsetToIndicesSingle(u2, s2, a2.slice().reverse()));
          }), t3;
        }
        static offsetToIndicesSingle(t3, e3, n3) {
          const r3 = [];
          for (let t4 = 0; t4 < e3 - 1; ++t4) r3.push(`
      indices[${t4}] = offset / ${n3[t4]};`), r3.push(`
        offset -= indices[${t4}] * ${n3[t4]};`);
          return r3.push(`
      indices[${e3 - 1}] = offset;`), `
      void ${t3}(int offset, out int indices[${e3}]) {
        ${r3.join("")}
      }
      `;
        }
        incrementIndices() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const i3 = this.context.inputTextureLayouts[n3].shape, o2 = i3.length, a2 = `incrementIndices_${e3}`;
            let s2 = "";
            for (let t4 = 0; t4 < o2; ++t4) s2 += `
        shape[${t4}] = ${i3[t4]};`;
            const u2 = `
        void ${a2}(int axis, out int indices[${o2}]) {
          int shape[${o2}];
          ${s2};
          for(int i = ${o2} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
            t3[a2] = new r2.GlslLibRoutine(u2);
          }), t3;
        }
      }
      e2.ShapeUtilsGlslLib = i2;
    }, 5060: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getDefaultFragShaderMain = e2.getFragShaderPreamble = e2.getVertexShaderSource = e2.getGlsl = void 0;
      const n2 = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r2 = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
      function i2(t3) {
        return 1 === t3 ? n2 : r2;
      }
      e2.getGlsl = i2, e2.getVertexShaderSource = function(t3) {
        const e3 = i2(t3);
        return `${e3.version}
      precision highp float;
      ${e3.attribute} vec3 position;
      ${e3.attribute} vec2 textureCoord;

      ${e3.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
      }, e2.getFragShaderPreamble = function(t3) {
        const e3 = i2(t3);
        return `${e3.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e3.varyingFrag} vec2 TexCoords;
    ${e3.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
      }, e2.getDefaultFragShaderMain = function(t3, e3) {
        return `
  void main() {
    int indices[${e3}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i2(t3).output} = result;
  }
  `;
      };
    }, 3891: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.VecGlslLib = void 0;
      const r2 = n2(8520);
      class i2 extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getCustomTypes() {
          return {};
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
        }
        binaryVecFunctions() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n3 = {};
          for (const i3 in e3) {
            const o2 = `${i3}Vec`;
            let a2 = "";
            for (let n4 = 0; n4 < t3; ++n4) a2 += `
          dest[${n4}] ${e3[i3]} src[${n4}];
          `;
            const s2 = `
        void ${o2}(int src[${t3}], out int dest[${t3}]) {
          ${a2}
        }
        `;
            n3[o2] = new r2.GlslLibRoutine(s2);
          }
          return n3;
        }
        copyVec() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = "";
          for (let n4 = 0; n4 < t3; ++n4) e3 += `
        dest[${n4}] = src[${n4}];
        `;
          const n3 = `
      void copyVec(int src[${t3}], out int dest[${t3}]) {
        ${e3}
      }
      `;
          return { copyVec: new r2.GlslLibRoutine(n3) };
        }
        setVecItem() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = `
        if(index < 0)
            index =${t3} + index;
        if (index == 0)
            m[0] = value;
        `;
          for (let n4 = 1; n4 < t3 - 1; ++n4) e3 += `
        else if (index == ${n4})
            m[${n4}] = value;
            `;
          e3 += `
        else
            m[${t3 - 1}] = value;
        `;
          const n3 = `
      void setVecItem(out int m[${t3}], int index, int value) {
        ${e3}
      }
        `;
          return { setVecItem: new r2.GlslLibRoutine(n3) };
        }
        getVecItem() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = `
        if(index < 0)
            index = ${t3} + index;
        if (index == 0)
            return m[0];
      `;
          for (let n4 = 1; n4 < t3 - 1; ++n4) e3 += `
        else if (index == ${n4})
            return m[${n4}];
      `;
          e3 += `
        else
            return m[${t3 - 1}];
        `;
          const n3 = `
      int getVecItem(int m[${t3}], int index) {
        ${e3}
      }
    `;
          return { getVecItem: new r2.GlslLibRoutine(n3) };
        }
      }
      e2.VecGlslLib = i2;
    }, 8316: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLInferenceHandler = void 0;
      const r2 = n2(6231), i2 = n2(9162), o2 = n2(2517), a2 = n2(2403), s2 = n2(7019), u2 = n2(8710), c2 = n2(5611), l2 = n2(4057), p2 = n2(2039);
      e2.WebGLInferenceHandler = class {
        constructor(t3) {
          this.session = t3, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        calculateTextureWidthAndHeight(t3, e3) {
          return (0, l2.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t3, e3);
        }
        executeProgram(t3, e3) {
          if (e3.length < t3.inputNames.length) throw new Error(`Input size mustn't be less than ${t3.inputNames.length}.`);
          if (t3.inputNames.length !== t3.inputTypes.length) throw new Error("input names size does not match input types");
          const n3 = [];
          for (let r4 = 0; r4 < t3.inputNames.length; ++r4) n3[r4] = this.getOrCreateTextureData(e3[r4], t3.inputTypes[r4]);
          const r3 = ((t4, e4) => {
            const n4 = e4.map((t5) => `${t5.unpackedShape.join(",")};${t5.width}x${t5.height}`).join("_");
            let r4 = t4.name;
            return t4.cacheHint && (r4 += "[" + t4.cacheHint + "]"), r4 += ":" + n4, r4;
          })(t3, n3);
          let i3 = this.session.programManager.getArtifact(r3);
          const o3 = i3 ? i3.programInfo : "function" == typeof t3.get ? t3.get() : t3, a3 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o3.output.dims, o3.output.textureType), s3 = this.createTextureData(a3, o3.output.type);
          return i3 || (i3 = this.session.programManager.build(o3, n3, s3), this.session.programManager.setArtifact(r3, i3)), this.runProgram(i3, n3, s3), s3;
        }
        run(t3, e3) {
          return this.executeProgram(t3, e3).tensor;
        }
        runProgram(t3, e3, n3) {
          for (let n4 = 0; n4 < e3.length; ++n4) if (!!e3[n4].isPacked != (t3.programInfo.inputTypes[n4] === p2.TextureType.packed)) throw new Error(`input[${n4}] property packed inconsistent`);
          if (!!n3.isPacked != (t3.programInfo.output.textureType === p2.TextureType.packed)) throw new Error("output property packed inconsistent");
          this.session.programManager.run(t3, e3, n3);
        }
        getOrCreateTextureData(t3, e3) {
          let n3 = this.getTextureData(t3.dataId, e3 === p2.TextureType.packed);
          if (!n3 && (n3 = this.getTextureData(t3.dataId, e3 !== p2.TextureType.packed), n3)) return e3 === p2.TextureType.packed ? this.pack(n3) : this.unpack(n3);
          if (!n3) {
            const r3 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t3.dims, e3);
            if (e3 === p2.TextureType.packedLastDimension) {
              const n4 = 1, r4 = 4, i3 = t3.dims;
              if (4 === i3.length) {
                const o3 = [i3[0], Math.ceil(i3[1] * i3[2] * i3[3] / r4)], a3 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o3, e3);
                let s3 = t3.numberData;
                if (i3[1] * i3[2] * i3[3] % r4 != 0) {
                  const e4 = i3[0], o4 = i3[1] * i3[2] * i3[3], a4 = Math.ceil(o4 * n4 / r4) * r4;
                  s3 = new Float32Array(e4 * a4);
                  for (let r5 = 0; r5 < e4; ++r5) {
                    const e5 = r5 * o4, i4 = r5 * a4 + r5 % n4 * o4;
                    s3.set(t3.numberData.subarray(e5, e5 + o4), i4);
                  }
                }
                return this.createTextureData(a3, t3.type, s3, t3, 1);
              }
            }
            if (e3 === p2.TextureType.packed) {
              const e4 = (0, l2.createTextureLayoutFromShape)(this.session.layoutStrategy, t3.dims, 1, [], { reverseWH: true }), r4 = this.createTextureData(e4, t3.type, t3.numberData, t3, 1);
              n3 = this.pack(r4);
            } else n3 = this.createTextureData(r3, t3.type, t3.numberData, t3, 1);
          }
          return n3;
        }
        createTextureDataFromLayoutBindTensor(t3, e3, n3, r3) {
          return this.createTextureData(t3, e3, n3, r3, 1);
        }
        createTextureData(t3, e3, n3, i3, o3) {
          r2.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t3)}]`);
          const a3 = this.session.textureManager.createTextureFromLayout(e3, t3, n3, o3);
          return this.createTextureDataFromTexture(t3, e3, a3, i3);
        }
        reshapeUnpacked(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.unpacked), r3 = { channels: n3.channels, height: n3.height, width: n3.width, shape: 0 !== e3.length ? e3 : [1], strides: o2.ShapeUtil.computeStrides(e3), unpackedShape: e3 };
          return this.createTextureDataFromTexture(r3, t3.type, n3.texture).tensor;
        }
        reshapePacked(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.packed);
          if ((0, s2.isReshapeCheap)(t3.dims, e3)) {
            const r4 = { channels: n3.channels, height: n3.height, width: n3.width, shape: 0 !== e3.length ? e3 : [1], strides: o2.ShapeUtil.computeStrides(e3), unpackedShape: e3, isPacked: true };
            return this.createTextureDataFromTexture(r4, t3.type, n3.texture).tensor;
          }
          const r3 = (0, s2.processDims3D)(t3.dims), i3 = (0, s2.processDims3D)(e3), a3 = this.reshapePacked(t3, r3), u3 = this.run((0, s2.createPackedReshape3DProgramInfoLoader)(this, a3, i3), [a3]);
          return this.reshapePacked(u3, e3);
        }
        cast(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.unpacked);
          return this.createTextureDataFromTexture(n3, e3, n3.texture).tensor;
        }
        createTextureDataFromTexture(t3, e3, n3, r3, o3) {
          const a3 = Object.assign(Object.assign({}, t3), { tensor: r3 || new i2.Tensor(t3.unpackedShape, e3, (t4) => this.readTexture(a3), async (t4) => this.readTextureAsync(a3), void 0, o3), texture: n3 });
          return this.setTextureData(a3.tensor.dataId, a3, t3.isPacked), a3;
        }
        getTextureData(t3, e3 = false) {
          return this.session.isInitializer(t3) ? this.session.getTextureData(t3, e3) : e3 ? this.packedTextureDataCache.get(t3) : this.unpackedTextureDataCache.get(t3);
        }
        setTextureData(t3, e3, n3 = false) {
          this.session.isInitializer(t3) ? this.session.setTextureData(t3, e3, n3) : (n3 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t3, e3);
        }
        isTextureLayoutCached(t3, e3 = false) {
          return !!this.getTextureData(t3.dataId, e3);
        }
        dispose() {
          this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t3) => this.session.textureManager.releaseTexture(t3)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t3) => this.session.textureManager.releaseTexture(t3)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        readTexture(t3) {
          return t3.isPacked ? this.readTexture(this.unpack(t3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t3, t3.tensor.type, t3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u2.encodeAsUint8)(this, t3));
        }
        async readTextureAsync(t3) {
          return t3.isPacked ? this.readTextureAsync(this.unpack(t3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t3, t3.tensor.type, t3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u2.encodeAsUint8)(this, t3));
        }
        pack(t3) {
          return this.executeProgram((0, a2.createPackProgramInfoLoader)(this, t3.tensor), [t3.tensor]);
        }
        unpack(t3) {
          return this.executeProgram((0, c2.createUnpackProgramInfoLoader)(this, t3.tensor), [t3.tensor]);
        }
      };
    }, 1640: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i3 = Object.getOwnPropertyDescriptor(e3, n3);
        i3 && !("get" in i3 ? !e3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i3);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i2 = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o2 = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i2(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WEBGL_OP_RESOLVE_RULES = void 0;
      const a2 = n2(2898), s2 = o2(n2(7839)), u2 = n2(4196), c2 = n2(2069), l2 = n2(8138), p2 = n2(9663), f2 = n2(5193), d2 = n2(7992), h2 = n2(1253), g2 = n2(4776), b2 = n2(6572), m2 = n2(3346), y2 = n2(5623), _ = n2(2870), v2 = n2(2143), w2 = n2(4939), x2 = n2(718), T2 = n2(2268), S2 = n2(8117), O2 = n2(2278), A2 = n2(5524), E2 = n2(5975), I2 = n2(3933), P2 = n2(6558), D2 = n2(5723), $2 = n2(3738), k2 = o2(n2(4909)), C2 = n2(8428), F2 = n2(9793);
      e2.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k2.abs], ["Acos", "", "7+", k2.acos], ["Add", "", "7+", s2.add], ["And", "", "7+", s2.and], ["Asin", "", "7+", k2.asin], ["Atan", "", "7+", k2.atan], ["AveragePool", "", "7+", v2.averagePool, v2.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a2.batchNormalization, a2.parseBatchNormalizationAttributes], ["Cast", "", "6+", u2.cast, u2.parseCastAttributes], ["Ceil", "", "6+", k2.ceil], ["Clip", "", "6-10", k2.clip, k2.parseClipAttributes], ["Clip", "", "11+", k2.clipV11], ["Concat", "", "4+", c2.concat, c2.parseConcatAttributes], ["Conv", "", "1+", l2.conv, l2.parseConvAttributes], ["ConvTranspose", "", "1+", p2.convTranspose, p2.parseConvTransposeAttributes], ["Cos", "", "7+", k2.cos], ["Div", "", "7+", s2.div], ["Dropout", "", "7+", k2.identity], ["DepthToSpace", "", "1+", f2.depthToSpace, f2.parseDepthToSpaceAttributes], ["Equal", "", "7+", s2.equal], ["Elu", "", "6+", k2.elu, k2.parseEluAttributes], ["Exp", "", "6+", k2.exp], ["Flatten", "", "1+", d2.flatten, d2.parseFlattenAttributes], ["Floor", "", "6+", k2.floor], ["FusedConv", "com.microsoft", "1+", l2.conv, l2.parseConvAttributes], ["Gather", "", "1+", h2.gather, h2.parseGatherAttributes], ["Gemm", "", "7-10", g2.gemm, g2.parseGemmAttributesV7], ["Gemm", "", "11+", g2.gemm, g2.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", v2.globalAveragePool, v2.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", v2.globalMaxPool], ["Greater", "", "7+", s2.greater], ["Identity", "", "1+", k2.identity], ["ImageScaler", "", "1+", b2.imageScaler, b2.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m2.instanceNormalization, m2.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k2.leakyRelu, k2.parseLeakyReluAttributes], ["Less", "", "7+", s2.less], ["Log", "", "6+", k2.log], ["MatMul", "", "1+", y2.matMul, y2.parseMatMulAttributes], ["MaxPool", "", "1+", v2.maxPool, v2.parseMaxPoolAttributes], ["Mul", "", "7+", s2.mul], ["Neg", "", "6+", k2.neg], ["Not", "", "1+", k2.not], ["Or", "", "7+", s2.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s2.pow], ["PRelu", "", "7+", s2.pRelu], ["ReduceLogSum", "", "1+", w2.reduceLogSum, w2.parseReduceAttributes], ["ReduceMax", "", "1+", w2.reduceMax, w2.parseReduceAttributes], ["ReduceMean", "", "1+", w2.reduceMean, w2.parseReduceAttributes], ["ReduceMin", "", "1+", w2.reduceMin, w2.parseReduceAttributes], ["ReduceProd", "", "1+", w2.reduceProd, w2.parseReduceAttributes], ["ReduceSum", "", "1-12", w2.reduceSum, w2.parseReduceAttributes], ["ReduceSumSquare", "", "1+", w2.reduceLogSumSquare, w2.parseReduceAttributes], ["Relu", "", "6+", k2.relu], ["Reshape", "", "5+", x2.reshape], ["Resize", "", "10", T2.resize, T2.parseResizeAttributesV10], ["Resize", "", "11+", T2.resize, T2.parseResizeAttributesV11], ["Shape", "", "1+", S2.shape], ["Sigmoid", "", "6+", k2.sigmoid], ["Sin", "", "7+", k2.sin], ["Slice", "", "10+", O2.sliceV10], ["Slice", "", "1-9", O2.slice, O2.parseSliceAttributes], ["Softmax", "", "1-12", A2.softmax, A2.parseSoftmaxAttributes], ["Softmax", "", "13+", A2.softmaxV13, A2.parseSoftmaxAttributesV13], ["Split", "", "2-12", E2.split, E2.parseSplitAttributes], ["Sqrt", "", "6+", k2.sqrt], ["Squeeze", "", "1-12", I2.squeeze, I2.parseSqueezeAttributes], ["Squeeze", "", "13+", I2.squeezeV13], ["Sub", "", "7+", s2.sub], ["Sum", "", "6+", P2.sum], ["Tan", "", "7+", k2.tan], ["Tanh", "", "6+", k2.tanh], ["Tile", "", "6+", D2.tile], ["Transpose", "", "1+", $2.transpose, $2.parseTransposeAttributes], ["Upsample", "", "7-8", F2.upsample, F2.parseUpsampleAttributesV7], ["Upsample", "", "9", F2.upsample, F2.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", C2.unsqueeze, C2.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", C2.unsqueezeV13], ["Xor", "", "7+", s2.xor]];
    }, 2898: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseBatchNormalizationAttributes = e2.batchNormalization = void 0;
      const r2 = n2(246), i2 = n2(5060), o2 = n2(2039), a2 = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked] };
      e2.batchNormalization = (t3, e3, n3) => (u2(e3), [t3.run(Object.assign(Object.assign({}, a2), { cacheHint: n3.cacheKey, get: () => s2(t3, e3, n3) }), e3)]), e2.parseBatchNormalizationAttributes = (t3) => {
        const e3 = t3.attributes.getFloat("epsilon", 1e-5), n3 = t3.attributes.getFloat("momentum", 0.9), i3 = t3.attributes.getInt("spatial", 1);
        return (0, r2.createAttributeWithCacheKey)({ epsilon: e3, momentum: n3, spatial: i3 });
      };
      const s2 = (t3, e3, n3) => {
        const r3 = (0, i2.getGlsl)(t3.session.backend.glContext.version), s3 = e3[0].dims.length, [u3, c2] = t3.calculateTextureWidthAndHeight(e3[1].dims, o2.TextureType.unpacked), l2 = `
  float process(int[${s3}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u3}, ${c2});
    float scale = getColorAsFloat(${r3.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r3.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r3.texture2D}(Variance, position));
    float b = getColorAsFloat(${r3.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n3.epsilon})) ) + b;
  }`;
        return Object.assign(Object.assign({}, a2), { output: { dims: e3[0].dims, type: e3[0].type, textureType: o2.TextureType.unpacked }, shaderSource: l2 });
      }, u2 = (t3) => {
        if (!t3 || 5 !== t3.length) throw new Error("BatchNormalization requires 5 inputs.");
        const e3 = t3[0], n3 = t3[1], r3 = t3[2], i3 = t3[3], o3 = t3[4];
        if (e3.dims.length < 3 || 1 !== n3.dims.length || 1 !== r3.dims.length || 1 !== i3.dims.length || 1 !== o3.dims.length) throw new Error("invalid input shape.");
        if (n3.dims[0] !== e3.dims[1] || r3.dims[0] !== e3.dims[1] || i3.dims[0] !== e3.dims[1] || o3.dims[0] !== e3.dims[1]) throw new Error("invalid input shape.");
        if ("float32" !== e3.type && "float64" !== e3.type || "float32" !== n3.type && "float64" !== n3.type || "float32" !== r3.type && "float64" !== r3.type || "float32" !== i3.type && "float64" !== i3.type || "float32" !== o3.type && "float64" !== o3.type) throw new Error("invalid input tensor types.");
      };
    }, 7839: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.xor = e2.sub = e2.pRelu = e2.pow = e2.or = e2.mul = e2.less = e2.greater = e2.equal = e2.div = e2.and = e2.add = e2.glslPRelu = e2.glslPow = e2.glslXor = e2.glslOr = e2.glslAnd = e2.glslLess = e2.glslGreater = e2.glslEqual = e2.glslSub = e2.glslMul = e2.glslDiv = e2.glslAdd = void 0;
      const r2 = n2(2517), i2 = n2(8520), o2 = n2(5060), a2 = n2(2039);
      function s2() {
        const t3 = "add_";
        return { body: `
  float ${t3}(float a, float b) {
    return a + b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function u2() {
        const t3 = "div_";
        return { body: `
  float ${t3}(float a, float b) {
    return a / b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function c2() {
        const t3 = "mul_";
        return { body: `
  float ${t3}(float a, float b) {
    return a * b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function l2() {
        const t3 = "sub_";
        return { body: `
  float ${t3}(float a, float b) {
    return a - b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function p2() {
        const t3 = "equal_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function f2() {
        const t3 = "greater_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function d2() {
        const t3 = "less_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function h2() {
        const t3 = "and_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function g2() {
        const t3 = "or_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function b2() {
        const t3 = "xor_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      function m2() {
        return function(t3) {
          const e3 = `${t3}_`;
          return { body: `
  float ${e3}(float a, float b) {
    return ${t3}(a, b);
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return ${t3}(v1, v2);
  }
  `, name: e3, type: i2.FunctionType.ValueBased };
        }("pow");
      }
      function y2() {
        const t3 = "prelu_";
        return { body: `
  float ${t3}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: t3, type: i2.FunctionType.ValueBased };
      }
      e2.glslAdd = s2, e2.glslDiv = u2, e2.glslMul = c2, e2.glslSub = l2, e2.glslEqual = p2, e2.glslGreater = f2, e2.glslLess = d2, e2.glslAnd = h2, e2.glslOr = g2, e2.glslXor = b2, e2.glslPow = m2, e2.glslPRelu = y2;
      const _ = (t3, e3, n3, r3 = e3[0].type, i3) => {
        const o3 = t3.session.pack ? a2.TextureType.packed : a2.TextureType.unpacked;
        return { name: n3.name, inputNames: ["A", "B"], inputTypes: [o3, o3], cacheHint: i3, get: () => v2(t3, e3, n3, r3) };
      }, v2 = (t3, e3, n3, i3 = e3[0].type) => {
        const s3 = t3.session.pack ? a2.TextureType.packed : a2.TextureType.unpacked, u3 = !r2.ShapeUtil.areEqual(e3[0].dims, e3[1].dims);
        let c3 = e3[0].dims;
        const l3 = t3.session.pack;
        if (u3) {
          const a3 = r2.BroadcastUtil.calcShape(e3[0].dims, e3[1].dims, false);
          if (!a3) throw new Error("Can't perform binary op on the given tensors");
          c3 = a3;
          const u4 = c3.length, p4 = 0 !== e3[0].dims.length ? e3[0].dims.length : 1, f4 = 0 !== e3[1].dims.length ? e3[1].dims.length : 1, d3 = 0 !== e3[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h3 = 0 !== e3[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g3 = (0, o2.getGlsl)(t3.session.backend.glContext.version), b3 = l3 ? `
      ${n3.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n3.name}(a, b);
        ${g3.output} = result;
      }` : `
      ${n3.body}
      float process(int indices[${u4}]) {
        int aindices[${p4}];
        int bindices[${f4}];
        ${d3}
        ${h3}
        return ${n3.name}(_A(aindices), _B(bindices));
      }`;
          return { name: n3.name, inputNames: ["A", "B"], inputTypes: [s3, s3], output: { dims: c3, type: i3, textureType: s3 }, shaderSource: b3, hasMain: l3 };
        }
        const p3 = (0, o2.getGlsl)(t3.session.backend.glContext.version), f3 = `
    ${n3.body}
    void main() {
      vec4 v1 = ${p3.texture2D}(A, TexCoords);
      vec4 v2 = ${p3.texture2D}(B, TexCoords);
      vec4 result = ${n3.name}(v1, v2);
      ${p3.output} = result;
    }
    `;
        return { name: n3.name, inputNames: ["A", "B"], inputTypes: [s3, s3], output: { dims: e3[0].dims, type: i3, textureType: s3 }, shaderSource: f3, hasMain: true };
      };
      e2.add = (t3, e3) => [t3.run(_(t3, e3, s2()), e3)], e2.and = (t3, e3) => [t3.run(_(t3, e3, h2(), "bool"), e3)], e2.div = (t3, e3) => [t3.run(_(t3, e3, u2()), e3)], e2.equal = (t3, e3) => [t3.run(_(t3, e3, p2(), "bool"), e3)], e2.greater = (t3, e3) => [t3.run(_(t3, e3, f2(), "bool"), e3)], e2.less = (t3, e3) => [t3.run(_(t3, e3, d2(), "bool"), e3)], e2.mul = (t3, e3) => [t3.run(_(t3, e3, c2()), e3)], e2.or = (t3, e3) => [t3.run(_(t3, e3, g2(), "bool"), e3)], e2.pow = (t3, e3) => [t3.run(_(t3, e3, m2()), e3)], e2.pRelu = (t3, e3) => [t3.run(_(t3, e3, y2()), e3)], e2.sub = (t3, e3) => [t3.run(_(t3, e3, l2()), e3)], e2.xor = (t3, e3) => [t3.run(_(t3, e3, b2(), "bool"), e3)];
    }, 4196: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseCastAttributes = e2.cast = void 0;
      const r2 = n2(2517);
      e2.cast = (t3, e3, n3) => (i2(e3), [t3.cast(e3[0], n3)]), e2.parseCastAttributes = (t3) => r2.ProtoUtil.tensorDataTypeFromProto(t3.attributes.getInt("to"));
      const i2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Cast requires 1 input.");
        if ("string" === t3[0].type) throw new Error("Invalid input type.");
      };
    }, 1163: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedConcatProgramInfoLoader = void 0;
      const r2 = n2(5060), i2 = n2(2039), o2 = n2(9390), a2 = n2(2827);
      e2.createPackedConcatProgramInfoLoader = (t3, e3, n3) => {
        const u2 = (c2 = e3.length, l2 = n3.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c2 }, (t4, e4) => `X${e4}`), inputTypes: Array(c2).fill(i2.TextureType.packed), cacheHint: l2 });
        var c2, l2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, u3) => {
          const c3 = n4[0].dims.slice();
          if (u3 >= c3.length || u3 < -1 * c3.length) throw new Error("axis specified for concat doesn't match input dimensionality");
          u3 < 0 && (u3 = c3.length + u3);
          const l3 = c3.slice(0);
          for (let t5 = 1; t5 < n4.length; t5++) {
            const e5 = n4[t5].dims.slice();
            for (let t6 = 0; t6 < c3.length; t6++) if (t6 === u3) l3[u3] += e5[t6];
            else if (c3[t6] !== e5[t6]) throw new Error("non concat dimensions must match");
          }
          const p2 = l3.length, f2 = (0, a2.getChannels)("coords", p2), d2 = (0, o2.getCoordsDataType)(p2), h2 = (0, a2.unpackFromChannel)(), g2 = n4.map((t5) => t5.dims), b2 = (0, o2.getGlChannels)(p2), m2 = new Array(g2.length - 1);
          m2[0] = g2[0][u3];
          for (let t5 = 1; t5 < m2.length; t5++) m2[t5] = m2[t5 - 1] + g2[t5][u3];
          const y2 = b2[u3], _ = b2.slice(-2), v2 = b2.join();
          let w2 = `if (${y2} < ${m2[0]}) {
        return getChannel(
            getX0(${v2}), vec2(${_.join()}));
        }`;
          for (let t5 = 1; t5 < m2.length; t5++) {
            const e5 = m2[t5 - 1];
            w2 += `
            if (${y2} < ${m2[t5]}  && ${y2} >= ${m2[t5 - 1]}) {
              return getChannel(
                getX${t5}(${s2(b2, y2, e5)}),
                vec2(${s2(_, y2, e5)}));
            }`;
          }
          const x2 = m2.length, T2 = m2[m2.length - 1];
          w2 += `
            return getChannel(
              getX${x2}(${s2(b2, y2, T2)}),
              vec2(${s2(_, y2, T2)}));`;
          const S2 = (0, r2.getGlsl)(t4.session.backend.glContext.version), O2 = `
          ${h2}
          float getValue(${b2.map((t5) => "int " + t5)}) {
            ${w2}
          }

          void main() {
            ${d2} coords = getOutputCoords();
            int lastDim = coords.${b2[p2 - 1]};
            coords.${b2[p2 - 1]} = coords.${b2[p2 - 2]};
            coords.${b2[p2 - 2]} = lastDim;

            vec4 result = vec4(getValue(${f2}), 0., 0., 0.);

            ${f2[p2 - 1]} = ${f2[p2 - 1]} + 1;
            if (${f2[p2 - 1]} < ${l3[p2 - 1]}) {
              result.g = getValue(${f2});
            }

            ${f2[p2 - 2]} = ${f2[p2 - 2]} + 1;
            if (${f2[p2 - 2]} < ${l3[p2 - 2]}) {
              result.a = getValue(${f2});
            }

            ${f2[p2 - 1]} = ${f2[p2 - 1]} - 1;
            if (${f2[p2 - 2]} < ${l3[p2 - 2]} &&
                ${f2[p2 - 1]} < ${l3[p2 - 1]}) {
              result.b = getValue(${f2});
            }
            ${S2.output} = result;
          }
        `;
          return Object.assign(Object.assign({}, e4), { output: { dims: l3, type: n4[0].type, textureType: i2.TextureType.packed }, shaderSource: O2, hasMain: true });
        })(t3, u2, e3, n3.axis) });
      };
      const s2 = (t3, e3, n3) => {
        const r3 = t3.indexOf(e3);
        return t3.map((t4, e4) => e4 === r3 ? `${t4} - ${n3}` : t4).join();
      };
    }, 2069: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConcatAttributes = e2.concat = void 0;
      const r2 = n2(246), i2 = n2(2039), o2 = n2(1163);
      e2.concat = (t3, e3, n3) => (p2(e3), t3.session.pack && e3[0].dims.length > 1 ? [t3.run((0, o2.createPackedConcatProgramInfoLoader)(t3, e3, n3), e3)] : [t3.run(a2(t3, e3, n3), e3)]);
      const a2 = (t3, e3, n3) => {
        const r3 = (o3 = e3.length, a3 = n3.cacheKey, { name: "Concat", inputNames: Array.from({ length: o3 }, (t4, e4) => `X${e4}`), inputTypes: Array(o3).fill(i2.TextureType.unpacked), cacheHint: a3 });
        var o3, a3;
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const o4 = n4[0].dims.slice();
          if (r4 >= o4.length || r4 < -1 * o4.length) throw new Error("axis specified for concat doesn't match input dimensionality");
          r4 < 0 && (r4 = o4.length + r4);
          const a4 = o4.slice(0);
          for (let t5 = 1; t5 < n4.length; t5++) {
            const e5 = n4[t5].dims.slice();
            for (let t6 = 0; t6 < o4.length; t6++) if (t6 === r4) a4[r4] += e5[t6];
            else if (o4[t6] !== e5[t6]) throw new Error("non concat dimensions must match");
          }
          const p3 = a4.length, f2 = new Array(n4.length);
          let d2 = 0;
          for (let t5 = 0; t5 < f2.length; ++t5) d2 += n4[t5].dims[r4], f2[t5] = d2;
          let h2 = "";
          h2 = n4.length < 5 ? s2(f2) : u2(f2);
          const g2 = `
        ${c2(n4.length, p3)}
        ${l2(f2)}
        ${h2}
        float process(int indices[${p3}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r4}]);

          if(textureIndex != 0) {
            indices[${r4}] = indices[${r4}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: a4, type: n4[0].type, textureType: i2.TextureType.unpacked }, shaderSource: g2 });
        })(0, r3, e3, n3.axis) });
      }, s2 = (t3) => `int getTextureWhereDataResides(int index) {
      ${t3.map((t4, e3) => `if(index<${t4}) {return ${e3};}
`).join("")}
    }`, u2 = (t3) => s2(t3), c2 = (t3, e3) => {
        const n3 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e3}]) {`];
        for (let e4 = 0; e4 < t3; ++e4) 0 === e4 ? n3.push(`	if (textureIndex == ${e4}) { return _X${e4}(indices); }`) : e4 === t3 - 1 ? n3.push(`	else { return _X${e4}(indices); }`) : n3.push(`	else if (textureIndex == ${e4}) { return _X${e4}(indices); }`);
        return n3.push("	}"), n3.join("\n");
      }, l2 = (t3) => {
        const e3 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
        for (let n3 = 0; n3 < t3.length; ++n3) 0 === n3 ? e3.push(`	if (index == ${n3}) { return ${t3[n3]}; }`) : n3 === t3.length - 1 ? e3.push(`	else { return ${t3[n3]}; }`) : e3.push(`	else if (index == ${n3}) { return ${t3[n3]}; }`);
        return e3.push("	}"), e3.join("\n");
      };
      e2.parseConcatAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis") });
      const p2 = (t3) => {
        if (!t3 || t3.length < 1) throw new Error("too few inputs");
        const e3 = t3[0].type, n3 = t3[0].dims.length;
        if ("string" === e3) throw new Error("string tensor is not supported yet");
        for (const r3 of t3) {
          if (r3.type !== e3) throw new Error("input tensors should be one type");
          if (r3.dims.length !== n3) throw new Error("input tensors should have the same shape");
        }
      };
    }, 4770: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createUnpackedGroupedConvProgramInfoLoader = void 0;
      const r2 = n2(6231), i2 = n2(5060), o2 = n2(2039), a2 = n2(8138), s2 = n2(2823);
      e2.createUnpackedGroupedConvProgramInfoLoader = (t3, e3, n3) => {
        const u2 = (c2 = e3.length > 2, l2 = n3.cacheKey, { name: "GroupedConv", inputNames: c2 ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c2 ? [o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked] : [o2.TextureType.unpacked, o2.TextureType.unpacked], cacheHint: l2 });
        var c2, l2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, u3) => {
          const c3 = e4.length > 2 ? "value += getBias(output_channel);" : "", l3 = e4[0].dims.slice(), p2 = e4[1].dims.slice(), f2 = p2[0] / u3.group;
          r2.Logger.verbose("GroupedConv", `autpPad:${u3.autoPad}, dilations:${u3.dilations}, group:${u3.group}, kernelShape:${u3.kernelShape}, pads:${u3.pads}, strides:${u3.strides}`);
          const d2 = (0, a2.calculateOutputShape)(l3, p2, u3.dilations, u3.pads, u3.strides), h2 = (0, i2.getGlsl)(t4.session.backend.glContext.version), { activationFunction: g2, applyActivation: b2 } = (0, s2.getActivationSnippet)(u3), m2 = `
  const ivec2 strides = ivec2(${u3.strides[0]}, ${u3.strides[1]});
  const ivec2 pads = ivec2(${u3.pads[0]}, ${u3.pads[1]});
  ${g2}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f2};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p2[1]}; wInChannel++) {
      int input_channel = group_id * ${p2[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p2[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u3.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l3[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p2[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u3.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l3[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c3}
    ${b2}
    ${h2.output} = vec4(value, .0, .0, .0);
  }
`;
          return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: e4[0].type, textureType: o2.TextureType.unpacked }, shaderSource: m2, hasMain: true });
        })(t3, e3, u2, n3) });
      };
    }, 1386: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.conv2DPacked = e2.conv2DPackedPointwise = void 0;
      const r2 = n2(8138), i2 = n2(8555), o2 = n2(708);
      e2.conv2DPackedPointwise = (t3, e3, n3) => {
        const i3 = e3[0].dims, a2 = e3[1].dims, s2 = (0, r2.calculateOutputShape)(i3, a2, n3.dilations, n3.pads, n3.strides), u2 = t3.reshapePacked(e3[0], [i3[1], i3[2] * i3[3]]), c2 = t3.reshapePacked(e3[1], [a2[0], a2[1]]), l2 = e3.length > 2 ? [c2, u2, e3[2]] : [c2, u2], p2 = t3.run((0, o2.createPackedMatmulProgramInfoLoader)(t3, l2, n3), l2);
        return t3.reshapePacked(p2, s2);
      }, e2.conv2DPacked = (t3, e3, n3) => {
        const a2 = e3[0].dims, s2 = e3[1].dims, u2 = (0, r2.calculateOutputShape)(a2, s2, n3.dilations, n3.pads, n3.strides), c2 = t3.run((0, i2.createPackedIm2ColProgramInfoLoader)(t3, e3[0], e3[1], u2, n3), [e3[0]]), l2 = t3.reshapePacked(e3[1], [s2[0], s2[1] * s2[2] * s2[3]]), p2 = 3 === e3.length ? [l2, c2, e3[2]] : [l2, c2], f2 = t3.run((0, o2.createPackedMatmulProgramInfoLoader)(t3, p2, n3), p2);
        return t3.reshapePacked(f2, u2);
      };
    }, 9663: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConvTransposeAttributes = e2.convTranspose = void 0;
      const r2 = n2(246), i2 = n2(5060), o2 = n2(2039), a2 = n2(2823), s2 = (t3, e3, n3, r3, i3, o3) => (t3 - 1) * e3 + n3 + (r3 - 1) * i3 + 1 - o3, u2 = (t3, e3, n3, r3, i3) => {
        const o3 = Math.floor(t3 / 2);
        "SAME_UPPER" === e3 ? (n3[r3] = o3, n3[i3] = t3 - o3) : "SAME_LOWER" === e3 && (n3[r3] = t3 - o3, n3[i3] = o3);
      };
      e2.convTranspose = (t3, e3, n3) => (f2(e3, n3), c2(t3, e3, n3));
      const c2 = (t3, e3, n3) => {
        const r3 = p2(n3, e3);
        return [l2(t3, e3, r3)];
      }, l2 = (t3, e3, n3) => t3.run(((t4, e4, n4) => {
        const r3 = (s3 = e4.length > 2, u3 = n4.cacheKey, { name: "ConvTranspose", inputNames: s3 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s3 ? [o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked] : [o2.TextureType.unpacked, o2.TextureType.unpacked], cacheHint: u3 });
        var s3, u3;
        return Object.assign(Object.assign({}, r3), { get: () => ((t5, e5, n5, r4) => {
          const s4 = e5.length > 2 ? "getB(output_channel)" : "0.0", u4 = e5[0].dims, c3 = e5[1].dims, l3 = c3[1], p3 = c3[0] / r4.group, f3 = [e5[0].dims[0], e5[1].dims[1] * r4.group, ...r4.outputShape], d2 = (0, i2.getGlsl)(t5.session.backend.glContext.version), { activationFunction: h2, applyActivation: g2 } = (0, a2.getActivationSnippet)(r4), b2 = `
  const ivec2 strides = ivec2(${r4.strides[0]}, ${r4.strides[1]});
  const ivec2 pads = ivec2(${r4.pads[0]}, ${r4.pads[1]});
  ${h2}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${l3};
    int wOutChannel = output_channel - group_id * ${l3};

    float value = ${s4};
    for (int inChannelOffset = 0; inChannelOffset < ${p3}; inChannelOffset++) {
      int input_channel = group_id * ${p3} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c3[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c3[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r4.dilations[0]}, wHOff * ${r4.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u4[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u4[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g2}
    ${d2.output} = vec4(value, .0, .0, .0);
  }
`;
          return Object.assign(Object.assign({}, n5), { output: { dims: f3, type: e5[0].type, textureType: o2.TextureType.unpacked }, shaderSource: b2, hasMain: true });
        })(t4, e4, r3, n4) });
      })(t3, e3, n3), e3), p2 = (t3, e3) => {
        const n3 = t3.kernelShape.slice();
        if (0 === t3.kernelShape.length) for (let t4 = 2; t4 < e3[1].dims.length; ++t4) n3.push(e3[1].dims[t4]);
        const r3 = t3.pads.slice(), i3 = t3.outputShape.slice();
        ((t4, e4, n4, r4, i4, o4, a3, c3) => {
          const l3 = t4.length - 2, p3 = 0 === c3.length;
          for (let f3 = 0; f3 < l3; ++f3) {
            const d2 = p3 ? t4[f3 + 2] * o4[f3] : c3[f3], h2 = s2(t4[f3 + 2], o4[f3], i4[f3], e4[f3], n4[f3], d2);
            u2(h2, r4, i4, f3, f3 + l3), p3 && c3.push(o4[f3] * (t4[f3 + 2] - 1) + a3[f3] + (e4[f3] - 1) * n4[f3] + 1 - i4[f3] - i4[f3 + l3]);
          }
        })(e3[0].dims, n3, t3.dilations, t3.autoPad, r3, t3.strides, t3.outputPadding, i3);
        const o3 = Object.assign({}, t3);
        return Object.assign(o3, { kernelShape: n3, pads: r3, outputShape: i3, cacheKey: t3.cacheKey }), o3;
      };
      e2.parseConvTransposeAttributes = (t3) => {
        const e3 = t3.attributes, n3 = (0, a2.parseInternalActivationAttributes)(e3), i3 = e3.getString("auto_pad", "NOTSET"), o3 = e3.getInts("dilations", [1, 1]), s3 = e3.getInt("group", 1), u3 = e3.getInts("kernel_shape", []), c3 = e3.getInts("output_padding", [0, 0]), l3 = e3.getInts("output_shape", []), p3 = e3.getInts("pads", [0, 0, 0, 0]), f3 = e3.getInts("strides", [1, 1]);
        return (0, r2.createAttributeWithCacheKey)(Object.assign({ autoPad: i3, dilations: o3, group: s3, kernelShape: u3, outputPadding: c3, outputShape: l3, pads: p3, strides: f3 }, n3));
      };
      const f2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Conv requires 2 or 3 inputs");
        if (4 !== t3[0].dims.length || 4 !== t3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
        if (t3[0].dims[1] !== t3[1].dims[0]) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        const n3 = t3[1].dims[1] * e3.group;
        if (3 === t3.length && (1 !== t3[2].dims.length || t3[2].dims[0] !== n3)) throw new Error("invalid bias");
        const r3 = t3[0].dims.length - 2;
        if (e3.dilations.length !== r3) throw new Error(`dilations should be ${r3}D`);
        if (e3.strides.length !== r3) throw new Error(`strides should be ${r3}D`);
        if (e3.pads.length !== 2 * r3) throw new Error(`pads should be ${2 * r3}D`);
        if (e3.outputPadding.length !== r3) throw new Error(`output_padding should be ${r3}D`);
        if (0 !== e3.kernelShape.length && e3.kernelShape.length !== t3[1].dims.length - 2) throw new Error("invalid kernel shape");
        if (0 !== e3.outputShape.length && e3.outputShape.length !== t3[0].dims.length - 2) throw new Error("invalid output shape");
        if ("float32" !== t3[0].type || "float32" !== t3[1].type) throw new Error("ConvTranspose input(X,W) should be float tensor");
        if (3 === t3.length && "float32" !== t3[2].type) throw new Error("ConvTranspose input(bias) should be float tensor");
      };
    }, 8138: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConvAttributes = e2.conv = e2.calculateOutputShape = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(4770), a2 = n2(1386), s2 = n2(9828), u2 = n2(2823), c2 = n2(3248), l2 = n2(5623);
      e2.calculateOutputShape = (t3, e3, n3, r3, i3) => {
        const o3 = t3[0], a3 = t3.slice(2), s3 = a3.length, u3 = e3[0], c3 = e3.slice(2).map((t4, e4) => t4 + (t4 - 1) * (n3[e4] - 1)), l3 = a3.map((t4, e4) => t4 + r3[e4] + r3[e4 + s3]).map((t4, e4) => Math.floor((t4 - c3[e4] + i3[e4]) / i3[e4]));
        return [o3, u3].concat(...l3);
      }, e2.conv = (t3, e3, n3) => (g2(e3, n3), p2(t3, e3, n3));
      const p2 = (t3, e3, n3) => {
        const r3 = h2(n3, e3), i3 = t3.session.pack, s3 = 1 === r3.kernelShape[0] && 1 === r3.kernelShape[1];
        return r3.group > 1 ? [t3.run((0, o2.createUnpackedGroupedConvProgramInfoLoader)(t3, e3, r3), e3)] : s3 && i3 ? [f2(t3, e3, r3)] : i3 && 4 === e3[0].dims.length && 1 === e3[0].dims[0] && !s3 ? [(0, a2.conv2DPacked)(t3, e3, r3)] : [d2(t3, e3, r3)];
      }, f2 = (t3, n3, r3) => {
        const i3 = n3[0].dims, o3 = n3[1].dims, a3 = (0, e2.calculateOutputShape)(i3, o3, r3.dilations, r3.pads, r3.strides), s3 = t3.reshapeUnpacked(n3[0], [i3[1], i3[2] * i3[3]]), u3 = t3.reshapeUnpacked(n3[1], [o3[0], o3[1]]), c3 = n3.length > 2 ? [u3, s3, n3[2]] : [u3, s3], p3 = t3.run((0, l2.createMatmulProgramInfoLoader)(c3, r3), c3);
        return t3.reshapeUnpacked(p3, a3);
      }, d2 = (t3, n3, r3) => {
        const i3 = n3[0].dims, o3 = n3[1].dims, a3 = (0, e2.calculateOutputShape)(i3, o3, r3.dilations, r3.pads, r3.strides), u3 = t3.run((0, c2.createIm2ColProgramInfoLoader)(t3, n3[0], n3[1], a3, r3), [n3[0]]), l3 = 3 === n3.length ? [u3, n3[1], n3[2]] : [u3, n3[1]];
        return t3.run((0, s2.createDotProductProgramInfoLoader)(t3, n3, a3, r3), l3);
      }, h2 = (t3, e3) => {
        const n3 = t3.kernelShape.slice();
        if (0 === t3.kernelShape.length) for (let t4 = 2; t4 < e3[1].dims.length; ++t4) n3.push(e3[1].dims[t4]);
        const r3 = t3.pads.slice();
        i2.PoolConvUtil.adjustPadsBasedOnAutoPad(e3[0].dims, t3.strides, t3.dilations, n3, r3, t3.autoPad);
        const o3 = Object.assign({}, t3);
        return Object.assign(o3, { kernelShape: n3, pads: r3, cacheKey: t3.cacheKey }), o3;
      };
      e2.parseConvAttributes = (t3) => {
        const e3 = t3.attributes, n3 = (0, u2.parseInternalActivationAttributes)(e3), i3 = e3.getString("auto_pad", "NOTSET"), o3 = e3.getInts("dilations", [1, 1]), a3 = e3.getInt("group", 1), s3 = e3.getInts("kernel_shape", []), c3 = e3.getInts("pads", [0, 0, 0, 0]), l3 = e3.getInts("strides", [1, 1]);
        return (0, r2.createAttributeWithCacheKey)(Object.assign({ autoPad: i3, dilations: o3, group: a3, kernelShape: s3, pads: c3, strides: l3 }, n3));
      };
      const g2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Conv requires 2 or 3 inputs");
        if (4 !== t3[0].dims.length || 4 !== t3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
        if (t3[0].dims[1] !== t3[1].dims[1] * e3.group) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        if (3 === t3.length && (1 !== t3[2].dims.length || t3[1].dims[0] !== t3[2].dims[0])) throw new Error("invalid bias");
        const n3 = t3[0].dims.length - 2;
        if (e3.dilations.length !== n3) throw new Error(`dilations should be ${n3}D`);
        if (e3.strides.length !== n3) throw new Error(`strides should be ${n3}D`);
        if (e3.pads.length !== 2 * n3) throw new Error(`pads should be ${2 * n3}D`);
        if (0 !== e3.kernelShape.length && e3.kernelShape.length !== t3[1].dims.length - 2) throw new Error("invalid kernel shape");
        if ("float32" !== t3[0].type || "float32" !== t3[1].type) throw new Error("Conv input(X,W) should be float tensor");
        if (3 === t3.length && "float32" !== t3[2].type) throw new Error("Conv input(bias) should be float tensor");
      };
    }, 5193: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseDepthToSpaceAttributes = e2.depthToSpace = void 0;
      const r2 = n2(3738);
      e2.depthToSpace = (t3, e3, n3) => {
        i2(e3);
        const o2 = n3.blocksize, a2 = o2 * o2, s2 = "DCR" === n3.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u2 = "DCR" === n3.mode ? [e3[0].dims[0], o2, o2, e3[0].dims[1] / a2, e3[0].dims[2], e3[0].dims[3]] : [e3[0].dims[0], e3[0].dims[1] / a2, o2, o2, e3[0].dims[2], e3[0].dims[3]], c2 = t3.reshapeUnpacked(e3[0], u2), l2 = { perm: s2, cacheKey: `${s2}` }, [p2] = (0, r2.transpose)(t3, [c2], l2), f2 = [e3[0].dims[0], e3[0].dims[1] / a2, e3[0].dims[2] * o2, e3[0].dims[3] * o2];
        return [t3.reshapeUnpacked(p2, f2)];
      }, e2.parseDepthToSpaceAttributes = (t3) => {
        const e3 = t3.attributes.getInt("blocksize");
        if (e3 < 1) throw new Error(`blocksize must be >= 1, but got : ${e3} for DepthToSpace`);
        const n3 = t3.attributes.getString("mode", "DCR");
        if ("DCR" !== n3 && "CRD" !== n3) throw new Error(`unrecognized mode: ${n3} for DepthToSpace`);
        return { mode: n3, blocksize: e3 };
      };
      const i2 = (t3) => {
        if (1 !== t3.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${t3.length}`);
        if ("string" === t3[0].type || 4 !== t3[0].dims.length) throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
      };
    }, 9828: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createDotProductProgramInfoLoader = void 0;
      const r2 = n2(2517), i2 = n2(5060), o2 = n2(2039), a2 = n2(2823), s2 = n2(3248);
      e2.createDotProductProgramInfoLoader = (t3, e3, n3, u2) => {
        const c2 = ((t4, e4) => ({ name: "ConvDotProduct", inputNames: t4 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: t4 ? [o2.TextureType.unpacked, o2.TextureType.packedLastDimension, o2.TextureType.unpacked] : [o2.TextureType.unpacked, o2.TextureType.packedLastDimension], cacheKey: e4.activationCacheKey }))(e3.length > 2, u2);
        return Object.assign(Object.assign({}, c2), { get: () => ((t4, e4, n4, u3, c3) => {
          const l2 = n4[0].dims, p2 = n4[1].dims, f2 = [p2[0], Math.ceil(l2[1] * p2[2] * p2[3] / 4)], d2 = (0, s2.calculateIm2ColDims)(l2, p2, u3), [h2, g2] = t4.calculateTextureWidthAndHeight(f2, o2.TextureType.packedLastDimension), b2 = r2.ShapeUtil.computeStrides(d2), [m2, y2] = t4.calculateTextureWidthAndHeight(d2, o2.TextureType.packedLastDimension), _ = u3.length, v2 = n4.length < 3 ? "0.0" : "_B(b)", w2 = Math.ceil(l2[1] * p2[2] * p2[3] / 4), { activationFunction: x2, applyActivation: T2 } = (0, a2.getActivationSnippet)(c3), S2 = (0, i2.getGlsl)(t4.session.backend.glContext.version), O2 = `
${x2}
float process(int indices[${_}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b2[0]} + im2col[1] * ${b2[1]} + im2col[2] * ${b2[2]};
  int kernelOffset = indices[1] * ${f2[1]};
  float value = ${v2};
  for (int i = 0; i < ${w2}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m2}, ${y2});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h2}, ${g2});
    value += dot(${S2.texture2D}(Im2Col, im2colCoords), ${S2.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T2}
  return value;
}`;
          return Object.assign(Object.assign({}, e4), { output: { dims: u3, type: n4[0].type, textureType: o2.TextureType.unpacked }, shaderSource: O2 });
        })(t3, c2, e3, n3, u2) });
      };
    }, 7992: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseFlattenAttributes = e2.flatten = void 0;
      const r2 = n2(2517);
      e2.flatten = (t3, e3, n3) => {
        i2(e3, n3);
        const o2 = r2.ShapeUtil.flattenShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o2)];
      }, e2.parseFlattenAttributes = (t3) => t3.attributes.getInt("axis", 1);
      const i2 = (t3, e3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Flatten requires 1 input.");
        const n3 = t3[0].dims.length;
        if (0 === n3) throw new Error("scalar tensor is not supported.");
        if (e3 < -n3 || e3 > n3) throw new Error("Invalid axis");
        if ("string" === t3[0].type) throw new Error("string tensor is not supported.");
      };
    }, 2823: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseInternalActivationAttributes = e2.getActivationSnippet = void 0;
      const r2 = n2(2517), i2 = n2(4909);
      e2.getActivationSnippet = function(t3) {
        let e3;
        switch (t3.activation) {
          case "Relu":
            e3 = (0, i2.glslRelu)();
            break;
          case "Sigmoid":
            e3 = (0, i2.glslSigmoid)();
            break;
          case "Clip":
            e3 = (0, i2.glslClip)(t3.clipMin, t3.clipMax);
            break;
          default:
            return { activationFunction: "", applyActivation: "" };
        }
        const n3 = e3.name;
        return { activationFunction: e3.body, applyActivation: `value = ${n3}_(value);` };
      }, e2.parseInternalActivationAttributes = (t3) => {
        const e3 = t3.getString("activation", "");
        if ("Clip" === e3) {
          const [n3, i3] = t3.getFloats("activation_params", [r2.MIN_CLIP, r2.MAX_CLIP]);
          return { activation: e3, clipMax: i3, clipMin: n3, activationCacheKey: `${e3}:${n3},${i3}` };
        }
        return { activation: e3, activationCacheKey: e3 };
      };
    }, 1253: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseGatherAttributes = e2.gather = void 0;
      const r2 = n2(246), i2 = n2(782), o2 = n2(2517), a2 = n2(2039);
      e2.gather = (t3, e3, n3) => (c2(e3, n3.axis), [t3.run(u2(t3, e3, n3), e3)]), e2.parseGatherAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", 0) });
      const s2 = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a2.TextureType.unpacked, a2.TextureType.unpacked] }, u2 = (t3, e3, n3) => {
        const r3 = Object.assign(Object.assign({}, s2), { cacheHint: n3.cacheKey });
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const i3 = n4[0].dims.slice(), s3 = n4[1].dims.slice(), u3 = new Array(i3.length + s3.length - 1);
          r4 = o2.ShapeUtil.normalizeAxis(r4, i3.length);
          const c3 = [];
          for (let t5 = 0; t5 < u3.length; t5++) t5 < r4 ? (u3[t5] = i3[t5], c3.push(`inputIdx[${t5}] = outputIdx[${t5}];`)) : t5 < r4 + s3.length ? (u3[t5] = s3[t5 - r4], c3.push(`indexDataIdx[${t5 - r4}] = outputIdx[${t5}];`)) : (u3[t5] = i3[t5 - s3.length + 1], c3.push(`inputIdx[${t5 - s3.length + 1}] = outputIdx[${t5}];`));
          const l2 = `
      float process(int outputIdx[${u3.length || 1}]) {
        int inputIdx[${i3.length}];
        int indexDataIdx[${s3.length || 1}];
        indexDataIdx[0] = 0;
        ${c3.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r4}] = idx < 0 ? idx + ${i3[r4]} : idx;
        return _A(inputIdx);
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: u3, type: n4[0].type, textureType: a2.TextureType.unpacked }, shaderSource: l2 });
        })(0, r3, e3, n3.axis) });
      }, c2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Gather requires 2 inputs.");
        const n3 = t3[0].dims.length;
        if (n3 < 1) throw new Error("Invalid input shape.");
        if (e3 < -n3 || e3 > n3 - 1) throw new Error("Invalid axis.");
        if (-1 === i2.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invaid input type.");
        if ("int32" !== t3[1].type && "int16" !== t3[1].type) throw new Error("Invaid input type.");
      };
    }, 4776: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseGemmAttributesV11 = e2.parseGemmAttributesV7 = e2.gemm = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(2039);
      e2.gemm = (t3, e3, n3) => (c2(e3, n3), [t3.run(s2(e3, n3), e3)]);
      const a2 = (t3, e3) => {
        const n3 = 0 !== t3.attributes.getInt("transA", 0), i3 = 0 !== t3.attributes.getInt("transB", 0), o3 = t3.attributes.getFloat("alpha", 1), a3 = t3.attributes.getFloat("beta", 1);
        return (0, r2.createAttributeWithCacheKey)({ transA: n3, transB: i3, alpha: o3, beta: a3, isOptionalC: e3 });
      };
      e2.parseGemmAttributesV7 = (t3) => a2(t3, false), e2.parseGemmAttributesV11 = (t3) => a2(t3, true);
      const s2 = (t3, e3) => {
        const n3 = { name: "Gemm", inputNames: 3 === t3.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === t3.length ? [o2.TextureType.unpacked, o2.TextureType.unpacked, o2.TextureType.unpacked] : [o2.TextureType.unpacked, o2.TextureType.unpacked], key: e3.cacheKey };
        return Object.assign(Object.assign({}, n3), { get: () => u2(n3, t3, e3) });
      }, u2 = (t3, e3, n3) => {
        const r3 = e3[0].dims.slice(), a3 = e3[1].dims.slice(), [s3, u3] = i2.GemmUtil.getShapeOfGemmResult(r3, n3.transA, a3, n3.transB, 3 === e3.length ? e3[2].dims : void 0), c3 = [s3, u3];
        if (!c3) throw new Error("Can't use gemm on the given tensors");
        let l2 = r3[r3.length - 1], p2 = "";
        n3.transA && (l2 = r3[0]), n3.transA && n3.transB ? p2 = "value += _A_T(a) * _B_T(b);" : n3.transA && !n3.transB ? p2 = "value += _A_T(a) * _B(b);" : !n3.transA && n3.transB ? p2 = "value += _A(a) * _B_T(b);" : n3.transA || n3.transB || (p2 = "value += _A(a) * _B(b);");
        const f2 = c3.length, d2 = `
      float process(int indices[${f2}]) {
          int a[${f2}];
          int b[${f2}];
          ${3 === e3.length ? `int c[${e3[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === e3.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${l2}; ++k) {
              a[${f2 - 1}] = k;
              b[${f2 - 2}] = k;
              ${p2}
          }

          value = value * alpha;
          ${3 === e3.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
        return Object.assign(Object.assign({}, t3), { output: { dims: c3, type: e3[0].type, textureType: o2.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n3.alpha }, { name: "beta", type: "float", data: n3.beta }], shaderSource: d2 });
      }, c2 = (t3, e3) => {
        if (!t3) throw new Error("Input is missing");
        if (e3.isOptionalC && (t3.length < 2 || t3.length > 3)) throw new Error("Invaid input shape.");
        if (!e3.isOptionalC && 3 !== t3.length) throw new Error("Gemm requires 3 inputs");
        if (3 === t3.length && 1 !== t3[2].dims.length && 2 !== t3[2].dims.length) throw new Error("Invalid input shape of C");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type || "float32" !== t3[1].type && "float64" !== t3[1].type || 3 === t3.length && "float32" !== t3[2].type && "float64" !== t3[2].type) throw new Error("Invalid input type.");
        if (t3[0].type !== t3[1].type || 3 === t3.length && t3[0].type !== t3[2].type) throw new Error("Input types are mismatched");
      };
    }, 8555: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedIm2ColProgramInfoLoader = void 0;
      const r2 = n2(5060), i2 = n2(2039), o2 = n2(2827);
      e2.createPackedIm2ColProgramInfoLoader = (t3, e3, n3, a2, s2) => {
        const u2 = (c2 = s2.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i2.TextureType.packed], cacheHint: c2 });
        var c2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, a3, s3, u3) => {
          const c3 = n4.dims, l2 = a3.dims, p2 = s3.length, f2 = [l2[1] * l2[2] * l2[3], s3[2] * s3[3]], d2 = l2[2] * l2[3], h2 = (0, o2.unpackFromChannel)(), g2 = (0, r2.getGlsl)(t4.session.backend.glContext.version);
          let b2 = "";
          for (let t5 = 0; t5 <= 1; t5++) for (let e5 = 0; e5 <= 1; e5++) b2 += `
            blockIndex = rc.x + ${e5};
            pos = rc.y + ${t5};

            if(blockIndex < ${f2[1]} && pos < ${f2[0]}) {
              offsetY = int(blockIndex / (${s3[p2 - 1]})) * ${u3.strides[0]} -
                ${u3.pads[0]};
              d0 = offsetY + ${u3.dilations[0]} * (imod(pos, ${d2}) / ${l2[2]});

              if(d0 < ${c3[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s3[p2 - 1]}) * ${u3.strides[1]} -
                  ${u3.pads[1]};
                d1 = offsetX + ${u3.dilations[1]} * imod(imod(pos, ${d2}), ${l2[2]});

                if(d1 < ${c3[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d2}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * t5 + e5}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
          const m2 = `
      ${h2}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b2}
          ${g2.output} = result;
      }
            `;
          return Object.assign(Object.assign({}, e4), { output: { dims: f2, type: n4.type, textureType: i2.TextureType.packed }, shaderSource: m2, hasMain: true });
        })(t3, u2, e3, n3, a2, s2) });
      };
    }, 3248: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.calculateIm2ColDims = e2.createIm2ColProgramInfoLoader = void 0;
      const r2 = n2(2039);
      e2.createIm2ColProgramInfoLoader = (t3, n3, i2, o2, a2) => {
        const s2 = (u2 = a2.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r2.TextureType.unpacked], cacheHint: u2 });
        var u2;
        return Object.assign(Object.assign({}, s2), { get: () => ((t4, n4, i3, o3, a3, s3) => {
          const u3 = i3.dims, c2 = o3.dims, l2 = a3.length, p2 = (0, e2.calculateIm2ColDims)(u3, c2, a3, 4), f2 = `
        const int XC = ${u3[1]};
        const int XH = ${u3[2]};
        const int XW = ${u3[3]};
        const int KH = ${s3.kernelShape[0]};
        const int KW = ${s3.kernelShape[1]};
        const int dilationH = ${s3.dilations[0]};
        const int dilationW = ${s3.dilations[1]};
        const int strideH = ${s3.strides[0]};
        const int strideW = ${s3.strides[1]};
        const int padH = ${s3.pads[0]};
        const int padW = ${s3.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${l2}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u3.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
          return Object.assign(Object.assign({}, n4), { output: { dims: p2, type: i3.type, textureType: r2.TextureType.packedLastDimension }, shaderSource: f2 });
        })(0, s2, n3, i2, o2, a2) });
      }, e2.calculateIm2ColDims = (t3, e3, n3, r3 = 4) => [n3[0], n3[2], n3[3], Math.ceil(t3[1] * e3[2] * e3[3] / r3)];
    }, 6572: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseImageScalerAttributes = e2.imageScaler = void 0;
      const r2 = n2(246), i2 = n2(2039);
      e2.imageScaler = (t3, e3, n3) => (u2(e3), [t3.run(a2(t3, e3, n3), e3)]), e2.parseImageScalerAttributes = (t3) => {
        const e3 = t3.attributes.getFloat("scale"), n3 = t3.attributes.getFloats("bias");
        return (0, r2.createAttributeWithCacheKey)({ scale: e3, bias: n3 });
      };
      const o2 = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i2.TextureType.unpacked] }, a2 = (t3, e3, n3) => {
        const r3 = Object.assign(Object.assign({}, o2), { cacheHint: n3.cacheKey });
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const o3 = n4[0].dims.slice(), a3 = o3.length, u3 = `
      ${s2(r4.bias.length)}
      float process(int indices[${a3}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: o3, type: n4[0].type, textureType: i2.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r4.bias.length, data: r4.bias }, { name: "scale", type: "float", data: r4.scale }], shaderSource: u3 });
        })(0, r3, e3, n3) });
      }, s2 = (t3) => {
        const e3 = [`float getBias(float bias[${t3}], int channel) {`];
        for (let n3 = 0; n3 < t3; ++n3) 0 === n3 ? e3.push(`	if (channel == ${n3}) { return bias[${n3}]; }`) : n3 === t3 - 1 ? e3.push(`	else { return bias[${n3}]; }`) : e3.push(`	else if (channel == ${n3}) { return bias[${n3}]; }`);
        return e3.push("	}"), e3.join("\n");
      }, u2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("ImageScaler requires 1 input.");
        if (4 !== t3[0].dims.length) throw new Error("Invalid input shape.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      };
    }, 3346: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseInstanceNormalizationAttributes = e2.instanceNormalization = void 0;
      const r2 = n2(5060), i2 = n2(2039);
      e2.instanceNormalization = (t3, e3, n3) => {
        c2(e3);
        const r3 = t3.run(a2(e3[0]), e3);
        return [t3.run(u2(t3, e3[0], n3, r3.dims), [e3[0], r3, e3[1], e3[2]])];
      }, e2.parseInstanceNormalizationAttributes = (t3) => t3.attributes.getFloat("epsilon", 1e-5);
      const o2 = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i2.TextureType.unpacked] }, a2 = (t3) => Object.assign(Object.assign({}, o2), { get: () => ((t4, e3) => {
        const n3 = e3.dims.slice(), r3 = n3[1], o3 = n3[2] * n3[3], a3 = [n3[0], r3], s3 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n3[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n3[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o3});
        temp = 0.0;
        for(int a2=0; a2<${n3[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n3[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o3});

        return v;
      }`;
        return Object.assign(Object.assign({}, t4), { output: { dims: a3, type: e3.type, textureType: i2.TextureType.packedLastDimension }, shaderSource: s3 });
      })(o2, t3) }), s2 = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i2.TextureType.unpacked, i2.TextureType.packedLastDimension, i2.TextureType.unpacked, i2.TextureType.unpacked] }, u2 = (t3, e3, n3, o3) => {
        const a3 = Object.assign(Object.assign({}, s2), { cacheHint: `${n3}` });
        return Object.assign(Object.assign({}, a3), { get: () => ((t4, e4, n4, o4, a4) => {
          const s3 = (0, r2.getGlsl)(t4.session.backend.glContext.version), [u3, c3] = t4.calculateTextureWidthAndHeight(a4, i2.TextureType.packedLastDimension), [l2, p2] = [u3 / 4, c3], f2 = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${l2}, ${p2});
        return ${s3.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: n4.dims, type: n4.type, textureType: i2.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o4 }], shaderSource: f2 });
        })(t3, a3, e3, n3, o3) });
      }, c2 = (t3) => {
        if (!t3 || 3 !== t3.length) throw new Error("InstanceNormalization requires 3 inputs.");
        const e3 = t3[0], n3 = t3[1], r3 = t3[2];
        if (e3.dims.length < 3 || 1 !== n3.dims.length || 1 !== r3.dims.length) throw new Error("Invalid input shape.");
        if (n3.dims[0] !== e3.dims[1] || r3.dims[0] !== e3.dims[1]) throw new Error("Input shapes are mismatched.");
        if ("float32" !== e3.type && "float64" !== e3.type || "float32" !== n3.type && "float64" !== n3.type || "float32" !== r3.type && "float64" !== r3.type) throw new Error("Invalid input type.");
        if (4 !== t3[0].dims.length) throw new Error("Only support 4-D input shape.");
      };
    }, 708: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedMatmulProgramInfoLoader = void 0;
      const r2 = n2(2517), i2 = n2(5060), o2 = n2(2039), a2 = n2(9390), s2 = n2(2823), u2 = n2(5623);
      e2.createPackedMatmulProgramInfoLoader = (t3, e3, n3) => {
        const c2 = (l2 = e3.length > 2, p2 = n3.activationCacheKey, { name: "MatMul (packed)", inputNames: l2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: l2 ? [o2.TextureType.packed, o2.TextureType.packed, o2.TextureType.packed] : [o2.TextureType.packed, o2.TextureType.packed], cacheHint: p2 });
        var l2, p2;
        return Object.assign(Object.assign({}, c2), { get: () => ((t4, e4, n4, c3) => {
          const l3 = n4.length > 2, p3 = l3 ? "value += getBiasForMatmul();" : "", f2 = n4[0].dims, d2 = n4[1].dims, h2 = r2.BroadcastUtil.calcShape(f2, d2, true), g2 = !r2.ShapeUtil.areEqual(n4[0].dims, n4[1].dims);
          if (!h2) throw new Error("Can't use matmul on the given tensors");
          const b2 = f2[f2.length - 1], m2 = Math.ceil(b2 / 2), y2 = f2.length, _ = d2.length, v2 = (0, i2.getGlsl)(t4.session.backend.glContext.version), w2 = (0, a2.getCoordsDataType)(h2.length), x2 = h2.length, T2 = (0, a2.getGlChannels)(), { activationFunction: S2, applyActivation: O2 } = (0, s2.getActivationSnippet)(c3), A2 = l3 ? `${(0, u2.getBiasForMatmul)(w2, T2, n4[2].dims, h2, true)}` : "", E2 = g2 ? `${function(t5, e5, n5, i3) {
            let o3 = [], a3 = [];
            const s3 = n5[0].dims, u3 = n5[1].dims, c4 = s3.length, l4 = u3.length, p4 = i3.length, f3 = p4 - c4, d3 = p4 - l4;
            o3 = s3.map((t6, n6) => `coords.${e5[n6 + f3]}`), o3[c4 - 1] = "i*2", o3.join(", "), a3 = u3.map((t6, n6) => `coords.${e5[n6 + d3]}`), a3[l4 - 2] = "i*2", a3.join(", ");
            const h3 = r2.BroadcastUtil.getBroadcastDims(s3, i3), g3 = r2.BroadcastUtil.getBroadcastDims(u3, i3), b3 = h3.map((t6) => `coords.${e5[t6 + f3]} = 0;`).join("\n"), m3 = g3.map((t6) => `coords.${e5[t6 + d3]} = 0;`).join("\n"), y3 = `int lastDim = coords.${e5[p4 - 1]};
  coords.${e5[p4 - 1]} = coords.${e5[p4 - 2]};
  coords.${e5[p4 - 2]} = lastDim;`;
            return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${t5} coords = getOutputCoords();
  ${y3}
  ${b3}
  vec4 outputValue = getA(${o3});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t5} coords = getOutputCoords();
  ${y3}
  ${m3}
  vec4 outputValue = getB(${a3});
  return outputValue;
}`;
          }(w2, T2, n4, h2)}` : "", I2 = g2 ? "getAAtOutCoordsMatmul(i)" : `getA(${function(t5, e5) {
            let n5 = "";
            for (let r3 = 0; r3 < e5 - 2; r3++) n5 += `rc.${t5[r3]}, `;
            return n5 += `rc.${t5[e5 - 2]}, i*2`, n5;
          }(T2, y2)})`, P2 = g2 ? "getBAtOutCoordsMatmul(i)" : `getB(${function(t5, e5) {
            let n5 = "";
            for (let r3 = 0; r3 < e5 - 2; r3++) n5 += `rc.${t5[r3]}, `;
            return n5 += `i*2, rc.${t5[e5 - 1]}`, n5;
          }(T2, _)})`, D2 = `
            ${E2}
            ${A2}
            ${S2}
            void main() {
              ${g2 ? "" : `${w2} rc =
          getOutputCoords(); int lastDim = rc.${T2[x2 - 1]}; rc.${T2[x2 - 1]} =
          rc.${T2[x2 - 2]}; rc.${T2[x2 - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m2}; i++) {
                vec4 a = ${I2};
                vec4 b = ${P2};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p3}
              ${O2}
              ${v2.output} = value;
            }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: h2, type: n4[0].type, textureType: o2.TextureType.packed }, shaderSource: D2, hasMain: true });
        })(t3, c2, e3, n3) });
      };
    }, 5623: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getBiasForMatmul = e2.createMatmulProgramInfoLoader = e2.parseMatMulAttributes = e2.matMul = void 0;
      const r2 = n2(2517), i2 = n2(2039), o2 = n2(9390), a2 = n2(2823), s2 = n2(708);
      function u2(t3, e3) {
        const n3 = (s3 = t3.length > 2, u3 = e3.activationCacheKey, { name: "MatMul", inputNames: s3 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: s3 ? [i2.TextureType.unpacked, i2.TextureType.unpacked, i2.TextureType.unpacked] : [i2.TextureType.unpacked, i2.TextureType.unpacked], cacheHint: u3 });
        var s3, u3;
        return Object.assign(Object.assign({}, n3), { get: () => function(t4, e4, n4) {
          const s4 = e4[0].dims, u4 = e4[1].dims, c3 = r2.BroadcastUtil.calcShape(s4, u4, true);
          if (!c3) throw new Error("Can't use matmul on the given tensors");
          const p2 = (0, o2.getCoordsDataType)(c3.length), f2 = (0, o2.getGlChannels)(), { activationFunction: d2, applyActivation: h2 } = (0, a2.getActivationSnippet)(n4), g2 = e4.length > 2, b2 = g2 ? "value += getBiasForMatmul();" : "", m2 = g2 ? `${l2(p2, f2, e4[2].dims, c3, false)}` : "", y2 = c3.length, _ = s4.length, v2 = u4.length, w2 = `
    ${d2}
    ${m2}
    float process(int indices[${y2}]) {
        int a[${_}];
        int b[${v2}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s4[s4.length - 1]}; ++k) {
            a[${_ - 1}] = k;
            b[${v2 - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b2}
        ${h2}
        return value;
    }`;
          return Object.assign(Object.assign({}, t4), { output: { dims: c3, type: e4[0].type, textureType: i2.TextureType.unpacked }, shaderSource: w2 });
        }(n3, t3, e3) });
      }
      e2.matMul = (t3, e3, n3) => (c2(e3), t3.session.pack ? [t3.run((0, s2.createPackedMatmulProgramInfoLoader)(t3, e3, n3), e3)] : [t3.run(u2(e3, n3), e3)]), e2.parseMatMulAttributes = (t3) => (0, a2.parseInternalActivationAttributes)(t3.attributes), e2.createMatmulProgramInfoLoader = u2;
      const c2 = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("MatMul requires 2 inputs.");
        if (t3[0].dims[t3[0].dims.length - 1] !== t3[1].dims[t3[1].dims.length - 2]) throw new Error("shared dimension does not match.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type || "float32" !== t3[1].type && "float64" !== t3[1].type) throw new Error("inputs should be float type");
        if (t3[0].type !== t3[1].type) throw new Error("inputs types should match");
      };
      function l2(t3, e3, n3, i3, o3) {
        let a3 = "";
        const s3 = n3.length, u3 = i3.length, c3 = u3 - s3;
        a3 = u3 < 2 && s3 > 0 ? "coords" : n3.map((t4, n4) => `coords.${e3[n4 + c3]}`).join(", ");
        const l3 = r2.BroadcastUtil.getBroadcastDims(n3, i3).map((t4) => `coords.${e3[t4 + c3]} = 0;`).join("\n");
        let p2 = "vec4(outputValue.xx, outputValue.yy)";
        return 1 === r2.ShapeUtil.size(n3) && (p2 = "vec4(outputValue.x)"), o3 ? `
vec4 getBiasForMatmul() {
  ${t3} coords = getOutputCoords();
  ${l3}
  vec4 outputValue = getBias(${a3});
  return ${p2};
}` : `
float getBiasForMatmul() {
  ${t3} coords = getOutputCoords();
  ${l3}
  return getBias(coords.x);
}`;
      }
      e2.getBiasForMatmul = l2;
    }, 2403: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackProgramInfoLoader = void 0;
      const r2 = n2(5060), i2 = n2(2039), o2 = n2(9390), a2 = n2(2827), s2 = { name: "pack", inputNames: ["A"], inputTypes: [i2.TextureType.unpackedReversed] };
      e2.createPackProgramInfoLoader = (t3, e3) => Object.assign(Object.assign({}, s2), { get: () => ((t4, e4) => {
        const n3 = (0, r2.getGlsl)(t4.session.backend.glContext.version), u2 = e4.dims, c2 = u2.length, l2 = e4.dims.length, p2 = (0, o2.getCoordsDataType)(l2), f2 = (0, a2.getChannels)("rc", l2), d2 = (h2 = l2, g2 = f2, b2 = u2[u2.length - 2], m2 = u2[u2.length - 1], 0 === h2 || 1 === h2 ? "" : `
    int r = ${g2[h2 - 2]};
    int c = ${g2[h2 - 1]};
    int rp1 = ${g2[h2 - 2]} + 1;
    int cp1 = ${g2[h2 - 1]} + 1;
    bool rEdge = rp1 >= ${m2};
    bool cEdge = cp1 >= ${b2};
    `);
        var h2, g2, b2, m2;
        let y2;
        y2 = 0 === c2 ? [1, 1] : 1 === c2 ? [u2[0], 1] : [u2[l2 - 1], u2[l2 - 2]];
        const _ = function(t5, e5, n4) {
          if (0 === t5) return "false";
          if (1 === t5) return `rc > ${e5[0]}`;
          let r3 = "";
          for (let i3 = t5 - 2; i3 < t5; i3++) r3 += `${n4[i3]} >= ${e5[i3 - t5 + 2]}`, i3 < t5 - 1 && (r3 += "||");
          return r3;
        }(l2, y2, f2), v2 = function(t5, e5) {
          const n4 = t5.length;
          if (0 === n4) return "getA(), 0, 0, 0";
          if (1 === n4) return `getA(rc),
            rc + 1 >= ${t5[0]} ? 0. : getA(rc + 1),
            0, 0`;
          let r3 = "";
          if (n4 > 2) for (let t6 = 0; t6 < n4 - 2; ++t6) r3 += `${e5[t6]},`;
          return `getA(${r3}r, c),
          rEdge ? 0. : getA(${r3}rp1, c),
          cEdge ? 0. : getA(${r3}r, cp1),
          rEdge || cEdge ? 0. : getA(${r3}rp1, cp1)`;
        }(u2, f2), w2 = `
        void main() {
          ${p2} rc = getOutputCoords();

          if(${_}) {
            ${n3.output} = vec4(0);
          } else {
            ${d2}

            ${n3.output} = vec4(${v2});
          }
        }
      `;
        return Object.assign(Object.assign({}, s2), { hasMain: true, output: { dims: e4.dims, type: e4.type, textureType: i2.TextureType.packed }, shaderSource: w2 });
      })(t3, e3) });
    }, 2827: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.unpackFromChannel = e2.getChannels = e2.getVecChannels = void 0;
      const r2 = n2(9390);
      function i2(t3, e3) {
        return (0, r2.getGlChannels)(e3).map((e4) => `${t3}.${e4}`);
      }
      e2.getVecChannels = i2, e2.getChannels = function(t3, e3) {
        return 1 === e3 ? [t3] : i2(t3, e3);
      }, e2.unpackFromChannel = function() {
        return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
      };
    }, 2870: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parsePadAttributesV11 = e2.padV11 = e2.parsePadAttributesV2 = e2.padV2 = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(5060), a2 = n2(2039), s2 = { name: "Pad", inputNames: ["A"], inputTypes: [a2.TextureType.unpacked] };
      e2.padV2 = (t3, e3, n3) => (l2(e3), [t3.run(Object.assign(Object.assign({}, s2), { cacheHint: n3.cacheKey, get: () => c2(t3, e3[0], n3) }), e3)]), e2.parsePadAttributesV2 = (t3) => {
        const e3 = t3.attributes.getString("mode", "constant"), n3 = t3.attributes.getFloat("value", 0), i3 = t3.attributes.getInts("pads");
        return (0, r2.createAttributeWithCacheKey)({ mode: e3, value: n3, pads: i3 });
      }, e2.padV11 = (t3, n3, r3) => {
        p2(n3);
        const i3 = u2(t3, n3, r3);
        return (0, e2.padV2)(t3, [n3[0]], i3);
      }, e2.parsePadAttributesV11 = (t3) => t3.attributes.getString("mode", "constant");
      const u2 = (t3, e3, n3) => {
        if (!t3.session.isInitializer(e3[1].dataId) || e3.length >= 3 && !t3.session.isInitializer(e3[2].dataId)) throw new Error("dynamic pad attributes are not allowed");
        const i3 = Array.from(e3[1].integerData), o3 = e3.length >= 3 ? e3[2].floatData[0] : 0;
        return (0, r2.createAttributeWithCacheKey)({ mode: n3, pads: i3, value: o3 });
      }, c2 = (t3, e3, n3) => {
        const r3 = i2.ShapeUtil.padShape(e3.dims.slice(), n3.pads), o3 = r3.length, s3 = `
      ${f2(t3, e3, n3)}
      float process(int[${o3}] indices) {
          return padA(indices);
      }`;
        return { name: "Pad", inputNames: ["A"], inputTypes: [a2.TextureType.unpacked], output: { dims: r3, type: e3.type, textureType: a2.TextureType.unpacked }, shaderSource: s3 };
      }, l2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Pad requires 1 input");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      }, p2 = (t3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Pad requires 2 or 3 inputs");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
        if (t3.length >= 3 && "string" === t3[2].type) throw new Error("Invalid input type.");
      }, f2 = (t3, e3, n3) => {
        const r3 = (0, o2.getGlsl)(t3.session.backend.glContext.version), [s3, u3] = t3.calculateTextureWidthAndHeight(e3.dims, a2.TextureType.unpacked), c3 = i2.ShapeUtil.computeStrides(e3.dims);
        switch (n3.mode) {
          case "constant":
            return d2(r3, e3.dims, c3, s3, u3, n3.pads, n3.value);
          case "reflect":
            return h2(r3, e3.dims, c3, s3, u3, n3.pads);
          case "edge":
            return g2(r3, e3.dims, c3, s3, u3, n3.pads);
          default:
            throw new Error("Invalid mode");
        }
      }, d2 = (t3, e3, n3, r3, i3, o3, a3) => {
        const s3 = e3.length;
        let u3 = "";
        for (let t4 = s3 - 1; t4 >= 0; --t4) u3 += `
        k = m[${t4}] - ${o3[t4]};
        if (k < 0)  return constant;
        if (k >= ${e3[t4]}) return constant;
        offset += k * ${n3[t4]};
        `;
        return `
      float padA(int m[${s3}]) {
        const float constant = float(${a3});
        int offset = 0;
        int k = 0;
        ${u3}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i3});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      }, h2 = (t3, e3, n3, r3, i3, o3) => {
        const a3 = e3.length;
        let s3 = "";
        for (let t4 = a3 - 1; t4 >= 0; --t4) s3 += `
        k = m[${t4}] - ${o3[t4]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (e3[t4] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e3[t4]}) { k = _2n_1 - k; }
        }
        offset += k * ${n3[t4]};
        `;
        return `
      float padA(int m[${a3}]) {
        int offset = 0;
        int k = 0;
        ${s3}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i3});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      }, g2 = (t3, e3, n3, r3, i3, o3) => {
        const a3 = e3.length;
        let s3 = "";
        for (let t4 = a3 - 1; t4 >= 0; --t4) s3 += `
        k = m[${t4}] - ${o3[t4]};
        if (k < 0)  k = 0;
        if (k >= ${e3[t4]}) k = ${e3[t4] - 1};
        offset += k * ${n3[t4]};
      `;
        return `
      float padA(int m[${a3}]) {
        int offset = 0;
        int k = 0;
        ${s3}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i3});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      };
    }, 2143: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.globalMaxPool = e2.parseMaxPoolAttributes = e2.maxPool = e2.parseGlobalAveragePoolAttributes = e2.globalAveragePool = e2.parseAveragePoolAttributes = e2.averagePool = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(2039);
      e2.averagePool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o2.TextureType.unpacked], cacheHint: n3.cacheKey };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => a2(e3, r3, false, n3) }), e3)];
      }, e2.parseAveragePoolAttributes = (t3) => {
        const e3 = t3.attributes.getString("auto_pad", "NOTSET"), n3 = t3.attributes.getInt("ceil_mode", 0), i3 = 0 !== t3.attributes.getInt("count_include_pad", 0), o3 = t3.attributes.getInts("kernel_shape"), a3 = t3.attributes.getInts("strides", []), s3 = t3.attributes.getInts("pads", []);
        if (0 !== n3) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        return (0, r2.createAttributeWithCacheKey)({ autoPad: e3, ceilMode: n3, countIncludePad: i3, kernelShape: o3, strides: a3, pads: s3 });
      };
      const a2 = (t3, e3, n3, r3) => {
        const [a3, s3] = u2(t3, r3, n3), c3 = i2.ShapeUtil.size(a3.kernelShape);
        let l3 = "";
        a3.countIncludePad ? l3 += `value /= float(${c3});` : l3 += `value /= float(${c3} - pad);`;
        const p3 = `
        ${f2(t3[0].dims, a3, "value += _X(x);", l3, "0.0")}
      `;
        return Object.assign(Object.assign({}, e3), { output: { dims: s3, type: t3[0].type, textureType: o2.TextureType.unpacked }, shaderSource: p3 });
      };
      e2.globalAveragePool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o2.TextureType.unpacked], cacheHint: `${n3.countIncludePad}` };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => a2(e3, r3, true, n3) }), e3)];
      }, e2.parseGlobalAveragePoolAttributes = (t3) => {
        const e3 = 0 !== t3.attributes.getInt("count_include_pad", 0);
        return (0, r2.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: e3, kernelShape: [], strides: [], pads: [] });
      }, e2.maxPool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o2.TextureType.unpacked], cacheHint: n3.cacheKey };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => s2(e3, r3, false, n3) }), e3)];
      }, e2.parseMaxPoolAttributes = (t3) => {
        const e3 = t3.attributes.getString("auto_pad", "NOTSET"), n3 = t3.attributes.getInt("ceil_mode", 0), i3 = t3.attributes.getInts("kernel_shape"), o3 = t3.attributes.getInts("strides", []), a3 = t3.attributes.getInts("pads", []), s3 = t3.attributes.getInt("storage_order", 0), u3 = t3.attributes.getInts("dilations", []);
        if (0 !== s3) throw new Error("column major storage order is not yet supported for MaxPool");
        if (0 !== n3) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        return (0, r2.createAttributeWithCacheKey)({ autoPad: e3, ceilMode: n3, countIncludePad: false, kernelShape: i3, strides: o3, pads: a3, storageOrder: s3, dilations: u3 });
      };
      const s2 = (t3, e3, n3, r3) => {
        const [i3, a3] = u2(t3, r3, n3), s3 = `
      ${f2(t3[0].dims, i3, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
        return Object.assign(Object.assign({}, e3), { output: { dims: a3, type: t3[0].type, textureType: o2.TextureType.unpacked }, shaderSource: s3 });
      }, u2 = (t3, e3, n3) => {
        const r3 = t3[0].dims.slice(), o3 = Object.hasOwnProperty.call(e3, "dilations"), a3 = e3.kernelShape.slice(), s3 = e3.strides.slice(), u3 = o3 ? e3.dilations.slice() : [], c3 = e3.pads.slice();
        i2.PoolConvUtil.adjustPoolAttributes(n3, r3, a3, s3, u3, c3);
        const l3 = i2.PoolConvUtil.computePoolOutputShape(n3, r3, s3, u3, a3, c3, e3.autoPad), p3 = Object.assign({}, e3);
        return o3 ? Object.assign(p3, { kernelShape: a3, strides: s3, pads: c3, dilations: u3, cacheKey: e3.cacheKey }) : Object.assign(p3, { kernelShape: a3, strides: s3, pads: c3, cacheKey: e3.cacheKey }), [p3, l3];
      }, c2 = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, l2 = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o2.TextureType.unpacked] };
      e2.globalMaxPool = (t3, e3) => (p2(e3), [t3.run(Object.assign(Object.assign({}, l2), { get: () => s2(e3, l2, true, c2) }), e3)]);
      const p2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Pool ops requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      }, f2 = (t3, e3, n3, r3, o3) => {
        const a3 = t3.length;
        if (e3.kernelShape.length <= 2) {
          const i3 = e3.kernelShape[e3.kernelShape.length - 1], s3 = e3.strides[e3.strides.length - 1], u3 = e3.pads[e3.pads.length / 2 - 1], c3 = e3.pads[e3.pads.length - 1], l3 = t3[a3 - 1];
          let p3 = "", f3 = "", d3 = "";
          if (p3 = u3 + c3 !== 0 ? `
          for (int i = 0; i < ${i3}; i++) {
            x[${a3} - 1] = indices[${a3} - 1] * ${s3} - ${u3} + i;
            if (x[${a3} - 1] < 0 || x[${a3} - 1] >= ${l3}) {
              pad++;
              continue;
            }
            ${n3}
          }` : `
          for (int i = 0; i < ${i3}; i++) {
            x[${a3} - 1] = indices[${a3} - 1] * ${s3} - ${u3} + i;
            ${n3}
          }`, 2 === e3.kernelShape.length) {
            const n4 = e3.kernelShape[e3.kernelShape.length - 2], r4 = e3.strides[e3.strides.length - 2], o4 = e3.pads[e3.pads.length / 2 - 2], s4 = e3.pads[e3.pads.length - 2], u4 = t3[a3 - 2];
            f3 = o4 + s4 !== 0 ? `
            for (int j = 0; j < ${n4}; j++) {
              x[${a3} - 2] = indices[${a3} - 2] * ${r4} - ${o4} + j;
              if (x[${a3} - 2] < 0 || x[${a3} - 2] >= ${u4}) {
                pad+= ${i3};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n4}; j++) {
              x[${a3} - 2] = indices[${a3} - 2] * ${r4} - ${o4} + j;
            `, d3 = "\n          }\n        ";
          }
          return `
        float process(int indices[${a3}]) {
          int x[${a3}];
          copyVec(indices, x);

          float value = ${o3};
          int pad = 0;
          ${f3}
          ${p3}
          ${d3}
          ${r3}
          return value;
        }
      `;
        }
        {
          const s3 = i2.ShapeUtil.size(e3.kernelShape), u3 = i2.ShapeUtil.computeStrides(e3.kernelShape), c3 = u3.length, l3 = e3.pads.length, p3 = h2(c3), f3 = d2(t3, "inputDims"), g2 = d2(e3.pads, "pads"), b2 = d2(u3, "kernelStrides"), m2 = d2(e3.strides, "strides");
          let y2 = "";
          return y2 = e3.pads.reduce((t4, e4) => t4 + e4) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n3}
          }` : `
          }
          ${n3}
        `, `
        ${p3}
        float process(int indices[${a3}]) {
          int x[${a3}];
          copyVec(indices, x);
          int offset[${c3}];
          int pads[${l3}];
          int inputDims[${a3}];
          int kernelStrides[${c3}];
          int strides[${c3}];
          ${g2}
          ${f3}
          ${m2}
          ${b2}

          float value = ${o3};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s3}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a3} - ${c3}; j < ${a3}; j++) {
              x[j] = indices[j] * strides[j - ${a3} + ${c3}]
                + offset[j - ${a3} + ${c3}] - pads[j - 2];
              ${y2}
          }
          ${r3}

          return value;
        }
      `;
        }
      }, d2 = (t3, e3) => {
        let n3 = "";
        for (let r3 = 0; r3 < t3.length; r3++) n3 += `
      ${e3}[${r3}] = ${t3[r3]};
    `;
        return n3;
      }, h2 = (t3) => `
  void offsetToIndices(int offset, int[${t3}] strides, out int[${t3}] indices) {
    if (${t3} == 0) {
      return;
    }
    for (int i = 0; i < ${t3} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t3} - 1] = offset;
  }`;
    }, 4939: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.reduceLogSumSquare = e2.reduceLogSum = e2.reduceProd = e2.reduceMin = e2.reduceMax = e2.reduceMean = e2.reduceSum = e2.parseReduceAttributes = void 0;
      const r2 = n2(246), i2 = n2(782), o2 = n2(2517), a2 = n2(2039), s2 = (t3, e3, n3, r3, i3) => {
        c2(e3);
        const o3 = { name: r3, inputNames: ["A"], inputTypes: [a2.TextureType.unpacked] };
        return [t3.run(Object.assign(Object.assign({}, o3), { cacheHint: n3.cacheKey, get: () => u2(t3, e3, n3, r3, i3, o3) }), e3)];
      };
      e2.parseReduceAttributes = (t3) => {
        const e3 = t3.attributes.getInts("axes", []), n3 = 1 === t3.attributes.getInt("keepdims", 1);
        return (0, r2.createAttributeWithCacheKey)({ axes: e3, keepDims: n3 });
      };
      const u2 = (t3, e3, n3, r3, i3, s3) => {
        const u3 = [], c3 = e3[0].dims.length || 1, l2 = [], p2 = o2.ShapeUtil.normalizeAxes(n3.axes, e3[0].dims.length), f2 = i3(e3, p2);
        let d2 = f2[1];
        for (let t4 = 0; t4 < e3[0].dims.length; t4++) p2.indexOf(t4) >= 0 || 0 === p2.length ? (n3.keepDims && u3.push(1), d2 = `
          for(int j${t4} = 0; j${t4} < ${e3[0].dims[t4]}; j${t4}++) {
            inputIdx[${t4}] = j${t4};
            ${d2}
          }`) : (l2.push(`inputIdx[${t4}] = outputIdx[${u3.length}];`), u3.push(e3[0].dims[t4]));
        const h2 = `
      float process(int outputIdx[${u3.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c3}];      // addressing input data
        ${l2.join("\n")}
        ${f2[0]}       // init ops for reduce max/min
        ${d2}
        ${f2[2]}       // final computation for reduce mean
        return value;
      }`;
        return Object.assign(Object.assign({}, s3), { output: { dims: u3, type: e3[0].type, textureType: a2.TextureType.unpacked }, shaderSource: h2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Reduce op requires 1 input.");
        if (-1 === i2.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
      };
      e2.reduceSum = (t3, e3, n3) => s2(t3, e3, n3, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), e2.reduceMean = (t3, e3, n3) => s2(t3, e3, n3, "ReduceMean", (t4, e4) => {
        let n4 = 1;
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && (n4 *= t4[0].dims[r3]);
        return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n4}.;`];
      }), e2.reduceMax = (t3, e3, n3) => s2(t3, e3, n3, "ReduceMax", (t4, e4) => {
        const n4 = [];
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && n4.push(`inputIdx[${r3}] = 0;`);
        return [`${n4.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
      }), e2.reduceMin = (t3, e3, n3) => s2(t3, e3, n3, "ReduceMin", (t4, e4) => {
        const n4 = [];
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && n4.push(`inputIdx[${r3}] = 0;`);
        return [`${n4.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
      }), e2.reduceProd = (t3, e3, n3) => s2(t3, e3, n3, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), e2.reduceLogSum = (t3, e3, n3) => s2(t3, e3, n3, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), e2.reduceLogSumSquare = (t3, e3, n3) => s2(t3, e3, n3, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
    }, 7019: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.isReshapeCheap = e2.processDims3D = e2.createPackedReshape3DProgramInfoLoader = void 0;
      const r2 = n2(2517), i2 = n2(5060), o2 = n2(2039), a2 = n2(2827);
      e2.createPackedReshape3DProgramInfoLoader = (t3, e3, n3) => {
        const s2 = ((t4) => ({ name: "Reshape (packed)", inputTypes: [o2.TextureType.packed], inputNames: ["A"], cacheHint: `${t4}` }))(n3);
        return Object.assign(Object.assign({}, s2), { get: () => ((t4, e4, n4, s3) => {
          const u2 = e4.dims, c2 = s3;
          let l2 = "";
          for (let t5 = 0; t5 < 4; t5++) {
            let e5 = "";
            switch (t5) {
              case 0:
                e5 = "outputCoords = rc;";
                break;
              case 1:
                e5 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                break;
              case 2:
                e5 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                break;
              case 3:
                e5 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                break;
              default:
                throw new Error();
            }
            l2 += `
        ${e5}
        ${t5 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t5}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t5 > 0 ? "}" : ""}
      `;
          }
          const p2 = (0, i2.getGlsl)(t4.session.backend.glContext.version), f2 = `
      ${function(t5) {
            const e5 = r2.ShapeUtil.computeStrides(t5), n5 = ["b", "r", "c"], i3 = "index";
            return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e5.map((t6, r3) => `int ${n5[r3]} = ${i3} / ${t6}; ${r3 === e5.length - 1 ? `int ${n5[r3 + 1]} = ${i3} - ${n5[r3]} * ${t6}` : `index -= ${n5[r3]} * ${t6}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
          }(u2)}
      ${function(t5) {
            const e5 = r2.ShapeUtil.computeStrides(t5);
            return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e5[0]} + coords.z * ${e5[1]} + coords.y;
  }
`;
          }(c2)}
      ${(0, a2.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c2[2]};
        int cols = ${c2[1]};

        ${l2}
        ${p2.output} = result;
      }
    `;
          return Object.assign(Object.assign({}, n4), { output: { dims: c2, type: e4.type, textureType: o2.TextureType.packed }, shaderSource: f2, hasMain: true });
        })(t3, e3, s2, n3) });
      }, e2.processDims3D = function(t3) {
        if (0 === t3.length) return [1, 1, 1];
        let e3 = 1;
        for (let n3 = 0; n3 < t3.length - 2; ++n3) e3 *= t3[n3];
        return [e3, t3.length > 1 ? t3[t3.length - 2] : 1, t3[t3.length - 1]];
      }, e2.isReshapeCheap = function(t3, e3) {
        let n3 = false;
        return n3 = 0 === t3.length || 0 === e3.length || (t3.length < 2 || e3.length < 2 ? t3[t3.length - 1] === e3[e3.length - 1] : t3[t3.length - 1] === e3[e3.length - 1] && t3[t3.length - 2] === e3[e3.length - 2]), n3;
      };
    }, 718: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.reshape = void 0;
      const r2 = n2(2517);
      e2.reshape = (t3, e3) => {
        const n3 = r2.ShapeUtil.calculateReshapedDims(e3[0].dims, e3[1].integerData);
        return t3.session.pack ? [t3.reshapePacked(e3[0], n3)] : [t3.reshapeUnpacked(e3[0], n3)];
      };
    }, 2268: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseResizeAttributesV11 = e2.parseResizeAttributesV10 = e2.resize = void 0;
      const r2 = n2(5060), i2 = n2(2039), o2 = n2(9390), a2 = n2(2827), s2 = n2(9793), u2 = { name: "Resize", inputNames: ["A"], inputTypes: [i2.TextureType.packed] };
      e2.resize = (t3, e3, n3) => ((0, s2.validateInputs)(e3, n3), [t3.run(Object.assign(Object.assign({}, u2), { cacheHint: n3.cacheKey, get: () => c2(t3, e3, n3) }), e3)]), e2.parseResizeAttributesV10 = (t3) => (0, s2.parseUpsampleAttributes)(t3, 10), e2.parseResizeAttributesV11 = (t3) => (0, s2.parseUpsampleAttributes)(t3, 11);
      const c2 = (t3, e3, n3) => {
        const s3 = (0, r2.getGlsl)(t3.session.backend.glContext.version), [c3, p3] = l2(e3, n3);
        if (c3.every((t4) => 1 === t4) && "tf_crop_and_resize" !== n3.coordinateTransformMode) return Object.assign(Object.assign({}, u2), { output: { dims: p3, type: e3[0].type, textureType: i2.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s3.texture2D}(X, TexCoords);
                    ${s3.output} = v;
                }` });
        const f3 = p3.length;
        if (f3 < 2) throw new Error(`output dimension should be at least 2, but got ${f3}`);
        const d2 = p3[f3 - 2], h2 = p3[f3 - 1], g2 = e3[0].dims;
        if (f3 !== g2.length) throw new Error(`output dimension should match input ${g2.length}, but got ${f3}`);
        const b2 = g2[f3 - 2], m2 = g2[f3 - 1], y2 = c3[f3 - 2], _ = c3[f3 - 1];
        let v2 = "";
        if ("linear" !== n3.mode) throw new Error(`resize (packed) does not support mode: '${n3.mode}'`);
        switch (n3.coordinateTransformMode) {
          case "asymmetric":
            v2 = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
            break;
          case "half_pixel":
            v2 = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
            break;
          case "pytorch_half_pixel":
            v2 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h2}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d2}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h2}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d2}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
            break;
          case "align_corners":
            v2 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h2}.0 - 1.0, ${d2}.0 - 1.0, ${h2}.0 - 1.0,
                            ${d2}.0 - 1.0);
                        vec4 original = vec4(${m2}.0 - 1.0, ${b2}.0 - 1.0, ${m2}.0 - 1.0,
                            ${b2}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
            break;
          default:
            throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n3.coordinateTransformMode}'`);
        }
        const w2 = (0, o2.getCoordsDataType)(f3), x2 = `
            const vec2 inputWH = vec2(${b2}.0, ${m2}.0);
            const vec4 scaleWHWH = vec4(float(${y2}), float(${_}), float(${y2}), float(${_}));
            ${(0, a2.unpackFromChannel)()}
            ${v2}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w2} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d2 - 1};
                bool hasNextCol = rc.z < ${h2 - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s3.output} = vec4(newValue);
            }
        `;
        return Object.assign(Object.assign({}, u2), { output: { dims: p3, type: e3[0].type, textureType: i2.TextureType.packed }, hasMain: true, shaderSource: x2 });
      }, l2 = (t3, e3) => {
        const n3 = t3[0].dims;
        let r3, i3 = e3.scales;
        if (0 === i3.length) {
          const o4 = t3[e3.scalesInputIdx];
          if (o4 && 0 !== o4.size) {
            if (t3[e3.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
            i3 = p2(o4, e3.mode, e3.isResize);
          } else {
            const o5 = t3[e3.sizesInputIdx];
            if (!o5 || 0 === o5.size) throw new Error("Either scales or sizes MUST be provided as input.");
            r3 = Array.from(o5.integerData), i3 = f2(r3, n3, e3.mode, e3.isResize);
          }
        } else if (t3[e3.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
        const o3 = r3 || n3.map((t4, e4) => Math.floor(t4 * i3[e4]));
        return [i3, o3];
      }, p2 = (t3, e3, n3) => {
        const r3 = Array.from(t3.floatData);
        return (0, s2.scalesValidation)(r3, e3, n3), r3;
      }, f2 = (t3, e3, n3, r3) => {
        const i3 = e3.length, o3 = new Array(i3);
        for (let n4 = 0, r4 = i3; n4 < r4; n4++) if (0 === e3[n4]) {
          if (0 !== t3[n4]) throw new Error("Input dim is zero but required output dim is non-zero.");
          o3[n4] = 1;
        } else o3[n4] = t3[n4] / e3[n4];
        return (0, s2.scalesValidation)(o3, n3, r3), o3;
      };
    }, 8117: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.shape = void 0;
      const r2 = n2(9162);
      e2.shape = (t3, e3) => (i2(e3), [new r2.Tensor([e3[0].dims.length], "int32", void 0, void 0, new Int32Array(e3[0].dims))]);
      const i2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Shape requires 1 input.");
      };
    }, 2278: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.sliceV10 = e2.parseSliceAttributes = e2.slice = void 0;
      const r2 = n2(246), i2 = n2(782), o2 = n2(2517), a2 = n2(2039), s2 = { name: "Slice", inputNames: ["A"], inputTypes: [a2.TextureType.unpacked] };
      e2.slice = (t3, e3, n3) => (c2(e3), [t3.run(Object.assign(Object.assign({}, s2), { cacheHint: n3.cacheKey, get: () => u2(t3, e3[0], n3) }), e3)]), e2.parseSliceAttributes = (t3) => {
        const e3 = t3.attributes.getInts("starts"), n3 = t3.attributes.getInts("ends"), i3 = t3.attributes.getInts("axes", []);
        return (0, r2.createAttributeWithCacheKey)({ starts: e3, ends: n3, axes: i3 });
      };
      const u2 = (t3, e3, n3) => {
        const r3 = 0 === n3.axes.length ? e3.dims.slice(0).map((t4, e4) => e4) : n3.axes, i3 = o2.ShapeUtil.normalizeAxes(r3, e3.dims.length), u3 = n3.starts.map((t4, n4) => t4 > e3.dims[i3[n4]] - 1 ? e3.dims[i3[n4]] : o2.ShapeUtil.normalizeAxis(t4, e3.dims[i3[n4]])), c3 = n3.ends.map((t4, n4) => t4 > e3.dims[i3[n4]] - 1 ? e3.dims[i3[n4]] : o2.ShapeUtil.normalizeAxis(t4, e3.dims[i3[n4]])), l3 = e3.dims.slice(), p3 = [];
        for (let t4 = 0; t4 < i3.length; t4++) l3[i3[t4]] = c3[t4] - u3[t4], u3[t4] > 0 && p3.push(`outputIdx[${i3[t4]}] += ${u3[t4]};`);
        const f2 = `
      float process(int outputIdx[${l3.length}]) {
        ${p3.join("\n      ")}
        return _A(outputIdx);
      }`;
        return Object.assign(Object.assign({}, s2), { output: { dims: l3, type: e3.type, textureType: a2.TextureType.unpacked }, shaderSource: f2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Slice requires 1 input.");
        if (-1 === i2.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
      };
      e2.sliceV10 = (t3, e3) => {
        p2(e3);
        const n3 = l2(t3, e3);
        return [t3.run(Object.assign(Object.assign({}, s2), { cacheHint: n3.cacheKey, get: () => u2(t3, e3[0], n3) }), [e3[0]])];
      };
      const l2 = (t3, e3) => {
        if (!t3.session.isInitializer(e3[1].dataId) || !t3.session.isInitializer(e3[2].dataId) || e3.length >= 4 && !t3.session.isInitializer(e3[3].dataId) || e3.length >= 5 && !t3.session.isInitializer(e3[4].dataId)) throw new Error("dynamic slice attributes are not allowed");
        if (e3.length >= 5 && e3[4].integerData.some((t4) => 1 !== t4)) throw new Error("currently non-1 steps is not supported for Slice");
        const n3 = Array.from(e3[1].integerData), r3 = Array.from(e3[2].integerData), i3 = e3.length >= 4 ? Array.from(e3[3].integerData) : [];
        return { starts: n3, ends: r3, axes: i3, cacheKey: `${i3};${n3};${r3}` };
      }, p2 = (t3) => {
        if (!t3 || t3.length < 3 || t3.length > 5) throw new Error("Invalid input number.");
        if ("int32" !== t3[1].type || 1 !== t3[1].dims.length) throw new Error("Invalid input type.");
        if ("int32" !== t3[2].type || 1 !== t3[2].dims.length) throw new Error("Invalid input type.");
        if (t3.length >= 4 && ("int32" !== t3[3].type || 1 !== t3[3].dims.length)) throw new Error("Invalid input type.");
        if (t3.length >= 5 && ("int32" !== t3[4].type || 1 !== t3[4].dims.length)) throw new Error("Invalid input type.");
      };
    }, 5524: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.softmaxV13 = e2.parseSoftmaxAttributesV13 = e2.parseSoftmaxAttributes = e2.softmax = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(5060), a2 = n2(2039), s2 = n2(3738), u2 = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a2.TextureType.unpacked] }, c2 = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a2.TextureType.unpacked, a2.TextureType.unpacked] }, l2 = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a2.TextureType.unpacked, a2.TextureType.unpacked, a2.TextureType.unpacked] };
      e2.softmax = (t3, e3, n3) => {
        g2(e3);
        const r3 = e3[0].dims.slice(), o3 = i2.ShapeUtil.normalizeAxis(n3.axis, r3.length), a3 = i2.ShapeUtil.sizeToDimension(r3, o3), s3 = i2.ShapeUtil.sizeFromDimension(r3, o3);
        return p2(t3, e3, n3, a3, s3);
      }, e2.parseSoftmaxAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", 1) }), e2.parseSoftmaxAttributesV13 = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", -1) }), e2.softmaxV13 = (t3, e3, n3) => {
        g2(e3);
        const o3 = e3[0].dims.slice(), a3 = i2.ShapeUtil.normalizeAxis(n3.axis, o3.length), u3 = o3.length, c3 = a3 !== u3 - 1, l3 = [];
        let f3, d3 = [], h3 = [];
        c3 && (d3 = Array.from({ length: u3 }).map((t4, e4) => e4), d3[a3] = u3 - 1, d3[u3 - 1] = a3, d3.map((t4) => l3.push(o3[t4])), f3 = (0, r2.createAttributeWithCacheKey)({ perm: d3 }), h3 = (0, s2.transpose)(t3, e3, f3));
        const b2 = c3 ? i2.ShapeUtil.sizeToDimension(l3, u3 - 1) : i2.ShapeUtil.sizeToDimension(o3, u3 - 1), m2 = c3 ? i2.ShapeUtil.sizeFromDimension(l3, u3 - 1) : i2.ShapeUtil.sizeFromDimension(o3, u3 - 1), y2 = p2(t3, c3 ? h3 : e3, n3, b2, m2);
        return c3 ? (0, s2.transpose)(t3, y2, f3) : y2;
      };
      const p2 = (t3, e3, n3, r3, i3) => {
        const o3 = f2(t3, e3[0], r3, i3, [r3]), a3 = t3.run(Object.assign(Object.assign({}, u2), { cacheHint: n3.cacheKey, get: () => o3 }), e3), s3 = d2(t3, e3[0], r3, i3, o3.output.dims, [r3]), p3 = t3.run(Object.assign(Object.assign({}, c2), { cacheHint: n3.cacheKey, get: () => s3 }), [e3[0], a3]), g3 = h2(t3, e3[0], r3, i3, o3.output.dims, s3.output.dims);
        return [t3.run(Object.assign(Object.assign({}, l2), { cacheHint: n3.cacheKey, get: () => g3 }), [e3[0], a3, p3])];
      }, f2 = (t3, e3, n3, r3, i3) => {
        const [s3, c3] = t3.calculateTextureWidthAndHeight(e3.dims, a2.TextureType.unpacked), l3 = i3.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== i3.length) throw new Error("Dimensionality of the output should be 1");
        if (i3[0] !== n3) throw new Error("Shape of the output should be equal to logical row count");
        const p3 = (0, o2.getGlsl)(t3.session.backend.glContext.version), f3 = `
      float process(int[${l3}] indices) {
        int logical_row_start_offset = indices[0] * ${r3};

        float max = getColorAsFloat(${p3.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s3},
        ${c3} )));
        for(int i=1; i<${r3}; ++i)
        {
          float current = getColorAsFloat(${p3.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s3}, ${c3})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
        return Object.assign(Object.assign({}, u2), { output: { dims: i3, type: e3.type, textureType: a2.TextureType.unpacked }, shaderSource: f3 });
      }, d2 = (t3, e3, n3, r3, i3, s3) => {
        const [u3, l3] = t3.calculateTextureWidthAndHeight(e3.dims, a2.TextureType.unpacked), p3 = s3.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== s3.length) throw new Error("Dimensionality of the output should be 1");
        if (s3[0] !== n3) throw new Error("Shape of the output should be equal to logical row count");
        if (1 !== i3.length) throw new Error("Dimensionality of the intermediate results should be 1");
        if (i3[0] !== n3) throw new Error("Shape of the intermediate results should be equal to logical row count");
        const f3 = `
      float process(int[${p3}] indices) {
        int logical_row_start_offset = indices[0] * ${r3};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r3}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o2.getGlsl)(t3.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u3}, ${l3}))) - max);
        }

        return norm_factor;
      }`;
        return Object.assign(Object.assign({}, c2), { output: { dims: s3, type: e3.type, textureType: a2.TextureType.unpacked }, shaderSource: f3 });
      }, h2 = (t3, e3, n3, r3, i3, o3) => {
        const [s3, u3] = t3.calculateTextureWidthAndHeight(e3.dims, a2.TextureType.unpacked), c3 = e3.dims.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== i3.length || 1 !== o3.length) throw new Error("Dimensionality of the intermediate results should be 1");
        if (i3[0] !== n3 || o3[0] !== n3) throw new Error("Shape of the intermediate results should be equal to logical row count");
        const p3 = `
      float process(int[${c3}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s3}, ${u3});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r3};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
        return Object.assign(Object.assign({}, l2), { output: { dims: e3.dims, type: e3.type, textureType: a2.TextureType.unpacked }, shaderSource: p3 });
      }, g2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Softmax requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type");
      };
    }, 5975: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseSplitAttributes = e2.split = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(2039), a2 = { name: "Split", inputNames: ["A"], inputTypes: [o2.TextureType.unpacked] };
      e2.split = (t3, e3, n3) => {
        c2(e3);
        const r3 = i2.ShapeUtil.normalizeAxis(n3.axis, e3[0].dims.length), o3 = s2(t3, e3, r3, n3), l2 = [];
        for (let i3 = 0; i3 < o3; ++i3) l2.push(t3.run(Object.assign(Object.assign({}, a2), { cacheHint: `${n3.cacheKey};${i3}`, get: () => u2(t3, e3[0], n3, r3, i3) }), e3));
        return l2;
      }, e2.parseSplitAttributes = (t3) => {
        const e3 = t3.attributes.getInt("axis", 0), n3 = t3.attributes.getInts("split", []), i3 = t3.outputs.length;
        return (0, r2.createAttributeWithCacheKey)({ axis: e3, split: n3, numOutputs: i3 });
      };
      const s2 = (t3, e3, n3, r3) => {
        const [, o3] = i2.SplitUtil.splitShape(e3[0].dims, n3, r3.split, r3.numOutputs);
        return o3.length;
      }, u2 = (t3, e3, n3, r3, s3) => {
        const [u3, c3] = i2.SplitUtil.splitShape(e3.dims, r3, n3.split, n3.numOutputs), l2 = c3[s3], p2 = u3[s3], f2 = `
      float process(int indices[${p2.length}]) {
        indices[${r3}] += ${l2};
        return _A(indices);
      }
    `;
        return Object.assign(Object.assign({}, a2), { cacheHint: `${n3.cacheKey}:${s3}`, output: { dims: p2, type: e3.type, textureType: o2.TextureType.unpacked }, shaderSource: f2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Split requires one input.");
        if ("int8" !== t3[0].type && "uint8" !== t3[0].type && "int16" !== t3[0].type && "uint16" !== t3[0].type && "int32" !== t3[0].type && "uint32" !== t3[0].type && "float32" !== t3[0].type && "float64" !== t3[0].type && "bool" !== t3[0].type) throw new Error("Invalid input type.");
      };
    }, 3933: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseSqueezeAttributes = e2.squeezeV13 = e2.squeeze = void 0;
      const r2 = n2(2517);
      e2.squeeze = (t3, e3, n3) => {
        i2(e3);
        const o3 = r2.ShapeUtil.squeezeShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o3)];
      }, e2.squeezeV13 = (t3, n3) => (o2(n3), (0, e2.squeeze)(t3, [n3[0]], Array.from(n3[1].integerData))), e2.parseSqueezeAttributes = (t3) => t3.attributes.getInts("axes");
      const i2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Squeeze requires 1 input.");
        if ("string" === t3[0].type) throw new Error("invalid input tensor types.");
      }, o2 = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Squeeze requires 2 inputs.");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
      };
    }, 6558: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.sum = void 0;
      const r2 = n2(5060), i2 = n2(2039);
      e2.sum = (t3, e3) => {
        a2(e3);
        const n3 = { name: "Sum", inputNames: e3.map((t4, e4) => `X${e4}`), inputTypes: new Array(e3.length).fill(i2.TextureType.unpacked) };
        return [t3.run(Object.assign(Object.assign({}, n3), { get: () => o2(t3, e3, n3) }), e3)];
      };
      const o2 = (t3, e3, n3) => {
        const o3 = (0, r2.getGlsl)(t3.session.backend.glContext.version), a3 = e3[0].dims.slice(), s2 = `
      void main() {
        vec4 result = ${e3.map((t4, e4) => `${o3.texture2D}(X${e4},TexCoords)`).join(" + ")};
        ${o3.output} = result;
      }
    `;
        return Object.assign(Object.assign({}, n3), { output: { dims: a3, type: e3[0].type, textureType: i2.TextureType.unpacked }, hasMain: true, shaderSource: s2 });
      }, a2 = (t3) => {
        if (!t3 || 0 === t3.length) throw new Error("Sum requires inputs.");
        const e3 = t3[0].dims.length;
        for (let n3 = 1; n3 < t3.length; n3++) {
          if (e3 !== t3[n3].dims.length) throw new Error("Input shapes are mismatched.");
          for (let r3 = 0; r3 < e3; r3++) if (t3[0].dims[r3] !== t3[n3].dims[r3]) throw new Error("Input shapes are not matched.");
        }
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
        for (let e4 = 1; e4 < t3.length; e4++) if (t3[0].type !== t3[e4].type) throw new Error("Input types are not matched.");
      };
    }, 5723: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.tile = void 0;
      const r2 = n2(782), i2 = n2(2039);
      e2.tile = (t3, e3) => {
        a2(e3);
        const n3 = { name: "Tile", inputNames: ["A"], inputTypes: [i2.TextureType.unpacked] };
        return [t3.run(Object.assign(Object.assign({}, n3), { get: () => o2(t3, e3, n3) }), e3)];
      };
      const o2 = (t3, e3, n3) => {
        const r3 = e3[0].dims.slice(), o3 = new Array(r3.length), a3 = [];
        for (let t4 = 0; t4 < r3.length; t4++) o3[t4] = r3[t4] * e3[1].numberData[t4], a3.push(`inputIdx[${t4}] = int(mod(float(outputIdx[${t4}]), ${r3[t4]}.));`);
        const s2 = o3.length, u2 = `
      float process(int outputIdx[${s2}]) {
        int inputIdx[${s2}];
        ${a3.join("\n")}
        return _A(inputIdx);
      }
    `;
        return Object.assign(Object.assign({}, n3), { output: { dims: o3, type: e3[0].type, textureType: i2.TextureType.unpacked }, shaderSource: u2 });
      }, a2 = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Tile requires 2 input.");
        if (1 !== t3[1].dims.length) throw new Error("The second input shape must 1 dimension.");
        if (t3[1].dims[0] !== t3[0].dims.length) throw new Error("Invalid input shape.");
        if (-1 === r2.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
        if ("int32" !== t3[1].type && "int16" !== t3[1].type) throw new Error("Invalid repeat type.");
      };
    }, 3738: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseTransposeAttributes = e2.transpose = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(2039), a2 = { name: "Transpose", inputNames: ["A"], inputTypes: [o2.TextureType.unpacked] };
      e2.transpose = (t3, e3, n3) => (p2(e3), [t3.run(Object.assign(Object.assign({}, a2), { cacheHint: n3.cacheKey, get: () => s2(t3, e3[0], n3.perm) }), e3)]), e2.parseTransposeAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ perm: t3.attributes.getInts("perm", []) });
      const s2 = (t3, e3, n3) => {
        const r3 = e3.dims;
        n3 = u2(r3, n3);
        const i3 = c2(r3, n3), s3 = r3.length, p3 = `
      ${l2("perm", n3, s3)}
      float process(int indices[${s3}]) {
        int a[${s3}];
        perm(a, indices);
        return _A(a);
      }`;
        return Object.assign(Object.assign({}, a2), { output: { dims: i3, type: e3.type, textureType: o2.TextureType.unpacked }, shaderSource: p3 });
      }, u2 = (t3, e3) => (e3 && e3.length !== t3.length && (e3 = [...t3.keys()].reverse()), e3), c2 = (t3, e3) => (e3 = u2(t3, e3), i2.ShapeUtil.sortBasedOnPerm(t3, e3)), l2 = (t3, e3, n3) => {
        const r3 = [];
        r3.push(`void ${t3}(out int a[${n3}], int src[${n3}]) {`);
        for (let t4 = 0; t4 < n3; ++t4) r3.push(`	a[${e3[t4]}]=src[${t4}];`);
        return r3.push("	}"), r3.join("\n");
      }, p2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Transpose requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("input should be float tensor");
      };
    }, 8710: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.encodeAsUint8 = void 0;
      const r2 = n2(5060), i2 = n2(2039);
      e2.encodeAsUint8 = (t3, e3) => {
        const n3 = e3.shape, o2 = (0, r2.getGlsl)(t3.session.backend.glContext.version), a2 = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o2.texture2D}(X,TexCoords).r;
      ${o2.output} = encodeAsUint8(value);
    }`, s2 = { name: "Uint8Encode", inputTypes: [i2.TextureType.unpacked], inputNames: ["X"], output: { dims: n3, type: e3.tensor.type, textureType: i2.TextureType.downloadUint8AsFloat }, shaderSource: a2, hasMain: true };
        return t3.executeProgram(s2, [e3.tensor]);
      };
    }, 4909: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.tanh = e2.tan = e2.sqrt = e2.sin = e2.sigmoid = e2.relu = e2.not = e2.neg = e2.log = e2.parseLeakyReluAttributes = e2.leakyRelu = e2.identity = e2.floor = e2.exp = e2.parseEluAttributes = e2.elu = e2.cos = e2.ceil = e2.clipV11 = e2.parseClipAttributes = e2.clip = e2.atan = e2.asin = e2.acos = e2.abs = e2.glslTanh = e2.glslTan = e2.glslSqrt = e2.glslSigmoid = e2.glslRelu = e2.glslSin = e2.glslNot = e2.glslNeg = e2.glslLog = e2.glslLeakyRelu = e2.glslIdentity = e2.glslClip = e2.glslFloor = e2.glslExp = e2.glslElu = e2.glslCos = e2.glslCeil = e2.glslAtan = e2.glslAsin = e2.glslAcos = e2.glslAbs = void 0;
      const r2 = n2(246), i2 = n2(2517), o2 = n2(8520), a2 = n2(5060), s2 = n2(2039);
      function u2() {
        return P2("abs");
      }
      function c2() {
        return P2("acos");
      }
      function l2() {
        return P2("asin");
      }
      function p2() {
        return P2("atan");
      }
      function f2() {
        return P2("ceil");
      }
      function d2() {
        return P2("cos");
      }
      function h2(t3) {
        const e3 = "elu";
        return { body: `
  const float alpha = float(${t3});

  float ${e3}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e3}_(vec4 v) {
    return vec4(${e3}_(v.x), ${e3}_(v.y), ${e3}_(v.z), ${e3}_(v.w));
  }
  `, name: e3, type: o2.FunctionType.ValueBased };
      }
      function g2() {
        return P2("exp");
      }
      function b2() {
        return P2("floor");
      }
      function m2(t3, e3) {
        const n3 = "clip";
        return { body: `
  const float min = float(${t3});
  const float max = float(${e3});

  float ${n3}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n3}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n3, type: o2.FunctionType.ValueBased };
      }
      function y2() {
        const t3 = "indentity";
        return { body: `
  float ${t3}_(float a) {
    return a;
  }
  vec4 ${t3}_(vec4 v) {
    return v;
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function _(t3) {
        const e3 = "leakyRelu";
        return { body: `
  const float alpha = float(${t3});

  float ${e3}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e3}_(vec4 v) {
    return vec4(${e3}_(v.x), ${e3}_(v.y), ${e3}_(v.z), ${e3}_(v.w));
  }
  `, name: e3, type: o2.FunctionType.ValueBased };
      }
      function v2() {
        return P2("log");
      }
      function w2() {
        const t3 = "neg";
        return { body: `
  float ${t3}_(float a) {
    return -a;
  }
  vec4 ${t3}_(vec4 v) {
    return -v;
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function x2() {
        const t3 = "not";
        return { body: `
  float ${t3}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t3}_(bool a) {
    return !a;
  }
  vec4 ${t3}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t3}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function T2() {
        return P2("sin");
      }
      function S2() {
        const t3 = "relu";
        return { body: `
  float ${t3}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t3}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function O2() {
        const t3 = "sigmoid";
        return { body: `
  float ${t3}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t3}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function A2() {
        return P2("sqrt");
      }
      function E2() {
        return P2("tan");
      }
      function I2() {
        const t3 = "tanh";
        return { body: `
  float ${t3}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t3}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      function P2(t3) {
        return { body: `
  float ${t3}_(float a) {
    return ${t3}(a);
  }
  vec4 ${t3}_(vec4 v) {
    return ${t3}(v);
  }
  `, name: t3, type: o2.FunctionType.ValueBased };
      }
      e2.glslAbs = u2, e2.glslAcos = c2, e2.glslAsin = l2, e2.glslAtan = p2, e2.glslCeil = f2, e2.glslCos = d2, e2.glslElu = h2, e2.glslExp = g2, e2.glslFloor = b2, e2.glslClip = m2, e2.glslIdentity = y2, e2.glslLeakyRelu = _, e2.glslLog = v2, e2.glslNeg = w2, e2.glslNot = x2, e2.glslSin = T2, e2.glslRelu = S2, e2.glslSigmoid = O2, e2.glslSqrt = A2, e2.glslTan = E2, e2.glslTanh = I2;
      const D2 = (t3, e3, n3, r3) => {
        const i3 = t3.session.pack ? s2.TextureType.packed : s2.TextureType.unpacked, o3 = { name: n3.name, inputTypes: [i3], inputNames: ["A"], cacheHint: r3 };
        return Object.assign(Object.assign({}, o3), { get: () => ((t4, e4, n4, r4) => {
          const i4 = t4.session.pack ? s2.TextureType.packed : s2.TextureType.unpacked, o4 = (0, a2.getGlsl)(t4.session.backend.glContext.version);
          return Object.assign(Object.assign({}, e4), { output: { dims: n4.dims, type: n4.type, textureType: i4 }, shaderSource: `
     ${r4.body}
     void main() {
       vec4 v = ${o4.texture2D}(A, TexCoords);
       v = ${r4.name}_(v);
       ${o4.output} = v;
     }
     `, hasMain: true });
        })(t3, o3, e3, n3) });
      };
      e2.abs = (t3, e3) => [t3.run(D2(t3, e3[0], u2()), e3)], e2.acos = (t3, e3) => [t3.run(D2(t3, e3[0], c2()), e3)], e2.asin = (t3, e3) => [t3.run(D2(t3, e3[0], l2()), e3)], e2.atan = (t3, e3) => [t3.run(D2(t3, e3[0], p2()), e3)], e2.clip = (t3, e3, n3) => [t3.run(D2(t3, e3[0], m2(n3.min, n3.max), n3.cacheKey), e3)], e2.parseClipAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ min: t3.attributes.getFloat("min", i2.MIN_CLIP), max: t3.attributes.getFloat("max", i2.MAX_CLIP) }), e2.clipV11 = (t3, n3) => {
        const r3 = $2(t3, n3);
        return (0, e2.clip)(t3, [n3[0]], r3);
      };
      const $2 = (t3, e3) => {
        if (e3.length >= 3 && (!t3.session.isInitializer(e3[1].dataId) || !t3.session.isInitializer(e3[2].dataId))) throw new Error("dynamic clip attributes are not allowed");
        const n3 = e3.length >= 3 ? e3[1].numberData[0] : i2.MIN_CLIP, o3 = e3.length >= 3 ? e3[2].numberData[0] : i2.MAX_CLIP;
        return (0, r2.createAttributeWithCacheKey)({ min: n3, max: o3 });
      };
      e2.ceil = (t3, e3) => [t3.run(D2(t3, e3[0], f2()), e3)], e2.cos = (t3, e3) => [t3.run(D2(t3, e3[0], d2()), e3)], e2.elu = (t3, e3, n3) => [t3.run(D2(t3, e3[0], h2(n3.alpha), n3.cacheKey), e3)], e2.parseEluAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ alpha: t3.attributes.getFloat("alpha", 1) }), e2.exp = (t3, e3) => [t3.run(D2(t3, e3[0], g2()), e3)], e2.floor = (t3, e3) => [t3.run(D2(t3, e3[0], b2()), e3)], e2.identity = (t3, e3) => [t3.run(D2(t3, e3[0], y2()), e3)], e2.leakyRelu = (t3, e3, n3) => [t3.run(D2(t3, e3[0], _(n3.alpha), n3.cacheKey), e3)], e2.parseLeakyReluAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ alpha: t3.attributes.getFloat("alpha", 0.01) }), e2.log = (t3, e3) => [t3.run(D2(t3, e3[0], v2()), e3)], e2.neg = (t3, e3) => [t3.run(D2(t3, e3[0], w2()), e3)], e2.not = (t3, e3) => [t3.run(D2(t3, e3[0], x2()), e3)], e2.relu = (t3, e3) => [t3.run(D2(t3, e3[0], S2()), e3)], e2.sigmoid = (t3, e3) => [t3.run(D2(t3, e3[0], O2()), e3)], e2.sin = (t3, e3) => [t3.run(D2(t3, e3[0], T2()), e3)], e2.sqrt = (t3, e3) => [t3.run(D2(t3, e3[0], A2()), e3)], e2.tan = (t3, e3) => [t3.run(D2(t3, e3[0], E2()), e3)], e2.tanh = (t3, e3) => [t3.run(D2(t3, e3[0], I2()), e3)];
    }, 5611: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createUnpackProgramInfoLoader = e2.createUnpackProgramInfo = void 0;
      const r2 = n2(5060), i2 = n2(2039), o2 = n2(9390), a2 = n2(2827), s2 = { name: "unpack", inputNames: ["A"], inputTypes: [i2.TextureType.packed] };
      e2.createUnpackProgramInfo = (t3, e3) => {
        const n3 = e3.dims.length, u2 = (0, a2.getChannels)("rc", n3), c2 = u2.slice(-2), l2 = (0, o2.getCoordsDataType)(n3), p2 = (0, a2.unpackFromChannel)(), f2 = 0 === e3.dims.length ? "" : function(t4, e4) {
          if (1 === t4) return "rc";
          let n4 = "";
          for (let r3 = 0; r3 < t4; r3++) n4 += e4[r3], r3 < t4 - 1 && (n4 += ",");
          return n4;
        }(n3, u2), d2 = n3 <= 1 ? "rc" : `vec2(${c2.join(",")})`, h2 = `
    ${p2}
    void main() {
      ${l2} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f2});

       ${(0, r2.getGlsl)(t3.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d2}), 0, 0, 0);
     }
   `;
        return Object.assign(Object.assign({}, s2), { hasMain: true, output: { dims: e3.dims, type: e3.type, textureType: i2.TextureType.unpacked }, shaderSource: h2 });
      }, e2.createUnpackProgramInfoLoader = (t3, n3) => Object.assign(Object.assign({}, s2), { get: () => (0, e2.createUnpackProgramInfo)(t3, n3) });
    }, 8428: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseUnsqueezeAttributes = e2.unsqueezeV13 = e2.unsqueeze = void 0;
      const r2 = n2(2517);
      e2.unsqueeze = (t3, e3, n3) => {
        i2(e3);
        const o3 = r2.ShapeUtil.unsqueezeShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o3)];
      }, e2.unsqueezeV13 = (t3, n3) => (o2(n3), (0, e2.unsqueeze)(t3, [n3[0]], Array.from(n3[1].integerData))), e2.parseUnsqueezeAttributes = (t3) => t3.attributes.getInts("axes");
      const i2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Unsqueeze requires 1 input.");
        if ("string" === t3[0].type) throw new Error("invalid input tensor types.");
      }, o2 = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Unsqueeze requires 2 inputs.");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
      };
    }, 9793: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.scalesValidation = e2.validateInputs = e2.parseUpsampleAttributes = e2.parseUpsampleAttributesV9 = e2.parseUpsampleAttributesV7 = e2.upsample = void 0;
      const r2 = n2(246), i2 = n2(5060), o2 = n2(2039), a2 = { name: "Upsample", inputNames: ["X"], inputTypes: [o2.TextureType.unpacked] };
      e2.upsample = (t3, n3, r3) => ((0, e2.validateInputs)(n3, r3), [t3.run(Object.assign(Object.assign({}, a2), { cacheHint: r3.cacheKey, get: () => s2(t3, n3, r3) }), n3)]), e2.parseUpsampleAttributesV7 = (t3) => (0, e2.parseUpsampleAttributes)(t3, 7), e2.parseUpsampleAttributesV9 = (t3) => (0, e2.parseUpsampleAttributes)(t3, 9), e2.parseUpsampleAttributes = (t3, n3) => {
        const i3 = n3 >= 10, o3 = t3.attributes.getString("mode", "nearest");
        if ("nearest" !== o3 && "linear" !== o3 && (n3 < 11 || "cubic" !== o3)) throw new Error(`unrecognized mode: ${o3}`);
        let a3 = [];
        n3 < 9 && (a3 = t3.attributes.getFloats("scales"), (0, e2.scalesValidation)(a3, o3, i3));
        const s3 = t3.attributes.getFloat("extrapolation_value", 0), u2 = n3 > 10 ? t3.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
        if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u2)) throw new Error(`coordinate_transform_mode '${u2}' is not supported`);
        const c2 = "tf_crop_and_resize" === u2, l2 = c2, p2 = "nearest" === o3 && n3 >= 11 ? t3.attributes.getString("nearest_mode", "round_prefer_floor") : "";
        if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p2)) throw new Error(`nearest_mode '${p2}' is not supported`);
        const f2 = t3.attributes.getFloat("cubic_coeff_a", -0.75), d2 = 0 !== t3.attributes.getInt("exclude_outside", 0);
        if (d2 && "cubic" !== o3) throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
        const h2 = n3 < 11 || "nearest" === o3 && "asymmetric" === u2 && "floor" === p2;
        let g2 = 0, b2 = 0, m2 = 0;
        return n3 > 10 ? t3.inputs.length > 2 ? (g2 = 1, b2 = 2, m2 = 3) : (b2 = 1, m2 = 2) : 9 === n3 && (b2 = 1), (0, r2.createAttributeWithCacheKey)({ opset: n3, isResize: i3, mode: o3, scales: a3, extrapolationValue: s3, coordinateTransformMode: u2, useExtrapolation: l2, needRoiInput: c2, nearestMode: p2, cubicCoefficientA: f2, excludeOutside: d2, useNearest2xOptimization: h2, roiInputIdx: g2, scalesInputIdx: b2, sizesInputIdx: m2 });
      };
      const s2 = (t3, e3, n3) => {
        const r3 = (0, i2.getGlsl)(t3.session.backend.glContext.version), [s3, u2] = t3.calculateTextureWidthAndHeight(e3[0].dims, o2.TextureType.unpacked), c2 = e3[0].dims.map((t4, e4) => Math.floor(t4 * n3.scales[e4])), [l2, p2] = t3.calculateTextureWidthAndHeight(c2, o2.TextureType.unpacked), f2 = c2.length, d2 = new Array(f2), h2 = new Array(f2);
        let g2 = `
      int output_pitches[${f2}];
      int input_pitches[${f2}];
      `;
        for (let t4 = f2 - 1; t4 >= 0; t4--) d2[t4] = t4 === f2 - 1 ? 1 : d2[t4 + 1] * c2[t4 + 1], h2[t4] = t4 === f2 - 1 ? 1 : h2[t4 + 1] * e3[0].dims[t4 + 1], g2 += `
        output_pitches[${t4}] = ${d2[t4]};
        input_pitches[${t4}] = ${h2[t4]};
        `;
        const b2 = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s3}, ${u2});
        float value = getColorAsFloat(${r3.texture2D}(X, coords));
        return value;
      }
      `, m2 = "nearest" === n3.mode ? `
    ${b2}
    float process(int indices[${f2}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int d, m;
      for (int dim = 0; dim < ${f2}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === f2 ? `
    ${b2}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e3[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b2}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e3[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
        return Object.assign(Object.assign({}, a2), { output: { dims: c2, type: e3[0].type, textureType: o2.TextureType.unpacked }, shaderSource: m2, variables: [{ name: "scales", type: "int", arrayLength: n3.scales.length, data: n3.scales.map((t4) => Math.ceil(t4)) }] });
      };
      e2.validateInputs = (t3, e3) => {
        if (!t3 || e3.opset < 9 && 1 !== t3.length || e3.opset >= 9 && e3.opset < 11 && 2 !== t3.length || e3.opset >= 11 && t3.length < 2) throw new Error("invalid inputs.");
        if (e3.scales.length > 0 && t3[0].dims.length !== e3.scales.length) throw new Error("Invalid input shape.");
        if ("string" === t3[0].type) throw new Error("Invalid input tensor types.");
      }, e2.scalesValidation = (t3, e3, n3) => {
        if (n3) {
          for (const e4 of t3) if (e4 <= 0) throw new Error("Scale value should be greater than 0.");
        } else for (const e4 of t3) if (e4 < 1) throw new Error("Scale value should be greater than or equal to 1.");
        if (!("linear" !== e3 && "cubic" !== e3 || 2 === t3.length || 4 === t3.length && 1 === t3[0] && 1 === t3[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n3 ? "Resize" : "Upsample"} opeartor.`);
      };
    }, 1958: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ProgramManager = void 0;
      const r2 = n2(1670), i2 = n2(6231), o2 = n2(8879), a2 = n2(5060);
      e2.ProgramManager = class {
        constructor(t3, e3, n3) {
          this.profiler = t3, this.glContext = e3, this.textureLayoutStrategy = n3, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
        }
        getArtifact(t3) {
          return this.repo.get(t3);
        }
        setArtifact(t3, e3) {
          this.repo.set(t3, e3);
        }
        run(t3, e3, n3) {
          var r3;
          this.profiler.event("op", `ProgramManager.run ${null !== (r3 = t3.programInfo.name) && void 0 !== r3 ? r3 : "unknown kernel"}`, () => {
            var r4;
            const o3 = this.glContext.gl, a3 = t3.program;
            o3.useProgram(a3);
            try {
              this.bindOutput(n3), this.attributesBound || this.bindAttributes(t3.attribLocations), this.bindUniforms(t3.uniformLocations, null !== (r4 = t3.programInfo.variables) && void 0 !== r4 ? r4 : [], e3);
            } catch (e4) {
              throw i2.Logger.error("ProgramManager", t3.programInfo.shaderSource), e4;
            }
            this.profiler.event("backend", "GlContext.draw()", () => {
              this.glContext.draw();
            });
          }, this.glContext);
        }
        dispose() {
          this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t3) => this.glContext.deleteProgram(t3.program));
        }
        build(t3, e3, n3) {
          return this.profiler.event("backend", "ProgramManager.build", () => {
            const r3 = new o2.GlslPreprocessor(this.glContext, t3, e3, n3), i3 = r3.preprocess(), a3 = this.compile(i3);
            return { programInfo: t3, program: a3, uniformLocations: this.getUniformLocations(a3, r3.context.programInfo.inputNames, r3.context.programInfo.variables), attribLocations: this.getAttribLocations(a3) };
          });
        }
        compile(t3) {
          if (!this.vertexShader) {
            i2.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
            const t4 = (0, a2.getVertexShaderSource)(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(t4, this.glContext.gl.VERTEX_SHADER);
          }
          r2.env.debug && i2.Logger.verbose("ProrgramManager", `FragShader:
${t3}
`);
          const e3 = this.glContext.compileShader(t3, this.glContext.gl.FRAGMENT_SHADER), n3 = this.glContext.createProgram(this.vertexShader, e3);
          return this.glContext.deleteShader(e3), n3;
        }
        bindOutput(t3) {
          const e3 = t3.width, n3 = t3.height;
          i2.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${e3}/${n3}, shape=${t3.shape}, type=${t3.tensor.type}`), this.glContext.attachFramebuffer(t3.texture, e3, n3);
        }
        bindAttributes(t3) {
          const e3 = t3.position, n3 = t3.textureCoord;
          this.glContext.setVertexAttributes(e3, n3), this.attributesBound = true;
        }
        bindUniforms(t3, e3, n3) {
          var r3;
          const i3 = this.glContext.gl;
          let o3 = 0;
          for (const { name: a3, type: s2, location: u2, arrayLength: c2 } of t3) {
            const t4 = null === (r3 = e3.find((t5) => t5.name === a3)) || void 0 === r3 ? void 0 : r3.data;
            if ("sampler2D" !== s2 && !t4) throw new Error(`variable '${a3}' does not have data defined in program info`);
            switch (s2) {
              case "sampler2D":
                this.bindTexture(n3[o3], u2, o3), o3++;
                break;
              case "float":
                c2 ? i3.uniform1fv(u2, t4) : i3.uniform1f(u2, t4);
                break;
              case "int":
                c2 ? i3.uniform1iv(u2, t4) : i3.uniform1i(u2, t4);
                break;
              default:
                throw new Error(`Uniform not implemented: ${s2}`);
            }
          }
        }
        bindTexture(t3, e3, n3) {
          this.glContext.bindTextureToUniform(t3.texture, n3, e3);
        }
        getAttribLocations(t3) {
          return { position: this.getAttribLocation(t3, "position"), textureCoord: this.getAttribLocation(t3, "textureCoord") };
        }
        getUniformLocations(t3, e3, n3) {
          const r3 = [];
          if (e3) for (const n4 of e3) r3.push({ name: n4, type: "sampler2D", location: this.getUniformLocation(t3, n4) });
          if (n3) for (const e4 of n3) r3.push(Object.assign(Object.assign({}, e4), { location: this.getUniformLocation(t3, e4.name) }));
          return r3;
        }
        getUniformLocation(t3, e3) {
          const n3 = this.glContext.gl.getUniformLocation(t3, e3);
          if (null === n3) throw new Error(`Uniform ${e3} not found.`);
          return n3;
        }
        getAttribLocation(t3, e3) {
          return this.glContext.gl.getAttribLocation(t3, e3);
        }
      };
    }, 6416: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLSessionHandler = void 0;
      const r2 = n2(6231), i2 = n2(1047), o2 = n2(8316), a2 = n2(1640), s2 = n2(1958), u2 = n2(7859), c2 = n2(5702);
      e2.WebGLSessionHandler = class {
        constructor(t3, e3) {
          this.backend = t3, this.context = e3, this.layoutStrategy = new u2.PreferLogicalStrategy(t3.glContext.maxTextureSize), this.programManager = new s2.ProgramManager(this.context.profiler, t3.glContext, this.layoutStrategy), this.textureManager = new c2.TextureManager(t3.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === t3.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t3.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
        }
        createInferenceHandler() {
          return new o2.WebGLInferenceHandler(this);
        }
        onGraphInitialized(t3) {
          const e3 = t3.getValues().filter((t4) => -1 === t4.from && t4.tensor).map((t4) => t4.tensor.dataId);
          this.initializers = new Set(e3);
        }
        isInitializer(t3) {
          return !!this.initializers && this.initializers.has(t3);
        }
        addInitializer(t3) {
          this.initializers.add(t3);
        }
        getTextureData(t3, e3) {
          return e3 ? this.packedTextureDataCache.get(t3) : this.unpackedTextureDataCache.get(t3);
        }
        setTextureData(t3, e3, n3 = false) {
          r2.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n3 ? this.packedTextureDataCache.set(t3, e3) : this.unpackedTextureDataCache.set(t3, e3);
        }
        dispose() {
          this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t3) => this.textureManager.releaseTexture(t3, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t3) => this.textureManager.releaseTexture(t3, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        resolve(t3, e3, n3) {
          const r3 = (0, i2.resolveOperator)(t3, e3, a2.WEBGL_OP_RESOLVE_RULES);
          return { impl: r3.opImpl, context: r3.opInit ? r3.opInit(t3, n3) : t3 };
        }
      };
    }, 7769: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Uint8DataEncoder = e2.RGBAFloatDataEncoder = e2.RedFloat32DataEncoder = void 0;
      const r2 = n2(6231);
      e2.RedFloat32DataEncoder = class {
        constructor(t3, e3 = 1) {
          if (1 === e3) this.internalFormat = t3.R32F, this.format = t3.RED, this.textureType = t3.FLOAT, this.channelSize = e3;
          else {
            if (4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
            this.internalFormat = t3.RGBA32F, this.format = t3.RGBA, this.textureType = t3.FLOAT, this.channelSize = e3;
          }
        }
        encode(t3, e3) {
          let n3, i2;
          return t3.constructor !== Float32Array && (r2.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i2 = new Float32Array(t3)), e3 * this.channelSize > t3.length ? (r2.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i2 = t3, n3 = this.allocate(e3 * this.channelSize), i2.forEach((t4, e4) => n3[e4] = t4)) : (i2 = t3, n3 = i2), n3;
        }
        allocate(t3) {
          return new Float32Array(4 * t3);
        }
        decode(t3, e3) {
          return 1 === this.channelSize ? t3.filter((t4, e4) => e4 % 4 == 0).subarray(0, e3) : t3.subarray(0, e3);
        }
      }, e2.RGBAFloatDataEncoder = class {
        constructor(t3, e3 = 1, n3) {
          if (1 !== e3 && 4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
          this.internalFormat = t3.RGBA, this.format = t3.RGBA, this.channelSize = e3, this.textureType = n3 || t3.FLOAT;
        }
        encode(t3, e3) {
          let n3 = t3;
          return 1 === this.channelSize && (r2.Logger.verbose("Encoder", "Exploding into a larger array"), n3 = this.allocate(e3), t3.forEach((t4, e4) => n3[4 * e4] = t4)), n3;
        }
        allocate(t3) {
          return new Float32Array(4 * t3);
        }
        decode(t3, e3) {
          return 1 === this.channelSize ? t3.filter((t4, e4) => e4 % 4 == 0).subarray(0, e3) : t3.subarray(0, e3);
        }
      }, e2.Uint8DataEncoder = class {
        constructor(t3, e3 = 1) {
          if (this.channelSize = 4, 1 === e3) this.internalFormat = t3.ALPHA, this.format = t3.ALPHA, this.textureType = t3.UNSIGNED_BYTE, this.channelSize = e3;
          else {
            if (4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
            this.internalFormat = t3.RGBA, this.format = t3.RGBA, this.textureType = t3.UNSIGNED_BYTE, this.channelSize = e3;
          }
        }
        encode(t3, e3) {
          return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
        }
        allocate(t3) {
          return new Uint8Array(t3 * this.channelSize);
        }
        decode(t3, e3) {
          if (t3 instanceof Uint8Array) return t3.subarray(0, e3);
          throw new Error(`Invalid array type: ${t3.constructor}`);
        }
      };
    }, 7859: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getBatchDim = e2.sizeToSquarishShape = e2.getRowsCols = e2.sizeFromShape = e2.isInt = e2.parseAxisParam = e2.squeezeShape = e2.PreferLogicalStrategy = e2.AlwaysKeepOriginalSizeStrategy = void 0;
      const r2 = n2(6231), i2 = n2(2517);
      function o2(t3, e3) {
        const n3 = [], r3 = [], i3 = null != e3 && Array.isArray(e3) && 0 === e3.length, o3 = null == e3 || i3 ? null : a2(e3, t3).sort();
        let s3 = 0;
        for (let e4 = 0; e4 < t3.length; ++e4) {
          if (null != o3) {
            if (o3[s3] === e4 && 1 !== t3[e4]) throw new Error(`Can't squeeze axis ${e4} since its dim '${t3[e4]}' is not 1`);
            (null == o3[s3] || o3[s3] > e4) && 1 === t3[e4] && (n3.push(t3[e4]), r3.push(e4)), o3[s3] <= e4 && s3++;
          }
          1 !== t3[e4] && (n3.push(t3[e4]), r3.push(e4));
        }
        return { newShape: n3, keptDims: r3 };
      }
      function a2(t3, e3) {
        const n3 = e3.length;
        return t3 = null == t3 ? e3.map((t4, e4) => e4) : [].concat(t3), (0, i2.assert)(t3.every((t4) => t4 >= -n3 && t4 < n3), () => `All values in axis param must be in range [-${n3}, ${n3}) but got axis ${t3}`), (0, i2.assert)(t3.every(s2), () => `All values in axis param must be integers but got axis ${t3}`), t3.map((t4) => t4 < 0 ? n3 + t4 : t4);
      }
      function s2(t3) {
        return t3 % 1 == 0;
      }
      function u2(t3) {
        if (0 === t3.length) return 1;
        let e3 = t3[0];
        for (let n3 = 1; n3 < t3.length; n3++) e3 *= t3[n3];
        return e3;
      }
      function c2(t3) {
        const e3 = Math.ceil(Math.sqrt(t3));
        return [e3, Math.ceil(t3 / e3)];
      }
      e2.AlwaysKeepOriginalSizeStrategy = class {
        constructor(t3) {
          this.maxTextureSize = t3;
        }
        computeTextureWH(t3, e3) {
          if (0 === t3.length) return [1, 1];
          const n3 = this.maxTextureSize;
          if (e3 && void 0 !== e3.breakAxis) {
            const i4 = e3.breakAxis >= t3.length ? 1 : t3.slice(e3.breakAxis).reduce((t4, e4) => t4 * e4), o4 = e3.breakAxis <= 0 ? 1 : t3.slice(0, e3.breakAxis).reduce((t4, e4) => t4 * e4);
            if (!(i4 > n3 || o4 > n3)) return [i4, o4];
            r2.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t3}, breakAxis:${e3.breakAxis}`);
          }
          const i3 = t3.reduce((t4, e4) => t4 * e4);
          let o3 = Math.floor(Math.sqrt(i3));
          for (; o3 < n3 && o3 < i3 && i3 % o3 != 0; o3++) ;
          if (o3 >= n3 || i3 % o3 != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${t3}`);
          return [o3, i3 / o3];
        }
      }, e2.PreferLogicalStrategy = class {
        constructor(t3) {
          this.maxTextureSize = t3;
        }
        computeTextureWH(t3, e3) {
          const n3 = this.computeTexture(t3, e3);
          return e3 && e3.isPacked && (n3[0] /= 2, n3[1] /= 2), e3 && e3.reverseWH ? [n3[1], n3[0]] : n3;
        }
        computeTexture(t3, e3) {
          const n3 = e3 && e3.isPacked;
          if (0 === t3.length) return n3 ? [2, 2] : [1, 1];
          let i3 = this.maxTextureSize;
          if (e3 && void 0 !== e3.breakAxis) {
            const n4 = e3.breakAxis >= t3.length ? 1 : t3.slice(e3.breakAxis).reduce((t4, e4) => t4 * e4), o3 = e3.breakAxis <= 0 ? 1 : t3.slice(0, e3.breakAxis).reduce((t4, e4) => t4 * e4);
            if (!(n4 > i3 || o3 > i3)) return [n4, o3];
            r2.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t3}, breakAxis:${e3.breakAxis}`);
          }
          let a3 = t3.slice(0);
          if (n3 && (i3 *= 2, a3 = a3.map((t4, e4) => e4 >= a3.length - 2 ? a3[e4] % 2 == 0 ? a3[e4] : a3[e4] + 1 : a3[e4]), 1 === a3.length && (a3 = [2, a3[0]])), 2 !== a3.length) {
            const t4 = o2(a3);
            a3 = t4.newShape;
          }
          const s3 = u2(a3);
          return a3.length <= 1 && s3 <= i3 ? [1, s3] : 2 === a3.length && a3[0] <= i3 && a3[1] <= i3 ? a3 : 3 === a3.length && a3[0] * a3[1] <= i3 && a3[2] <= i3 ? [a3[0] * a3[1], a3[2]] : 3 === a3.length && a3[0] <= i3 && a3[1] * a3[2] <= i3 ? [a3[0], a3[1] * a3[2]] : 4 === a3.length && a3[0] * a3[1] * a3[2] <= i3 && a3[3] <= i3 ? [a3[0] * a3[1] * a3[2], a3[3]] : 4 === a3.length && a3[0] <= i3 && a3[1] * a3[2] * a3[3] <= i3 ? [a3[0], a3[1] * a3[2] * a3[3]] : n3 ? c2(s3 / 4).map((t4) => 2 * t4) : c2(s3);
        }
      }, e2.squeezeShape = o2, e2.parseAxisParam = a2, e2.isInt = s2, e2.sizeFromShape = u2, e2.getRowsCols = function(t3) {
        if (0 === t3.length) throw Error("Cannot get rows and columns of an empty shape array.");
        return [t3.length > 1 ? t3[t3.length - 2] : 1, t3[t3.length - 1]];
      }, e2.sizeToSquarishShape = c2, e2.getBatchDim = function(t3, e3 = 2) {
        return u2(t3.slice(0, t3.length - e3));
      };
    }, 4057: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createTextureLayoutFromShape = e2.calculateTextureWidthAndHeight = e2.createTextureLayoutFromTextureType = void 0;
      const r2 = n2(2517), i2 = n2(2039);
      e2.createTextureLayoutFromTextureType = (t3, n3, r3) => {
        const o2 = r3 === i2.TextureType.unpacked || r3 === i2.TextureType.unpackedReversed ? 1 : 4, a2 = r3 === i2.TextureType.packed, s2 = r3 === i2.TextureType.unpackedReversed || r3 === i2.TextureType.packed, u2 = r3 === i2.TextureType.packedLastDimension ? n3.length - 1 : void 0, c2 = r3 === i2.TextureType.packedLastDimension ? n3.map((t4, e3) => e3 === n3.length - 1 ? 4 * t4 : t4) : void 0;
        return (0, e2.createTextureLayoutFromShape)(t3, n3, o2, c2, { isPacked: a2, reverseWH: s2, breakAxis: u2 });
      }, e2.calculateTextureWidthAndHeight = (t3, n3, r3) => {
        const i3 = (0, e2.createTextureLayoutFromTextureType)(t3, n3, r3);
        return [i3.width, i3.height];
      }, e2.createTextureLayoutFromShape = (t3, e3, n3 = 1, i3, o2) => {
        const a2 = !(!o2 || !o2.isPacked), [s2, u2] = t3.computeTextureWH(a2 && i3 || e3, o2), c2 = e3.length;
        let l2 = e3.slice(0);
        if (0 === c2 && (l2 = [1]), 1 === n3) i3 = e3;
        else if (a2) {
          if (4 !== n3) throw new Error("a packed texture must be 4-channel");
          i3 = e3, c2 > 0 && (l2[c2 - 1] = Math.ceil(l2[c2 - 1] / 2)), c2 > 1 && (l2[c2 - 2] = Math.ceil(l2[c2 - 2] / 2));
        } else if (!i3) throw new Error("Unpacked shape is needed when using channels > 1");
        return { width: s2, height: u2, channels: n3, isPacked: a2, shape: l2, strides: r2.ShapeUtil.computeStrides(l2), unpackedShape: i3, reversedWH: o2 && o2.reverseWH };
      };
    }, 5702: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TextureManager = void 0;
      const r2 = n2(6231);
      e2.TextureManager = class {
        constructor(t3, e3, n3, r3) {
          this.glContext = t3, this.layoutStrategy = e3, this.profiler = n3, this.config = r3, this.pendingRead = /* @__PURE__ */ new Map(), r3.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
        }
        createTextureFromLayout(t3, e3, n3, i2) {
          const o2 = this.toEncoderType(t3), a2 = this.glContext.getEncoder(o2, e3.channels || 1, i2);
          if (e3.isPacked && 1 === i2) throw new Error("not implemented");
          const s2 = e3.width, u2 = e3.height;
          let c2, l2;
          if (this.config.reuseTextures) {
            c2 = `${s2}x${u2}_${a2.format}_${a2.internalFormat}_${a2.textureType}`, l2 = this.inUseTextures.get(c2), l2 || (l2 = [], this.inUseTextures.set(c2, l2));
            const e4 = this.idleTextures.get(c2);
            if (e4 && e4.length > 0) {
              const r3 = e4.pop();
              return l2.push(r3), 1 === i2 && this.glContext.updateTexture(r3, s2, u2, a2, this.toTextureData(t3, n3)), r3;
            }
          }
          r2.Logger.verbose("TextureManager", `Creating new texture of size ${e3.width}x${e3.height}`);
          const p2 = this.glContext.allocateTexture(s2, u2, a2, this.toTextureData(t3, n3));
          return this.config.reuseTextures && (l2.push(p2), this.textureLookup.set(p2, c2)), p2;
        }
        readTexture(t3, e3, n3) {
          return n3 || (n3 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
            const r3 = t3.shape.reduce((t4, e4) => t4 * e4) * n3, i2 = this.glContext.readTexture(t3.texture, t3.width, t3.height, r3, this.toEncoderType(e3), n3);
            return this.toTensorData(e3, i2);
          });
        }
        async readTextureAsync(t3, e3, n3) {
          const r3 = t3.tensor.dataId;
          if (n3 || (n3 = 1), this.pendingRead.has(r3)) {
            const t4 = this.pendingRead.get(r3);
            return new Promise((e4) => null == t4 ? void 0 : t4.push(e4));
          }
          return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
            this.pendingRead.set(r3, []);
            const i2 = t3.shape.reduce((t4, e4) => t4 * e4) * n3;
            await this.glContext.createAndWaitForFence();
            const o2 = this.glContext.readTexture(t3.texture, t3.width, t3.height, i2, this.toEncoderType(e3), n3), a2 = this.toTensorData(e3, o2), s2 = this.pendingRead.get(r3);
            return this.pendingRead.delete(r3), null == s2 || s2.forEach((t4) => t4(a2)), a2;
          });
        }
        readUint8TextureAsFloat(t3) {
          return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
            const e3 = t3.shape.reduce((t4, e4) => t4 * e4), n3 = this.glContext.readTexture(t3.texture, t3.width, t3.height, 4 * e3, "byte", 4);
            return new Float32Array(n3.buffer, n3.byteOffset, e3);
          });
        }
        releaseTexture(t3, e3) {
          let n3;
          if (this.config.reuseTextures && (n3 = this.textureLookup.get(t3.texture), n3)) {
            e3 && this.textureLookup.delete(n3);
            const r3 = this.inUseTextures.get(n3);
            if (r3) {
              const e4 = r3.indexOf(t3.texture);
              if (-1 !== e4) {
                r3.splice(e4, 1);
                let i2 = this.idleTextures.get(n3);
                i2 || (i2 = [], this.idleTextures.set(n3, i2)), i2.push(t3.texture);
              }
            }
          }
          n3 && !e3 || (r2.Logger.verbose("TextureManager", `Deleting texture of size ${t3.width}x${t3.height}`), this.glContext.deleteTexture(t3.texture));
        }
        toTensorData(t3, e3) {
          switch (t3) {
            case "int16":
              return e3 instanceof Int16Array ? e3 : Int16Array.from(e3);
            case "int32":
              return e3 instanceof Int32Array ? e3 : Int32Array.from(e3);
            case "int8":
              return e3 instanceof Int8Array ? e3 : Int8Array.from(e3);
            case "uint16":
              return e3 instanceof Uint16Array ? e3 : Uint16Array.from(e3);
            case "uint32":
              return e3 instanceof Uint32Array ? e3 : Uint32Array.from(e3);
            case "uint8":
            case "bool":
              return e3 instanceof Uint8Array ? e3 : Uint8Array.from(e3);
            case "float32":
              return e3 instanceof Float32Array ? e3 : Float32Array.from(e3);
            case "float64":
              return e3 instanceof Float64Array ? e3 : Float64Array.from(e3);
            default:
              throw new Error(`TensorData type ${t3} is not supported`);
          }
        }
        toTextureData(t3, e3) {
          if (e3) return e3 instanceof Float32Array ? e3 : new Float32Array(e3);
        }
        toEncoderType(t3) {
          return "float";
        }
        clearActiveTextures() {
          this.glContext.clearActiveTextures();
        }
      };
    }, 2039: (t2, e2) => {
      var n2;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TextureType = void 0, (n2 = e2.TextureType || (e2.TextureType = {}))[n2.unpacked = 0] = "unpacked", n2[n2.unpackedReversed = 1] = "unpackedReversed", n2[n2.packed = 2] = "packed", n2[n2.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n2[n2.packedLastDimension = 4] = "packedLastDimension";
    }, 9390: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getGlChannels = e2.getCoordsDataType = e2.getSqueezedParams = e2.squeezeInputShape = e2.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e2.generateShaderFuncNameFromInputSamplerName = e2.repeatedTry = e2.getPackedShape = void 0;
      const r2 = n2(2517);
      e2.getPackedShape = function(t3) {
        const e3 = t3.length;
        return t3.slice(0, e3 - 1).concat(t3[e3 - 1] / 4);
      }, e2.repeatedTry = async function(t3, e3 = (t4) => 0, n3) {
        return new Promise((r3, i2) => {
          let o2 = 0;
          const a2 = () => {
            if (t3()) return void r3();
            o2++;
            const s2 = e3(o2);
            null != n3 && o2 >= n3 ? i2() : setTimeout(a2, s2);
          };
          a2();
        });
      }, e2.generateShaderFuncNameFromInputSamplerName = function(t3) {
        return (0, r2.assert)(void 0 !== t3 && 0 !== t3.length, () => "empty string found for sampler name"), "get" + t3.charAt(0).toUpperCase() + t3.slice(1);
      }, e2.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t3) {
        return (0, r2.assert)(void 0 !== t3 && 0 !== t3.length, () => "empty string found for sampler name"), "get" + t3.charAt(0).toUpperCase() + t3.slice(1) + "AtOutCoords";
      }, e2.squeezeInputShape = function(t3, e3) {
        let n3 = JSON.parse(JSON.stringify(t3));
        return n3 = e3, n3;
      }, e2.getSqueezedParams = function(t3, e3) {
        return e3.map((e4) => t3[e4]).join(", ");
      }, e2.getCoordsDataType = function(t3) {
        if (t3 <= 1) return "int";
        if (2 === t3) return "ivec2";
        if (3 === t3) return "ivec3";
        if (4 === t3) return "ivec4";
        if (5 === t3) return "ivec5";
        if (6 === t3) return "ivec6";
        throw Error(`GPU for rank ${t3} is not yet supported`);
      }, e2.getGlChannels = function(t3 = 6) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t3);
      };
    }, 7305: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createNewWebGLContext = e2.createWebGLContext = void 0;
      const r2 = n2(6231), i2 = n2(1713), o2 = {};
      function a2(t3) {
        const e3 = function() {
          if ("undefined" == typeof document) {
            if ("undefined" == typeof OffscreenCanvas) throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
            return new OffscreenCanvas(1, 1);
          }
          const t4 = document.createElement("canvas");
          return t4.width = 1, t4.height = 1, t4;
        }();
        let n3;
        const o3 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
        if ((!t3 || "webgl2" === t3) && (n3 = e3.getContext("webgl2", o3), n3)) try {
          return new i2.WebGLContext(n3, 2);
        } catch (t4) {
          r2.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t4}`);
        }
        if ((!t3 || "webgl" === t3) && (n3 = e3.getContext("webgl", o3) || e3.getContext("experimental-webgl", o3), n3)) try {
          return new i2.WebGLContext(n3, 1);
        } catch (t4) {
          r2.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t4}`);
        }
        throw new Error("WebGL is not supported");
      }
      e2.createWebGLContext = function t3(e3) {
        let n3;
        e3 && "webgl2" !== e3 || !("webgl2" in o2) ? e3 && "webgl" !== e3 || !("webgl" in o2) || (n3 = o2.webgl) : n3 = o2.webgl2, n3 = n3 || a2(e3), e3 = e3 || 1 === n3.version ? "webgl" : "webgl2";
        const r3 = n3.gl;
        return o2[e3] = n3, r3.isContextLost() ? (delete o2[e3], t3(e3)) : (r3.disable(r3.DEPTH_TEST), r3.disable(r3.STENCIL_TEST), r3.disable(r3.BLEND), r3.disable(r3.DITHER), r3.disable(r3.POLYGON_OFFSET_FILL), r3.disable(r3.SAMPLE_COVERAGE), r3.enable(r3.SCISSOR_TEST), r3.enable(r3.CULL_FACE), r3.cullFace(r3.BACK), n3);
      }, e2.createNewWebGLContext = a2;
    }, 1713: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i3 = Object.getOwnPropertyDescriptor(e3, n3);
        i3 && !("get" in i3 ? !e3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i3);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i2 = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o2 = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i2(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLContext = e2.linearSearchLastTrue = void 0;
      const a2 = n2(1670), s2 = o2(n2(7769)), u2 = n2(9390);
      function c2(t3) {
        let e3 = 0;
        for (; e3 < t3.length && t3[e3](); ++e3) ;
        return e3 - 1;
      }
      e2.linearSearchLastTrue = c2, e2.WebGLContext = class {
        constructor(t3, e3) {
          this.frameBufferBound = false, this.itemsToPoll = [], this.gl = t3, this.version = e3, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
        }
        allocateTexture(t3, e3, n3, r3) {
          const i3 = this.gl, o3 = i3.createTexture();
          i3.bindTexture(i3.TEXTURE_2D, o3), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MIN_FILTER, i3.NEAREST), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MAG_FILTER, i3.NEAREST), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_S, i3.CLAMP_TO_EDGE), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_T, i3.CLAMP_TO_EDGE);
          const a3 = r3 ? n3.encode(r3, t3 * e3) : null;
          return i3.texImage2D(i3.TEXTURE_2D, 0, n3.internalFormat, t3, e3, 0, n3.format, n3.textureType, a3), this.checkError(), o3;
        }
        updateTexture(t3, e3, n3, r3, i3) {
          const o3 = this.gl;
          o3.bindTexture(o3.TEXTURE_2D, t3);
          const a3 = r3.encode(i3, e3 * n3);
          o3.texSubImage2D(o3.TEXTURE_2D, 0, 0, 0, e3, n3, r3.format, r3.textureType, a3), this.checkError();
        }
        attachFramebuffer(t3, e3, n3) {
          const r3 = this.gl;
          r3.bindTexture(r3.TEXTURE_2D, t3), r3.bindFramebuffer(r3.FRAMEBUFFER, this.framebuffer), r3.framebufferTexture2D(r3.FRAMEBUFFER, r3.COLOR_ATTACHMENT0, r3.TEXTURE_2D, t3, 0), this.checkError(), r3.viewport(0, 0, e3, n3), r3.scissor(0, 0, e3, n3);
        }
        readTexture(t3, e3, n3, r3, i3, o3) {
          const a3 = this.gl;
          o3 || (o3 = 1), this.frameBufferBound || this.attachFramebuffer(t3, e3, n3);
          const s3 = this.getEncoder(i3, o3), u3 = s3.allocate(e3 * n3);
          return a3.bindTexture(a3.TEXTURE_2D, t3), a3.framebufferTexture2D(a3.FRAMEBUFFER, a3.COLOR_ATTACHMENT0, a3.TEXTURE_2D, t3, 0), a3.readPixels(0, 0, e3, n3, a3.RGBA, s3.textureType, u3), this.checkError(), s3.decode(u3, r3);
        }
        isFramebufferReady() {
          return true;
        }
        getActiveTexture() {
          const t3 = this.gl;
          return "TEXTURE" + (t3.getParameter(this.gl.ACTIVE_TEXTURE) - t3.TEXTURE0);
        }
        getTextureBinding() {
          return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
        }
        getFramebufferBinding() {
          return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
        }
        setVertexAttributes(t3, e3) {
          const n3 = this.gl;
          n3.vertexAttribPointer(t3, 3, n3.FLOAT, false, 20, 0), n3.enableVertexAttribArray(t3), -1 !== e3 && (n3.vertexAttribPointer(e3, 2, n3.FLOAT, false, 20, 12), n3.enableVertexAttribArray(e3)), this.checkError();
        }
        createProgram(t3, e3) {
          const n3 = this.gl, r3 = n3.createProgram();
          return n3.attachShader(r3, t3), n3.attachShader(r3, e3), n3.linkProgram(r3), r3;
        }
        compileShader(t3, e3) {
          const n3 = this.gl, r3 = n3.createShader(e3);
          if (!r3) throw new Error(`createShader() returned null with type ${e3}`);
          if (n3.shaderSource(r3, t3), n3.compileShader(r3), false === n3.getShaderParameter(r3, n3.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n3.getShaderInfoLog(r3)}
Shader source:
${t3}`);
          return r3;
        }
        deleteShader(t3) {
          this.gl.deleteShader(t3);
        }
        bindTextureToUniform(t3, e3, n3) {
          const r3 = this.gl;
          r3.activeTexture(r3.TEXTURE0 + e3), this.checkError(), r3.bindTexture(r3.TEXTURE_2D, t3), this.checkError(), r3.uniform1i(n3, e3), this.checkError();
        }
        draw() {
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
        }
        checkError() {
          if (a2.env.debug) {
            const t3 = this.gl, e3 = t3.getError();
            let n3 = "";
            switch (e3) {
              case t3.NO_ERROR:
                return;
              case t3.INVALID_ENUM:
                n3 = "INVALID_ENUM";
                break;
              case t3.INVALID_VALUE:
                n3 = "INVALID_VALUE";
                break;
              case t3.INVALID_OPERATION:
                n3 = "INVALID_OPERATION";
                break;
              case t3.INVALID_FRAMEBUFFER_OPERATION:
                n3 = "INVALID_FRAMEBUFFER_OPERATION";
                break;
              case t3.OUT_OF_MEMORY:
                n3 = "OUT_OF_MEMORY";
                break;
              case t3.CONTEXT_LOST_WEBGL:
                n3 = "CONTEXT_LOST_WEBGL";
                break;
              default:
                n3 = `Unknown WebGL Error: ${e3.toString(16)}`;
            }
            throw new Error(n3);
          }
        }
        deleteTexture(t3) {
          this.gl.deleteTexture(t3);
        }
        deleteProgram(t3) {
          this.gl.deleteProgram(t3);
        }
        getEncoder(t3, e3, n3 = 0) {
          if (2 === this.version) return new s2.RedFloat32DataEncoder(this.gl, e3);
          switch (t3) {
            case "float":
              return 1 === n3 || this.isRenderFloat32Supported ? new s2.RGBAFloatDataEncoder(this.gl, e3) : new s2.RGBAFloatDataEncoder(this.gl, e3, this.textureHalfFloatExtension.HALF_FLOAT_OES);
            case "int":
              throw new Error("not implemented");
            case "byte":
              return new s2.Uint8DataEncoder(this.gl, e3);
            default:
              throw new Error(`Invalid dataType: ${t3}`);
          }
        }
        clearActiveTextures() {
          const t3 = this.gl;
          for (let e3 = 0; e3 < this.maxTextureImageUnits; ++e3) t3.activeTexture(t3.TEXTURE0 + e3), t3.bindTexture(t3.TEXTURE_2D, null);
        }
        dispose() {
          if (this.disposed) return;
          const t3 = this.gl;
          t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteFramebuffer(this.framebuffer), t3.bindBuffer(t3.ARRAY_BUFFER, null), t3.deleteBuffer(this.vertexbuffer), t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, null), t3.finish(), this.disposed = true;
        }
        createDefaultGeometry() {
          return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
        }
        createVertexbuffer() {
          const t3 = this.gl, e3 = t3.createBuffer();
          if (!e3) throw new Error("createBuffer() returned null");
          const n3 = this.createDefaultGeometry();
          return t3.bindBuffer(t3.ARRAY_BUFFER, e3), t3.bufferData(t3.ARRAY_BUFFER, n3, t3.STATIC_DRAW), this.checkError(), e3;
        }
        createFramebuffer() {
          const t3 = this.gl.createFramebuffer();
          if (!t3) throw new Error("createFramebuffer returned null");
          return t3;
        }
        queryVitalParameters() {
          const t3 = this.gl;
          if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error("both float32 and float16 TextureType are not supported");
          this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS), this.version;
        }
        getExtensions() {
          2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
        }
        checkFloatTextureAttachableToFrameBuffer() {
          const t3 = this.gl, e3 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e3);
          const n3 = 2 === this.version ? t3.RGBA32F : t3.RGBA;
          t3.texImage2D(t3.TEXTURE_2D, 0, n3, 1, 1, 0, t3.RGBA, t3.FLOAT, null);
          const r3 = t3.createFramebuffer();
          t3.bindFramebuffer(t3.FRAMEBUFFER, r3), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0);
          const i3 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
          return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(e3), t3.deleteFramebuffer(r3), i3;
        }
        checkRenderFloat32() {
          if (2 === this.version) {
            if (!this.colorBufferFloatExtension) return false;
          } else if (!this.textureFloatExtension) return false;
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Download() {
          if (2 === this.version) {
            if (!this.colorBufferFloatExtension) return false;
          } else {
            if (!this.textureFloatExtension) return false;
            if (!this.gl.getExtension("WEBGL_color_buffer_float")) return false;
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Blend() {
          const t3 = this.gl;
          let e3, n3, r3, i3, o3;
          try {
            e3 = t3.createTexture(), n3 = t3.createFramebuffer(), t3.bindTexture(t3.TEXTURE_2D, e3);
            const a3 = 2 === this.version ? t3.RGBA32F : t3.RGBA;
            return t3.texImage2D(t3.TEXTURE_2D, 0, a3, 1, 1, 0, t3.RGBA, t3.FLOAT, null), t3.bindFramebuffer(t3.FRAMEBUFFER, n3), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0), t3.enable(t3.BLEND), r3 = t3.createShader(t3.VERTEX_SHADER), !!r3 && (t3.shaderSource(r3, "void main(){}"), t3.compileShader(r3), i3 = t3.createShader(t3.FRAGMENT_SHADER), !!i3 && (t3.shaderSource(i3, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t3.compileShader(i3), o3 = t3.createProgram(), !!o3 && (t3.attachShader(o3, r3), t3.attachShader(o3, i3), t3.linkProgram(o3), t3.useProgram(o3), t3.drawArrays(t3.POINTS, 0, 1), t3.getError() === t3.NO_ERROR)));
          } finally {
            t3.disable(t3.BLEND), o3 && t3.deleteProgram(o3), r3 && t3.deleteShader(r3), i3 && t3.deleteShader(i3), n3 && (t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteFramebuffer(n3)), e3 && (t3.bindTexture(t3.TEXTURE_2D, null), t3.deleteTexture(e3));
          }
        }
        beginTimer() {
          if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
            const t3 = this.gl, e3 = this.disjointTimerQueryWebgl2Extension, n3 = t3.createQuery();
            return t3.beginQuery(e3.TIME_ELAPSED_EXT, n3), n3;
          }
          throw new Error("WebGL1 profiling currently not supported.");
        }
        endTimer() {
          if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
          {
            const t3 = this.gl, e3 = this.disjointTimerQueryWebgl2Extension;
            t3.endQuery(e3.TIME_ELAPSED_EXT);
          }
        }
        isTimerResultAvailable(t3) {
          let e3 = false, n3 = false;
          if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
          {
            const r3 = this.gl, i3 = this.disjointTimerQueryWebgl2Extension;
            e3 = r3.getQueryParameter(t3, r3.QUERY_RESULT_AVAILABLE), n3 = r3.getParameter(i3.GPU_DISJOINT_EXT);
          }
          return e3 && !n3;
        }
        getTimerResult(t3) {
          let e3 = 0;
          if (2 !== this.version) throw new Error("WebGL1 profiling currently not supported");
          {
            const n3 = this.gl;
            e3 = n3.getQueryParameter(t3, n3.QUERY_RESULT), n3.deleteQuery(t3);
          }
          return e3 / 1e6;
        }
        async waitForQueryAndGetTime(t3) {
          return await (0, u2.repeatedTry)(() => this.isTimerResultAvailable(t3)), this.getTimerResult(t3);
        }
        async createAndWaitForFence() {
          const t3 = this.createFence(this.gl);
          return this.pollFence(t3);
        }
        createFence(t3) {
          let e3;
          const n3 = t3, r3 = n3.fenceSync(n3.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return t3.flush(), e3 = null === r3 ? () => true : () => {
            const t4 = n3.clientWaitSync(r3, 0, 0);
            return t4 === n3.ALREADY_SIGNALED || t4 === n3.CONDITION_SATISFIED;
          }, { query: r3, isFencePassed: e3 };
        }
        async pollFence(t3) {
          return new Promise((e3) => {
            this.addItemToPoll(() => t3.isFencePassed(), () => e3());
          });
        }
        pollItems() {
          const t3 = c2(this.itemsToPoll.map((t4) => t4.isDoneFn));
          for (let e3 = 0; e3 <= t3; ++e3) {
            const { resolveFn: t4 } = this.itemsToPoll[e3];
            t4();
          }
          this.itemsToPoll = this.itemsToPoll.slice(t3 + 1);
        }
        async addItemToPoll(t3, e3) {
          this.itemsToPoll.push({ isDoneFn: t3, resolveFn: e3 }), this.itemsToPoll.length > 1 || await (0, u2.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
        }
      };
    }, 1036: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ExecutionPlan = void 0;
      const r2 = n2(6231);
      class i2 {
        constructor(t3, e3) {
          this.op = t3, this.node = e3;
        }
      }
      e2.ExecutionPlan = class {
        constructor(t3, e3, n3) {
          this.graph = t3, this.profiler = n3, this.initialize(e3);
        }
        initialize(t3) {
          this.profiler.event("session", "ExecutionPlan.initialize", () => {
            const e3 = this.graph.getNodes();
            if (e3.length !== t3.length) throw new Error("The size of nodes and OPs do not match.");
            this._ops = t3.map((t4, n3) => new i2(t4, e3[n3])), this.reset(), this._starter = [], this._ops.forEach((t4, e4) => {
              let n3 = true;
              for (const e5 of t4.node.inputs) if (!this._values[e5] && -1 === this.graph.getInputIndices().indexOf(e5)) {
                n3 = false;
                break;
              }
              n3 && this._starter.push(e4);
            });
          });
        }
        reset() {
          this._values = this.graph.getValues().map((t3) => t3.tensor);
        }
        async execute(t3, e3) {
          return this.profiler.event("session", "ExecutionPlan.execute", async () => {
            this.reset();
            const n3 = t3.createInferenceHandler(), i3 = this.graph.getInputIndices();
            if (e3.length !== i3.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e3.length} expected: ${i3.length}`);
            e3.forEach((t4, e4) => {
              const n4 = i3[e4];
              this._values[n4] = t4;
            });
            const o2 = this._starter.slice(0), a2 = this.graph.getValues(), s2 = this.graph.getNodes();
            let u2 = 0;
            for (; u2 < o2.length; ) {
              const t4 = o2[u2++], e4 = this._ops[t4], i4 = e4.node.inputs.map((t5) => this._values[t5]);
              if (-1 !== i4.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${e4.node}`);
              const c3 = i4;
              r2.Logger.verbose("ExecPlan", `Runing op:${e4.node.name} (${c3.map((t5, n4) => `'${e4.node.inputs[n4]}': ${t5.type}[${t5.dims.join(",")}]`).join(", ")})`);
              const l2 = await this.profiler.event("node", e4.node.name, async () => e4.op.impl(n3, c3, e4.op.context));
              if (l2.length !== e4.node.outputs.length) throw new Error("the size of output does not match model definition.");
              l2.forEach((t5, n4) => {
                const r3 = e4.node.outputs[n4];
                if (this._values[r3]) throw new Error(`output [${r3}] already has value: op:${e4.node.name}`);
                this._values[r3] = t5;
              });
              const p2 = /* @__PURE__ */ new Set();
              l2.forEach((t5, n4) => {
                const r3 = e4.node.outputs[n4];
                for (const t6 of a2[r3].to) {
                  const e5 = s2[t6];
                  let n5 = true;
                  for (const t7 of e5.inputs) if (!this._values[t7]) {
                    n5 = false;
                    break;
                  }
                  n5 && p2.add(t6);
                }
              }), o2.push(...p2);
            }
            const c2 = [];
            for (let t4 = 0; t4 < this.graph.getOutputIndices().length; t4++) {
              const e4 = this.graph.getOutputIndices()[t4], n4 = this._values[e4];
              if (void 0 === n4) throw new Error(`required output [${e4}] does not have value`);
              0 === e4 ? await n4.getData() : n4.data, c2.push(n4);
            }
            return r2.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n3.dispose(), c2;
          });
        }
      };
    }, 7070: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Graph = void 0;
      const r2 = n2(1446), i2 = n2(7778), o2 = n2(9395), a2 = n2(9162), s2 = n2(2517);
      var u2 = o2.onnxruntime.experimental.fbs;
      e2.Graph = { from: (t3, e3) => new p2(t3, e3) };
      class c2 {
        constructor(t3) {
          this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t3 && (this.type = s2.ProtoUtil.tensorValueTypeFromProto(t3.type.tensorType));
        }
        get from() {
          return this._from;
        }
        get to() {
          return this._to;
        }
      }
      class l2 {
        constructor(t3, e3) {
          t3 instanceof r2.onnx.NodeProto ? (this.name = t3.name, this.opType = t3.opType, this.attributes = new i2.Attribute(t3.attribute)) : t3 instanceof u2.Node && (this.name = null != e3 ? e3 : t3.name(), this.opType = t3.opType(), this.attributes = new i2.Attribute(s2.ProtoUtil.tensorAttributesFromORTFormat(t3))), this.inputs = [], this.outputs = [], this.executeNode = true;
        }
      }
      class p2 {
        constructor(t3, e3) {
          if (!t3) throw new TypeError("graph is empty");
          this.buildGraph(t3), this.transformGraph(e3), this.checkIsAcyclic();
        }
        getInputIndices() {
          return this._allInputIndices;
        }
        getInputNames() {
          return this._allInputNames;
        }
        getOutputIndices() {
          return this._allOutputIndices;
        }
        getOutputNames() {
          return this._allOutputNames;
        }
        getValues() {
          return this._allData;
        }
        getNodes() {
          return this._nodes;
        }
        buildGraph(t3) {
          if (t3 instanceof r2.onnx.GraphProto) this.buildGraphFromOnnxFormat(t3);
          else {
            if (!(t3 instanceof u2.Graph)) throw new TypeError("Graph type is not supported.");
            this.buildGraphFromOrtFormat(t3);
          }
        }
        buildGraphFromOnnxFormat(t3) {
          const e3 = /* @__PURE__ */ new Map();
          this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
          const n3 = /* @__PURE__ */ new Map();
          if (!t3.input) throw new Error("missing information in graph: input");
          const r3 = [];
          for (const n4 of t3.input) {
            if (e3.has(n4.name)) throw new Error(`duplicated input name: ${n4.name}`);
            const t4 = this._allData.push(new c2(n4)) - 1;
            e3.set(n4.name, t4), r3.push(n4.name);
          }
          if (!t3.initializer) throw new Error("missing information in graph: initializer");
          for (const n4 of t3.initializer) {
            let t4 = e3.get(n4.name);
            if (void 0 === t4) {
              const r4 = new c2();
              r4.type = { shape: { dims: s2.ProtoUtil.tensorDimsFromProto(n4.dims) }, tensorType: s2.ProtoUtil.tensorDataTypeFromProto(n4.dataType) }, t4 = this._allData.push(r4) - 1, e3.set(n4.name, t4);
            }
            this._allData[t4]._from = -1, this._allData[t4].tensor = a2.Tensor.fromProto(n4);
          }
          for (let t4 = 0; t4 < this._allData.length; t4++) this._allData[t4].tensor || (this._allInputIndices.push(t4), this._allInputNames.push(r3[t4]));
          if (!t3.output) throw new Error("missing information in graph: output");
          for (const n4 of t3.output) {
            if (e3.has(n4.name)) throw new Error(`duplicated output name: ${n4.name}`);
            const t4 = this._allData.push(new c2(n4)) - 1;
            e3.set(n4.name, t4), this._allOutputIndices.push(t4), this._allOutputNames.push(n4.name);
          }
          if (!t3.node) throw new Error("missing information in graph: node");
          for (const e4 of t3.node) {
            if (!e4.name) for (let t5 = 0; ; t5++) {
              const r4 = `unnamed_${e4.opType}_${t5}`;
              if (!n3.has(r4)) {
                e4.name = r4;
                break;
              }
            }
            if (n3.has(e4.name)) throw new Error(`duplicated node name: ${e4.name}`);
            const t4 = this._nodes.push(new l2(e4)) - 1;
            n3.set(e4.name, t4);
          }
          for (let n4 = 0; n4 < this._nodes.length; n4++) {
            const r4 = this._nodes[n4], i3 = t3.node[n4];
            if (!i3.output) throw new Error(`missing output for node: ${i3.name}`);
            for (const t4 of i3.output) {
              let o3 = e3.get(t4);
              if (void 0 === o3 && (o3 = this._allData.push(new c2()) - 1, e3.set(t4, o3)), r4.outputs.push(o3), void 0 !== this._allData[o3]._from) throw new Error(`multiple nodes output to one data value: ${o3}`);
              if (this._allData[o3]._from = n4, "Constant" === i3.opType) {
                if (!i3.attribute || 1 !== i3.attribute.length || !i3.attribute[0].t) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                if (!i3.output || 1 !== i3.output.length) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                r4.outputs.pop(), r4.executeNode = false, this._allData[o3]._from = -1, this._allData[o3].tensor = a2.Tensor.fromProto(i3.attribute[0].t);
              }
            }
          }
          for (let n4 = 0; n4 < this._nodes.length; n4++) {
            const r4 = this._nodes[n4], i3 = t3.node[n4];
            if (!i3.input) throw new Error(`missing input for node: ${i3.name}`);
            for (const t4 of i3.input) {
              const o3 = e3.get(t4);
              if (void 0 === o3) {
                if ("" === t4 && 3 === i3.input.length && "Resize" === i3.opType) continue;
                throw new Error(`unrecognized input '${t4}' for node: ${i3.name}`);
              }
              r4.inputs.push(o3), this._allData[o3]._to.push(n4);
            }
          }
          return true;
        }
        buildGraphFromOrtFormat(t3) {
          var e3, n3, r3;
          const i3 = /* @__PURE__ */ new Map();
          this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
          const o3 = /* @__PURE__ */ new Map(), p3 = [];
          for (let o4 = 0; o4 < t3.inputsLength(); o4++) {
            const a3 = t3.inputs(o4);
            if (i3.has(a3)) throw new Error(`duplicated input name: ${a3}`);
            for (let o5 = 0; o5 < t3.nodeArgsLength(); o5++) if ((null === (e3 = t3.nodeArgs(o5)) || void 0 === e3 ? void 0 : e3.name()) === a3) {
              const e4 = new c2();
              if ((null === (r3 = null === (n3 = t3.nodeArgs(o5)) || void 0 === n3 ? void 0 : n3.type()) || void 0 === r3 ? void 0 : r3.valueType()) !== u2.TypeInfoValue.tensor_type) throw new Error("Unexpected value type for the nodeArg.");
              const l3 = t3.nodeArgs(o5).type().value(new u2.TensorTypeAndShape()), f2 = s2.ProtoUtil.tensorDataTypeFromProto(l3.elemType()), d2 = l3.shape(), h2 = [];
              for (let t4 = 0; t4 < d2.dimLength(); t4++) h2.push(s2.LongUtil.longToNumber(d2.dim(t4).value().dimValue()));
              e4.type = { shape: { dims: h2 }, tensorType: f2 };
              const g2 = this._allData.push(e4) - 1;
              i3.set(a3, g2), p3.push(a3);
            }
          }
          for (let e4 = 0; e4 < t3.initializersLength(); e4++) {
            const n4 = t3.initializers(e4);
            let r4 = i3.get(n4.name());
            if (void 0 === r4) {
              const t4 = new c2(), e5 = s2.ProtoUtil.tensorDimsFromORTFormat(n4), o4 = s2.ProtoUtil.tensorDataTypeFromProto(n4.dataType());
              t4.type = { shape: { dims: e5 }, tensorType: o4 }, r4 = this._allData.push(t4) - 1, i3.set(n4.name(), r4);
            }
            this._allData[r4]._from = -1, this._allData[r4].tensor = a2.Tensor.fromOrtTensor(n4);
          }
          for (let t4 = 0; t4 < this._allData.length; t4++) this._allData[t4].tensor || (this._allInputIndices.push(t4), this._allInputNames.push(p3[t4]));
          for (let e4 = 0; e4 < t3.outputsLength(); e4++) {
            const n4 = t3.outputs(e4);
            if (i3.has(n4)) throw new Error(`duplicated output name: ${n4}`);
            const r4 = this._allData.push(new c2()) - 1;
            i3.set(n4, r4), this._allOutputIndices.push(r4), this._allOutputNames.push(n4);
          }
          if (!t3.nodes) throw new Error("missing information in graph: node");
          for (let e4 = 0; e4 < t3.nodesLength(); e4++) {
            const n4 = t3.nodes(e4);
            let r4 = n4.name();
            if (!r4) for (let t4 = 0; r4 = `unnamed_${n4.opType()}_${t4}`, o3.has(r4); t4++) ;
            if (o3.has(r4)) throw new Error(`duplicated node name: ${r4}`);
            const i4 = this._nodes.push(new l2(n4, r4)) - 1;
            o3.set(r4, i4);
          }
          for (let e4 = 0; e4 < this._nodes.length; e4++) {
            const n4 = this._nodes[e4], r4 = t3.nodes(e4);
            if (null == r4) throw new Error(`No node exists at index ${e4}`);
            if (0 === (null == r4 ? void 0 : r4.outputsLength())) throw new Error(`missing output for node: ${r4.name}`);
            for (let t4 = 0; t4 < (null == r4 ? void 0 : r4.outputsLength()); t4++) {
              const o4 = null == r4 ? void 0 : r4.outputs(t4);
              let s3 = i3.get(o4);
              if (void 0 === s3 && (s3 = this._allData.push(new c2()) - 1, i3.set(o4, s3)), n4.outputs.push(s3), void 0 !== this._allData[s3]._from) throw new Error(`multiple nodes output to one data value: ${s3}`);
              if (this._allData[s3]._from = e4, "Constant" === r4.opType()) {
                if (1 !== r4.attributesLength() || !r4.attributes(0).t()) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                if (1 !== r4.outputsLength()) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                n4.outputs.pop(), n4.executeNode = false, this._allData[s3]._from = -1, this._allData[s3].tensor = a2.Tensor.fromOrtTensor(r4.attributes(0).t());
              }
            }
          }
          for (let e4 = 0; e4 < this._nodes.length; e4++) {
            const n4 = this._nodes[e4], r4 = t3.nodes(e4);
            if (0 === r4.inputsLength()) throw new Error(`missing input for node: ${r4.name}`);
            for (let t4 = 0; t4 < r4.inputsLength(); t4++) {
              const o4 = r4.inputs(t4), a3 = i3.get(o4);
              if (void 0 === a3) throw new Error(`unrecognized input '${o4}' for node: ${r4.name()}`);
              n4.inputs.push(a3), this._allData[a3]._to.push(e4);
            }
          }
        }
        checkIsAcyclic() {
          const t3 = /* @__PURE__ */ new Set();
          this._allInputIndices.forEach((e4) => {
            this._allData[e4]._to.forEach((e5) => {
              t3.add(e5);
            });
          });
          const e3 = Array.from(t3), n3 = new Array(this._nodes.length).fill("white");
          for (; e3.length > 0; ) {
            const t4 = e3.pop();
            "gray" === n3[t4] ? n3[t4] = "black" : (e3.push(t4), n3[t4] = "gray", this._nodes[t4].outputs.forEach((r3) => {
              const i3 = this._allData[r3];
              if (void 0 !== i3.tensor) throw new Error("node outputs should not be initialized");
              if (i3._from !== t4) throw new Error("from property of the Value object doesn't match index of Node being processed");
              i3._to.forEach((t5) => {
                if ("gray" === n3[t5]) throw new Error("model graph is cyclic");
                "white" === n3[t5] && e3.push(t5);
              });
            }));
          }
        }
        transformGraph(t3) {
          this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t3 && t3.transformGraph(this), this.finalizeGraph();
        }
        finalizeGraph() {
          let t3 = 0;
          for (let e3 = 0; e3 < this._nodes.length; e3++) this._nodes[e3].executeNode ? t3 > 0 && (this._nodes[e3].inputs.forEach((n3) => {
            const r3 = this._allData[n3]._to.indexOf(e3 + t3);
            -1 !== r3 && (this._allData[n3]._to[r3] = e3);
          }), this._nodes[e3].outputs.forEach((n3) => {
            this._allData[n3]._from && this._allData[n3]._from === e3 + t3 && (this._allData[n3]._from = e3);
          })) : (t3++, this._nodes[e3].outputs.forEach((t4) => {
            this._allData[t4]._from = -2;
          }), this._nodes.splice(e3, 1), e3--);
          t3 = 0;
          for (let e3 = 0; e3 < this._allData.length; e3++) if (-2 !== this._allData[e3].from || -1 !== this._allOutputIndices.indexOf(e3 + t3)) {
            if (t3 > 0) {
              let n3 = -1;
              void 0 !== this._allData[e3].from && -1 !== this._allData[e3].from ? (n3 = this._nodes[this._allData[e3].from].outputs.indexOf(e3 + t3), -1 !== n3 && (this._nodes[this._allData[e3].from].outputs[n3] = e3)) : (n3 = this._allInputIndices.indexOf(e3 + t3), -1 !== n3 && (this._allInputIndices[n3] = e3)), this._allData[e3].to.forEach((r3) => {
                n3 = this._nodes[r3].inputs.indexOf(e3 + t3), -1 !== n3 && (this._nodes[r3].inputs[n3] = e3);
              }), 0 === this._allData[e3].to.length && (n3 = this._allOutputIndices.indexOf(e3 + t3), -1 !== n3 && (this._allOutputIndices[n3] = e3));
            }
          } else t3++, this._allData.splice(e3, 1), e3--;
        }
        deleteNode(t3) {
          const e3 = this._nodes[t3];
          if (e3.outputs.length > 1) {
            for (let t4 = 1; t4 < e3.outputs.length; t4++) if (this._allData[e3.outputs[t4]].to.length > 0) throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
          }
          e3.executeNode = false;
          const n3 = e3.inputs[0], r3 = e3.outputs[0], i3 = this._allData[r3].to, o3 = this._allData[n3].to.indexOf(t3);
          if (-1 === o3) throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
          this._allData[n3].to.splice(o3, 1), this._allData[r3]._to = [];
          const a3 = this._allOutputIndices.indexOf(r3);
          if (-1 !== a3 && (this._allOutputIndices[a3] = n3), i3 && i3.length > 0) for (const t4 of i3) {
            const e4 = this._nodes[t4].inputs.indexOf(r3);
            if (-1 === e4) throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
            this._nodes[t4].inputs[e4] = n3, this._allData[n3].to.push(t4);
          }
        }
        removeAllDropoutNodes() {
          let t3 = 0;
          for (const e3 of this._nodes) {
            if ("Dropout" === e3.opType) {
              if (1 !== e3.inputs.length) throw new Error("Dropout nodes should only contain one input. ");
              if (1 !== e3.outputs.length && 2 !== e3.outputs.length) throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
              if (2 === e3.outputs.length && 0 !== this._allData[e3.outputs[1]]._to.length) throw new Error("Dropout nodes's second output should not be referenced by other nodes");
              this.deleteNode(t3);
            }
            t3++;
          }
        }
        removeAllIdentityNodes() {
          let t3 = 0;
          for (const e3 of this._nodes) "Identity" === e3.opType && this.deleteNode(t3), t3++;
        }
        isActivation(t3) {
          switch (t3.opType) {
            case "Relu":
            case "Sigmoid":
            case "Clip":
              return true;
            default:
              return false;
          }
        }
        fuseConvActivationNodes() {
          for (const t3 of this._nodes) if ("Conv" === t3.opType) {
            const e3 = this._allData[t3.outputs[0]]._to;
            if (1 === e3.length && this.isActivation(this._nodes[e3[0]])) {
              const n3 = this._nodes[e3[0]];
              if ("Clip" === n3.opType) if (1 === n3.inputs.length) try {
                t3.attributes.set("activation_params", "floats", [n3.attributes.getFloat("min"), n3.attributes.getFloat("max")]);
              } catch (e4) {
                t3.attributes.set("activation_params", "floats", [s2.MIN_CLIP, s2.MAX_CLIP]);
              }
              else {
                if (!(n3.inputs.length >= 3 && void 0 !== this._allData[n3.inputs[1]].tensor && void 0 !== this._allData[n3.inputs[2]].tensor)) continue;
                t3.attributes.set("activation_params", "floats", [this._allData[n3.inputs[1]].tensor.floatData[0], this._allData[n3.inputs[2]].tensor.floatData[0]]);
              }
              t3.attributes.set("activation", "string", n3.opType), this.deleteNode(e3[0]);
            }
          }
        }
      }
    }, 6231: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.now = e2.Profiler = e2.Logger = void 0;
      const n2 = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r2 = { none: new class {
        log(t3, e3, n3) {
        }
      }(), console: new class {
        log(t3, e3, n3) {
          console.log(`${this.color(t3)} ${n3 ? "\x1B[35m" + n3 + "\x1B[0m " : ""}${e3}`);
        }
        color(t3) {
          switch (t3) {
            case "verbose":
              return "\x1B[34;40mv\x1B[0m";
            case "info":
              return "\x1B[32mi\x1B[0m";
            case "warning":
              return "\x1B[30;43mw\x1B[0m";
            case "error":
              return "\x1B[31;40me\x1B[0m";
            case "fatal":
              return "\x1B[101mf\x1B[0m";
            default:
              throw new Error(`unsupported severity: ${t3}`);
          }
        }
      }() }, i2 = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
      let o2 = { "": i2 };
      function a2(t3, e3, n3, r3) {
        if (void 0 === e3) return i3 = t3, { verbose: a2.verbose.bind(null, i3), info: a2.info.bind(null, i3), warning: a2.warning.bind(null, i3), error: a2.error.bind(null, i3), fatal: a2.fatal.bind(null, i3) };
        if (void 0 === n3) s2(t3, e3);
        else if ("number" == typeof n3 && void 0 === r3) s2(t3, e3);
        else if ("string" == typeof n3 && void 0 === r3) s2(t3, n3, 0, e3);
        else {
          if ("string" != typeof n3 || "number" != typeof r3) throw new TypeError("input is valid");
          s2(t3, n3, 0, e3);
        }
        var i3;
      }
      function s2(t3, e3, i3, a3) {
        const s3 = o2[a3 || ""] || o2[""];
        n2[t3] < n2[s3.minimalSeverity] || (s3.logDateTime && (e3 = `${(/* @__PURE__ */ new Date()).toISOString()}|${e3}`), s3.logSourceLocation, r2[s3.provider].log(t3, e3, a3));
      }
      !function(t3) {
        function e3(t4) {
          o2 = {}, n3("", t4 || {});
        }
        function n3(t4, n4) {
          if ("*" === t4) e3(n4);
          else {
            const e4 = o2[t4] || i2;
            o2[t4] = { provider: n4.provider || e4.provider, minimalSeverity: n4.minimalSeverity || e4.minimalSeverity, logDateTime: void 0 === n4.logDateTime ? e4.logDateTime : n4.logDateTime, logSourceLocation: void 0 === n4.logSourceLocation ? e4.logSourceLocation : n4.logSourceLocation };
          }
        }
        t3.verbose = function(e4, n4) {
          t3("verbose", e4, n4);
        }, t3.info = function(e4, n4) {
          t3("info", e4, n4);
        }, t3.warning = function(e4, n4) {
          t3("warning", e4, n4);
        }, t3.error = function(e4, n4) {
          t3("error", e4, n4);
        }, t3.fatal = function(e4, n4) {
          t3("fatal", e4, n4);
        }, t3.reset = e3, t3.set = n3, t3.setWithEnv = function(t4) {
          const e4 = {};
          t4.logLevel && (e4.minimalSeverity = t4.logLevel), n3("", e4);
        };
      }(a2), e2.Logger = a2;
      class u2 {
        constructor(t3, e3, n3, r3, i3, o3) {
          this.category = t3, this.name = e3, this.startTime = n3, this.endCallback = r3, this.timer = i3, this.ctx = o3;
        }
        end() {
          return this.endCallback(this);
        }
        async checkTimer() {
          if (void 0 === this.ctx || void 0 === this.timer) throw new Error("No webgl timer found");
          return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
        }
      }
      class c2 {
        constructor(t3, e3, n3, r3) {
          this.category = t3, this.name = e3, this.startTime = n3, this.endTime = r3;
        }
      }
      e2.Profiler = class {
        static create(t3) {
          return void 0 === t3 ? new this() : new this(t3.maxNumberEvents, t3.flushBatchSize, t3.flushIntervalInMilliseconds);
        }
        constructor(t3, e3, n3) {
          this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === t3 ? 1e4 : t3, this._flushBatchSize = void 0 === e3 ? 10 : e3, this._flushIntervalInMilliseconds = void 0 === n3 ? 5e3 : n3;
        }
        start() {
          this._started = true, this._timingEvents = [], this._flushTime = (0, e2.now)(), this._flushPointer = 0;
        }
        stop() {
          for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
        event(t3, e3, n3, r3) {
          const i3 = this._started ? this.begin(t3, e3, r3) : void 0;
          let o3 = false;
          const a3 = n3();
          if (a3 && "function" == typeof a3.then) return o3 = true, new Promise((t4, e4) => {
            a3.then(async (e5) => {
              i3 && await i3.end(), t4(e5);
            }, async (t5) => {
              i3 && await i3.end(), e4(t5);
            });
          });
          if (!o3 && i3) {
            const t4 = i3.end();
            if (t4 && "function" == typeof t4.then) return new Promise((e4, n4) => {
              t4.then(() => {
                e4(a3);
              }, (t5) => {
                n4(t5);
              });
            });
          }
          return a3;
        }
        begin(t3, n3, r3) {
          if (!this._started) throw new Error("profiler is not started yet");
          if (void 0 === r3) {
            const r4 = (0, e2.now)();
            return this.flush(r4), new u2(t3, n3, r4, (t4) => this.endSync(t4));
          }
          {
            const e3 = r3.beginTimer();
            return new u2(t3, n3, 0, async (t4) => this.end(t4), e3, r3);
          }
        }
        async end(t3) {
          const e3 = await t3.checkTimer();
          this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c2(t3.category, t3.name, t3.startTime, e3)), this.flush(e3));
        }
        endSync(t3) {
          const n3 = (0, e2.now)();
          this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c2(t3.category, t3.name, t3.startTime, n3)), this.flush(n3));
        }
        logOneEvent(t3) {
          e2.Logger.verbose(`Profiler.${t3.category}`, `${(t3.endTime - t3.startTime).toFixed(2)}ms on event '${t3.name}' at ${t3.endTime.toFixed(2)}`);
        }
        flush(t3) {
          if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t3 - this._flushTime >= this._flushIntervalInMilliseconds) {
            for (const t4 = this._flushPointer; this._flushPointer < t4 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
            this._flushTime = (0, e2.now)();
          }
        }
        get started() {
          return this._started;
        }
      }, e2.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
    }, 2644: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Model = void 0;
      const r2 = n2(5686), i2 = n2(1446), o2 = n2(7070), a2 = n2(9395), s2 = n2(2517);
      var u2 = a2.onnxruntime.experimental.fbs;
      e2.Model = class {
        constructor() {
        }
        load(t3, e3, n3) {
          if (!n3) try {
            return void this.loadFromOnnxFormat(t3, e3);
          } catch (t4) {
            if (void 0 !== n3) throw t4;
          }
          this.loadFromOrtFormat(t3, e3);
        }
        loadFromOnnxFormat(t3, e3) {
          const n3 = i2.onnx.ModelProto.decode(t3);
          if (s2.LongUtil.longToNumber(n3.irVersion) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
          this._opsets = n3.opsetImport.map((t4) => ({ domain: t4.domain, version: s2.LongUtil.longToNumber(t4.version) })), this._graph = o2.Graph.from(n3.graph, e3);
        }
        loadFromOrtFormat(t3, e3) {
          const n3 = new r2.flatbuffers.ByteBuffer(t3), i3 = u2.InferenceSession.getRootAsInferenceSession(n3).model();
          if (s2.LongUtil.longToNumber(i3.irVersion()) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
          this._opsets = [];
          for (let t4 = 0; t4 < i3.opsetImportLength(); t4++) {
            const e4 = i3.opsetImport(t4);
            this._opsets.push({ domain: null == e4 ? void 0 : e4.domain(), version: s2.LongUtil.longToNumber(e4.version()) });
          }
          this._graph = o2.Graph.from(i3.graph(), e3);
        }
        get graph() {
          return this._graph;
        }
        get opsets() {
          return this._opsets;
        }
      };
    }, 782: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.FLOAT_TYPES = e2.INT_TYPES = e2.NUMBER_TYPES = void 0, e2.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], e2.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], e2.FLOAT_TYPES = ["float32", "float64"];
    }, 1047: (t2, e2) => {
      function n2(t3, e3) {
        if (e3.endsWith("+")) {
          const n3 = Number.parseInt(e3.substring(0, e3.length - 1), 10);
          return !isNaN(n3) && n3 <= t3;
        }
        if (2 === e3.split("-").length) {
          const n3 = e3.split("-"), r2 = Number.parseInt(n3[0], 10), i2 = Number.parseInt(n3[1], 10);
          return !isNaN(r2) && !isNaN(i2) && r2 <= t3 && t3 <= i2;
        }
        return Number.parseInt(e3, 10) === t3;
      }
      Object.defineProperty(e2, "__esModule", { value: true }), e2.resolveOperator = void 0, e2.resolveOperator = function(t3, e3, r2) {
        for (const i2 of r2) {
          const r3 = i2[0], o2 = i2[1], a2 = i2[2], s2 = i2[3], u2 = i2[4];
          if (t3.opType === r3) {
            for (const t4 of e3) if ((t4.domain === o2 || "ai.onnx" === t4.domain && "" === o2) && n2(t4.version, a2)) return { opImpl: s2, opInit: u2 };
          }
        }
        throw new TypeError(`cannot resolve operator '${t3.opType}' with opsets: ${e3.map((t4) => `${t4.domain || "ai.onnx"} v${t4.version}`).join(", ")}`);
      };
    }, 9395: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.onnxruntime = void 0;
      const r2 = n2(5686);
      var i2, o2;
      i2 = e2.onnxruntime || (e2.onnxruntime = {}), function(t3) {
        !function(t4) {
          t4[t4.UNDEFINED = 0] = "UNDEFINED", t4[t4.FLOAT = 1] = "FLOAT", t4[t4.INT = 2] = "INT", t4[t4.STRING = 3] = "STRING", t4[t4.TENSOR = 4] = "TENSOR", t4[t4.GRAPH = 5] = "GRAPH", t4[t4.FLOATS = 6] = "FLOATS", t4[t4.INTS = 7] = "INTS", t4[t4.STRINGS = 8] = "STRINGS", t4[t4.TENSORS = 9] = "TENSORS", t4[t4.GRAPHS = 10] = "GRAPHS", t4[t4.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", t4[t4.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
        }(t3.AttributeType || (t3.AttributeType = {}));
      }((o2 = i2.experimental || (i2.experimental = {})).fbs || (o2.fbs = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.UNKNOWN = 0] = "UNKNOWN", t6[t6.VALUE = 1] = "VALUE", t6[t6.PARAM = 2] = "PARAM";
            }(t5.DimensionValueType || (t5.DimensionValueType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.UNDEFINED = 0] = "UNDEFINED", t6[t6.FLOAT = 1] = "FLOAT", t6[t6.UINT8 = 2] = "UINT8", t6[t6.INT8 = 3] = "INT8", t6[t6.UINT16 = 4] = "UINT16", t6[t6.INT16 = 5] = "INT16", t6[t6.INT32 = 6] = "INT32", t6[t6.INT64 = 7] = "INT64", t6[t6.STRING = 8] = "STRING", t6[t6.BOOL = 9] = "BOOL", t6[t6.FLOAT16 = 10] = "FLOAT16", t6[t6.DOUBLE = 11] = "DOUBLE", t6[t6.UINT32 = 12] = "UINT32", t6[t6.UINT64 = 13] = "UINT64", t6[t6.COMPLEX64 = 14] = "COMPLEX64", t6[t6.COMPLEX128 = 15] = "COMPLEX128", t6[t6.BFLOAT16 = 16] = "BFLOAT16";
            }(t5.TensorDataType || (t5.TensorDataType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.Primitive = 0] = "Primitive", t6[t6.Fused = 1] = "Fused";
            }(t5.NodeType || (t5.NodeType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.NONE = 0] = "NONE", t6[t6.tensor_type = 1] = "tensor_type", t6[t6.sequence_type = 2] = "sequence_type", t6[t6.map_type = 3] = "map_type";
            }(t5.TypeInfoValue || (t5.TypeInfoValue = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsShape(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsShape(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              dim(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 4);
                return r3 ? (n4 || new t3.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              dimLength() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startShape(t4) {
                t4.startObject(1);
              }
              static addDim(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static createDimVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startDimVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endShape(t4) {
                return t4.endObject();
              }
              static createShape(t4, e5) {
                return n3.startShape(t4), n3.addDim(t4, e5), n3.endShape(t4);
              }
            }
            e4.Shape = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsDimension(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsDimension(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              value(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              denotation(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startDimension(t4) {
                t4.startObject(2);
              }
              static addValue(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDenotation(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endDimension(t4) {
                return t4.endObject();
              }
              static createDimension(t4, e5, r3) {
                return n3.startDimension(t4), n3.addValue(t4, e5), n3.addDenotation(t4, r3), n3.endDimension(t4);
              }
            }
            e4.Dimension = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsDimensionValue(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsDimensionValue(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              dimType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt8(this.bb_pos + e5) : t3.experimental.fbs.DimensionValueType.UNKNOWN;
              }
              dimValue() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              dimParam(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startDimensionValue(t4) {
                t4.startObject(3);
              }
              static addDimType(e5, n4) {
                e5.addFieldInt8(0, n4, t3.experimental.fbs.DimensionValueType.UNKNOWN);
              }
              static addDimValue(t4, e5) {
                t4.addFieldInt64(1, e5, t4.createLong(0, 0));
              }
              static addDimParam(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endDimensionValue(t4) {
                return t4.endObject();
              }
              static createDimensionValue(t4, e5, r3, i3) {
                return n3.startDimensionValue(t4), n3.addDimType(t4, e5), n3.addDimValue(t4, r3), n3.addDimParam(t4, i3), n3.endDimensionValue(t4);
              }
            }
            e4.DimensionValue = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTensorTypeAndShape(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTensorTypeAndShape(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              elemType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              shape(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startTensorTypeAndShape(t4) {
                t4.startObject(2);
              }
              static addElemType(e5, n4) {
                e5.addFieldInt32(0, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addShape(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endTensorTypeAndShape(t4) {
                return t4.endObject();
              }
              static createTensorTypeAndShape(t4, e5, r3) {
                return n3.startTensorTypeAndShape(t4), n3.addElemType(t4, e5), n3.addShape(t4, r3), n3.endTensorTypeAndShape(t4);
              }
            }
            e4.TensorTypeAndShape = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsMapType(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsMapType(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              keyType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              valueType(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startMapType(t4) {
                t4.startObject(2);
              }
              static addKeyType(e5, n4) {
                e5.addFieldInt32(0, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addValueType(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endMapType(t4) {
                return t4.endObject();
              }
              static createMapType(t4, e5, r3) {
                return n3.startMapType(t4), n3.addKeyType(t4, e5), n3.addValueType(t4, r3), n3.endMapType(t4);
              }
            }
            e4.MapType = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSequenceType(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSequenceType(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              elemType(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startSequenceType(t4) {
                t4.startObject(1);
              }
              static addElemType(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static endSequenceType(t4) {
                return t4.endObject();
              }
              static createSequenceType(t4, e5) {
                return n3.startSequenceType(t4), n3.addElemType(t4, e5), n3.endSequenceType(t4);
              }
            }
            e4.SequenceType = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          (t4.fbs || (t4.fbs = {})).EdgeEnd = class {
            constructor() {
              this.bb = null, this.bb_pos = 0;
            }
            __init(t5, e3) {
              return this.bb_pos = t5, this.bb = e3, this;
            }
            nodeIndex() {
              return this.bb.readUint32(this.bb_pos);
            }
            srcArgIndex() {
              return this.bb.readInt32(this.bb_pos + 4);
            }
            dstArgIndex() {
              return this.bb.readInt32(this.bb_pos + 8);
            }
            static createEdgeEnd(t5, e3, n3, r3) {
              return t5.prep(4, 12), t5.writeInt32(r3), t5.writeInt32(n3), t5.writeInt32(e3), t5.offset();
            }
          };
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsNodeEdge(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsNodeEdge(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              nodeIndex() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              inputEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r3) + 12 * e5, this.bb) : null;
              }
              inputEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 8);
                return r3 ? (n4 || new t3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r3) + 12 * e5, this.bb) : null;
              }
              outputEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startNodeEdge(t4) {
                t4.startObject(3);
              }
              static addNodeIndex(t4, e5) {
                t4.addFieldInt32(0, e5, 0);
              }
              static addInputEdges(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static startInputEdgesVector(t4, e5) {
                t4.startVector(12, e5, 4);
              }
              static addOutputEdges(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static startOutputEdgesVector(t4, e5) {
                t4.startVector(12, e5, 4);
              }
              static endNodeEdge(t4) {
                return t4.endObject();
              }
              static createNodeEdge(t4, e5, r3, i3) {
                return n3.startNodeEdge(t4), n3.addNodeIndex(t4, e5), n3.addInputEdges(t4, r3), n3.addOutputEdges(t4, i3), n3.endNodeEdge(t4);
              }
            }
            e4.NodeEdge = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsNode(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsNode(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              domain(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              sinceVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readInt32(this.bb_pos + t4) : 0;
              }
              index() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              opType(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 14);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type() {
                let e5 = this.bb.__offset(this.bb_pos, 16);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.NodeType.Primitive;
              }
              executionProviderType(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 18);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              inputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 20);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              inputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 22);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              outputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 22);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              attributes(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 24);
                return r3 ? (n4 || new t3.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              attributesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 24);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputArgCounts(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 26);
                return e5 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e5) + 4 * t4) : 0;
              }
              inputArgCountsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputArgCountsArray() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              implicitInputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 28);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              implicitInputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 28);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startNode(t4) {
                t4.startObject(13);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDomain(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static addSinceVersion(t4, e5) {
                t4.addFieldInt32(3, e5, 0);
              }
              static addIndex(t4, e5) {
                t4.addFieldInt32(4, e5, 0);
              }
              static addOpType(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static addType(e5, n4) {
                e5.addFieldInt32(6, n4, t3.experimental.fbs.NodeType.Primitive);
              }
              static addExecutionProviderType(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addInputs(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static createInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addOutputs(t4, e5) {
                t4.addFieldOffset(9, e5, 0);
              }
              static createOutputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOutputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addAttributes(t4, e5) {
                t4.addFieldOffset(10, e5, 0);
              }
              static createAttributesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startAttributesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInputArgCounts(t4, e5) {
                t4.addFieldOffset(11, e5, 0);
              }
              static createInputArgCountsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt32(e5[n4]);
                return t4.endVector();
              }
              static startInputArgCountsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addImplicitInputs(t4, e5) {
                t4.addFieldOffset(12, e5, 0);
              }
              static createImplicitInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startImplicitInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endNode(t4) {
                return t4.endObject();
              }
              static createNode(t4, e5, r3, i3, o3, a2, s2, u2, c2, l2, p2, f2, d2, h2) {
                return n3.startNode(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addDomain(t4, i3), n3.addSinceVersion(t4, o3), n3.addIndex(t4, a2), n3.addOpType(t4, s2), n3.addType(t4, u2), n3.addExecutionProviderType(t4, c2), n3.addInputs(t4, l2), n3.addOutputs(t4, p2), n3.addAttributes(t4, f2), n3.addInputArgCounts(t4, d2), n3.addImplicitInputs(t4, h2), n3.endNode(t4);
              }
            }
            e4.Node = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsValueInfo(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsValueInfo(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 8);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startValueInfo(t4) {
                t4.startObject(3);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addType(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endValueInfo(t4) {
                return t4.endObject();
              }
              static createValueInfo(t4, e5, r3, i3) {
                return n3.startValueInfo(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addType(t4, i3), n3.endValueInfo(t4);
              }
            }
            e4.ValueInfo = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTypeInfo(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTypeInfo(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              denotation(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              valueType() {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.readUint8(this.bb_pos + e5) : t3.experimental.fbs.TypeInfoValue.NONE;
              }
              value(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__union(t4, this.bb_pos + e5) : null;
              }
              static startTypeInfo(t4) {
                t4.startObject(3);
              }
              static addDenotation(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addValueType(e5, n4) {
                e5.addFieldInt8(1, n4, t3.experimental.fbs.TypeInfoValue.NONE);
              }
              static addValue(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endTypeInfo(t4) {
                return t4.endObject();
              }
              static createTypeInfo(t4, e5, r3, i3) {
                return n3.startTypeInfo(t4), n3.addDenotation(t4, e5), n3.addValueType(t4, r3), n3.addValue(t4, i3), n3.endTypeInfo(t4);
              }
            }
            e4.TypeInfo = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            class e3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t6, e4) {
                return this.bb_pos = t6, this.bb = e4, this;
              }
              static getRootAsOperatorSetId(t6, n3) {
                return (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              static getSizePrefixedRootAsOperatorSetId(t6, n3) {
                return t6.setPosition(t6.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              domain(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 4);
                return e4 ? this.bb.__string(this.bb_pos + e4, t6) : null;
              }
              version() {
                let t6 = this.bb.__offset(this.bb_pos, 6);
                return t6 ? this.bb.readInt64(this.bb_pos + t6) : this.bb.createLong(0, 0);
              }
              static startOperatorSetId(t6) {
                t6.startObject(2);
              }
              static addDomain(t6, e4) {
                t6.addFieldOffset(0, e4, 0);
              }
              static addVersion(t6, e4) {
                t6.addFieldInt64(1, e4, t6.createLong(0, 0));
              }
              static endOperatorSetId(t6) {
                return t6.endObject();
              }
              static createOperatorSetId(t6, n3, r3) {
                return e3.startOperatorSetId(t6), e3.addDomain(t6, n3), e3.addVersion(t6, r3), e3.endOperatorSetId(t6);
              }
            }
            t5.OperatorSetId = e3;
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTensor(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTensor(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              dims(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              dimsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              dataType() {
                let e5 = this.bb.__offset(this.bb_pos, 10);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              rawData(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 12);
                return e5 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e5) + t4) : 0;
              }
              rawDataLength() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              rawDataArray() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              stringData(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 14);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              stringDataLength() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startTensor(t4) {
                t4.startObject(6);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDims(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createDimsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startDimsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static addDataType(e5, n4) {
                e5.addFieldInt32(3, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addRawData(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static createRawDataVector(t4, e5) {
                t4.startVector(1, e5.length, 1);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt8(e5[n4]);
                return t4.endVector();
              }
              static startRawDataVector(t4, e5) {
                t4.startVector(1, e5, 1);
              }
              static addStringData(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static createStringDataVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startStringDataVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endTensor(t4) {
                return t4.endObject();
              }
              static createTensor(t4, e5, r3, i3, o3, a2, s2) {
                return n3.startTensor(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addDims(t4, i3), n3.addDataType(t4, o3), n3.addRawData(t4, a2), n3.addStringData(t4, s2), n3.endTensor(t4);
              }
            }
            e4.Tensor = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSparseTensor(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSparseTensor(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              values(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              indices(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              dims(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              dimsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startSparseTensor(t4) {
                t4.startObject(3);
              }
              static addValues(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addIndices(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDims(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createDimsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startDimsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static endSparseTensor(t4) {
                return t4.endObject();
              }
              static createSparseTensor(t4, e5, r3, i3) {
                return n3.startSparseTensor(t4), n3.addValues(t4, e5), n3.addIndices(t4, r3), n3.addDims(t4, i3), n3.endSparseTensor(t4);
              }
            }
            e4.SparseTensor = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsAttribute(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsAttribute(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type() {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.AttributeType.UNDEFINED;
              }
              f() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readFloat32(this.bb_pos + t4) : 0;
              }
              i() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              s(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 14);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              t(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 16);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              g(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 18);
                return n4 ? (e5 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              floats(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 20);
                return e5 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e5) + 4 * t4) : 0;
              }
              floatsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              floatsArray() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              ints(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 22);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              intsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 22);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              strings(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 24);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              stringsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 24);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              tensors(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 26);
                return r3 ? (n4 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              tensorsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              graphs(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 28);
                return r3 ? (n4 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              graphsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 28);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startAttribute(t4) {
                t4.startObject(13);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addType(e5, n4) {
                e5.addFieldInt32(2, n4, t3.experimental.fbs.AttributeType.UNDEFINED);
              }
              static addF(t4, e5) {
                t4.addFieldFloat32(3, e5, 0);
              }
              static addI(t4, e5) {
                t4.addFieldInt64(4, e5, t4.createLong(0, 0));
              }
              static addS(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static addT(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static addG(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addFloats(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static createFloatsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addFloat32(e5[n4]);
                return t4.endVector();
              }
              static startFloatsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInts(t4, e5) {
                t4.addFieldOffset(9, e5, 0);
              }
              static createIntsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startIntsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static addStrings(t4, e5) {
                t4.addFieldOffset(10, e5, 0);
              }
              static createStringsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startStringsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addTensors(t4, e5) {
                t4.addFieldOffset(11, e5, 0);
              }
              static createTensorsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startTensorsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addGraphs(t4, e5) {
                t4.addFieldOffset(12, e5, 0);
              }
              static createGraphsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startGraphsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endAttribute(t4) {
                return t4.endObject();
              }
              static createAttribute(t4, e5, r3, i3, o3, a2, s2, u2, c2, l2, p2, f2, d2, h2) {
                return n3.startAttribute(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addType(t4, i3), n3.addF(t4, o3), n3.addI(t4, a2), n3.addS(t4, s2), n3.addT(t4, u2), n3.addG(t4, c2), n3.addFloats(t4, l2), n3.addInts(t4, p2), n3.addStrings(t4, f2), n3.addTensors(t4, d2), n3.addGraphs(t4, h2), n3.endAttribute(t4);
              }
            }
            e4.Attribute = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsGraph(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsGraph(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              initializers(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 4);
                return r3 ? (n4 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              initializersLength() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              nodeArgs(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodeArgsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              nodes(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 8);
                return r3 ? (n4 || new t3.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              maxNodeIndex() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              nodeEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 12);
                return r3 ? (n4 || new t3.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodeEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 14);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              inputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 16);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              outputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 16);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              sparseInitializers(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 18);
                return r3 ? (n4 || new t3.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              sparseInitializersLength() {
                let t4 = this.bb.__offset(this.bb_pos, 18);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startGraph(t4) {
                t4.startObject(8);
              }
              static addInitializers(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static createInitializersVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInitializersVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addNodeArgs(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createNodeArgsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodeArgsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addNodes(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createNodesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addMaxNodeIndex(t4, e5) {
                t4.addFieldInt32(3, e5, 0);
              }
              static addNodeEdges(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static createNodeEdgesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodeEdgesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInputs(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static createInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addOutputs(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static createOutputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOutputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addSparseInitializers(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static createSparseInitializersVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startSparseInitializersVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endGraph(t4) {
                return t4.endObject();
              }
              static createGraph(t4, e5, r3, i3, o3, a2, s2, u2, c2) {
                return n3.startGraph(t4), n3.addInitializers(t4, e5), n3.addNodeArgs(t4, r3), n3.addNodes(t4, i3), n3.addMaxNodeIndex(t4, o3), n3.addNodeEdges(t4, a2), n3.addInputs(t4, s2), n3.addOutputs(t4, u2), n3.addSparseInitializers(t4, c2), n3.endGraph(t4);
              }
            }
            e4.Graph = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsModel(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsModel(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              irVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              opsetImport(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              opsetImportLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              producerName(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              producerVersion(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 10);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              domain(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 12);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              modelVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 16);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              graph(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 18);
                return n4 ? (e5 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              graphDocString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 20);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startModel(t4) {
                t4.startObject(9);
              }
              static addIrVersion(t4, e5) {
                t4.addFieldInt64(0, e5, t4.createLong(0, 0));
              }
              static addOpsetImport(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createOpsetImportVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOpsetImportVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addProducerName(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static addProducerVersion(t4, e5) {
                t4.addFieldOffset(3, e5, 0);
              }
              static addDomain(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static addModelVersion(t4, e5) {
                t4.addFieldInt64(5, e5, t4.createLong(0, 0));
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static addGraph(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addGraphDocString(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static endModel(t4) {
                return t4.endObject();
              }
              static createModel(t4, e5, r3, i3, o3, a2, s2, u2, c2, l2) {
                return n3.startModel(t4), n3.addIrVersion(t4, e5), n3.addOpsetImport(t4, r3), n3.addProducerName(t4, i3), n3.addProducerVersion(t4, o3), n3.addDomain(t4, a2), n3.addModelVersion(t4, s2), n3.addDocString(t4, u2), n3.addGraph(t4, c2), n3.addGraphDocString(t4, l2), n3.endModel(t4);
              }
            }
            e4.Model = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            class e3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t6, e4) {
                return this.bb_pos = t6, this.bb = e4, this;
              }
              static getRootAsKernelCreateInfos(t6, n3) {
                return (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              static getSizePrefixedRootAsKernelCreateInfos(t6, n3) {
                return t6.setPosition(t6.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              nodeIndices(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 4);
                return e4 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e4) + 4 * t6) : 0;
              }
              nodeIndicesLength() {
                let t6 = this.bb.__offset(this.bb_pos, 4);
                return t6 ? this.bb.__vector_len(this.bb_pos + t6) : 0;
              }
              nodeIndicesArray() {
                let t6 = this.bb.__offset(this.bb_pos, 4);
                return t6 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t6), this.bb.__vector_len(this.bb_pos + t6)) : null;
              }
              kernelDefHashes(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 6);
                return e4 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e4) + 8 * t6) : this.bb.createLong(0, 0);
              }
              kernelDefHashesLength() {
                let t6 = this.bb.__offset(this.bb_pos, 6);
                return t6 ? this.bb.__vector_len(this.bb_pos + t6) : 0;
              }
              static startKernelCreateInfos(t6) {
                t6.startObject(2);
              }
              static addNodeIndices(t6, e4) {
                t6.addFieldOffset(0, e4, 0);
              }
              static createNodeIndicesVector(t6, e4) {
                t6.startVector(4, e4.length, 4);
                for (let n3 = e4.length - 1; n3 >= 0; n3--) t6.addInt32(e4[n3]);
                return t6.endVector();
              }
              static startNodeIndicesVector(t6, e4) {
                t6.startVector(4, e4, 4);
              }
              static addKernelDefHashes(t6, e4) {
                t6.addFieldOffset(1, e4, 0);
              }
              static createKernelDefHashesVector(t6, e4) {
                t6.startVector(8, e4.length, 8);
                for (let n3 = e4.length - 1; n3 >= 0; n3--) t6.addInt64(e4[n3]);
                return t6.endVector();
              }
              static startKernelDefHashesVector(t6, e4) {
                t6.startVector(8, e4, 8);
              }
              static endKernelCreateInfos(t6) {
                return t6.endObject();
              }
              static createKernelCreateInfos(t6, n3, r3) {
                return e3.startKernelCreateInfos(t6), e3.addNodeIndices(t6, n3), e3.addKernelDefHashes(t6, r3), e3.endKernelCreateInfos(t6);
              }
            }
            t5.KernelCreateInfos = e3;
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSubGraphSessionState(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSubGraphSessionState(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              graphId(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              sessionState(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startSubGraphSessionState(t4) {
                t4.startObject(2);
              }
              static addGraphId(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addSessionState(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endSubGraphSessionState(t4) {
                let e5 = t4.endObject();
                return t4.requiredField(e5, 4), e5;
              }
              static createSubGraphSessionState(t4, e5, r3) {
                return n3.startSubGraphSessionState(t4), n3.addGraphId(t4, e5), n3.addSessionState(t4, r3), n3.endSubGraphSessionState(t4);
              }
            }
            e4.SubGraphSessionState = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSessionState(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSessionState(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              kernels(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              subGraphSessionStates(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              subGraphSessionStatesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startSessionState(t4) {
                t4.startObject(2);
              }
              static addKernels(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addSubGraphSessionStates(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createSubGraphSessionStatesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startSubGraphSessionStatesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endSessionState(t4) {
                return t4.endObject();
              }
              static createSessionState(t4, e5, r3) {
                return n3.startSessionState(t4), n3.addKernels(t4, e5), n3.addSubGraphSessionStates(t4, r3), n3.endSessionState(t4);
              }
            }
            e4.SessionState = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsInferenceSession(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsInferenceSession(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static bufferHasIdentifier(t4) {
                return t4.__has_identifier("ORTM");
              }
              ortVersion(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              model(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              sessionState(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 8);
                return n4 ? (e5 || new t3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startInferenceSession(t4) {
                t4.startObject(3);
              }
              static addOrtVersion(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addModel(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addSessionState(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endInferenceSession(t4) {
                return t4.endObject();
              }
              static finishInferenceSessionBuffer(t4, e5) {
                t4.finish(e5, "ORTM");
              }
              static finishSizePrefixedInferenceSessionBuffer(t4, e5) {
                t4.finish(e5, "ORTM", true);
              }
              static createInferenceSession(t4, e5, r3, i3) {
                return n3.startInferenceSession(t4), n3.addOrtVersion(t4, e5), n3.addModel(t4, r3), n3.addSessionState(t4, i3), n3.endInferenceSession(t4);
              }
            }
            e4.InferenceSession = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {}));
    }, 7448: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.OnnxjsSessionHandler = void 0;
      const r2 = n2(1670), i2 = n2(9162);
      e2.OnnxjsSessionHandler = class {
        constructor(t3) {
          this.session = t3, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
        }
        async dispose() {
        }
        async run(t3, e3, n3) {
          const o2 = /* @__PURE__ */ new Map();
          for (const e4 in t3) if (Object.hasOwnProperty.call(t3, e4)) {
            const n4 = t3[e4];
            o2.set(e4, new i2.Tensor(n4.dims, n4.type, void 0, void 0, n4.data));
          }
          const a2 = await this.session.run(o2), s2 = {};
          return a2.forEach((t4, e4) => {
            s2[e4] = new r2.Tensor(t4.type, t4.data, t4.dims);
          }), s2;
        }
        startProfiling() {
          this.session.startProfiling();
        }
        endProfiling() {
          this.session.endProfiling();
        }
      };
    }, 6919: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Session = void 0;
      const r2 = n2(7067), i2 = n2(1296), o2 = n2(7091), a2 = n2(1036), s2 = n2(6231), u2 = n2(2644);
      e2.Session = class {
        constructor(t3 = {}) {
          this._initialized = false, this.backendHint = t3.backendHint, this.profiler = s2.Profiler.create(t3.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
        }
        get inputNames() {
          return this._model.graph.getInputNames();
        }
        get outputNames() {
          return this._model.graph.getOutputNames();
        }
        startProfiling() {
          this.profiler.start();
        }
        endProfiling() {
          this.profiler.stop();
        }
        async loadModel(t3, e3, n3) {
          await this.profiler.event("session", "Session.loadModel", async () => {
            const a3 = await (0, o2.resolveBackend)(this.backendHint);
            if (this.sessionHandler = a3.createSessionHandler(this.context), this._model = new u2.Model(), "string" == typeof t3) {
              const e4 = t3.endsWith(".ort");
              if ("undefined" == typeof fetch) {
                const n4 = await (0, i2.promisify)(r2.readFile)(t3);
                this.initialize(n4, e4);
              } else {
                const n4 = await fetch(t3), r3 = await n4.arrayBuffer();
                this.initialize(new Uint8Array(r3), e4);
              }
            } else if (ArrayBuffer.isView(t3)) this.initialize(t3);
            else {
              const r3 = new Uint8Array(t3, e3 || 0, n3 || t3.byteLength);
              this.initialize(r3);
            }
          });
        }
        initialize(t3, e3) {
          if (this._initialized) throw new Error("already initialized");
          this.profiler.event("session", "Session.initialize", () => {
            const n3 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
            this._model.load(t3, n3, e3), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a2.ExecutionPlan(this._model.graph, this._ops, this.profiler);
          }), this._initialized = true;
        }
        async run(t3) {
          if (!this._initialized) throw new Error("session not initialized yet");
          return this.profiler.event("session", "Session.run", async () => {
            const e3 = this.normalizeAndValidateInputs(t3), n3 = await this._executionPlan.execute(this.sessionHandler, e3);
            return this.createOutput(n3);
          });
        }
        normalizeAndValidateInputs(t3) {
          const e3 = this._model.graph.getInputNames();
          if (Array.isArray(t3)) {
            if (t3.length !== e3.length) throw new Error(`incorrect input array length: expected ${e3.length} but got ${t3.length}`);
          } else {
            if (t3.size !== e3.length) throw new Error(`incorrect input map size: expected ${e3.length} but got ${t3.size}`);
            const n3 = new Array(t3.size);
            let r3 = 0;
            for (let i3 = 0; i3 < e3.length; ++i3) {
              const o3 = t3.get(e3[i3]);
              if (!o3) throw new Error(`missing input tensor for: '${name}'`);
              n3[r3++] = o3;
            }
            t3 = n3;
          }
          if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, t3, false);
          else {
            const e4 = this._model.graph.getInputIndices(), n3 = this._model.graph.getValues(), r3 = new Array(e4.length);
            for (let i3 = 0; i3 < e4.length; ++i3) {
              const o3 = n3[e4[i3]];
              r3[i3] = o3.type.shape.dims, this.context.graphInputTypes.push(o3.type.tensorType), this.context.graphInputDims.push(t3[i3].dims);
            }
            this.validateInputTensorDims(r3, t3, true);
          }
          return this.validateInputTensorTypes(this.context.graphInputTypes, t3), t3;
        }
        validateInputTensorTypes(t3, e3) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            const r3 = t3[n3], i3 = e3[n3].type;
            if (r3 !== i3) throw new Error(`input tensor[${n3}] check failed: expected type '${r3}' but got ${i3}`);
          }
        }
        validateInputTensorDims(t3, e3, n3) {
          for (let r3 = 0; r3 < e3.length; r3++) {
            const i3 = t3[r3], o3 = e3[r3].dims;
            if (!this.compareTensorDims(i3, o3, n3)) throw new Error(`input tensor[${r3}] check failed: expected shape '[${i3.join(",")}]' but got [${o3.join(",")}]`);
          }
        }
        compareTensorDims(t3, e3, n3) {
          if (t3.length !== e3.length) return false;
          for (let r3 = 0; r3 < t3.length; ++r3) if (t3[r3] !== e3[r3] && (!n3 || 0 !== t3[r3])) return false;
          return true;
        }
        createOutput(t3) {
          const e3 = this._model.graph.getOutputNames();
          if (t3.length !== e3.length) throw new Error("expected number of outputs do not match number of generated outputs");
          const n3 = /* @__PURE__ */ new Map();
          for (let r3 = 0; r3 < e3.length; ++r3) n3.set(e3[r3], t3[r3]);
          return n3;
        }
        initializeOps(t3) {
          const e3 = t3.getNodes();
          this._ops = new Array(e3.length);
          for (let n3 = 0; n3 < e3.length; n3++) this._ops[n3] = this.sessionHandler.resolve(e3[n3], this._model.opsets, t3);
        }
      };
    }, 9162: function(t2, e2, n2) {
      var r2 = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Tensor = void 0;
      const i2 = n2(3442), o2 = r2(n2(3720)), a2 = n2(1446), s2 = n2(9395), u2 = n2(2517);
      var c2 = s2.onnxruntime.experimental.fbs;
      class l2 {
        get data() {
          if (void 0 === this.cache) {
            const t3 = this.dataProvider(this.dataId);
            if (t3.length !== this.size) throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
            this.cache = t3;
          }
          return this.cache;
        }
        get stringData() {
          if ("string" !== this.type) throw new TypeError("data type is not string");
          return this.data;
        }
        get integerData() {
          switch (this.type) {
            case "uint8":
            case "int8":
            case "uint16":
            case "int16":
            case "int32":
            case "uint32":
            case "bool":
              return this.data;
            default:
              throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
          }
        }
        get floatData() {
          switch (this.type) {
            case "float32":
            case "float64":
              return this.data;
            default:
              throw new TypeError("data type is not float (float32, float64)");
          }
        }
        get numberData() {
          if ("string" !== this.type) return this.data;
          throw new TypeError("type cannot be non-number (string)");
        }
        get(t3) {
          return this.data[u2.ShapeUtil.indicesToOffset(t3, this.strides)];
        }
        set(t3, e3) {
          this.data[u2.ShapeUtil.indicesToOffset(t3, this.strides)] = e3;
        }
        async getData() {
          return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
        }
        get strides() {
          return this._strides || (this._strides = u2.ShapeUtil.computeStrides(this.dims)), this._strides;
        }
        constructor(t3, e3, n3, r3, o3, a3 = i2.Guid.create()) {
          this.dims = t3, this.type = e3, this.dataProvider = n3, this.asyncDataProvider = r3, this.cache = o3, this.dataId = a3, this.size = u2.ShapeUtil.validateDimsAndCalcSize(t3);
          const s3 = this.size, c3 = void 0 === n3 && void 0 === r3 && void 0 === o3;
          if (void 0 !== o3 && o3.length !== s3) throw new RangeError("Input dims doesn't match data length.");
          if ("string" === e3) {
            if (!(void 0 === o3 || Array.isArray(o3) && o3.every((t4) => "string" == typeof t4))) throw new TypeError("cache should be a string array");
            c3 && (this.cache = new Array(s3));
          } else {
            if (void 0 !== o3) {
              const t4 = f2(e3);
              if (!(o3 instanceof t4)) throw new TypeError(`cache should be type ${t4.name}`);
            }
            if (c3) {
              const t4 = new ArrayBuffer(s3 * function(t5) {
                switch (t5) {
                  case "bool":
                  case "int8":
                  case "uint8":
                    return 1;
                  case "int16":
                  case "uint16":
                    return 2;
                  case "int32":
                  case "uint32":
                  case "float32":
                    return 4;
                  case "float64":
                    return 8;
                  default:
                    throw new Error(`cannot calculate sizeof() on type ${t5}`);
                }
              }(e3));
              this.cache = function(t5, e4) {
                return new (f2(e4))(t5);
              }(t4, e3);
            }
          }
        }
        static fromProto(t3) {
          if (!t3) throw new Error("cannot construct Value from an empty tensor");
          const e3 = u2.ProtoUtil.tensorDataTypeFromProto(t3.dataType), n3 = u2.ProtoUtil.tensorDimsFromProto(t3.dims), r3 = new l2(n3, e3);
          if ("string" === e3) t3.stringData.forEach((t4, e4) => {
            r3.data[e4] = (0, u2.decodeUtf8String)(t4);
          });
          else if (t3.rawData && "number" == typeof t3.rawData.byteLength && t3.rawData.byteLength > 0) {
            const e4 = r3.data, n4 = new DataView(t3.rawData.buffer, t3.rawData.byteOffset, t3.rawData.byteLength), i3 = p2(t3.dataType), o3 = t3.rawData.byteLength / i3;
            if (t3.rawData.byteLength % i3 != 0) throw new Error("invalid buffer length");
            if (e4.length !== o3) throw new Error("buffer length mismatch");
            for (let r4 = 0; r4 < o3; r4++) {
              const o4 = h2(n4, t3.dataType, r4 * i3);
              e4[r4] = o4;
            }
          } else {
            let e4;
            switch (t3.dataType) {
              case a2.onnx.TensorProto.DataType.FLOAT:
                e4 = t3.floatData;
                break;
              case a2.onnx.TensorProto.DataType.INT32:
              case a2.onnx.TensorProto.DataType.INT16:
              case a2.onnx.TensorProto.DataType.UINT16:
              case a2.onnx.TensorProto.DataType.INT8:
              case a2.onnx.TensorProto.DataType.UINT8:
              case a2.onnx.TensorProto.DataType.BOOL:
                e4 = t3.int32Data;
                break;
              case a2.onnx.TensorProto.DataType.INT64:
                e4 = t3.int64Data;
                break;
              case a2.onnx.TensorProto.DataType.DOUBLE:
                e4 = t3.doubleData;
                break;
              case a2.onnx.TensorProto.DataType.UINT32:
              case a2.onnx.TensorProto.DataType.UINT64:
                e4 = t3.uint64Data;
                break;
              default:
                throw new Error("unspecific error");
            }
            if (null == e4) throw new Error("failed to populate data from a tensorproto value");
            const n4 = r3.data;
            if (n4.length !== e4.length) throw new Error("array length mismatch");
            for (let r4 = 0; r4 < e4.length; r4++) {
              const i3 = e4[r4];
              o2.default.isLong(i3) ? n4[r4] = d2(i3, t3.dataType) : n4[r4] = i3;
            }
          }
          return r3;
        }
        static fromData(t3, e3, n3) {
          return new l2(e3, n3, void 0, void 0, t3);
        }
        static fromOrtTensor(t3) {
          if (!t3) throw new Error("cannot construct Value from an empty tensor");
          const e3 = u2.ProtoUtil.tensorDimsFromORTFormat(t3), n3 = u2.ProtoUtil.tensorDataTypeFromProto(t3.dataType()), r3 = new l2(e3, n3);
          if ("string" === n3) for (let e4 = 0; e4 < t3.stringDataLength(); e4++) r3.data[e4] = t3.stringData(e4);
          else if (t3.rawDataArray() && "number" == typeof t3.rawDataLength() && t3.rawDataLength() > 0) {
            const e4 = r3.data, n4 = new DataView(t3.rawDataArray().buffer, t3.rawDataArray().byteOffset, t3.rawDataLength()), i3 = p2(t3.dataType()), o3 = t3.rawDataLength() / i3;
            if (t3.rawDataLength() % i3 != 0) throw new Error("invalid buffer length");
            if (e4.length !== o3) throw new Error("buffer length mismatch");
            for (let r4 = 0; r4 < o3; r4++) {
              const o4 = h2(n4, t3.dataType(), r4 * i3);
              e4[r4] = o4;
            }
          }
          return r3;
        }
      }
      function p2(t3) {
        switch (t3) {
          case a2.onnx.TensorProto.DataType.UINT8:
          case a2.onnx.TensorProto.DataType.INT8:
          case a2.onnx.TensorProto.DataType.BOOL:
            return 1;
          case a2.onnx.TensorProto.DataType.UINT16:
          case a2.onnx.TensorProto.DataType.INT16:
            return 2;
          case a2.onnx.TensorProto.DataType.FLOAT:
          case a2.onnx.TensorProto.DataType.INT32:
          case a2.onnx.TensorProto.DataType.UINT32:
            return 4;
          case a2.onnx.TensorProto.DataType.INT64:
          case a2.onnx.TensorProto.DataType.DOUBLE:
          case a2.onnx.TensorProto.DataType.UINT64:
            return 8;
          default:
            throw new Error(`cannot calculate sizeof() on type ${a2.onnx.TensorProto.DataType[t3]}`);
        }
      }
      function f2(t3) {
        switch (t3) {
          case "bool":
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "int16":
            return Int16Array;
          case "uint16":
            return Uint16Array;
          case "int32":
            return Int32Array;
          case "uint32":
            return Uint32Array;
          case "float32":
            return Float32Array;
          case "float64":
            return Float64Array;
          default:
            throw new Error("unspecified error");
        }
      }
      function d2(t3, e3) {
        if (e3 === a2.onnx.TensorProto.DataType.INT64 || e3 === c2.TensorDataType.INT64) {
          if (t3.greaterThanOrEqual(2147483648) || t3.lessThan(-2147483648)) throw new TypeError("int64 is not supported");
        } else {
          if (e3 !== a2.onnx.TensorProto.DataType.UINT32 && e3 !== c2.TensorDataType.UINT32 && e3 !== a2.onnx.TensorProto.DataType.UINT64 && e3 !== c2.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a2.onnx.TensorProto.DataType[e3]}`);
          if (t3.greaterThanOrEqual(4294967296) || t3.lessThan(0)) throw new TypeError("uint64 is not supported");
        }
        return t3.toNumber();
      }
      function h2(t3, e3, n3) {
        switch (e3) {
          case a2.onnx.TensorProto.DataType.BOOL:
          case a2.onnx.TensorProto.DataType.UINT8:
            return t3.getUint8(n3);
          case a2.onnx.TensorProto.DataType.INT8:
            return t3.getInt8(n3);
          case a2.onnx.TensorProto.DataType.UINT16:
            return t3.getUint16(n3, true);
          case a2.onnx.TensorProto.DataType.INT16:
            return t3.getInt16(n3, true);
          case a2.onnx.TensorProto.DataType.FLOAT:
            return t3.getFloat32(n3, true);
          case a2.onnx.TensorProto.DataType.INT32:
            return t3.getInt32(n3, true);
          case a2.onnx.TensorProto.DataType.UINT32:
            return t3.getUint32(n3, true);
          case a2.onnx.TensorProto.DataType.INT64:
            return d2(o2.default.fromBits(t3.getUint32(n3, true), t3.getUint32(n3 + 4, true), false), e3);
          case a2.onnx.TensorProto.DataType.DOUBLE:
            return t3.getFloat64(n3, true);
          case a2.onnx.TensorProto.DataType.UINT64:
            return d2(o2.default.fromBits(t3.getUint32(n3, true), t3.getUint32(n3 + 4, true), true), e3);
          default:
            throw new Error(`cannot read from DataView for type ${a2.onnx.TensorProto.DataType[e3]}`);
        }
      }
      e2.Tensor = l2;
    }, 2517: function(t2, e2, n2) {
      var r2 = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.decodeUtf8String = e2.MAX_CLIP = e2.MIN_CLIP = e2.PoolConvUtil = e2.ReduceUtil = e2.SplitUtil = e2.MathUtil = e2.ShapeUtil = e2.LongUtil = e2.ProtoUtil = e2.GemmUtil = e2.arrayCopyHelper = e2.BroadcastUtil = e2.MatMulUtil = e2.ArrayUtil = e2.assert = e2.checkInputsShape = void 0;
      const i2 = n2(5686), o2 = r2(n2(3720)), a2 = n2(1446), s2 = n2(9162);
      e2.checkInputsShape = function(t3, ...e3) {
        if (!t3 || t3.length !== e3.length) return false;
        for (let n3 = 0; n3 < t3.length; n3++) if (!t3[n3].dims || t3[n3].dims.length !== e3[n3]) return false;
        return true;
      }, e2.assert = function(t3, e3) {
        if (!t3) throw new Error("string" == typeof e3 ? e3 : e3());
      }, e2.ArrayUtil = class {
        static arraysEqual(t3, e3) {
          if (t3.length !== e3.length) return false;
          for (let n3 = 0; n3 < t3.length; n3++) if (t3[n3] !== e3[n3]) return false;
          return true;
        }
      };
      class u2 {
        static preprocessInputShapes(t3, e3) {
          return [1 === t3.length ? [1, t3[0]] : t3, 1 === e3.length ? [e3[0], 1] : e3];
        }
        static postprocessOutputShape(t3, e3, n3) {
          1 === e3 && t3.splice(t3.length - 2, 1), 1 === n3 && t3.pop();
        }
        static calcMatMulShape(t3, e3) {
          return t3[1] !== e3[0] ? void 0 : [t3[0], e3[1]];
        }
      }
      e2.MatMulUtil = u2;
      class c2 {
        static calcShape(t3, e3, n3 = false) {
          const r3 = t3.length, i3 = e3.length;
          if (0 === r3) return e3;
          if (0 === i3) return t3;
          const o3 = Math.max(t3.length, e3.length), a3 = new Array(o3);
          if (n3) {
            if (r3 < 2 || i3 < 2) return;
            const n4 = u2.calcMatMulShape([t3[r3 - 2], t3[r3 - 1]], [e3[i3 - 2], e3[i3 - 1]]);
            if (void 0 === n4) return;
            [a3[o3 - 2], a3[o3 - 1]] = n4;
          }
          for (let s3 = n3 ? 3 : 1; s3 <= o3; s3++) {
            const n4 = r3 - s3 < 0 ? 1 : t3[r3 - s3], u3 = i3 - s3 < 0 ? 1 : e3[i3 - s3];
            if (n4 !== u3 && n4 > 1 && u3 > 1) return;
            a3[o3 - s3] = Math.max(n4, u3);
          }
          return a3;
        }
        static index(t3, e3) {
          const n3 = new Array(e3.length);
          return c2.fillIndex(t3, e3, n3), n3;
        }
        static fillIndex(t3, e3, n3) {
          const r3 = t3.length - e3.length;
          for (let i3 = 0; i3 < e3.length; i3++) n3[i3] = t3[r3 + i3] % e3[i3];
        }
        static calc(t3, e3, n3, r3, i3) {
          const o3 = c2.calcShape(t3.dims, e3.dims);
          if (o3) {
            if (r3 && !f2.areEqual(o3, t3.dims)) return;
            const a3 = f2.size(o3), u3 = r3 ? t3 : new s2.Tensor(o3, i3 || t3.type);
            if (0 === o3.length) u3.set([], n3(t3.get([]), e3.get([])));
            else {
              const r4 = new Array(o3.length), i4 = new Array(t3.dims.length), s3 = new Array(e3.dims.length);
              let l3, p3 = 0, f3 = 0, d3 = false, h3 = false;
              0 === t3.dims.length && (p3 = t3.get([]), d3 = true), 0 === e3.dims.length && (f3 = e3.get([]), h3 = true);
              for (let g3 = 0; g3 < a3; g3++) {
                l3 = g3;
                for (let t4 = o3.length - 1; t4 >= 0; t4--) r4[t4] = l3 % o3[t4], l3 = Math.floor(l3 / o3[t4]);
                d3 || (c2.fillIndex(r4, t3.dims, i4), p3 = t3.get(i4)), h3 || (c2.fillIndex(r4, e3.dims, s3), f3 = e3.get(s3)), u3.set(r4, n3(p3, f3));
              }
            }
            return u3;
          }
        }
        static isValidBroadcast(t3, e3) {
          const n3 = t3.length, r3 = e3.length;
          if (n3 > r3) return false;
          for (let i3 = 1; i3 <= n3; i3++) if (1 !== t3[n3 - i3] && t3[n3 - i3] !== e3[r3 - i3]) return false;
          return true;
        }
        static getBroadcastDims(t3, e3) {
          const n3 = t3.length, r3 = [];
          for (let i3 = 0; i3 < n3; i3++) {
            const o3 = n3 - 1 - i3, a3 = t3[o3] || 1;
            (e3[e3.length - 1 - i3] || 1) > 1 && 1 === a3 && r3.unshift(o3);
          }
          return r3;
        }
      }
      e2.BroadcastUtil = c2, e2.arrayCopyHelper = function(t3, e3, n3, r3, i3) {
        if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
        if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
        if (r3 + i3 > e3.length) throw new Error("source indices to be copied are outside bounds");
        if (n3 + i3 > t3.length) throw new Error("target array is too small to hold result");
        for (let o3 = 0; o3 < i3; o3++) t3[n3 + o3] = e3[r3 + o3];
      }, e2.GemmUtil = class {
        static getShapeOfGemmResult(t3, e3, n3, r3, i3) {
          if (2 !== t3.length || 2 !== n3.length) throw new Error("shape need to be of size 2");
          let o3, a3, s3;
          e3 ? (o3 = t3[1], a3 = t3[0]) : (o3 = t3[0], a3 = t3[1]);
          let u3 = -1;
          if (r3 ? (s3 = n3[0], u3 = 1) : (s3 = n3[1], u3 = 0), n3[u3] !== a3) throw new Error("dimension mismatch");
          if (o3 <= 0 || s3 <= 0 || a3 <= 0) throw new Error("invalid shape specified");
          if (i3 && !c2.isValidBroadcast(i3, [o3, s3])) throw new Error("gemm: invalid bias shape for broadcast");
          return [o3, s3, a3];
        }
      };
      class l2 {
        static tensorDataTypeFromProto(t3) {
          switch (t3) {
            case a2.onnx.TensorProto.DataType.INT8:
              return "int8";
            case a2.onnx.TensorProto.DataType.UINT8:
              return "uint8";
            case a2.onnx.TensorProto.DataType.BOOL:
              return "bool";
            case a2.onnx.TensorProto.DataType.INT16:
              return "int16";
            case a2.onnx.TensorProto.DataType.UINT16:
              return "uint16";
            case a2.onnx.TensorProto.DataType.INT32:
              return "int32";
            case a2.onnx.TensorProto.DataType.UINT32:
              return "uint32";
            case a2.onnx.TensorProto.DataType.FLOAT:
              return "float32";
            case a2.onnx.TensorProto.DataType.DOUBLE:
              return "float64";
            case a2.onnx.TensorProto.DataType.STRING:
              return "string";
            case a2.onnx.TensorProto.DataType.INT64:
              return "int32";
            case a2.onnx.TensorProto.DataType.UINT64:
              return "uint32";
            default:
              throw new Error(`unsupported data type: ${a2.onnx.TensorProto.DataType[t3]}`);
          }
        }
        static tensorDataTypeStringToEnum(t3) {
          switch (t3) {
            case "int8":
              return a2.onnx.TensorProto.DataType.INT8;
            case "uint8":
              return a2.onnx.TensorProto.DataType.UINT8;
            case "bool":
              return a2.onnx.TensorProto.DataType.BOOL;
            case "int16":
              return a2.onnx.TensorProto.DataType.INT16;
            case "uint16":
              return a2.onnx.TensorProto.DataType.UINT16;
            case "int32":
              return a2.onnx.TensorProto.DataType.INT32;
            case "uint32":
              return a2.onnx.TensorProto.DataType.UINT32;
            case "float32":
              return a2.onnx.TensorProto.DataType.FLOAT;
            case "float64":
              return a2.onnx.TensorProto.DataType.DOUBLE;
            case "string":
              return a2.onnx.TensorProto.DataType.STRING;
            case "int64":
              return a2.onnx.TensorProto.DataType.INT64;
            case "uint64":
              return a2.onnx.TensorProto.DataType.UINT64;
            default:
              throw new Error(`unsupported data type: ${t3}`);
          }
        }
        static tensorDimsFromProto(t3) {
          return t3.map((t4) => o2.default.isLong(t4) ? t4.toNumber() : t4);
        }
        static tensorValueTypeFromProto(t3) {
          return { tensorType: l2.tensorDataTypeFromProto(t3.elemType), shape: { dims: l2.tensorDimsFromProto(t3.shape.dim.map((t4) => t4.dimValue)) } };
        }
        static tensorDimsFromORTFormat(t3) {
          const e3 = [];
          for (let n3 = 0; n3 < t3.dimsLength(); n3++) e3.push(p2.longToNumber(t3.dims(n3)));
          return e3;
        }
        static tensorAttributesFromORTFormat(t3) {
          const e3 = [];
          for (let n3 = 0; n3 < t3.attributesLength(); n3++) e3.push(t3.attributes(n3));
          return e3;
        }
      }
      e2.ProtoUtil = l2;
      class p2 {
        static longToNumber(t3, e3) {
          return o2.default.isLong(t3) ? t3.toNumber() : t3 instanceof i2.flatbuffers.Long ? o2.default.fromValue({ low: t3.low, high: t3.high, unsigned: null != e3 && e3 }).toNumber() : t3;
        }
        static isLong(t3) {
          return o2.default.isLong(t3) || t3 instanceof i2.flatbuffers.Long;
        }
      }
      e2.LongUtil = p2;
      class f2 {
        static size(t3) {
          return f2.getSizeFromDimensionRange(t3, 0, t3.length);
        }
        static sizeFromDimension(t3, e3) {
          if (e3 < 0 || e3 > t3.length) throw new Error(`invalid dimension of ${e3} for sizeFromDimension as Tensor has ${t3.length} dimensions.`);
          return f2.getSizeFromDimensionRange(t3, e3, t3.length);
        }
        static sizeToDimension(t3, e3) {
          if (e3 < 0 || e3 > t3.length) throw new Error(`invalid dimension of ${e3} for sizeToDimension as Tensor has ${t3.length} dimensions.`);
          return f2.getSizeFromDimensionRange(t3, 0, e3);
        }
        static getSizeFromDimensionRange(t3, e3, n3) {
          let r3 = 1;
          for (let i3 = e3; i3 < n3; i3++) {
            if (t3[i3] <= 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
            r3 *= t3[i3];
          }
          return r3;
        }
        static computeStrides(t3) {
          const e3 = t3.length;
          if (0 === e3) return [];
          if (1 === e3) return [1];
          const n3 = new Array(e3);
          n3[e3 - 1] = 1, n3[e3 - 2] = t3[e3 - 1];
          for (let r3 = e3 - 3; r3 >= 0; --r3) n3[r3] = n3[r3 + 1] * t3[r3 + 1];
          return n3;
        }
        static transpose(t3) {
          return t3.slice().reverse();
        }
        static indicesToOffset(t3, e3, n3) {
          void 0 === n3 && (n3 = t3.length);
          let r3 = 0;
          for (let i3 = 0; i3 < n3; ++i3) r3 += e3[i3] * t3[i3];
          return r3;
        }
        static offsetToIndices(t3, e3) {
          const n3 = e3.length;
          if (0 === n3) return [];
          if (1 === n3) return [t3 * e3[0]];
          const r3 = new Array(e3.length);
          for (let n4 = 0; n4 < r3.length - 1; ++n4) r3[n4] = Math.floor(t3 / e3[n4]), t3 -= r3[n4] * e3[n4];
          return r3[r3.length - 1] = t3, r3;
        }
        static normalizeAxis(t3, e3) {
          if (t3 < -e3 && t3 >= e3) throw new Error("unsupported axis for this operation.");
          return t3 < 0 ? t3 + e3 : t3;
        }
        static normalizeAxes(t3, e3) {
          return t3.map((t4) => this.normalizeAxis(t4, e3));
        }
        static incrementIndex(t3, e3, n3) {
          if (0 === e3.length || 0 === t3.length) throw new Error("Index incrementing unsupported for scalar Tensor");
          if (void 0 === n3) n3 = e3.length;
          else if (n3 <= 0 || n3 > e3.length) throw new Error("Incorrect axis to increment on");
          for (let r3 = n3 - 1; r3 >= 0 && (t3[r3]++, !(t3[r3] < e3[r3])); --r3) t3[r3] = 0;
        }
        static calculateReshapedDims(t3, e3) {
          if (0 === e3.length) {
            if (0 === t3.length || 1 === f2.size(t3)) return [];
            throw new Error("cannot reshape to a scalar Tensor");
          }
          const n3 = e3.length, r3 = new Array(n3);
          let i3 = -1, o3 = 1;
          for (let a4 = 0; a4 < n3; a4++) {
            if (e3[a4] < -1) throw new Error("a dimension in shape hints cannot be less than -1");
            if (-1 === e3[a4]) {
              if (-1 !== i3) throw new Error("at most one dimension in shape hints can be -1");
              i3 = a4;
            } else {
              if (0 === e3[a4]) {
                if (a4 >= t3.length) throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                r3[a4] = t3[a4];
              } else r3[a4] = e3[a4];
              o3 *= r3[a4];
            }
          }
          const a3 = f2.size(t3);
          if (-1 !== i3) {
            if (a3 % o3 != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t3}] Output shape: [${e3}]`);
            r3[i3] = a3 / o3;
          } else if (o3 !== a3) throw new Error("reshapedDims and originalDims don't have matching sizes");
          return r3;
        }
        static sortBasedOnPerm(t3, e3) {
          return e3 ? e3.map((e4) => t3[e4]) : t3.slice().reverse();
        }
        static padShape(t3, e3) {
          const n3 = t3.length;
          return t3.map((t4, r3) => t4 + e3[r3] + e3[r3 + n3]);
        }
        static areEqual(t3, e3) {
          return t3.length === e3.length && t3.every((t4, n3) => t4 === e3[n3]);
        }
        static validateDimsAndCalcSize(t3) {
          if (t3.length > 6) throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
          let e3 = 1;
          for (const n3 of t3) {
            if (!Number.isInteger(n3)) throw new TypeError(`Invalid shape: ${n3} is not an integer`);
            if (n3 < 0 || n3 > 2147483647) throw new TypeError(`Invalid shape: length ${n3} is not allowed`);
            e3 *= n3;
          }
          return e3;
        }
        static flattenShape(t3, e3) {
          e3 < 0 && (e3 += t3.length);
          const n3 = t3.reduce((t4, e4) => t4 * e4, 1), r3 = t3.slice(e3).reduce((t4, e4) => t4 * e4, 1);
          return [n3 / r3, r3];
        }
        static squeezeShape(t3, e3) {
          const n3 = new Array();
          e3 = f2.normalizeAxes(e3, t3.length);
          for (let r3 = 0; r3 < t3.length; r3++) {
            const i3 = e3.indexOf(r3) >= 0;
            if (i3 && 1 !== t3[r3]) throw new Error("squeeze an axis of size different than 1");
            (0 === e3.length && t3[r3] > 1 || e3.length > 0 && !i3) && n3.push(t3[r3]);
          }
          return n3;
        }
        static unsqueezeShape(t3, e3) {
          const n3 = new Array(t3.length + e3.length);
          n3.fill(0);
          for (let t4 = 0; t4 < e3.length; t4++) {
            const r4 = f2.normalizeAxis(e3[t4], n3.length);
            if (r4 >= n3.length) throw new Error("'axes' has an out of range axis");
            if (0 !== n3[r4]) throw new Error("'axes' has a duplicate axis");
            n3[r4] = 1;
          }
          let r3 = 0;
          for (let e4 = 0; e4 < n3.length; e4++) 0 === n3[e4] && (n3[e4] = t3[r3++]);
          if (r3 !== t3.length) throw new Error("the unsqueezed dimension could not be established");
          return n3;
        }
      }
      e2.ShapeUtil = f2, e2.MathUtil = class {
        static sqr(t3, e3, n3, r3, i3) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i3 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i3 > t3.length) throw new Error("target array is too small to hold result");
          for (let o3 = 0; o3 < i3; o3++) t3[n3 + o3] += Math.pow(e3[r3 + o3], 2);
        }
        static axpy(t3, e3, n3, r3, i3, o3) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i3 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i3 > t3.length) throw new Error("target array is too small to hold result");
          for (let a3 = 0; a3 < i3; a3++) t3[n3 + a3] += o3 * e3[r3 + a3];
        }
        static powx(t3, e3, n3, r3, i3, o3) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i3 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i3 > t3.length) throw new Error("target array is too small to hold result");
          for (let a3 = 0; a3 < i3; a3++) t3[n3 + a3] = Math.pow(e3[r3 + a3], o3);
        }
        static mul(t3, e3, n3, r3, i3) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i3 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i3 > t3.length) throw new Error("target array is too small to hold result");
          for (let o3 = 0; o3 < i3; o3++) t3[n3 + o3] = e3[r3 + o3] * t3[n3 + o3];
        }
      };
      class d2 {
        static splitShape(t3, e3, n3, r3) {
          if (0 === n3.length) {
            if (!r3) throw new Error("need to know number of outputs when the 'split' attribute is not specified");
            d2.determineSplit(t3[e3], r3, n3);
          }
          const i3 = [], o3 = [0];
          for (let r4 = 0; r4 < n3.length; ++r4) {
            0 !== r4 && o3.push(o3[r4 - 1] + n3[r4 - 1]);
            const a3 = t3.slice();
            a3[e3] = n3[r4], i3.push(a3);
          }
          return [i3, o3];
        }
        static determineSplit(t3, e3, n3) {
          if (t3 % e3 != 0) throw new Error("cannot split tensor to equal sized parts");
          for (let r3 = 0; r3 < e3; ++r3) n3.push(t3 / e3);
        }
      }
      e2.SplitUtil = d2;
      class h2 {
        static calcReduce(t3, e3, n3, r3, i3) {
          const o3 = t3.dims.slice(0);
          0 === e3.length && o3.forEach((t4, n4) => e3.push(n4));
          const a3 = h2.calcReduceShape(o3, e3, true), u3 = f2.size(a3), l3 = new s2.Tensor(a3, t3.type), p3 = f2.computeStrides(a3), d3 = f2.computeStrides(o3), g3 = new Array(o3.length);
          for (let n4 = 0; n4 < u3; n4++) {
            const a4 = f2.offsetToIndices(n4, p3);
            c2.fillIndex(a4, o3, g3), l3.set(a4, h2.calcReduceByAxis(t3.numberData, e3, o3, 0, f2.indicesToOffset(g3, d3), r3, i3));
          }
          return n3 ? l3 : new s2.Tensor(h2.calcReduceShape(o3, e3, n3), l3.type, void 0, void 0, l3.data, l3.dataId);
        }
        static calcReduceByAxis(t3, e3, n3, r3, i3, o3, a3) {
          let s3 = 0;
          if (r3 >= e3.length) return o3(t3[i3]);
          const u3 = e3[r3], c3 = u3 >= n3.length ? 1 : f2.size(n3.slice(u3 + 1));
          for (let l3 = 0; l3 < n3[u3]; l3++) s3 = 0 === l3 ? h2.calcReduceByAxis(t3, e3, n3, r3 + 1, i3, o3, a3) : a3(s3, h2.calcReduceByAxis(t3, e3, n3, r3 + 1, i3, o3, a3)), i3 += c3;
          return s3;
        }
        static calcReduceShape(t3, e3, n3) {
          const r3 = t3.slice();
          for (let t4 = 0; t4 < e3.length; t4++) r3[e3[t4]] = n3 ? 1 : 0;
          return r3.filter((t4) => 0 !== t4);
        }
      }
      e2.ReduceUtil = h2;
      class g2 {
        static adjustPoolAttributes(t3, e3, n3, r3, i3, o3) {
          if (!t3 && n3.length !== e3.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          if (t3) for (let t4 = 0; t4 < e3.length - 2; t4++) t4 >= n3.length ? n3.push(e3[t4 + 2]) : n3[t4] = e3[t4 + 2];
          for (let t4 = 0; t4 < n3.length; t4++) if (t4 < r3.length) {
            if (r3[t4] < 0) throw new Error("strides should be greater than or equal to 1");
          } else r3.push(1);
          for (let t4 = 0; t4 < n3.length; t4++) if (t4 < i3.length) {
            if (i3[t4] < 0) throw new Error("dilations should be greater than or equal to 1");
          } else i3.push(1);
          for (let t4 = 0; t4 < 2 * n3.length; t4++) if (t4 < o3.length) {
            if (o3[t4] < 0) throw new Error("pad should be greater than or equal to 1");
          } else o3.push(0);
          for (let t4 = 0; t4 < n3.length; t4++) {
            if (n3[t4] <= 0) throw new Error("kernel shapes need to be greater than 0");
            if (o3[t4] >= n3[t4] || o3[t4 + n3.length] >= n3[t4]) throw new Error("pads should be smaller than kernel");
          }
        }
        static adjustPadsBasedOnAutoPad(t3, e3, n3, r3, i3, o3) {
          if (o3) {
            if (i3.length !== 2 * (t3.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
            if (e3.length !== t3.length - 2) throw new Error("length of strides should be the length of data dimensions");
            if (r3.length !== t3.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
            for (let a3 = 0; a3 < t3.length - 2; a3++) g2.adjustPadAndReturnShape(t3[a3 + 2], e3[a3], n3[a3], r3[a3], i3, a3, a3 + t3.length - 2, o3);
          }
        }
        static computePoolOutputShape(t3, e3, n3, r3, i3, o3, a3) {
          if (e3.length <= 0) throw new Error("input shape must be of size greater than 0");
          const s3 = [e3[0], e3[1]];
          return g2.computeShapeHelper(t3, e3, s3, n3, r3, i3, o3, a3), s3;
        }
        static computeConvOutputShape(t3, e3, n3, r3, i3, o3, a3) {
          if (t3.length <= 0 || e3.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
          const s3 = [t3[0], e3[0]];
          return g2.computeShapeHelper(false, t3, s3, n3, r3, i3, o3, a3), s3;
        }
        static computeShapeHelper(t3, e3, n3, r3, i3, o3, a3, s3) {
          if (t3) for (let t4 = 0; t4 < e3.length - 2; t4++) n3.push(1);
          else for (let t4 = 0; t4 < e3.length - 2; t4++) n3.push(g2.adjustPadAndReturnShape(e3[t4 + 2], r3[t4], i3[t4], o3[t4], a3, t4, t4 + e3.length - 2, s3));
        }
        static adjustPadAndReturnShape(t3, e3, n3, r3, i3, o3, a3, s3) {
          const u3 = n3 * (r3 - 1) + 1;
          if (!s3 || "NOTSET" === s3) return Math.floor((t3 + i3[o3] + i3[a3] - u3) / e3 + 1);
          switch (s3) {
            case "VALID":
              return i3[o3] = 0, i3[a3] = 0, Math.floor((t3 - u3) / e3 + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (1 !== n3) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              {
                const n4 = ((t3 + e3 - 1) / e3 - 1) * e3 + r3 - t3;
                return i3[o3] = "SAME_LOWER" === s3 ? Math.floor((n4 + 1) / 2) : Math.floor(n4 / 2), i3[a3] = n4 - i3[o3], Math.floor((t3 + n4 - r3) / e3 + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        }
      }
      e2.PoolConvUtil = g2, e2.MIN_CLIP = -34028234663852886e22, e2.MAX_CLIP = 34028234663852886e22, e2.decodeUtf8String = function(t3) {
        return new TextDecoder().decode(t3);
      };
    }, 7967: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.iterateExtraOptions = void 0, e2.iterateExtraOptions = (t3, n2, r2, i2) => {
        if ("object" == typeof t3 && null !== t3) {
          if (r2.has(t3)) throw new Error("Circular reference in options");
          r2.add(t3);
        }
        Object.entries(t3).forEach(([t4, o2]) => {
          const a2 = n2 ? n2 + t4 : t4;
          if ("object" == typeof o2) (0, e2.iterateExtraOptions)(o2, a2 + ".", r2, i2);
          else if ("string" == typeof o2 || "number" == typeof o2) i2(a2, o2.toString());
          else {
            if ("boolean" != typeof o2) throw new Error("Can't handle extra config type: " + typeof o2);
            i2(a2, o2 ? "1" : "0");
          }
        });
      };
    }, 2157: function(t2, e2, n2) {
      var r2, i2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i3 = Object.getOwnPropertyDescriptor(e3, n3);
        i3 && !("get" in i3 ? !e3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i3);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), o2 = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), a2 = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && i2(e3, t3, n3);
        return o2(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.endProfiling = e2.run = e2.releaseSession = e2.createSession = e2.createSessionFinalize = e2.createSessionAllocate = e2.initOrt = e2.initWasm = void 0;
      const s2 = n2(1670), u2 = a2(n2(349)), c2 = n2(6361), l2 = () => !!s2.env.wasm.proxy && "undefined" != typeof document;
      let p2, f2, d2, h2 = false, g2 = false, b2 = false;
      const m2 = [], y2 = [], _ = [], v2 = [], w2 = [], x2 = [], T2 = () => {
        if (h2 || !g2 || b2 || !p2) throw new Error("worker not ready");
      }, S2 = (t3) => {
        switch (t3.data.type) {
          case "init-wasm":
            h2 = false, t3.data.err ? (b2 = true, f2[1](t3.data.err)) : (g2 = true, f2[0]());
            break;
          case "init-ort":
            t3.data.err ? d2[1](t3.data.err) : d2[0]();
            break;
          case "create_allocate":
            t3.data.err ? m2.shift()[1](t3.data.err) : m2.shift()[0](t3.data.out);
            break;
          case "create_finalize":
            t3.data.err ? y2.shift()[1](t3.data.err) : y2.shift()[0](t3.data.out);
            break;
          case "create":
            t3.data.err ? _.shift()[1](t3.data.err) : _.shift()[0](t3.data.out);
            break;
          case "release":
            t3.data.err ? v2.shift()[1](t3.data.err) : v2.shift()[0]();
            break;
          case "run":
            t3.data.err ? w2.shift()[1](t3.data.err) : w2.shift()[0](t3.data.out);
            break;
          case "end-profiling":
            t3.data.err ? x2.shift()[1](t3.data.err) : x2.shift()[0]();
        }
      }, O2 = "undefined" != typeof document ? null === (r2 = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r2 ? void 0 : r2.src : void 0;
      e2.initWasm = async () => {
        if (l2()) {
          if (g2) return;
          if (h2) throw new Error("multiple calls to 'initWasm()' detected.");
          if (b2) throw new Error("previous call to 'initWasm()' failed.");
          return h2 = true, void 0 === s2.env.wasm.wasmPaths && O2 && 0 !== O2.indexOf("blob:") && (s2.env.wasm.wasmPaths = O2.substr(0, +O2.lastIndexOf("/") + 1)), new Promise((t3, e3) => {
            null == p2 || p2.terminate(), p2 = n2(9710).Z(), p2.onmessage = S2, f2 = [t3, e3];
            const r3 = { type: "init-wasm", in: s2.env.wasm };
            p2.postMessage(r3);
          });
        }
        return (0, c2.initializeWebAssembly)(s2.env.wasm);
      }, e2.initOrt = async (t3, e3) => {
        if (l2()) return T2(), new Promise((n3, r3) => {
          d2 = [n3, r3];
          const i3 = { type: "init-ort", in: { numThreads: t3, loggingLevel: e3 } };
          p2.postMessage(i3);
        });
        u2.initOrt(t3, e3);
      }, e2.createSessionAllocate = async (t3) => l2() ? (T2(), new Promise((e3, n3) => {
        m2.push([e3, n3]);
        const r3 = { type: "create_allocate", in: { model: t3 } };
        p2.postMessage(r3, [t3.buffer]);
      })) : u2.createSessionAllocate(t3), e2.createSessionFinalize = async (t3, e3) => l2() ? (T2(), new Promise((n3, r3) => {
        y2.push([n3, r3]);
        const i3 = { type: "create_finalize", in: { modeldata: t3, options: e3 } };
        p2.postMessage(i3);
      })) : u2.createSessionFinalize(t3, e3), e2.createSession = async (t3, e3) => l2() ? (T2(), new Promise((n3, r3) => {
        _.push([n3, r3]);
        const i3 = { type: "create", in: { model: t3, options: e3 } };
        p2.postMessage(i3, [t3.buffer]);
      })) : u2.createSession(t3, e3), e2.releaseSession = async (t3) => {
        if (l2()) return T2(), new Promise((e3, n3) => {
          v2.push([e3, n3]);
          const r3 = { type: "release", in: t3 };
          p2.postMessage(r3);
        });
        u2.releaseSession(t3);
      }, e2.run = async (t3, e3, n3, r3, i3) => l2() ? (T2(), new Promise((o3, a3) => {
        w2.push([o3, a3]);
        const s3 = { type: "run", in: { sessionId: t3, inputIndices: e3, inputs: n3, outputIndices: r3, options: i3 } };
        p2.postMessage(s3, u2.extractTransferableBuffers(n3));
      })) : u2.run(t3, e3, n3, r3, i3), e2.endProfiling = async (t3) => {
        if (l2()) return T2(), new Promise((e3, n3) => {
          x2.push([e3, n3]);
          const r3 = { type: "end-profiling", in: t3 };
          p2.postMessage(r3);
        });
        u2.endProfiling(t3);
      };
    }, 586: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.setRunOptions = void 0;
      const r2 = n2(7967), i2 = n2(4983), o2 = n2(6361);
      e2.setRunOptions = (t3) => {
        const e3 = (0, o2.getInstance)();
        let n3 = 0;
        const a2 = [], s2 = t3 || {};
        try {
          if (void 0 === (null == t3 ? void 0 : t3.logSeverityLevel)) s2.logSeverityLevel = 2;
          else if ("number" != typeof t3.logSeverityLevel || !Number.isInteger(t3.logSeverityLevel) || t3.logSeverityLevel < 0 || t3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t3.logSeverityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.logVerbosityLevel)) s2.logVerbosityLevel = 0;
          else if ("number" != typeof t3.logVerbosityLevel || !Number.isInteger(t3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t3.logVerbosityLevel}`);
          void 0 === (null == t3 ? void 0 : t3.terminate) && (s2.terminate = false);
          let o3 = 0;
          if (void 0 !== (null == t3 ? void 0 : t3.tag) && (o3 = (0, i2.allocWasmString)(t3.tag, a2)), n3 = e3._OrtCreateRunOptions(s2.logSeverityLevel, s2.logVerbosityLevel, !!s2.terminate, o3), 0 === n3) throw new Error("Can't create run options");
          return void 0 !== (null == t3 ? void 0 : t3.extra) && (0, r2.iterateExtraOptions)(t3.extra, "", /* @__PURE__ */ new WeakSet(), (t4, r3) => {
            const o4 = (0, i2.allocWasmString)(t4, a2), s3 = (0, i2.allocWasmString)(r3, a2);
            if (0 !== e3._OrtAddRunConfigEntry(n3, o4, s3)) throw new Error(`Can't set a run config entry: ${t4} - ${r3}`);
          }), [n3, a2];
        } catch (t4) {
          throw 0 !== n3 && e3._OrtReleaseRunOptions(n3), a2.forEach(e3._free), t4;
        }
      };
    }, 2306: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.OnnxruntimeWebAssemblySessionHandler = void 0;
      const r2 = n2(2806), i2 = n2(1670), o2 = n2(2850), a2 = n2(2157);
      let s2;
      e2.OnnxruntimeWebAssemblySessionHandler = class {
        async createSessionAllocate(t3) {
          const e3 = await fetch(t3), n3 = await e3.arrayBuffer();
          return (0, a2.createSessionAllocate)(new Uint8Array(n3));
        }
        async loadModel(t3, e3) {
          if (s2 || (await (0, a2.initOrt)(i2.env.wasm.numThreads, ((t4) => {
            switch (t4) {
              case "verbose":
                return 0;
              case "info":
                return 1;
              case "warning":
                return 2;
              case "error":
                return 3;
              case "fatal":
                return 4;
              default:
                throw new Error(`unsupported logging level: ${t4}`);
            }
          })(i2.env.logLevel)), s2 = true), "string" == typeof t3) if ("undefined" == typeof fetch) {
            const n3 = await (0, o2.promisify)(r2.readFile)(t3);
            [this.sessionId, this.inputNames, this.outputNames] = await (0, a2.createSession)(n3, e3);
          } else {
            const n3 = await this.createSessionAllocate(t3);
            [this.sessionId, this.inputNames, this.outputNames] = await (0, a2.createSessionFinalize)(n3, e3);
          }
          else [this.sessionId, this.inputNames, this.outputNames] = await (0, a2.createSession)(t3, e3);
        }
        async dispose() {
          return (0, a2.releaseSession)(this.sessionId);
        }
        async run(t3, e3, n3) {
          const r3 = [], o3 = [];
          Object.entries(t3).forEach((t4) => {
            const e4 = t4[0], n4 = t4[1], i3 = this.inputNames.indexOf(e4);
            if (-1 === i3) throw new Error(`invalid input '${e4}'`);
            r3.push(n4), o3.push(i3);
          });
          const s3 = [];
          Object.entries(e3).forEach((t4) => {
            const e4 = t4[0], n4 = this.outputNames.indexOf(e4);
            if (-1 === n4) throw new Error(`invalid output '${e4}'`);
            s3.push(n4);
          });
          const u2 = await (0, a2.run)(this.sessionId, o3, r3.map((t4) => [t4.type, t4.dims, t4.data]), s3, n3), c2 = {};
          for (let t4 = 0; t4 < u2.length; t4++) c2[this.outputNames[s3[t4]]] = new i2.Tensor(u2[t4][0], u2[t4][2], u2[t4][1]);
          return c2;
        }
        startProfiling() {
        }
        endProfiling() {
          (0, a2.endProfiling)(this.sessionId);
        }
      };
    }, 4919: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.setSessionOptions = void 0;
      const r2 = n2(7967), i2 = n2(4983), o2 = n2(6361);
      e2.setSessionOptions = (t3) => {
        const e3 = (0, o2.getInstance)();
        let n3 = 0;
        const a2 = [], s2 = t3 || {};
        ((t4) => {
          t4.extra || (t4.extra = {}), t4.extra.session || (t4.extra.session = {});
          const e4 = t4.extra.session;
          e4.use_ort_model_bytes_directly || (e4.use_ort_model_bytes_directly = "1");
        })(s2);
        try {
          void 0 === (null == t3 ? void 0 : t3.graphOptimizationLevel) && (s2.graphOptimizationLevel = "all");
          const u2 = ((t4) => {
            switch (t4) {
              case "disabled":
                return 0;
              case "basic":
                return 1;
              case "extended":
                return 2;
              case "all":
                return 99;
              default:
                throw new Error(`unsupported graph optimization level: ${t4}`);
            }
          })(s2.graphOptimizationLevel);
          void 0 === (null == t3 ? void 0 : t3.enableCpuMemArena) && (s2.enableCpuMemArena = true), void 0 === (null == t3 ? void 0 : t3.enableMemPattern) && (s2.enableMemPattern = true), void 0 === (null == t3 ? void 0 : t3.executionMode) && (s2.executionMode = "sequential");
          const c2 = ((t4) => {
            switch (t4) {
              case "sequential":
                return 0;
              case "parallel":
                return 1;
              default:
                throw new Error(`unsupported execution mode: ${t4}`);
            }
          })(s2.executionMode);
          let l2 = 0;
          if (void 0 !== (null == t3 ? void 0 : t3.logId) && (l2 = (0, i2.allocWasmString)(t3.logId, a2)), void 0 === (null == t3 ? void 0 : t3.logSeverityLevel)) s2.logSeverityLevel = 2;
          else if ("number" != typeof t3.logSeverityLevel || !Number.isInteger(t3.logSeverityLevel) || t3.logSeverityLevel < 0 || t3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t3.logSeverityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.logVerbosityLevel)) s2.logVerbosityLevel = 0;
          else if ("number" != typeof t3.logVerbosityLevel || !Number.isInteger(t3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t3.logVerbosityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.enableProfiling) && (s2.enableProfiling = false), n3 = e3._OrtCreateSessionOptions(u2, !!s2.enableCpuMemArena, !!s2.enableMemPattern, c2, !!s2.enableProfiling, 0, l2, s2.logSeverityLevel, s2.logVerbosityLevel), 0 === n3) throw new Error("Can't create session options");
          return (null == t3 ? void 0 : t3.executionProviders) && ((t4, e4, n4) => {
            for (const r3 of e4) {
              let e5 = "string" == typeof r3 ? r3 : r3.name;
              switch (e5) {
                case "xnnpack":
                  e5 = "XNNPACK";
                  break;
                case "wasm":
                case "cpu":
                  continue;
                default:
                  throw new Error(`not supported EP: ${e5}`);
              }
              const a3 = (0, i2.allocWasmString)(e5, n4);
              if (0 !== (0, o2.getInstance)()._OrtAppendExecutionProvider(t4, a3)) throw new Error(`Can't append execution provider: ${e5}`);
            }
          })(n3, t3.executionProviders, a2), void 0 !== (null == t3 ? void 0 : t3.extra) && (0, r2.iterateExtraOptions)(t3.extra, "", /* @__PURE__ */ new WeakSet(), (t4, r3) => {
            const o3 = (0, i2.allocWasmString)(t4, a2), s3 = (0, i2.allocWasmString)(r3, a2);
            if (0 !== e3._OrtAddSessionConfigEntry(n3, o3, s3)) throw new Error(`Can't set a session config entry: ${t4} - ${r3}`);
          }), [n3, a2];
        } catch (t4) {
          throw 0 !== n3 && e3._OrtReleaseSessionOptions(n3), a2.forEach(e3._free), t4;
        }
      };
    }, 4983: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.allocWasmString = void 0;
      const r2 = n2(6361);
      e2.allocWasmString = (t3, e3) => {
        const n3 = (0, r2.getInstance)(), i2 = n3.lengthBytesUTF8(t3) + 1, o2 = n3._malloc(i2);
        return n3.stringToUTF8(t3, o2, i2), e3.push(o2), o2;
      };
    }, 349: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.extractTransferableBuffers = e2.endProfiling = e2.run = e2.releaseSession = e2.createSession = e2.createSessionFinalize = e2.createSessionAllocate = e2.initOrt = void 0;
      const r2 = n2(586), i2 = n2(4919), o2 = n2(4983), a2 = n2(6361);
      e2.initOrt = (t3, e3) => {
        const n3 = (0, a2.getInstance)()._OrtInit(t3, e3);
        if (0 !== n3) throw new Error(`Can't initialize onnxruntime. error code = ${n3}`);
      };
      const s2 = /* @__PURE__ */ new Map();
      e2.createSessionAllocate = (t3) => {
        const e3 = (0, a2.getInstance)(), n3 = e3._malloc(t3.byteLength);
        return e3.HEAPU8.set(t3, n3), [n3, t3.byteLength];
      }, e2.createSessionFinalize = (t3, e3) => {
        const n3 = (0, a2.getInstance)();
        let r3 = 0, o3 = 0, u3 = [];
        try {
          if ([o3, u3] = (0, i2.setSessionOptions)(e3), r3 = n3._OrtCreateSession(t3[0], t3[1], o3), 0 === r3) throw new Error("Can't create a session");
        } finally {
          n3._free(t3[0]), n3._OrtReleaseSessionOptions(o3), u3.forEach(n3._free);
        }
        const c3 = n3._OrtGetInputCount(r3), l3 = n3._OrtGetOutputCount(r3), p2 = [], f2 = [], d2 = [], h2 = [];
        for (let t4 = 0; t4 < c3; t4++) {
          const e4 = n3._OrtGetInputName(r3, t4);
          if (0 === e4) throw new Error("Can't get an input name");
          f2.push(e4), p2.push(n3.UTF8ToString(e4));
        }
        for (let t4 = 0; t4 < l3; t4++) {
          const e4 = n3._OrtGetOutputName(r3, t4);
          if (0 === e4) throw new Error("Can't get an output name");
          h2.push(e4), d2.push(n3.UTF8ToString(e4));
        }
        return s2.set(r3, [r3, f2, h2]), [r3, p2, d2];
      }, e2.createSession = (t3, n3) => {
        const r3 = (0, e2.createSessionAllocate)(t3);
        return (0, e2.createSessionFinalize)(r3, n3);
      }, e2.releaseSession = (t3) => {
        const e3 = (0, a2.getInstance)(), n3 = s2.get(t3);
        if (!n3) throw new Error("invalid session id");
        const r3 = n3[0], i3 = n3[1], o3 = n3[2];
        i3.forEach(e3._OrtFree), o3.forEach(e3._OrtFree), e3._OrtReleaseSession(r3), s2.delete(t3);
      };
      const u2 = (t3) => {
        switch (t3) {
          case "int8":
            return 3;
          case "uint8":
            return 2;
          case "bool":
            return 9;
          case "int16":
            return 5;
          case "uint16":
            return 4;
          case "int32":
            return 6;
          case "uint32":
            return 12;
          case "float32":
            return 1;
          case "float64":
            return 11;
          case "string":
            return 8;
          case "int64":
            return 7;
          case "uint64":
            return 13;
          default:
            throw new Error(`unsupported data type: ${t3}`);
        }
      }, c2 = (t3) => {
        switch (t3) {
          case 3:
            return "int8";
          case 2:
            return "uint8";
          case 9:
            return "bool";
          case 5:
            return "int16";
          case 4:
            return "uint16";
          case 6:
            return "int32";
          case 12:
            return "uint32";
          case 1:
            return "float32";
          case 11:
            return "float64";
          case 8:
            return "string";
          case 7:
            return "int64";
          case 13:
            return "uint64";
          default:
            throw new Error(`unsupported data type: ${t3}`);
        }
      }, l2 = (t3) => {
        switch (t3) {
          case "float32":
            return Float32Array;
          case "uint8":
          case "bool":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${t3}`);
        }
      };
      e2.run = (t3, e3, n3, i3, p2) => {
        const f2 = (0, a2.getInstance)(), d2 = s2.get(t3);
        if (!d2) throw new Error("invalid session id");
        const h2 = d2[0], g2 = d2[1], b2 = d2[2], m2 = e3.length, y2 = i3.length;
        let _ = 0, v2 = [];
        const w2 = [], x2 = [];
        try {
          [_, v2] = (0, r2.setRunOptions)(p2);
          for (let t5 = 0; t5 < m2; t5++) {
            const e4 = n3[t5][0], r3 = n3[t5][1], i4 = n3[t5][2];
            let a4, s4;
            if (Array.isArray(i4)) {
              s4 = 4 * i4.length, a4 = f2._malloc(s4), x2.push(a4);
              let t6 = a4 / 4;
              for (let e5 = 0; e5 < i4.length; e5++) {
                if ("string" != typeof i4[e5]) throw new TypeError(`tensor data at index ${e5} is not a string`);
                f2.HEAPU32[t6++] = (0, o2.allocWasmString)(i4[e5], x2);
              }
            } else s4 = i4.byteLength, a4 = f2._malloc(s4), x2.push(a4), f2.HEAPU8.set(new Uint8Array(i4.buffer, i4.byteOffset, s4), a4);
            const c3 = f2.stackSave(), l3 = f2.stackAlloc(4 * r3.length);
            try {
              let t6 = l3 / 4;
              r3.forEach((e5) => f2.HEAP32[t6++] = e5);
              const n4 = f2._OrtCreateTensor(u2(e4), a4, s4, l3, r3.length);
              if (0 === n4) throw new Error("Can't create a tensor");
              w2.push(n4);
            } finally {
              f2.stackRestore(c3);
            }
          }
          const t4 = f2.stackSave(), a3 = f2.stackAlloc(4 * m2), s3 = f2.stackAlloc(4 * m2), d3 = f2.stackAlloc(4 * y2), T2 = f2.stackAlloc(4 * y2);
          try {
            let n4 = a3 / 4, r3 = s3 / 4, o3 = d3 / 4, u3 = T2 / 4;
            for (let t5 = 0; t5 < m2; t5++) f2.HEAPU32[n4++] = w2[t5], f2.HEAPU32[r3++] = g2[e3[t5]];
            for (let t5 = 0; t5 < y2; t5++) f2.HEAPU32[o3++] = 0, f2.HEAPU32[u3++] = b2[i3[t5]];
            let p3 = f2._OrtRun(h2, s3, a3, m2, T2, y2, d3, _);
            const v3 = [];
            if (0 === p3) for (let t5 = 0; t5 < y2; t5++) {
              const e4 = f2.HEAPU32[d3 / 4 + t5], n5 = f2.stackSave(), r4 = f2.stackAlloc(16);
              let i4, o4 = 0;
              try {
                if (p3 = f2._OrtGetTensorData(e4, r4, r4 + 4, r4 + 8, r4 + 12), 0 !== p3) throw new Error(`Can't access output tensor data. error code = ${p3}`);
                let t6 = r4 / 4;
                const a4 = f2.HEAPU32[t6++];
                o4 = f2.HEAPU32[t6++];
                const s4 = f2.HEAPU32[t6++], u4 = f2.HEAPU32[t6++], d4 = [];
                for (let t7 = 0; t7 < u4; t7++) d4.push(f2.HEAPU32[s4 / 4 + t7]);
                f2._OrtFree(s4);
                const h3 = 0 === d4.length ? 1 : d4.reduce((t7, e5) => t7 * e5);
                if (i4 = c2(a4), "string" === i4) {
                  const t7 = [];
                  let e5 = o4 / 4;
                  for (let n6 = 0; n6 < h3; n6++) {
                    const r5 = f2.HEAPU32[e5++], i5 = n6 === h3 - 1 ? void 0 : f2.HEAPU32[e5] - r5;
                    t7.push(f2.UTF8ToString(r5, i5));
                  }
                  v3.push([i4, d4, t7]);
                } else {
                  const t7 = new (l2(i4))(h3);
                  new Uint8Array(t7.buffer, t7.byteOffset, t7.byteLength).set(f2.HEAPU8.subarray(o4, o4 + t7.byteLength)), v3.push([i4, d4, t7]);
                }
              } finally {
                f2.stackRestore(n5), "string" === i4 && o4 && f2._free(o4), f2._OrtReleaseTensor(e4);
              }
            }
            if (0 === p3) return v3;
            throw new Error(`failed to call OrtRun(). error code = ${p3}.`);
          } finally {
            f2.stackRestore(t4);
          }
        } finally {
          w2.forEach(f2._OrtReleaseTensor), x2.forEach(f2._free), f2._OrtReleaseRunOptions(_), v2.forEach(f2._free);
        }
      }, e2.endProfiling = (t3) => {
        const e3 = (0, a2.getInstance)(), n3 = s2.get(t3);
        if (!n3) throw new Error("invalid session id");
        const r3 = n3[0], i3 = e3._OrtEndProfiling(r3);
        if (0 === i3) throw new Error("Can't get an profile file name");
        e3._OrtFree(i3);
      }, e2.extractTransferableBuffers = (t3) => {
        const e3 = [];
        for (const n3 of t3) {
          const t4 = n3[2];
          !Array.isArray(t4) && t4.buffer && e3.push(t4.buffer);
        }
        return e3;
      };
    }, 6361: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i3 = Object.getOwnPropertyDescriptor(e3, n3);
        i3 && !("get" in i3 ? !e3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i3);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i2 = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o2 = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i2(e3, t3), e3;
      }, a2 = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.dispose = e2.getInstance = e2.initializeWebAssembly = void 0;
      const s2 = o2(n2(6449)), u2 = a2(n2(932)), c2 = n2(3474);
      let l2, p2 = false, f2 = false, d2 = false;
      const h2 = (t3, e3) => e3 ? t3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : t3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
      e2.initializeWebAssembly = async (t3) => {
        if (p2) return Promise.resolve();
        if (f2) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        if (d2) throw new Error("previous call to 'initializeWebAssembly()' failed.");
        f2 = true;
        const e3 = t3.initTimeout, r3 = t3.numThreads, i3 = t3.simd, o3 = r3 > 1 && (() => {
          try {
            return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
          } catch (t4) {
            return false;
          }
        })(), a3 = i3 && (() => {
          try {
            return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
          } catch (t4) {
            return false;
          }
        })(), g2 = "string" == typeof t3.wasmPaths ? t3.wasmPaths : void 0, b2 = h2(false, o3), m2 = h2(a3, o3), y2 = "object" == typeof t3.wasmPaths ? t3.wasmPaths[m2] : void 0;
        let _ = false;
        const v2 = [];
        if (e3 > 0 && v2.push(new Promise((t4) => {
          setTimeout(() => {
            _ = true, t4();
          }, e3);
        })), v2.push(new Promise((t4, e4) => {
          const r4 = o3 ? c2 : u2.default, i4 = { locateFile: (t5, e5) => o3 && t5.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n2(4154)], { type: "text/javascript" })) : t5 === b2 ? null != y2 ? y2 : (null != g2 ? g2 : e5) + m2 : e5 + t5 };
          if (o3) if ("undefined" == typeof Blob) i4.mainScriptUrlOrBlob = s2.join("/", "ort-wasm-threaded.js");
          else {
            const t5 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r4.toString()}})();`;
            i4.mainScriptUrlOrBlob = new Blob([t5], { type: "text/javascript" });
          }
          r4(i4).then((e5) => {
            f2 = false, p2 = true, l2 = e5, t4();
          }, (t5) => {
            f2 = false, d2 = true, e4(t5);
          });
        })), await Promise.race(v2), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e3}ms`);
      }, e2.getInstance = () => {
        if (p2 && l2) return l2;
        throw new Error("WebAssembly is not initialized yet.");
      }, e2.dispose = () => {
        var t3;
        !p2 || f2 || d2 || (f2 = true, null === (t3 = l2.PThread) || void 0 === t3 || t3.terminateAllThreads(), l2 = void 0, f2 = false, p2 = false, d2 = true);
      };
    }, 9710: (t2, e2, n2) => {
      n2.d(e2, { Z: () => o2 });
      var r2 = n2(477), i2 = n2.n(r2);
      function o2() {
        return i2()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
      }
    }, 477: (t2) => {
      t2.exports = function(t3, e2, n2, r2) {
        var i2 = self || window;
        try {
          try {
            var o2;
            try {
              o2 = new i2.Blob([t3]);
            } catch (e3) {
              (o2 = new (i2.BlobBuilder || i2.WebKitBlobBuilder || i2.MozBlobBuilder || i2.MSBlobBuilder)()).append(t3), o2 = o2.getBlob();
            }
            var a2 = i2.URL || i2.webkitURL, s2 = a2.createObjectURL(o2), u2 = new i2[e2](s2, n2);
            return a2.revokeObjectURL(s2), u2;
          } catch (r3) {
            return new i2[e2]("data:application/javascript,".concat(encodeURIComponent(t3)), n2);
          }
        } catch (t4) {
          if (!r2) throw Error("Inline worker is not supported");
          return new i2[e2](r2, n2);
        }
      };
    }, 4154: (t2) => {
      t2.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
    }, 1670: (t2) => {
      t2.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
    }, 7067: () => {
    }, 1296: () => {
    }, 1384: () => {
    }, 3993: () => {
    }, 908: () => {
    }, 6953: () => {
    }, 9925: () => {
    }, 2806: () => {
    }, 6449: () => {
    }, 2850: () => {
    }, 5381: () => {
    }, 5686: (t2, e2, n2) => {
      n2.r(e2), n2.d(e2, { flatbuffers: () => r2 });
      var r2 = {};
      r2.Offset, r2.Table, r2.SIZEOF_SHORT = 2, r2.SIZEOF_INT = 4, r2.FILE_IDENTIFIER_LENGTH = 4, r2.SIZE_PREFIX_LENGTH = 4, r2.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r2.int32 = new Int32Array(2), r2.float32 = new Float32Array(r2.int32.buffer), r2.float64 = new Float64Array(r2.int32.buffer), r2.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r2.Long = function(t3, e3) {
        this.low = 0 | t3, this.high = 0 | e3;
      }, r2.Long.create = function(t3, e3) {
        return 0 == t3 && 0 == e3 ? r2.Long.ZERO : new r2.Long(t3, e3);
      }, r2.Long.prototype.toFloat64 = function() {
        return (this.low >>> 0) + 4294967296 * this.high;
      }, r2.Long.prototype.equals = function(t3) {
        return this.low == t3.low && this.high == t3.high;
      }, r2.Long.ZERO = new r2.Long(0, 0), r2.Builder = function(t3) {
        if (t3) e3 = t3;
        else var e3 = 1024;
        this.bb = r2.ByteBuffer.allocate(e3), this.space = e3, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
      }, r2.Builder.prototype.clear = function() {
        this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
      }, r2.Builder.prototype.forceDefaults = function(t3) {
        this.force_defaults = t3;
      }, r2.Builder.prototype.dataBuffer = function() {
        return this.bb;
      }, r2.Builder.prototype.asUint8Array = function() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
      }, r2.Builder.prototype.prep = function(t3, e3) {
        t3 > this.minalign && (this.minalign = t3);
        for (var n3 = 1 + ~(this.bb.capacity() - this.space + e3) & t3 - 1; this.space < n3 + t3 + e3; ) {
          var i2 = this.bb.capacity();
          this.bb = r2.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i2;
        }
        this.pad(n3);
      }, r2.Builder.prototype.pad = function(t3) {
        for (var e3 = 0; e3 < t3; e3++) this.bb.writeInt8(--this.space, 0);
      }, r2.Builder.prototype.writeInt8 = function(t3) {
        this.bb.writeInt8(this.space -= 1, t3);
      }, r2.Builder.prototype.writeInt16 = function(t3) {
        this.bb.writeInt16(this.space -= 2, t3);
      }, r2.Builder.prototype.writeInt32 = function(t3) {
        this.bb.writeInt32(this.space -= 4, t3);
      }, r2.Builder.prototype.writeInt64 = function(t3) {
        this.bb.writeInt64(this.space -= 8, t3);
      }, r2.Builder.prototype.writeFloat32 = function(t3) {
        this.bb.writeFloat32(this.space -= 4, t3);
      }, r2.Builder.prototype.writeFloat64 = function(t3) {
        this.bb.writeFloat64(this.space -= 8, t3);
      }, r2.Builder.prototype.addInt8 = function(t3) {
        this.prep(1, 0), this.writeInt8(t3);
      }, r2.Builder.prototype.addInt16 = function(t3) {
        this.prep(2, 0), this.writeInt16(t3);
      }, r2.Builder.prototype.addInt32 = function(t3) {
        this.prep(4, 0), this.writeInt32(t3);
      }, r2.Builder.prototype.addInt64 = function(t3) {
        this.prep(8, 0), this.writeInt64(t3);
      }, r2.Builder.prototype.addFloat32 = function(t3) {
        this.prep(4, 0), this.writeFloat32(t3);
      }, r2.Builder.prototype.addFloat64 = function(t3) {
        this.prep(8, 0), this.writeFloat64(t3);
      }, r2.Builder.prototype.addFieldInt8 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt8(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt16 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt16(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt32 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt32(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt64 = function(t3, e3, n3) {
        !this.force_defaults && e3.equals(n3) || (this.addInt64(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldFloat32 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addFloat32(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldFloat64 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addFloat64(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldOffset = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addOffset(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldStruct = function(t3, e3, n3) {
        e3 != n3 && (this.nested(e3), this.slot(t3));
      }, r2.Builder.prototype.nested = function(t3) {
        if (t3 != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.");
      }, r2.Builder.prototype.notNested = function() {
        if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.");
      }, r2.Builder.prototype.slot = function(t3) {
        this.vtable[t3] = this.offset();
      }, r2.Builder.prototype.offset = function() {
        return this.bb.capacity() - this.space;
      }, r2.Builder.growByteBuffer = function(t3) {
        var e3 = t3.capacity();
        if (3221225472 & e3) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        var n3 = e3 << 1, i2 = r2.ByteBuffer.allocate(n3);
        return i2.setPosition(n3 - e3), i2.bytes().set(t3.bytes(), n3 - e3), i2;
      }, r2.Builder.prototype.addOffset = function(t3) {
        this.prep(r2.SIZEOF_INT, 0), this.writeInt32(this.offset() - t3 + r2.SIZEOF_INT);
      }, r2.Builder.prototype.startObject = function(t3) {
        this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t3;
        for (var e3 = 0; e3 < t3; e3++) this.vtable[e3] = 0;
        this.isNested = true, this.object_start = this.offset();
      }, r2.Builder.prototype.endObject = function() {
        if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
        this.addInt32(0);
        for (var t3 = this.offset(), e3 = this.vtable_in_use - 1; e3 >= 0 && 0 == this.vtable[e3]; e3--) ;
        for (var n3 = e3 + 1; e3 >= 0; e3--) this.addInt16(0 != this.vtable[e3] ? t3 - this.vtable[e3] : 0);
        this.addInt16(t3 - this.object_start);
        var i2 = (n3 + 2) * r2.SIZEOF_SHORT;
        this.addInt16(i2);
        var o2 = 0, a2 = this.space;
        t: for (e3 = 0; e3 < this.vtables.length; e3++) {
          var s2 = this.bb.capacity() - this.vtables[e3];
          if (i2 == this.bb.readInt16(s2)) {
            for (var u2 = r2.SIZEOF_SHORT; u2 < i2; u2 += r2.SIZEOF_SHORT) if (this.bb.readInt16(a2 + u2) != this.bb.readInt16(s2 + u2)) continue t;
            o2 = this.vtables[e3];
            break;
          }
        }
        return o2 ? (this.space = this.bb.capacity() - t3, this.bb.writeInt32(this.space, o2 - t3)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t3, this.offset() - t3)), this.isNested = false, t3;
      }, r2.Builder.prototype.finish = function(t3, e3, n3) {
        var i2 = n3 ? r2.SIZE_PREFIX_LENGTH : 0;
        if (e3) {
          var o2 = e3;
          if (this.prep(this.minalign, r2.SIZEOF_INT + r2.FILE_IDENTIFIER_LENGTH + i2), o2.length != r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r2.FILE_IDENTIFIER_LENGTH);
          for (var a2 = r2.FILE_IDENTIFIER_LENGTH - 1; a2 >= 0; a2--) this.writeInt8(o2.charCodeAt(a2));
        }
        this.prep(this.minalign, r2.SIZEOF_INT + i2), this.addOffset(t3), i2 && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
      }, r2.Builder.prototype.finishSizePrefixed = function(t3, e3) {
        this.finish(t3, e3, true);
      }, r2.Builder.prototype.requiredField = function(t3, e3) {
        var n3 = this.bb.capacity() - t3, r3 = n3 - this.bb.readInt32(n3);
        if (0 == this.bb.readInt16(r3 + e3)) throw new Error("FlatBuffers: field " + e3 + " must be set");
      }, r2.Builder.prototype.startVector = function(t3, e3, n3) {
        this.notNested(), this.vector_num_elems = e3, this.prep(r2.SIZEOF_INT, t3 * e3), this.prep(n3, t3 * e3);
      }, r2.Builder.prototype.endVector = function() {
        return this.writeInt32(this.vector_num_elems), this.offset();
      }, r2.Builder.prototype.createString = function(t3) {
        if (t3 instanceof Uint8Array) var e3 = t3;
        else {
          e3 = [];
          for (var n3 = 0; n3 < t3.length; ) {
            var r3, i2 = t3.charCodeAt(n3++);
            (r3 = i2 < 55296 || i2 >= 56320 ? i2 : (i2 << 10) + t3.charCodeAt(n3++) + -56613888) < 128 ? e3.push(r3) : (r3 < 2048 ? e3.push(r3 >> 6 & 31 | 192) : (r3 < 65536 ? e3.push(r3 >> 12 & 15 | 224) : e3.push(r3 >> 18 & 7 | 240, r3 >> 12 & 63 | 128), e3.push(r3 >> 6 & 63 | 128)), e3.push(63 & r3 | 128));
          }
        }
        this.addInt8(0), this.startVector(1, e3.length, 1), this.bb.setPosition(this.space -= e3.length), n3 = 0;
        for (var o2 = this.space, a2 = this.bb.bytes(); n3 < e3.length; n3++) a2[o2++] = e3[n3];
        return this.endVector();
      }, r2.Builder.prototype.createLong = function(t3, e3) {
        return r2.Long.create(t3, e3);
      }, r2.ByteBuffer = function(t3) {
        this.bytes_ = t3, this.position_ = 0;
      }, r2.ByteBuffer.allocate = function(t3) {
        return new r2.ByteBuffer(new Uint8Array(t3));
      }, r2.ByteBuffer.prototype.clear = function() {
        this.position_ = 0;
      }, r2.ByteBuffer.prototype.bytes = function() {
        return this.bytes_;
      }, r2.ByteBuffer.prototype.position = function() {
        return this.position_;
      }, r2.ByteBuffer.prototype.setPosition = function(t3) {
        this.position_ = t3;
      }, r2.ByteBuffer.prototype.capacity = function() {
        return this.bytes_.length;
      }, r2.ByteBuffer.prototype.readInt8 = function(t3) {
        return this.readUint8(t3) << 24 >> 24;
      }, r2.ByteBuffer.prototype.readUint8 = function(t3) {
        return this.bytes_[t3];
      }, r2.ByteBuffer.prototype.readInt16 = function(t3) {
        return this.readUint16(t3) << 16 >> 16;
      }, r2.ByteBuffer.prototype.readUint16 = function(t3) {
        return this.bytes_[t3] | this.bytes_[t3 + 1] << 8;
      }, r2.ByteBuffer.prototype.readInt32 = function(t3) {
        return this.bytes_[t3] | this.bytes_[t3 + 1] << 8 | this.bytes_[t3 + 2] << 16 | this.bytes_[t3 + 3] << 24;
      }, r2.ByteBuffer.prototype.readUint32 = function(t3) {
        return this.readInt32(t3) >>> 0;
      }, r2.ByteBuffer.prototype.readInt64 = function(t3) {
        return new r2.Long(this.readInt32(t3), this.readInt32(t3 + 4));
      }, r2.ByteBuffer.prototype.readUint64 = function(t3) {
        return new r2.Long(this.readUint32(t3), this.readUint32(t3 + 4));
      }, r2.ByteBuffer.prototype.readFloat32 = function(t3) {
        return r2.int32[0] = this.readInt32(t3), r2.float32[0];
      }, r2.ByteBuffer.prototype.readFloat64 = function(t3) {
        return r2.int32[r2.isLittleEndian ? 0 : 1] = this.readInt32(t3), r2.int32[r2.isLittleEndian ? 1 : 0] = this.readInt32(t3 + 4), r2.float64[0];
      }, r2.ByteBuffer.prototype.writeInt8 = function(t3, e3) {
        this.bytes_[t3] = e3;
      }, r2.ByteBuffer.prototype.writeUint8 = function(t3, e3) {
        this.bytes_[t3] = e3;
      }, r2.ByteBuffer.prototype.writeInt16 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8;
      }, r2.ByteBuffer.prototype.writeUint16 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8;
      }, r2.ByteBuffer.prototype.writeInt32 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8, this.bytes_[t3 + 2] = e3 >> 16, this.bytes_[t3 + 3] = e3 >> 24;
      }, r2.ByteBuffer.prototype.writeUint32 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8, this.bytes_[t3 + 2] = e3 >> 16, this.bytes_[t3 + 3] = e3 >> 24;
      }, r2.ByteBuffer.prototype.writeInt64 = function(t3, e3) {
        this.writeInt32(t3, e3.low), this.writeInt32(t3 + 4, e3.high);
      }, r2.ByteBuffer.prototype.writeUint64 = function(t3, e3) {
        this.writeUint32(t3, e3.low), this.writeUint32(t3 + 4, e3.high);
      }, r2.ByteBuffer.prototype.writeFloat32 = function(t3, e3) {
        r2.float32[0] = e3, this.writeInt32(t3, r2.int32[0]);
      }, r2.ByteBuffer.prototype.writeFloat64 = function(t3, e3) {
        r2.float64[0] = e3, this.writeInt32(t3, r2.int32[r2.isLittleEndian ? 0 : 1]), this.writeInt32(t3 + 4, r2.int32[r2.isLittleEndian ? 1 : 0]);
      }, r2.ByteBuffer.prototype.getBufferIdentifier = function() {
        if (this.bytes_.length < this.position_ + r2.SIZEOF_INT + r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
        for (var t3 = "", e3 = 0; e3 < r2.FILE_IDENTIFIER_LENGTH; e3++) t3 += String.fromCharCode(this.readInt8(this.position_ + r2.SIZEOF_INT + e3));
        return t3;
      }, r2.ByteBuffer.prototype.__offset = function(t3, e3) {
        var n3 = t3 - this.readInt32(t3);
        return e3 < this.readInt16(n3) ? this.readInt16(n3 + e3) : 0;
      }, r2.ByteBuffer.prototype.__union = function(t3, e3) {
        return t3.bb_pos = e3 + this.readInt32(e3), t3.bb = this, t3;
      }, r2.ByteBuffer.prototype.__string = function(t3, e3) {
        t3 += this.readInt32(t3);
        var n3 = this.readInt32(t3), i2 = "", o2 = 0;
        if (t3 += r2.SIZEOF_INT, e3 === r2.Encoding.UTF8_BYTES) return this.bytes_.subarray(t3, t3 + n3);
        for (; o2 < n3; ) {
          var a2, s2 = this.readUint8(t3 + o2++);
          if (s2 < 192) a2 = s2;
          else {
            var u2 = this.readUint8(t3 + o2++);
            if (s2 < 224) a2 = (31 & s2) << 6 | 63 & u2;
            else {
              var c2 = this.readUint8(t3 + o2++);
              a2 = s2 < 240 ? (15 & s2) << 12 | (63 & u2) << 6 | 63 & c2 : (7 & s2) << 18 | (63 & u2) << 12 | (63 & c2) << 6 | 63 & this.readUint8(t3 + o2++);
            }
          }
          a2 < 65536 ? i2 += String.fromCharCode(a2) : (a2 -= 65536, i2 += String.fromCharCode(55296 + (a2 >> 10), 56320 + (1023 & a2)));
        }
        return i2;
      }, r2.ByteBuffer.prototype.__indirect = function(t3) {
        return t3 + this.readInt32(t3);
      }, r2.ByteBuffer.prototype.__vector = function(t3) {
        return t3 + this.readInt32(t3) + r2.SIZEOF_INT;
      }, r2.ByteBuffer.prototype.__vector_len = function(t3) {
        return this.readInt32(t3 + this.readInt32(t3));
      }, r2.ByteBuffer.prototype.__has_identifier = function(t3) {
        if (t3.length != r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r2.FILE_IDENTIFIER_LENGTH);
        for (var e3 = 0; e3 < r2.FILE_IDENTIFIER_LENGTH; e3++) if (t3.charCodeAt(e3) != this.readInt8(this.position_ + r2.SIZEOF_INT + e3)) return false;
        return true;
      }, r2.ByteBuffer.prototype.createLong = function(t3, e3) {
        return r2.Long.create(t3, e3);
      };
    } }, __webpack_module_cache__ = {};
    function __webpack_require__(t2) {
      var e2 = __webpack_module_cache__[t2];
      if (void 0 !== e2) return e2.exports;
      var n2 = __webpack_module_cache__[t2] = { exports: {} };
      return __webpack_modules__[t2].call(n2.exports, n2, n2.exports, __webpack_require__), n2.exports;
    }
    __webpack_require__.n = (t2) => {
      var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
      return __webpack_require__.d(e2, { a: e2 }), e2;
    }, __webpack_require__.d = (t2, e2) => {
      for (var n2 in e2) __webpack_require__.o(e2, n2) && !__webpack_require__.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, __webpack_require__.g = function() {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t2) {
        if ("object" == typeof window) return window;
      }
    }(), __webpack_require__.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), __webpack_require__.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var __webpack_exports__ = __webpack_require__(6018);
    return __webpack_exports__;
  })());
})(ortWeb_min);
var ortWeb_minExports = ortWeb_min.exports;
var assetPath = {};
Object.defineProperty(assetPath, "__esModule", { value: true });
assetPath.baseAssetPath = void 0;
const isWeb = typeof window !== "undefined" && typeof window.document !== "undefined";
const currentScript = isWeb ? window.document.currentScript : null;
let basePath = "/";
if (currentScript) {
  basePath = currentScript.src.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
}
assetPath.baseAssetPath = basePath;
var defaultModelFetcher$1 = {};
Object.defineProperty(defaultModelFetcher$1, "__esModule", { value: true });
defaultModelFetcher$1.defaultModelFetcher = void 0;
const defaultModelFetcher = (path2) => {
  return fetch(path2).then((model) => model.arrayBuffer());
};
defaultModelFetcher$1.defaultModelFetcher = defaultModelFetcher;
var frameProcessor = {};
var logging = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.log = exports2.LOG_PREFIX = void 0;
  exports2.LOG_PREFIX = "[VAD]";
  const levels = ["error", "debug", "warn"];
  function getLog(level) {
    return (...args) => {
      console[level](exports2.LOG_PREFIX, ...args);
    };
  }
  const _log = levels.reduce((acc, level) => {
    acc[level] = getLog(level);
    return acc;
  }, {});
  exports2.log = _log;
})(logging);
var messages = {};
Object.defineProperty(messages, "__esModule", { value: true });
messages.Message = void 0;
var Message$1;
(function(Message3) {
  Message3["AudioFrame"] = "AUDIO_FRAME";
  Message3["SpeechStart"] = "SPEECH_START";
  Message3["VADMisfire"] = "VAD_MISFIRE";
  Message3["SpeechEnd"] = "SPEECH_END";
  Message3["SpeechStop"] = "SPEECH_STOP";
})(Message$1 || (messages.Message = Message$1 = {}));
Object.defineProperty(frameProcessor, "__esModule", { value: true });
frameProcessor.FrameProcessor = frameProcessor.validateOptions = frameProcessor.defaultV5FrameProcessorOptions = frameProcessor.defaultLegacyFrameProcessorOptions = void 0;
const logging_1$3 = logging;
const messages_1 = messages;
const RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
frameProcessor.defaultLegacyFrameProcessorOptions = {
  positiveSpeechThreshold: 0.5,
  negativeSpeechThreshold: 0.5 - 0.15,
  preSpeechPadFrames: 1,
  redemptionFrames: 8,
  frameSamples: 1536,
  minSpeechFrames: 3,
  submitUserSpeechOnPause: false
};
frameProcessor.defaultV5FrameProcessorOptions = {
  positiveSpeechThreshold: 0.5,
  negativeSpeechThreshold: 0.5 - 0.15,
  preSpeechPadFrames: 3,
  redemptionFrames: 24,
  frameSamples: 512,
  minSpeechFrames: 9,
  submitUserSpeechOnPause: false
};
function validateOptions(options) {
  if (!RECOMMENDED_FRAME_SAMPLES.includes(options.frameSamples)) {
    logging_1$3.log.warn("You are using an unusual frame size");
  }
  if (options.positiveSpeechThreshold < 0 || options.positiveSpeechThreshold > 1) {
    logging_1$3.log.error("positiveSpeechThreshold should be a number between 0 and 1");
  }
  if (options.negativeSpeechThreshold < 0 || options.negativeSpeechThreshold > options.positiveSpeechThreshold) {
    logging_1$3.log.error("negativeSpeechThreshold should be between 0 and positiveSpeechThreshold");
  }
  if (options.preSpeechPadFrames < 0) {
    logging_1$3.log.error("preSpeechPadFrames should be positive");
  }
  if (options.redemptionFrames < 0) {
    logging_1$3.log.error("redemptionFrames should be positive");
  }
}
frameProcessor.validateOptions = validateOptions;
const concatArrays = (arrays) => {
  const sizes2 = arrays.reduce((out, next2) => {
    out.push(out.at(-1) + next2.length);
    return out;
  }, [0]);
  const outArray = new Float32Array(sizes2.at(-1));
  arrays.forEach((arr, index) => {
    const place = sizes2[index];
    outArray.set(arr, place);
  });
  return outArray;
};
class FrameProcessor {
  constructor(modelProcessFunc, modelResetFunc, options) {
    this.modelProcessFunc = modelProcessFunc;
    this.modelResetFunc = modelResetFunc;
    this.options = options;
    this.speaking = false;
    this.redemptionCounter = 0;
    this.active = false;
    this.reset = () => {
      this.speaking = false;
      this.audioBuffer = [];
      this.modelResetFunc();
      this.redemptionCounter = 0;
    };
    this.pause = () => {
      this.active = false;
      if (this.options.submitUserSpeechOnPause) {
        return this.endSegment();
      } else {
        this.reset();
        return {};
      }
    };
    this.resume = () => {
      this.active = true;
    };
    this.endSegment = () => {
      const audioBuffer = this.audioBuffer;
      this.audioBuffer = [];
      const speaking = this.speaking;
      this.reset();
      const speechFrameCount = audioBuffer.reduce((acc, item) => {
        return acc + +item.isSpeech;
      }, 0);
      if (speaking) {
        if (speechFrameCount >= this.options.minSpeechFrames) {
          const audio = concatArrays(audioBuffer.map((item) => item.frame));
          return { msg: messages_1.Message.SpeechEnd, audio };
        } else {
          return { msg: messages_1.Message.VADMisfire };
        }
      }
      return {};
    };
    this.process = async (frame) => {
      if (!this.active) {
        return {};
      }
      const probs = await this.modelProcessFunc(frame);
      this.audioBuffer.push({
        frame,
        isSpeech: probs.isSpeech >= this.options.positiveSpeechThreshold
      });
      if (probs.isSpeech >= this.options.positiveSpeechThreshold && this.redemptionCounter) {
        this.redemptionCounter = 0;
      }
      if (probs.isSpeech >= this.options.positiveSpeechThreshold && !this.speaking) {
        this.speaking = true;
        return { probs, msg: messages_1.Message.SpeechStart, frame };
      }
      if (probs.isSpeech < this.options.negativeSpeechThreshold && this.speaking && ++this.redemptionCounter >= this.options.redemptionFrames) {
        this.redemptionCounter = 0;
        this.speaking = false;
        const audioBuffer = this.audioBuffer;
        this.audioBuffer = [];
        const speechFrameCount = audioBuffer.reduce((acc, item) => {
          return acc + +item.isSpeech;
        }, 0);
        if (speechFrameCount >= this.options.minSpeechFrames) {
          const audio = concatArrays(audioBuffer.map((item) => item.frame));
          return { probs, msg: messages_1.Message.SpeechEnd, audio, frame };
        } else {
          return { probs, msg: messages_1.Message.VADMisfire, frame };
        }
      }
      if (!this.speaking) {
        while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
          this.audioBuffer.shift();
        }
      }
      return { probs, frame };
    };
    this.audioBuffer = [];
    this.reset();
  }
}
frameProcessor.FrameProcessor = FrameProcessor;
var nonRealTimeVad = {};
var models = {};
var common = {};
Object.defineProperty(common, "__esModule", { value: true });
var legacy = {};
var _a$1;
Object.defineProperty(legacy, "__esModule", { value: true });
legacy.SileroLegacy = void 0;
const logging_1$2 = logging;
class SileroLegacy {
  constructor(ortInstance, _session, _h, _c, _sr) {
    this.ortInstance = ortInstance;
    this._session = _session;
    this._h = _h;
    this._c = _c;
    this._sr = _sr;
    this.reset_state = () => {
      const zeroes = Array(2 * 64).fill(0);
      this._h = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
      this._c = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
    };
    this.process = async (audioFrame) => {
      const t2 = new this.ortInstance.Tensor("float32", audioFrame, [
        1,
        audioFrame.length
      ]);
      const inputs = {
        input: t2,
        h: this._h,
        c: this._c,
        sr: this._sr
      };
      const out = await this._session.run(inputs);
      this._h = out["hn"];
      this._c = out["cn"];
      const [isSpeech] = out["output"]?.data;
      const notSpeech = 1 - isSpeech;
      return { notSpeech, isSpeech };
    };
  }
}
legacy.SileroLegacy = SileroLegacy;
_a$1 = SileroLegacy;
SileroLegacy.new = async (ortInstance, modelFetcher) => {
  logging_1$2.log.debug("initializing vad");
  const modelArrayBuffer = await modelFetcher();
  const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
  const _sr = new ortInstance.Tensor("int64", [16000n]);
  const zeroes = Array(2 * 64).fill(0);
  const _h = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
  const _c = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
  logging_1$2.log.debug("vad is initialized");
  const model = new _a$1(ortInstance, _session, _h, _c, _sr);
  return model;
};
var v5 = {};
var _a;
Object.defineProperty(v5, "__esModule", { value: true });
v5.SileroV5 = void 0;
const logging_1$1 = logging;
function getNewState(ortInstance) {
  const zeroes = Array(2 * 128).fill(0);
  return new ortInstance.Tensor("float32", zeroes, [2, 1, 128]);
}
class SileroV5 {
  constructor(_session, _state, _sr, ortInstance) {
    this._session = _session;
    this._state = _state;
    this._sr = _sr;
    this.ortInstance = ortInstance;
    this.reset_state = () => {
      this._state = getNewState(this.ortInstance);
    };
    this.process = async (audioFrame) => {
      const t2 = new this.ortInstance.Tensor("float32", audioFrame, [
        1,
        audioFrame.length
      ]);
      const inputs = {
        input: t2,
        state: this._state,
        sr: this._sr
      };
      const out = await this._session.run(inputs);
      this._state = out["stateN"];
      const [isSpeech] = out["output"]?.data;
      const notSpeech = 1 - isSpeech;
      return { notSpeech, isSpeech };
    };
  }
}
v5.SileroV5 = SileroV5;
_a = SileroV5;
SileroV5.new = async (ortInstance, modelFetcher) => {
  logging_1$1.log.debug("Loading VAD...");
  const modelArrayBuffer = await modelFetcher();
  const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
  const _sr = new ortInstance.Tensor("int64", [16000n]);
  const _state = getNewState(ortInstance);
  logging_1$1.log.debug("...finished loading VAD");
  return new _a(_session, _state, _sr, ortInstance);
};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SileroV5 = exports2.SileroLegacy = void 0;
  __exportStar(common, exports2);
  var legacy_1 = legacy;
  Object.defineProperty(exports2, "SileroLegacy", { enumerable: true, get: function() {
    return legacy_1.SileroLegacy;
  } });
  var v5_1 = v5;
  Object.defineProperty(exports2, "SileroV5", { enumerable: true, get: function() {
    return v5_1.SileroV5;
  } });
})(models);
var resampler = {};
Object.defineProperty(resampler, "__esModule", { value: true });
resampler.Resampler = void 0;
const logging_1 = logging;
class Resampler {
  constructor(options) {
    this.options = options;
    this.process = (audioFrame) => {
      const outputFrames = [];
      for (const sample of audioFrame) {
        this.inputBuffer.push(sample);
        while (this.hasEnoughDataForFrame()) {
          const outputFrame = this.generateOutputFrame();
          outputFrames.push(outputFrame);
        }
      }
      return outputFrames;
    };
    this.stream = async function* (audioInput) {
      for (const sample of audioInput) {
        this.inputBuffer.push(sample);
        while (this.hasEnoughDataForFrame()) {
          const outputFrame = this.generateOutputFrame();
          yield outputFrame;
        }
      }
    };
    if (options.nativeSampleRate < 16e3) {
      logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
    }
    this.inputBuffer = [];
  }
  hasEnoughDataForFrame() {
    return this.inputBuffer.length * this.options.targetSampleRate / this.options.nativeSampleRate >= this.options.targetFrameSize;
  }
  generateOutputFrame() {
    const outputFrame = new Float32Array(this.options.targetFrameSize);
    let outputIndex = 0;
    let inputIndex = 0;
    while (outputIndex < this.options.targetFrameSize) {
      let sum = 0;
      let num = 0;
      while (inputIndex < Math.min(this.inputBuffer.length, (outputIndex + 1) * this.options.nativeSampleRate / this.options.targetSampleRate)) {
        const value = this.inputBuffer[inputIndex];
        if (value !== void 0) {
          sum += value;
          num++;
        }
        inputIndex++;
      }
      outputFrame[outputIndex] = sum / num;
      outputIndex++;
    }
    this.inputBuffer = this.inputBuffer.slice(inputIndex);
    return outputFrame;
  }
}
resampler.Resampler = Resampler;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PlatformAgnosticNonRealTimeVAD = exports2.defaultNonRealTimeVADOptions = void 0;
  const frame_processor_1 = frameProcessor;
  const messages_12 = messages;
  const models_1 = models;
  const resampler_1 = resampler;
  exports2.defaultNonRealTimeVADOptions = {
    ...frame_processor_1.defaultLegacyFrameProcessorOptions,
    ortConfig: void 0
  };
  class PlatformAgnosticNonRealTimeVAD {
    static async _new(modelFetcher, ort, options = {}) {
      const fullOptions = {
        ...exports2.defaultNonRealTimeVADOptions,
        ...options
      };
      if (fullOptions.ortConfig !== void 0) {
        fullOptions.ortConfig(ort);
      }
      const vad = new this(modelFetcher, ort, fullOptions);
      await vad.init();
      return vad;
    }
    constructor(modelFetcher, ort, options) {
      this.modelFetcher = modelFetcher;
      this.ort = ort;
      this.options = options;
      this.init = async () => {
        const model = await models_1.SileroLegacy.new(this.ort, this.modelFetcher);
        this.frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
          frameSamples: this.options.frameSamples,
          positiveSpeechThreshold: this.options.positiveSpeechThreshold,
          negativeSpeechThreshold: this.options.negativeSpeechThreshold,
          redemptionFrames: this.options.redemptionFrames,
          preSpeechPadFrames: this.options.preSpeechPadFrames,
          minSpeechFrames: this.options.minSpeechFrames,
          submitUserSpeechOnPause: this.options.submitUserSpeechOnPause
        });
        this.frameProcessor.resume();
      };
      this.run = async function* (inputAudio, sampleRate) {
        const resamplerOptions = {
          nativeSampleRate: sampleRate,
          targetSampleRate: 16e3,
          targetFrameSize: this.options.frameSamples
        };
        const resampler2 = new resampler_1.Resampler(resamplerOptions);
        let start = 0;
        let end = 0;
        let frameIndex = 0;
        for await (const frame of resampler2.stream(inputAudio)) {
          const { msg: msg2, audio: audio2 } = await this.frameProcessor.process(frame);
          switch (msg2) {
            case messages_12.Message.SpeechStart:
              start = frameIndex * this.options.frameSamples / 16;
              break;
            case messages_12.Message.SpeechEnd:
              end = (frameIndex + 1) * this.options.frameSamples / 16;
              yield { audio: audio2, start, end };
              break;
          }
          frameIndex++;
        }
        const { msg, audio } = this.frameProcessor.endSegment();
        if (msg == messages_12.Message.SpeechEnd) {
          yield {
            audio,
            start,
            end: frameIndex * this.options.frameSamples / 16
          };
        }
      };
      (0, frame_processor_1.validateOptions)(options);
    }
  }
  exports2.PlatformAgnosticNonRealTimeVAD = PlatformAgnosticNonRealTimeVAD;
})(nonRealTimeVad);
var utils$3 = {};
Object.defineProperty(utils$3, "__esModule", { value: true });
utils$3.audioFileToArray = utils$3.encodeWAV = utils$3.arrayBufferToBase64 = utils$3.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16e3) {
  return Math.ceil(targetDuration * sr / 1e3 / frameSamples);
}
utils$3.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  const binary = new Array(len);
  for (var i2 = 0; i2 < len; i2++) {
    const byte = bytes[i2];
    if (byte === void 0) {
      break;
    }
    binary[i2] = String.fromCharCode(byte);
  }
  return btoa(binary.join(""));
}
utils$3.arrayBufferToBase64 = arrayBufferToBase64;
function encodeWAV(samples, format2 = 3, sampleRate = 16e3, numChannels = 1, bitDepth = 32) {
  var bytesPerSample = bitDepth / 8;
  var blockAlign = numChannels * bytesPerSample;
  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  var view = new DataView(buffer);
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, format2, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, "data");
  view.setUint32(40, samples.length * bytesPerSample, true);
  if (format2 === 1) {
    floatTo16BitPCM(view, 44, samples);
  } else {
    writeFloat32(view, 44, samples);
  }
  return buffer;
}
utils$3.encodeWAV = encodeWAV;
function writeFloat32(output, offset2, input) {
  for (var i2 = 0; i2 < input.length; i2++, offset2 += 4) {
    output.setFloat32(offset2, input[i2], true);
  }
}
function floatTo16BitPCM(output, offset2, input) {
  for (var i2 = 0; i2 < input.length; i2++, offset2 += 2) {
    var s2 = Math.max(-1, Math.min(1, input[i2]));
    output.setInt16(offset2, s2 < 0 ? s2 * 32768 : s2 * 32767, true);
  }
}
function writeString(view, offset2, string) {
  for (var i2 = 0; i2 < string.length; i2++) {
    view.setUint8(offset2 + i2, string.charCodeAt(i2));
  }
}
async function audioFileToArray(audioFileData) {
  const ctx = new OfflineAudioContext(1, 1, 44100);
  const reader = new FileReader();
  let audioBuffer = null;
  await new Promise((res) => {
    reader.addEventListener("loadend", (ev) => {
      const audioData = reader.result;
      ctx.decodeAudioData(audioData, (buffer) => {
        audioBuffer = buffer;
        ctx.startRendering().then((renderedBuffer) => {
          console.log("Rendering completed successfully");
          res();
        }).catch((err) => {
          console.error(`Rendering failed: ${err}`);
        });
      }, (e2) => {
        console.log(`Error with decoding audio data: ${e2}`);
      });
    });
    reader.readAsArrayBuffer(audioFileData);
  });
  if (audioBuffer === null) {
    throw Error("some shit");
  }
  let _audioBuffer = audioBuffer;
  let out = new Float32Array(_audioBuffer.length);
  for (let i2 = 0; i2 < _audioBuffer.length; i2++) {
    for (let j2 = 0; j2 < _audioBuffer.numberOfChannels; j2++) {
      out[i2] += _audioBuffer.getChannelData(j2)[i2];
    }
  }
  return { audio: out, sampleRate: _audioBuffer.sampleRate };
}
utils$3.audioFileToArray = audioFileToArray;
var realTimeVad = {};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AudioNodeVAD = exports2.MicVAD = exports2.getDefaultRealTimeVADOptions = exports2.ort = exports2.DEFAULT_MODEL = void 0;
  const ortInstance = __importStar(ortWeb_minExports);
  const default_model_fetcher_1 = defaultModelFetcher$1;
  const frame_processor_1 = frameProcessor;
  const logging_12 = logging;
  const messages_12 = messages;
  const models_1 = models;
  const resampler_1 = resampler;
  exports2.DEFAULT_MODEL = "legacy";
  exports2.ort = ortInstance;
  const workletFile = "vad.worklet.bundle.min.js";
  const sileroV5File = "silero_vad_v5.onnx";
  const sileroLegacyFile = "silero_vad_legacy.onnx";
  const getDefaultRealTimeVADOptions = (model) => {
    const frameProcessorOptions = model === "v5" ? frame_processor_1.defaultV5FrameProcessorOptions : frame_processor_1.defaultLegacyFrameProcessorOptions;
    return {
      ...frameProcessorOptions,
      onFrameProcessed: (probabilities) => {
      },
      onVADMisfire: () => {
        logging_12.log.debug("VAD misfire");
      },
      onSpeechStart: () => {
        logging_12.log.debug("Detected speech start");
      },
      onSpeechEnd: () => {
        logging_12.log.debug("Detected speech end");
      },
      baseAssetPath: "https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.22/dist/",
      onnxWASMBasePath: "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/",
      stream: void 0,
      ortConfig: void 0,
      model: exports2.DEFAULT_MODEL,
      workletOptions: {}
    };
  };
  exports2.getDefaultRealTimeVADOptions = getDefaultRealTimeVADOptions;
  class MicVAD {
    static async new(options = {}) {
      const fullOptions = {
        ...(0, exports2.getDefaultRealTimeVADOptions)(options.model ?? exports2.DEFAULT_MODEL),
        ...options
      };
      (0, frame_processor_1.validateOptions)(fullOptions);
      let stream;
      if (fullOptions.stream === void 0)
        stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            ...fullOptions.additionalAudioConstraints,
            channelCount: 1,
            echoCancellation: true,
            autoGainControl: true,
            noiseSuppression: true
          }
        });
      else
        stream = fullOptions.stream;
      const audioContext = new AudioContext();
      const sourceNode = new MediaStreamAudioSourceNode(audioContext, {
        mediaStream: stream
      });
      const audioNodeVAD = await AudioNodeVAD.new(audioContext, fullOptions);
      audioNodeVAD.receive(sourceNode);
      return new MicVAD(fullOptions, audioContext, stream, audioNodeVAD, sourceNode);
    }
    constructor(options, audioContext, stream, audioNodeVAD, sourceNode, listening = false) {
      this.options = options;
      this.audioContext = audioContext;
      this.stream = stream;
      this.audioNodeVAD = audioNodeVAD;
      this.sourceNode = sourceNode;
      this.listening = listening;
      this.pause = () => {
        this.audioNodeVAD.pause();
        this.listening = false;
      };
      this.start = () => {
        this.audioNodeVAD.start();
        this.listening = true;
      };
      this.destroy = () => {
        if (this.listening) {
          this.pause();
        }
        if (this.options.stream === void 0) {
          this.stream.getTracks().forEach((track) => track.stop());
        }
        this.sourceNode.disconnect();
        this.audioNodeVAD.destroy();
        this.audioContext.close();
      };
    }
  }
  exports2.MicVAD = MicVAD;
  class AudioNodeVAD {
    static async new(ctx, options = {}) {
      const fullOptions = {
        ...(0, exports2.getDefaultRealTimeVADOptions)(options.model ?? exports2.DEFAULT_MODEL),
        ...options
      };
      (0, frame_processor_1.validateOptions)(fullOptions);
      exports2.ort.env.wasm.wasmPaths = fullOptions.onnxWASMBasePath;
      if (fullOptions.ortConfig !== void 0) {
        fullOptions.ortConfig(exports2.ort);
      }
      const modelFile = fullOptions.model === "v5" ? sileroV5File : sileroLegacyFile;
      const modelURL = fullOptions.baseAssetPath + modelFile;
      const modelFactory = fullOptions.model === "v5" ? models_1.SileroV5.new : models_1.SileroLegacy.new;
      let model;
      try {
        model = await modelFactory(exports2.ort, () => (0, default_model_fetcher_1.defaultModelFetcher)(modelURL));
      } catch (e2) {
        console.error(`Encountered an error while loading model file ${modelURL}`);
        throw e2;
      }
      const frameProcessor2 = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
        frameSamples: fullOptions.frameSamples,
        positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
        negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
        redemptionFrames: fullOptions.redemptionFrames,
        preSpeechPadFrames: fullOptions.preSpeechPadFrames,
        minSpeechFrames: fullOptions.minSpeechFrames,
        submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause
      });
      const audioNodeVAD = new AudioNodeVAD(ctx, fullOptions, frameProcessor2);
      await audioNodeVAD.setupAudioNode();
      return audioNodeVAD;
    }
    constructor(ctx, options, frameProcessor2) {
      this.ctx = ctx;
      this.options = options;
      this.bufferIndex = 0;
      this.pause = () => {
        const ev = this.frameProcessor.pause();
        this.handleFrameProcessorEvent(ev);
      };
      this.start = () => {
        this.frameProcessor.resume();
      };
      this.receive = (node2) => {
        node2.connect(this.audioNode);
      };
      this.processFrame = async (frame) => {
        const ev = await this.frameProcessor.process(frame);
        this.handleFrameProcessorEvent(ev);
      };
      this.handleFrameProcessorEvent = (ev) => {
        if (ev.probs !== void 0) {
          this.options.onFrameProcessed(ev.probs, ev.frame);
        }
        switch (ev.msg) {
          case messages_12.Message.SpeechStart:
            this.options.onSpeechStart();
            break;
          case messages_12.Message.VADMisfire:
            this.options.onVADMisfire();
            break;
          case messages_12.Message.SpeechEnd:
            this.options.onSpeechEnd(ev.audio);
            break;
        }
      };
      this.destroy = () => {
        if (this.audioNode instanceof AudioWorkletNode) {
          this.audioNode.port.postMessage({
            message: messages_12.Message.SpeechStop
          });
        }
        this.audioNode.disconnect();
        this.gainNode?.disconnect();
      };
      this.frameProcessor = frameProcessor2;
    }
    async setupAudioNode() {
      const hasAudioWorklet = "audioWorklet" in this.ctx && typeof AudioWorkletNode === "function";
      if (hasAudioWorklet) {
        try {
          const workletURL = this.options.baseAssetPath + workletFile;
          await this.ctx.audioWorklet.addModule(workletURL);
          const workletOptions = this.options.workletOptions ?? {};
          workletOptions.processorOptions = {
            ...workletOptions.processorOptions ?? {},
            frameSamples: this.options.frameSamples
          };
          this.audioNode = new AudioWorkletNode(this.ctx, "vad-helper-worklet", workletOptions);
          this.audioNode.port.onmessage = async (ev) => {
            switch (ev.data?.message) {
              case messages_12.Message.AudioFrame:
                let buffer = ev.data.data;
                if (!(buffer instanceof ArrayBuffer)) {
                  buffer = new ArrayBuffer(ev.data.data.byteLength);
                  new Uint8Array(buffer).set(new Uint8Array(ev.data.data));
                }
                const frame = new Float32Array(buffer);
                await this.processFrame(frame);
                break;
            }
          };
          return;
        } catch (e2) {
          console.log("AudioWorklet setup failed, falling back to ScriptProcessor", e2);
        }
      }
      this.resampler = new resampler_1.Resampler({
        nativeSampleRate: this.ctx.sampleRate,
        targetSampleRate: 16e3,
        targetFrameSize: this.options.frameSamples ?? 480
      });
      const bufferSize = 4096;
      this.audioNode = this.ctx.createScriptProcessor(bufferSize, 1, 1);
      this.gainNode = this.ctx.createGain();
      this.gainNode.gain.value = 0;
      let processingAudio = false;
      this.audioNode.onaudioprocess = async (e2) => {
        if (processingAudio)
          return;
        processingAudio = true;
        try {
          const input = e2.inputBuffer.getChannelData(0);
          const output = e2.outputBuffer.getChannelData(0);
          output.fill(0);
          if (this.resampler) {
            const frames = this.resampler.process(input);
            for (const frame of frames) {
              await this.processFrame(frame);
            }
          }
        } catch (error) {
          console.error("Error processing audio:", error);
        } finally {
          processingAudio = false;
        }
      };
      this.audioNode.connect(this.gainNode);
      this.gainNode.connect(this.ctx.destination);
    }
  }
  exports2.AudioNodeVAD = AudioNodeVAD;
})(realTimeVad);
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NonRealTimeVAD = exports2.Message = exports2.FrameProcessor = exports2.getDefaultRealTimeVADOptions = exports2.MicVAD = exports2.DEFAULT_MODEL = exports2.AudioNodeVAD = exports2.utils = exports2.defaultNonRealTimeVADOptions = void 0;
  const ort = __importStar(ortWeb_minExports);
  const asset_path_1 = assetPath;
  const default_model_fetcher_1 = defaultModelFetcher$1;
  const frame_processor_1 = frameProcessor;
  Object.defineProperty(exports2, "FrameProcessor", { enumerable: true, get: function() {
    return frame_processor_1.FrameProcessor;
  } });
  const messages_12 = messages;
  Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
    return messages_12.Message;
  } });
  const non_real_time_vad_1 = nonRealTimeVad;
  const utils_1 = utils$3;
  exports2.defaultNonRealTimeVADOptions = {
    modelURL: asset_path_1.baseAssetPath + "silero_vad_legacy.onnx",
    modelFetcher: default_model_fetcher_1.defaultModelFetcher
  };
  class NonRealTimeVAD extends non_real_time_vad_1.PlatformAgnosticNonRealTimeVAD {
    static async new(options = {}) {
      const { modelURL, modelFetcher } = {
        ...exports2.defaultNonRealTimeVADOptions,
        ...options
      };
      return await this._new(() => modelFetcher(modelURL), ort, options);
    }
  }
  exports2.NonRealTimeVAD = NonRealTimeVAD;
  exports2.utils = {
    audioFileToArray: utils_1.audioFileToArray,
    minFramesForTargetMS: utils_1.minFramesForTargetMS,
    arrayBufferToBase64: utils_1.arrayBufferToBase64,
    encodeWAV: utils_1.encodeWAV
  };
  var real_time_vad_1 = realTimeVad;
  Object.defineProperty(exports2, "AudioNodeVAD", { enumerable: true, get: function() {
    return real_time_vad_1.AudioNodeVAD;
  } });
  Object.defineProperty(exports2, "DEFAULT_MODEL", { enumerable: true, get: function() {
    return real_time_vad_1.DEFAULT_MODEL;
  } });
  Object.defineProperty(exports2, "MicVAD", { enumerable: true, get: function() {
    return real_time_vad_1.MicVAD;
  } });
  Object.defineProperty(exports2, "getDefaultRealTimeVADOptions", { enumerable: true, get: function() {
    return real_time_vad_1.getDefaultRealTimeVADOptions;
  } });
})(dist);
class TaskQueue {
  queue = [];
  running = false;
  taskInterval;
  pendingComplete = false;
  activeTasks = /* @__PURE__ */ new Set();
  constructor(taskIntervalMs = 3e3) {
    this.taskInterval = taskIntervalMs;
  }
  addTask(task) {
    this.queue.push(task);
    this.runNextTask();
  }
  clearQueue() {
    this.queue = [];
    this.activeTasks.clear();
    this.running = false;
  }
  async runNextTask() {
    if (this.running || this.queue.length === 0) {
      if (this.queue.length === 0 && this.activeTasks.size === 0 && this.pendingComplete) {
        this.pendingComplete = false;
        await new Promise((resolve2) => setTimeout(resolve2, this.taskInterval));
      }
      return;
    }
    this.running = true;
    const task = this.queue.shift();
    if (task) {
      const taskPromise = task();
      this.activeTasks.add(taskPromise);
      try {
        await taskPromise;
        await new Promise((resolve2) => setTimeout(resolve2, this.taskInterval));
      } catch (error) {
        console.error("Task Queue Error", error);
      } finally {
        this.activeTasks.delete(taskPromise);
        this.running = false;
        this.runNextTask();
      }
    }
  }
  hasTask() {
    return this.queue.length > 0 || this.activeTasks.size > 0 || this.running;
  }
  waitForCompletion() {
    this.pendingComplete = true;
    return new Promise((resolve2) => {
      const check = () => {
        if (!this.hasTask()) {
          resolve2();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  }
}
const audioTaskQueue = new TaskQueue(20);
const ScreenCaptureContext = reactExports.createContext(void 0);
function ScreenCaptureProvider({ children }) {
  const [stream, setStream] = reactExports.useState(null);
  const [isStreaming, setIsStreaming] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const startCapture = async () => {
    try {
      let mediaStream;
      if (window.electron) {
        const sourceId = await window.electron.ipcRenderer.invoke("get-screen-capture");
        const displayMediaOptions = {
          video: {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            mandatory: {
              chromeMediaSource: "desktop",
              chromeMediaSourceId: sourceId,
              minWidth: 1280,
              maxWidth: 1280,
              minHeight: 720,
              maxHeight: 720
            }
          },
          audio: false
        };
        mediaStream = await navigator.mediaDevices.getUserMedia(displayMediaOptions);
      } else {
        const displayMediaOptions = {
          video: true,
          audio: false
        };
        mediaStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
      }
      setStream(mediaStream);
      setIsStreaming(true);
      setError("");
    } catch (err) {
      setError("Failed to start screen capture");
      toaster.create({
        title: `Failed to start screen capture: ${err}`,
        type: "error",
        duration: 2e3
      });
      console.error(err);
    }
  };
  const stopCapture = () => {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
      setStream(null);
      setIsStreaming(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScreenCaptureContext.Provider,
    {
      value: {
        stream,
        isStreaming,
        error,
        startCapture,
        stopCapture
      },
      children
    }
  );
}
const useScreenCaptureContext = () => {
  const context2 = reactExports.useContext(ScreenCaptureContext);
  if (context2 === void 0) {
    throw new Error("useScreenCaptureContext must be used within a ScreenCaptureProvider");
  }
  return context2;
};
function useMediaCapture() {
  const { stream: cameraStream } = useCamera();
  const { stream: screenStream } = useScreenCaptureContext();
  const captureFrame = reactExports.useCallback(async (stream, source) => {
    if (!stream) {
      console.warn(`No ${source} stream available`);
      return null;
    }
    const videoTrack = stream.getVideoTracks()[0];
    if (!videoTrack) {
      console.warn(`No video track in ${source} stream`);
      return null;
    }
    const imageCapture = new ImageCapture(videoTrack);
    try {
      const bitmap = await imageCapture.grabFrame();
      const canvas = document.createElement("canvas");
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        console.error("Failed to get canvas context");
        return null;
      }
      ctx.drawImage(bitmap, 0, 0);
      return canvas.toDataURL("image/jpeg", 0.8);
    } catch (error) {
      console.error(`Error capturing ${source} frame:`, error);
      toaster.create({
        title: `Failed to capture ${source} frame: ${error}`,
        type: "error",
        duration: 2e3
      });
      return null;
    }
  }, []);
  const captureAllMedia = reactExports.useCallback(async () => {
    const images = [];
    if (cameraStream) {
      const cameraFrame = await captureFrame(cameraStream, "camera");
      if (cameraFrame) {
        images.push({
          source: "camera",
          data: cameraFrame,
          mime_type: "image/jpeg"
        });
      }
    }
    if (screenStream) {
      const screenFrame = await captureFrame(screenStream, "screen");
      if (screenFrame) {
        images.push({
          source: "screen",
          data: screenFrame,
          mime_type: "image/jpeg"
        });
      }
    }
    console.log("images: ", images);
    return images;
  }, [cameraStream, screenStream, captureFrame]);
  return {
    captureAllMedia
  };
}
function useSendAudio() {
  const { sendMessage } = useWebSocket();
  const { captureAllMedia } = useMediaCapture();
  const sendAudioPartition = reactExports.useCallback(
    async (audio) => {
      const chunkSize = 4096;
      for (let index = 0; index < audio.length; index += chunkSize) {
        const endIndex = Math.min(index + chunkSize, audio.length);
        const chunk = audio.slice(index, endIndex);
        sendMessage({
          type: "mic-audio-data",
          audio: Array.from(chunk)
          // Only send images with first chunk
        });
      }
      const images = await captureAllMedia();
      sendMessage({ type: "mic-audio-end", images });
    },
    [sendMessage, captureAllMedia]
  );
  return {
    sendAudioPartition
  };
}
var AiStateEnum = /* @__PURE__ */ ((AiStateEnum2) => {
  AiStateEnum2["IDLE"] = "idle";
  AiStateEnum2["THINKING_SPEAKING"] = "thinking-speaking";
  AiStateEnum2["INTERRUPTED"] = "interrupted";
  AiStateEnum2["LOADING"] = "loading";
  AiStateEnum2["LISTENING"] = "listening";
  AiStateEnum2["WAITING"] = "waiting";
  return AiStateEnum2;
})(AiStateEnum || {});
const initialState = "loading";
const AiStateContext = reactExports.createContext(null);
function AiStateProvider({ children }) {
  const [aiState, setAiStateInternal] = reactExports.useState(initialState);
  const [backendSynthComplete, setBackendSynthComplete] = reactExports.useState(false);
  const timerRef = reactExports.useRef(null);
  const setAiState = reactExports.useCallback((newState) => {
    const nextState = typeof newState === "function" ? newState(aiState) : newState;
    if (nextState === "waiting") {
      if (aiState !== "thinking-speaking") {
        setAiStateInternal(nextState);
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
        timerRef.current = setTimeout(() => {
          setAiStateInternal(
            "idle"
            /* IDLE */
          );
          timerRef.current = null;
        }, 2e3);
      }
    } else {
      setAiStateInternal(nextState);
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    }
  }, [aiState]);
  const stateChecks = reactExports.useMemo(
    () => ({
      isIdle: aiState === "idle",
      isThinkingSpeaking: aiState === "thinking-speaking",
      isInterrupted: aiState === "interrupted",
      isLoading: aiState === "loading",
      isListening: aiState === "listening",
      isWaiting: aiState === "waiting"
      /* WAITING */
    }),
    [aiState]
  );
  const resetState = reactExports.useCallback(() => {
    setAiState(
      "idle"
      /* IDLE */
    );
  }, [setAiState]);
  reactExports.useEffect(() => () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      aiState,
      setAiState,
      backendSynthComplete,
      setBackendSynthComplete,
      ...stateChecks,
      resetState
    }),
    [aiState, setAiState, backendSynthComplete, stateChecks, resetState]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AiStateContext.Provider, { value: contextValue, children });
}
function useAiState() {
  const context2 = reactExports.useContext(AiStateContext);
  if (!context2) {
    throw new Error("useAiState must be used within a AiStateProvider");
  }
  return context2;
}
const DEFAULT_VAD_SETTINGS = {
  positiveSpeechThreshold: 50,
  negativeSpeechThreshold: 35,
  redemptionFrames: 35
};
const DEFAULT_VAD_STATE = {
  micOn: false,
  autoStopMic: false,
  autoStartMicOn: false,
  autoStartMicOnConvEnd: false
};
const VADContext = reactExports.createContext(null);
function VADProvider({ children }) {
  const vadRef = reactExports.useRef(null);
  const previousTriggeredProbabilityRef = reactExports.useRef(0);
  const [micOn, setMicOn] = useLocalStorage("micOn", DEFAULT_VAD_STATE.micOn);
  const autoStopMicRef = reactExports.useRef(true);
  const [autoStopMic, setAutoStopMicState] = useLocalStorage(
    "autoStopMic",
    DEFAULT_VAD_STATE.autoStopMic
  );
  const [settings2, setSettings] = useLocalStorage(
    "vadSettings",
    DEFAULT_VAD_SETTINGS
  );
  const [autoStartMicOn, setAutoStartMicOnState] = useLocalStorage(
    "autoStartMicOn",
    DEFAULT_VAD_STATE.autoStartMicOn
  );
  const autoStartMicRef = reactExports.useRef(false);
  const [autoStartMicOnConvEnd, setAutoStartMicOnConvEndState] = useLocalStorage(
    "autoStartMicOnConvEnd",
    DEFAULT_VAD_STATE.autoStartMicOnConvEnd
  );
  const autoStartMicOnConvEndRef = reactExports.useRef(false);
  const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
  const { interrupt } = useInterrupt();
  const { sendAudioPartition } = useSendAudio();
  const { setSubtitleText } = reactExports.useContext(SubtitleContext);
  const { aiState, setAiState } = reactExports.useContext(AiStateContext);
  const interruptRef = reactExports.useRef(interrupt);
  const sendAudioPartitionRef = reactExports.useRef(sendAudioPartition);
  const aiStateRef = reactExports.useRef(aiState);
  const setSubtitleTextRef = reactExports.useRef(setSubtitleText);
  const setAiStateRef = reactExports.useRef(setAiState);
  const isProcessingRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    aiStateRef.current = aiState;
  }, [aiState]);
  reactExports.useEffect(() => {
    interruptRef.current = interrupt;
  }, [interrupt]);
  reactExports.useEffect(() => {
    sendAudioPartitionRef.current = sendAudioPartition;
  }, [sendAudioPartition]);
  reactExports.useEffect(() => {
    setSubtitleTextRef.current = setSubtitleText;
  }, [setSubtitleText]);
  reactExports.useEffect(() => {
    setAiStateRef.current = setAiState;
  }, [setAiState]);
  reactExports.useEffect(() => {
    autoStopMicRef.current = autoStopMic;
  }, []);
  reactExports.useEffect(() => {
    autoStartMicRef.current = autoStartMicOn;
  }, []);
  reactExports.useEffect(() => {
    autoStartMicOnConvEndRef.current = autoStartMicOnConvEnd;
  }, []);
  const setPreviousTriggeredProbability = reactExports.useCallback((value) => {
    previousTriggeredProbabilityRef.current = value;
    forceUpdate();
  }, []);
  const handleSpeechStart = reactExports.useCallback(() => {
    console.log("Speech started");
    if (aiStateRef.current === "thinking-speaking") {
      interruptRef.current();
    }
    isProcessingRef.current = true;
    setAiStateRef.current("listening");
  }, []);
  const handleFrameProcessed = reactExports.useCallback((probs) => {
    if (probs.isSpeech > previousTriggeredProbabilityRef.current) {
      setPreviousTriggeredProbability(probs.isSpeech);
    }
  }, []);
  const handleSpeechEnd = reactExports.useCallback((audio) => {
    if (!isProcessingRef.current) return;
    console.log("Speech ended");
    audioTaskQueue.clearQueue();
    if (autoStopMicRef.current) {
      stopMic();
    } else {
      console.log("Auto stop mic is on, keeping mic active");
    }
    setPreviousTriggeredProbability(0);
    sendAudioPartitionRef.current(audio);
    isProcessingRef.current = false;
  }, []);
  const handleVADMisfire = reactExports.useCallback(() => {
    if (!isProcessingRef.current) return;
    console.log("VAD misfire detected");
    setPreviousTriggeredProbability(0);
    isProcessingRef.current = false;
    if (aiStateRef.current === "interrupted" || aiStateRef.current === "listening") {
      setAiStateRef.current("idle");
    }
    setSubtitleTextRef.current("The LLM can't hear you.");
  }, []);
  const updateSettings = reactExports.useCallback((newSettings) => {
    setSettings(newSettings);
    if (vadRef.current) {
      stopMic();
      setTimeout(() => {
        startMic();
      }, 100);
    }
  }, []);
  const initVAD = async () => {
    const newVAD = await dist.MicVAD.new({
      model: "v5",
      preSpeechPadFrames: 20,
      positiveSpeechThreshold: settings2.positiveSpeechThreshold / 100,
      negativeSpeechThreshold: settings2.negativeSpeechThreshold / 100,
      redemptionFrames: settings2.redemptionFrames,
      baseAssetPath: "/libs/",
      onnxWASMBasePath: "/libs/",
      onSpeechStart: handleSpeechStart,
      onFrameProcessed: handleFrameProcessed,
      onSpeechEnd: handleSpeechEnd,
      onVADMisfire: handleVADMisfire
    });
    vadRef.current = newVAD;
    newVAD.start();
  };
  const startMic = reactExports.useCallback(async () => {
    try {
      if (!vadRef.current) {
        console.log("Initializing VAD");
        await initVAD();
      } else {
        console.log("Starting VAD");
        vadRef.current.start();
      }
      setMicOn(true);
    } catch (error) {
      console.error("Failed to start VAD:", error);
      toaster.create({
        title: `Failed to start VAD: ${error}`,
        type: "error",
        duration: 2e3
      });
    }
  }, []);
  const stopMic = reactExports.useCallback(() => {
    console.log("Stopping VAD");
    if (vadRef.current) {
      vadRef.current.pause();
      vadRef.current.destroy();
      vadRef.current = null;
      console.log("VAD stopped and destroyed successfully");
      setPreviousTriggeredProbability(0);
    } else {
      console.log("VAD instance not found");
    }
    setMicOn(false);
    isProcessingRef.current = false;
  }, []);
  const setAutoStopMic = reactExports.useCallback((value) => {
    autoStopMicRef.current = value;
    setAutoStopMicState(value);
    forceUpdate();
  }, []);
  const setAutoStartMicOn = reactExports.useCallback((value) => {
    autoStartMicRef.current = value;
    setAutoStartMicOnState(value);
    forceUpdate();
  }, []);
  const setAutoStartMicOnConvEnd = reactExports.useCallback((value) => {
    autoStartMicOnConvEndRef.current = value;
    setAutoStartMicOnConvEndState(value);
    forceUpdate();
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      autoStopMic: autoStopMicRef.current,
      micOn,
      setMicOn,
      setAutoStopMic,
      startMic,
      stopMic,
      previousTriggeredProbability: previousTriggeredProbabilityRef.current,
      setPreviousTriggeredProbability,
      settings: settings2,
      updateSettings,
      autoStartMicOn: autoStartMicRef.current,
      setAutoStartMicOn,
      autoStartMicOnConvEnd: autoStartMicOnConvEndRef.current,
      setAutoStartMicOnConvEnd
    }),
    [
      micOn,
      startMic,
      stopMic,
      settings2,
      updateSettings
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VADContext.Provider, { value: contextValue, children });
}
function useVAD() {
  const context2 = reactExports.useContext(VADContext);
  if (!context2) {
    throw new Error("useVAD must be used within a VADProvider");
  }
  return context2;
}
function useMicToggle() {
  const { startMic, stopMic, micOn } = useVAD();
  const { aiState, setAiState } = useAiState();
  const handleMicToggle = async () => {
    if (micOn) {
      stopMic();
      if (aiState === "listening") {
        setAiState("idle");
      }
    } else {
      await startMic();
    }
  };
  return {
    handleMicToggle,
    micOn
  };
}
function useSwitchCharacter() {
  const { sendMessage } = useWebSocket();
  const { confName, getFilenameByName } = useConfig();
  const { interrupt } = useInterrupt();
  const { stopMic } = useVAD();
  const { setSubtitleText } = useSubtitle();
  const { setAiState } = useAiState();
  const { setModelInfo } = useLive2DConfig();
  const switchCharacter = reactExports.useCallback((fileName) => {
    const currentFilename = getFilenameByName(confName);
    if (currentFilename === fileName) {
      console.log("Skipping character switch - same configuration file");
      return;
    }
    setSubtitleText("New Character Loading...");
    interrupt();
    stopMic();
    setAiState("loading");
    setModelInfo(void 0);
    sendMessage({
      type: "switch-config",
      file: fileName
    });
    console.log("Switch Character fileName: ", fileName);
  }, [confName, getFilenameByName, sendMessage, interrupt, stopMic, setSubtitleText, setAiState]);
  return { switchCharacter };
}
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener3) => listener3(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState2;
  const subscribe2 = (listener3) => {
    listeners.add(listener3);
    return () => listeners.delete(listener3);
  };
  const api = { setState, getState, getInitialState, subscribe: subscribe2 };
  const initialState2 = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createStoreImpl(createState);
const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice2 = React.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  React.useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createImpl(createState);
const useForceIgnoreMouseStore = create((set2) => ({
  forceIgnoreMouse: false,
  setForceIgnoreMouse: (forceIgnore) => set2({ forceIgnoreMouse: forceIgnore })
}));
function useForceIgnoreMouse() {
  const { forceIgnoreMouse, setForceIgnoreMouse } = useForceIgnoreMouseStore();
  return {
    forceIgnoreMouse,
    setForceIgnoreMouse
  };
}
function useIpcHandlers({ isPet }) {
  const { handleMicToggle } = useMicToggle();
  const { interrupt } = useInterrupt();
  const { modelInfo, setModelInfo } = useLive2DConfig();
  const { switchCharacter } = useSwitchCharacter();
  const { setForceIgnoreMouse } = useForceIgnoreMouse();
  const micToggleHandler = reactExports.useCallback(() => {
    handleMicToggle();
  }, [handleMicToggle]);
  const interruptHandler = reactExports.useCallback(() => {
    interrupt();
  }, [interrupt]);
  const scrollToResizeHandler = reactExports.useCallback(() => {
    if (modelInfo) {
      setModelInfo({
        ...modelInfo,
        scrollToResize: !modelInfo.scrollToResize
      });
    }
  }, [modelInfo, setModelInfo]);
  const switchCharacterHandler = reactExports.useCallback(
    (_event, filename) => {
      switchCharacter(filename);
    },
    [switchCharacter]
  );
  const forceIgnoreMouseChangedHandler = reactExports.useCallback(
    (_event, isForced) => {
      console.log("Force ignore mouse changed:", isForced);
      setForceIgnoreMouse(isForced);
    },
    [setForceIgnoreMouse]
  );
  const toggleForceIgnoreMouseHandler = reactExports.useCallback(() => {
    window.api.toggleForceIgnoreMouse();
  }, []);
  reactExports.useEffect(() => {
    if (!window.electron?.ipcRenderer) return;
    if (!isPet) return;
    window.electron.ipcRenderer.removeAllListeners("mic-toggle");
    window.electron.ipcRenderer.removeAllListeners("interrupt");
    window.electron.ipcRenderer.removeAllListeners("toggle-scroll-to-resize");
    window.electron.ipcRenderer.removeAllListeners("switch-character");
    window.electron.ipcRenderer.removeAllListeners("toggle-force-ignore-mouse");
    window.electron.ipcRenderer.removeAllListeners("force-ignore-mouse-changed");
    window.electron.ipcRenderer.on("mic-toggle", micToggleHandler);
    window.electron.ipcRenderer.on("interrupt", interruptHandler);
    window.electron.ipcRenderer.on(
      "toggle-scroll-to-resize",
      scrollToResizeHandler
    );
    window.electron.ipcRenderer.on("switch-character", switchCharacterHandler);
    window.electron.ipcRenderer.on(
      "toggle-force-ignore-mouse",
      toggleForceIgnoreMouseHandler
    );
    window.electron.ipcRenderer.on(
      "force-ignore-mouse-changed",
      forceIgnoreMouseChangedHandler
    );
    return () => {
      window.electron?.ipcRenderer.removeAllListeners("mic-toggle");
      window.electron?.ipcRenderer.removeAllListeners("interrupt");
      window.electron?.ipcRenderer.removeAllListeners(
        "toggle-scroll-to-resize"
      );
      window.electron?.ipcRenderer.removeAllListeners("switch-character");
      window.electron?.ipcRenderer.removeAllListeners("toggle-force-ignore-mouse");
      window.electron?.ipcRenderer.removeAllListeners("force-ignore-mouse-changed");
    };
  }, [
    micToggleHandler,
    interruptHandler,
    scrollToResizeHandler,
    switchCharacterHandler,
    toggleForceIgnoreMouseHandler,
    forceIgnoreMouseChangedHandler,
    isPet
  ]);
}
var ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", ENV2[ENV2.WEBGL = 1] = "WEBGL", ENV2[ENV2.WEBGL2 = 2] = "WEBGL2", ENV2))(ENV || {}), RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = "UNKNOWN", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = "WEBGL", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = "CANVAS", RENDERER_TYPE2))(RENDERER_TYPE || {}), BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = "COLOR", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = "DEPTH", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = "STENCIL", BUFFER_BITS2))(BUFFER_BITS || {}), BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => (BLEND_MODES2[BLEND_MODES2.NORMAL = 0] = "NORMAL", BLEND_MODES2[BLEND_MODES2.ADD = 1] = "ADD", BLEND_MODES2[BLEND_MODES2.MULTIPLY = 2] = "MULTIPLY", BLEND_MODES2[BLEND_MODES2.SCREEN = 3] = "SCREEN", BLEND_MODES2[BLEND_MODES2.OVERLAY = 4] = "OVERLAY", BLEND_MODES2[BLEND_MODES2.DARKEN = 5] = "DARKEN", BLEND_MODES2[BLEND_MODES2.LIGHTEN = 6] = "LIGHTEN", BLEND_MODES2[BLEND_MODES2.COLOR_DODGE = 7] = "COLOR_DODGE", BLEND_MODES2[BLEND_MODES2.COLOR_BURN = 8] = "COLOR_BURN", BLEND_MODES2[BLEND_MODES2.HARD_LIGHT = 9] = "HARD_LIGHT", BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT = 10] = "SOFT_LIGHT", BLEND_MODES2[BLEND_MODES2.DIFFERENCE = 11] = "DIFFERENCE", BLEND_MODES2[BLEND_MODES2.EXCLUSION = 12] = "EXCLUSION", BLEND_MODES2[BLEND_MODES2.HUE = 13] = "HUE", BLEND_MODES2[BLEND_MODES2.SATURATION = 14] = "SATURATION", BLEND_MODES2[BLEND_MODES2.COLOR = 15] = "COLOR", BLEND_MODES2[BLEND_MODES2.LUMINOSITY = 16] = "LUMINOSITY", BLEND_MODES2[BLEND_MODES2.NORMAL_NPM = 17] = "NORMAL_NPM", BLEND_MODES2[BLEND_MODES2.ADD_NPM = 18] = "ADD_NPM", BLEND_MODES2[BLEND_MODES2.SCREEN_NPM = 19] = "SCREEN_NPM", BLEND_MODES2[BLEND_MODES2.NONE = 20] = "NONE", BLEND_MODES2[BLEND_MODES2.SRC_OVER = 0] = "SRC_OVER", BLEND_MODES2[BLEND_MODES2.SRC_IN = 21] = "SRC_IN", BLEND_MODES2[BLEND_MODES2.SRC_OUT = 22] = "SRC_OUT", BLEND_MODES2[BLEND_MODES2.SRC_ATOP = 23] = "SRC_ATOP", BLEND_MODES2[BLEND_MODES2.DST_OVER = 24] = "DST_OVER", BLEND_MODES2[BLEND_MODES2.DST_IN = 25] = "DST_IN", BLEND_MODES2[BLEND_MODES2.DST_OUT = 26] = "DST_OUT", BLEND_MODES2[BLEND_MODES2.DST_ATOP = 27] = "DST_ATOP", BLEND_MODES2[BLEND_MODES2.ERASE = 26] = "ERASE", BLEND_MODES2[BLEND_MODES2.SUBTRACT = 28] = "SUBTRACT", BLEND_MODES2[BLEND_MODES2.XOR = 29] = "XOR", BLEND_MODES2))(BLEND_MODES || {}), DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = "POINTS", DRAW_MODES2[DRAW_MODES2.LINES = 1] = "LINES", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = "LINE_LOOP", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = "LINE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = "TRIANGLES", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", DRAW_MODES2))(DRAW_MODES || {}), FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = "RGBA", FORMATS2[FORMATS2.RGB = 6407] = "RGB", FORMATS2[FORMATS2.RG = 33319] = "RG", FORMATS2[FORMATS2.RED = 6403] = "RED", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = "RGB_INTEGER", FORMATS2[FORMATS2.RG_INTEGER = 33320] = "RG_INTEGER", FORMATS2[FORMATS2.RED_INTEGER = 36244] = "RED_INTEGER", FORMATS2[FORMATS2.ALPHA = 6406] = "ALPHA", FORMATS2[FORMATS2.LUMINANCE = 6409] = "LUMINANCE", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", FORMATS2))(FORMATS || {}), TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = "TEXTURE_2D", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", TARGETS2))(TARGETS || {}), TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", TYPES2[TYPES2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", TYPES2[TYPES2.BYTE = 5120] = "BYTE", TYPES2[TYPES2.SHORT = 5122] = "SHORT", TYPES2[TYPES2.INT = 5124] = "INT", TYPES2[TYPES2.FLOAT = 5126] = "FLOAT", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", TYPES2[TYPES2.HALF_FLOAT = 36193] = "HALF_FLOAT", TYPES2))(TYPES || {}), SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = "FLOAT", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = "INT", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = "UINT", SAMPLER_TYPES2))(SAMPLER_TYPES || {}), SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = "NEAREST", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = "LINEAR", SCALE_MODES2))(SCALE_MODES || {}), WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = "CLAMP", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = "REPEAT", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", WRAP_MODES2))(WRAP_MODES || {}), MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = "OFF", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = "POW2", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = "ON", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = "ON_MANUAL", MIPMAP_MODES2))(MIPMAP_MODES || {}), ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = "NPM", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = "UNPACK", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = "PMA", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", ALPHA_MODES2))(ALPHA_MODES || {}), CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = "NO", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = "YES", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = "AUTO", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = "BLEND", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = "CLEAR", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = "BLIT", CLEAR_MODES2))(CLEAR_MODES || {}), GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = "AUTO", GC_MODES2[GC_MODES2.MANUAL = 1] = "MANUAL", GC_MODES2))(GC_MODES || {}), PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = "lowp", PRECISION2.MEDIUM = "mediump", PRECISION2.HIGH = "highp", PRECISION2))(PRECISION || {}), MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = "NONE", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = "SCISSOR", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = "STENCIL", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = "SPRITE", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = "COLOR", MASK_TYPES2))(MASK_TYPES || {}), MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = "NONE", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = "LOW", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = "MEDIUM", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = "HIGH", MSAA_QUALITY2))(MSAA_QUALITY || {}), BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => (BUFFER_TYPE2[BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", BUFFER_TYPE2))(BUFFER_TYPE || {});
const BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    return canvas.width = width, canvas.height = height, canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url2, options) => fetch(url2, options),
  parseXML: (xml) => new DOMParser().parseFromString(xml, "text/xml")
};
const settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent2) {
  return function(regex) {
    return regex.test(userAgent2);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent2 = nav.userAgent;
  var tmp = userAgent2.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  tmp = userAgent2.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  var match2 = createMatch(userAgent2);
  var result = {
    apple: {
      phone: match2(appleIphone) && !match2(windowsPhone),
      ipod: match2(appleIpod),
      tablet: !match2(appleIphone) && (match2(appleTablet) || isAppleTabletOnIos13(nav)) && !match2(windowsPhone),
      universal: match2(appleUniversal),
      device: (match2(appleIphone) || match2(appleIpod) || match2(appleTablet) || match2(appleUniversal) || isAppleTabletOnIos13(nav)) && !match2(windowsPhone)
    },
    amazon: {
      phone: match2(amazonPhone),
      tablet: !match2(amazonPhone) && match2(amazonTablet),
      device: match2(amazonPhone) || match2(amazonTablet)
    },
    android: {
      phone: !match2(windowsPhone) && match2(amazonPhone) || !match2(windowsPhone) && match2(androidPhone),
      tablet: !match2(windowsPhone) && !match2(amazonPhone) && !match2(androidPhone) && (match2(amazonTablet) || match2(androidTablet)),
      device: !match2(windowsPhone) && (match2(amazonPhone) || match2(amazonTablet) || match2(androidPhone) || match2(androidTablet)) || match2(/\bokhttp\b/i)
    },
    windows: {
      phone: match2(windowsPhone),
      tablet: match2(windowsTablet),
      device: match2(windowsPhone) || match2(windowsTablet)
    },
    other: {
      blackberry: match2(otherBlackBerry),
      blackberry10: match2(otherBlackBerry10),
      opera: match2(otherOpera),
      firefox: match2(otherFirefox),
      chrome: match2(otherChrome),
      device: match2(otherBlackBerry) || match2(otherBlackBerry10) || match2(otherOpera) || match2(otherFirefox) || match2(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
const isMobileCall = isMobile$1.default ?? isMobile$1, isMobile = isMobileCall(globalThis.navigator);
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix2 = false;
  }
  function EE(fn, context2, once2) {
    this.fn = fn;
    this.context = context2;
    this.once = once2 || false;
  }
  function addListener(emitter, event, fn, context2, once2) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener3 = new EE(fn, context2 || emitter, once2), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener3, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener3);
    else emitter._events[evt] = [emitter._events[evt], listener3];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name2;
    if (this._eventsCount === 0) return names;
    for (name2 in events = this._events) {
      if (has2.call(events, name2)) names.push(prefix2 ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers2 = this._events[evt];
    if (!handlers2) return [];
    if (handlers2.fn) return [handlers2.fn];
    for (var i2 = 0, l2 = handlers2.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers2[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
              args[j2 - 1] = arguments[j2];
            }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once2(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once2) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once2 || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
        if (listeners[i2].fn !== fn || once2 && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
          events.push(listeners[i2]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x2 = data[i2];
      y2 = data[i2 + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i2, last2;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  }
  if (last2 && equals(last2, last2.next)) {
    removeNode(last2);
    last2 = last2.next;
  }
  return last2;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev2, next2;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next2 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next2.i / dim | 0);
      removeNode(ear);
      ear = next2.next;
      stop = next2.next;
      continue;
    }
    ear = next2;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  var ax = a2.x, bx = b2.x, cx2 = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx2 ? ax : cx2 : bx < cx2 ? bx : cx2, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx2 ? ax : cx2 : bx > cx2 ? bx : cx2, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p2 = c2.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx2, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  var ax = a2.x, bx = b2.x, cx2 = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx2 ? ax : cx2 : bx < cx2 ? bx : cx2, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx2 ? ax : cx2 : bx > cx2 ? bx : cx2, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx2, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx2, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx2, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx2, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a2 = start;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx) return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e2;
        else list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx2, cy, px, py) {
  return (cx2 - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx2 - px) * (by - py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$3(area(p1, q1, p2));
  var o2 = sign$3(area(p1, q1, q2));
  var o3 = sign$3(area(p2, q2, p1));
  var o4 = sign$3(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign$3(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  var p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last2) {
  var p2 = new Node$1(i2, x2, y2);
  if (!last2) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last2.next;
    p2.prev = last2;
    last2.next.prev = p2;
    last2.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function Node$1(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start = holeIndices[i2] * dim;
      var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a2 = triangles[i2] * dim;
    var b2 = triangles[i2 + 1] * dim;
    var c2 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs(
      (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data.length; i2++) {
    for (var j2 = 0; j2 < data[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++) result.vertices.push(data[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
punycode$1.exports;
(function(module2, exports2) {
  (function(root) {
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = !module2.nodeType && module2;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter2 = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn) {
      var length2 = array.length;
      var result = [];
      while (length2--) {
        result[length2] = fn(array[length2]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts2 = string.split("@");
      var result = "";
      if (parts2.length > 1) {
        result = parts2[0] + "@";
        string = parts2[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length2 = string.length, value, extra;
      while (counter < length2) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length2) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map2(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor2(delta / damp) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor2(delta / baseMinusTMin);
      }
      return floor2(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
      basic = input.lastIndexOf(delimiter2);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor2((maxInt - i2) / w2)) {
            error("overflow");
          }
          i2 += digit * w2;
          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t2) {
            break;
          }
          baseMinusT = base - t2;
          if (w2 > floor2(maxInt / baseMinusT)) {
            error("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor2(i2 / out) > maxInt - n2) {
          error("overflow");
        }
        n2 += floor2(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return ucs2encode(output);
    }
    function encode3(input) {
      var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter2);
      }
      while (handledCPCount < inputLength) {
        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n2 && currentValue < m2) {
            m2 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n2 > floor2((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m2 - n2) * handledCPCountPlusOne;
        n2 = m2;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n2 && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n2) {
            for (q2 = delta, k2 = base; ; k2 += base) {
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t2) {
                break;
              }
              qMinusT = q2 - t2;
              baseMinusT = base - t2;
              output.push(
                stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
              );
              q2 = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
      });
    }
    punycode2 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode3,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module2.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var punycodeExports = punycode$1.exports;
var type = TypeError;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize$1 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat$1 = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace$1.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
  __proto__: null,
  "double": '"',
  single: "'"
};
var quoteREs = {
  __proto__: null,
  "double": /(["\\])/g,
  single: /(['\\])/g
};
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && !has$3(quotes, opts.quoteStyle)) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$3(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from2, noIndent) {
    if (from2) {
      seen = $arrSlice.call(seen);
      seen.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name2 = nameOf(obj);
    var keys = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs2 = obj.attributes || [];
    for (var i2 = 0; i2 < attrs2.length; i2++) {
      s2 += " " + attrs2[i2].name + "=" + wrapQuotes(quote(attrs2[i2].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$3(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts2 = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect2(obj.cause), parts2), ", ") + " }";
    }
    if (parts2.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts2, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize$1.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var style = opts.quoteStyle || defaultStyle;
  var quoteChar = quotes[style];
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace$1.call(String(s2), /"/g, "&quot;");
}
function isArray$3(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn$1.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2) {
      return i2;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize$1 || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize$1.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize$1.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var quoteRE = quoteREs[opts.quoteStyle || "single"];
  quoteRE.lastIndex = 0;
  var s2 = $replace$1.call($replace$1.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$3(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var inspect$3 = objectInspect;
var $TypeError$5 = type;
var listGetNode = function(list, key, isDelete) {
  var prev2 = list;
  var curr;
  for (; (curr = prev2.next) != null; prev2 = curr) {
    if (curr.key === key) {
      prev2.next = curr.next;
      if (!isDelete) {
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
      }
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  if (!objects) {
    return void 0;
  }
  var node2 = listGetNode(objects, key);
  return node2 && node2.value;
};
var listSet = function(objects, key, value) {
  var node2 = listGetNode(objects, key);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  if (!objects) {
    return false;
  }
  return !!listGetNode(objects, key);
};
var listDelete = function(objects, key) {
  if (objects) {
    return listGetNode(objects, key, true);
  }
};
var sideChannelList = function getSideChannelList2() {
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$5("Side channel does not contain " + inspect$3(key));
      }
    },
    "delete": function(key) {
      var root = $o && $o.next;
      var deletedNode = listDelete($o, key);
      if (deletedNode && root && root === deletedNode) {
        $o = void 0;
      }
      return !!deletedNode;
    },
    get: function(key) {
      return listGet($o, key);
    },
    has: function(key) {
      return listHas($o, key);
    },
    set: function(key, value) {
      if (!$o) {
        $o = {
          next: void 0
        };
      }
      listSet(
        /** @type {NonNullable<typeof $o>} */
        $o,
        key,
        value
      );
    }
  };
  return channel;
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var uri = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$1 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$2 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a2) {
  return a2 !== a2;
};
var $isNaN = _isNaN;
var sign$2 = function sign2(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : 1;
};
var gOPD = Object.getOwnPropertyDescriptor;
var $gOPD$1 = gOPD;
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var gopd = $gOPD$1;
var $defineProperty$1 = Object.defineProperty || false;
if ($defineProperty$1) {
  try {
    $defineProperty$1({}, "a", { value: 1 });
  } catch (e2) {
    $defineProperty$1 = false;
  }
}
var esDefineProperty = $defineProperty$1;
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object2 = esObjectAtoms;
  Object_getPrototypeOf = $Object2.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr2 = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a2, b2) {
    var arr = [];
    for (var i2 = 0; i2 < a2.length; i2 += 1) {
      arr[i2] = a2[i2];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a2.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset2) {
    var arr = [];
    for (var i2 = offset2, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
      arr[j2] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str += arr[i2];
      if (i2 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind4(that) {
    var target = this;
    if (typeof target !== "function" || toStr2.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
var bind$2 = requireFunctionBind();
var $apply$1 = requireFunctionApply();
var $call$2 = requireFunctionCall();
var $reflectApply = reflectApply;
var actualApply = $reflectApply || bind$2.call($call$2, $apply$1);
var bind$1 = requireFunctionBind();
var $TypeError$4 = type;
var $call$1 = requireFunctionCall();
var $actualApply = actualApply;
var callBindApplyHelpers = function callBindBasic2(args) {
  if (args.length < 1 || typeof args[0] !== "function") {
    throw new $TypeError$4("a function is required");
  }
  return $actualApply(bind$1, $call$1, args);
};
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get$1;
  hasRequiredGet = 1;
  var callBind = callBindApplyHelpers;
  var gOPD2 = gopd;
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e2) {
    if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
      throw e2;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object2 = Object;
  var $getPrototypeOf = $Object2.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object2(value));
    }
  ) : false;
  return get$1;
}
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O2) {
    return reflectGetProto(O2);
  } : originalGetProto ? function getProto2(O2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O2);
  } : getDunderProto ? function getProto2(O2) {
    return getDunderProto(O2);
  } : null;
  return getProto$1;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind4 = requireFunctionBind();
  hasown = bind4.call(call, $hasOwn);
  return hasown;
}
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$3 = type;
var $URIError = uri;
var abs = abs$1;
var floor = floor$1;
var max = max$1;
var min = min$1;
var pow = pow$1;
var round$1 = round$2;
var sign$1 = sign$2;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD = gopd;
var $defineProperty = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round$1,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto(getProto(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind = requireFunctionBind();
var hasOwn = requireHasown();
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first2 = $strSlice(string, 0, 1);
  var last2 = $strSlice(string, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match2, number, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts2 = stringToPath(name2);
  var intrinsicBaseName = parts2.length > 0 ? parts2[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts2, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts2.length; i2 += 1) {
    var part = parts2[i2];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts2.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var GetIntrinsic$2 = getIntrinsic;
var callBindBasic = callBindApplyHelpers;
var $indexOf = callBindBasic([GetIntrinsic$2("%String.prototype.indexOf%")]);
var callBound$2 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = (
    /** @type {Parameters<typeof callBindBasic>[0][0]} */
    GetIntrinsic$2(name2, !!allowMissing)
  );
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBindBasic([intrinsic]);
  }
  return intrinsic;
};
var GetIntrinsic$1 = getIntrinsic;
var callBound$1 = callBound$2;
var inspect$2 = objectInspect;
var $TypeError$2 = type;
var $Map = GetIntrinsic$1("%Map%", true);
var $mapGet = callBound$1("Map.prototype.get", true);
var $mapSet = callBound$1("Map.prototype.set", true);
var $mapHas = callBound$1("Map.prototype.has", true);
var $mapDelete = callBound$1("Map.prototype.delete", true);
var $mapSize = callBound$1("Map.prototype.size", true);
var sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
function getSideChannelMap2() {
  var $m;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$2("Side channel does not contain " + inspect$2(key));
      }
    },
    "delete": function(key) {
      if ($m) {
        var result = $mapDelete($m, key);
        if ($mapSize($m) === 0) {
          $m = void 0;
        }
        return result;
      }
      return false;
    },
    get: function(key) {
      if ($m) {
        return $mapGet($m, key);
      }
    },
    has: function(key) {
      if ($m) {
        return $mapHas($m, key);
      }
      return false;
    },
    set: function(key, value) {
      if (!$m) {
        $m = new $Map();
      }
      $mapSet($m, key, value);
    }
  };
  return channel;
};
var GetIntrinsic = getIntrinsic;
var callBound = callBound$2;
var inspect$1 = objectInspect;
var getSideChannelMap$1 = sideChannelMap;
var $TypeError$1 = type;
var $WeakMap = GetIntrinsic("%WeakMap%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
var sideChannelWeakmap = $WeakMap ? (
  /** @type {Exclude<import('.'), false>} */
  function getSideChannelWeakMap2() {
    var $wm;
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError$1("Side channel does not contain " + inspect$1(key));
        }
      },
      "delete": function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap$1) {
          if ($m) {
            return $m["delete"](key);
          }
        }
        return false;
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap$1) {
          if (!$m) {
            $m = getSideChannelMap$1();
          }
          $m.set(key, value);
        }
      }
    };
    return channel;
  }
) : getSideChannelMap$1;
var $TypeError = type;
var inspect = objectInspect;
var getSideChannelList = sideChannelList;
var getSideChannelMap = sideChannelMap;
var getSideChannelWeakMap = sideChannelWeakmap;
var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
var sideChannel = function getSideChannel2() {
  var $channelData;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    "delete": function(key) {
      return !!$channelData && $channelData["delete"](key);
    },
    get: function(key) {
      return $channelData && $channelData.get(key);
    },
    has: function(key) {
      return !!$channelData && $channelData.has(key);
    },
    set: function(key, value) {
      if (!$channelData) {
        $channelData = makeChannel();
      }
      $channelData.set(key, value);
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$4 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$3 = formats$4;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? { __proto__: null } : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object" && typeof source !== "function") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, defaultDecoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var limit = 1024;
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var j2 = 0; j2 < string.length; j2 += limit) {
    var segment = string.length >= limit ? string.slice(j2, j2 + limit) : string;
    var arr = [];
    for (var i2 = 0; i2 < segment.length; ++i2) {
      var c2 = segment.charCodeAt(i2);
      if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$3.RFC1738 && (c2 === 40 || c2 === 41)) {
        arr[arr.length] = segment.charAt(i2);
        continue;
      }
      if (c2 < 128) {
        arr[arr.length] = hexTable[c2];
        continue;
      }
      if (c2 < 2048) {
        arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
        continue;
      }
      if (c2 < 55296 || c2 >= 57344) {
        arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        continue;
      }
      i2 += 1;
      c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i2) & 1023);
      arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
    }
    out += arr.join("");
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j2 = 0; j2 < keys.length; ++j2) {
      var key = keys[j2];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b2) {
  return [].concat(a2, b2);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
};
var getSideChannel = sideChannel;
var utils$1 = utils$2;
var formats$2 = formats$4;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix2) {
    return prefix2 + "[]";
  },
  comma: "comma",
  indices: function indices2(prefix2, key) {
    return prefix2 + "[" + key + "]";
  },
  repeat: function repeat(prefix2) {
    return prefix2;
  }
};
var isArray$1 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$2["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  commaRoundTrip: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  filter: void 0,
  format: defaultFormat,
  formatter: formats$2.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify2(object, prefix2, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort2, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix2, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix2, defaults$1.encoder, charset, "key", format2) : prefix2;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix2) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort2 ? keys.sort(sort2) : keys;
  }
  var encodedPrefix = encodeDotInKeys ? String(prefix2).replace(/\./g, "%2E") : String(prefix2);
  var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
  if (allowEmptyArrays && isArray$1(obj) && obj.length === 0) {
    return adjustedPrefix + "[]";
  }
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key = objKeys[j2];
    var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify2(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder,
      filter,
      sort2,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$2["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$2.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$2.formatters[format2];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter = opts.filter;
  }
  var arrayFormat;
  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults$1.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$1(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    var value = obj[key];
    if (options.skipNulls && value === null) {
      continue;
    }
    pushToArray(keys, stringify$1(
      value,
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys.join(options.delimiter);
  var prefix2 = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix2 += "utf8=%26%2310003%3B&";
    } else {
      prefix2 += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix2 + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictDepth: false,
  strictNullHandling: false,
  throwOnLimitExceeded: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options, currentArrayLength) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
    throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  var limit2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts2 = cleanStr.split(
    options.delimiter,
    options.throwOnLimitExceeded ? limit2 + 1 : limit2
  );
  if (options.throwOnLimitExceeded && parts2.length > limit2) {
    throw new RangeError("Parameter limit exceeded. Only " + limit2 + " parameter" + (limit2 === 1 ? "" : "s") + " allowed.");
  }
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts2.length; ++i2) {
      if (parts2[i2].indexOf("utf8=") === 0) {
        if (parts2[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts2[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts2.length;
      }
    }
  }
  for (i2 = 0; i2 < parts2.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts2[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key;
    var val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(
          part.slice(pos + 1),
          options,
          isArray(obj[key]) ? obj[key].length : 0
        ),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(String(val));
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    var existing = has.call(obj, key);
    if (existing && options.duplicates === "combine") {
      obj[key] = utils.combine(obj[key], val);
    } else if (!existing || options.duplicates === "last") {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var currentArrayLength = 0;
  if (chain.length > 0 && chain[chain.length - 1] === "[]") {
    var parentKey = chain.slice(0, -1).join("");
    currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
  }
  var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root = chain[i2];
    if (root === "[]" && options.parseArrays) {
      obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
    } else {
      obj = options.plainObjects ? { __proto__: null } : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
      var index = parseInt(decodedRoot, 10);
      if (!options.parseArrays && decodedRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else if (decodedRoot !== "__proto__") {
        obj[decodedRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    if (options.strictDepth === true) {
      throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
    }
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
    throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
  if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
    throw new TypeError("The duplicates option must be either combine, first, or last");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
    throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
  };
};
var parse$3 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? { __proto__: null } : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? { __proto__: null } : {};
  var keys = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys.length; ++i2) {
    var key = keys[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify = stringify_1;
var parse$2 = parse$3;
var formats$1 = formats$4;
var lib = {
  formats: formats$1,
  parse: parse$2,
  stringify
};
var punycode = punycodeExports;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: true,
  "javascript:": true
}, hostlessProtocol = {
  javascript: true,
  "javascript:": true
}, slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = lib;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && typeof url2 === "object" && url2 instanceof Url) {
    return url2;
  }
  var u2 = new Url();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (typeof url2 !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p2 = this.port ? ":" + this.port : "";
    var h2 = this.hostname || "";
    this.host = h2 + p2;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae2 = autoEscape[i2];
      if (rest.indexOf(ae2) === -1) {
        continue;
      }
      var esc2 = encodeURIComponent(ae2);
      if (esc2 === ae2) {
        esc2 = escape(ae2);
      }
      rest = rest.split(ae2).join(esc2);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p2 = this.pathname || "";
    var s2 = this.search || "";
    this.path = p2 + s2;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query2 = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
    query2 = querystring.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    });
  }
  var search = this.search || query2 && "?" + query2 || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/" + pathname;
    }
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#") {
    hash2 = "#" + hash2;
  }
  if (search && search.charAt(0) !== "?") {
    search = "?" + search;
  }
  pathname = pathname.replace(/[?#]/g, function(match2) {
    return encodeURIComponent(match2);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url.prototype.resolveObject = function(relative) {
  if (typeof relative === "string") {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk2 = 0; tk2 < tkeys.length; tk2++) {
    var tkey = tkeys[tk2];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk2 = 0; rk2 < rkeys.length; rk2++) {
      var rkey = rkeys[rk2];
      if (rkey !== "protocol") {
        result[rkey] = relative[rkey];
      }
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v2 = 0; v2 < keys.length; v2++) {
        var k2 = keys[v2];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift())) {
      }
      if (!relative.host) {
        relative.host = "";
      }
      if (!relative.hostname) {
        relative.hostname = "";
      }
      if (relPath[0] !== "") {
        relPath.unshift("");
      }
      if (relPath.length < 2) {
        relPath.unshift("");
      }
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "") {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "") {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last2 = srcPath[i2];
    if (last2 === ".") {
      srcPath.splice(i2, 1);
    } else if (last2 === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    result.host = result.hostname;
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join("/");
  } else {
    result.pathname = null;
    result.path = null;
  }
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse$1 = urlParse;
var resolve$1 = urlResolve;
var format = urlFormat;
const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message])
    return;
  let stack = new Error().stack;
  typeof stack > "u" ? console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`) : (stack = stack.split(`
`).splice(ignoreDepth).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${message}
Deprecated since v${version}`
  ), console.warn(stack), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`), console.warn(stack))), warnings[message] = true;
}
const url = {
  /**
   * @deprecated since 7.3.0
   */
  get parse() {
    return deprecation("7.3.0", "utils.url.parse is deprecated, use native URL API instead."), parse$1;
  },
  /**
   * @deprecated since 7.3.0
   */
  get format() {
    return deprecation("7.3.0", "utils.url.format is deprecated, use native URL API instead."), format;
  },
  /**
   * @deprecated since 7.3.0
   */
  get resolve() {
    return deprecation("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."), resolve$1;
  }
};
function assertPath(path2) {
  if (typeof path2 != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
}
function removeUrlParams(url2) {
  return url2.split("?")[0].split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace2) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace2);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length)
      code = path2.charCodeAt(i2);
    else {
      if (code === 47)
        break;
      code = 47;
    }
    if (code === 47) {
      if (!(lastSlash === i2 - 1 || dots === 1))
        if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = i2, dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "", lastSegmentLength = 0, lastSlash = i2, dots = 0;
              continue;
            }
          }
        } else
          res.length > 0 ? res += `/${path2.slice(lastSlash + 1, i2)}` : res = path2.slice(lastSlash + 1, i2), lastSegmentLength = i2 - lastSlash - 1;
      lastSlash = i2, dots = 0;
    } else
      code === 46 && dots !== -1 ? ++dots : dots = -1;
  }
  return res;
}
const path = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(path2) {
    return path2.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(path2) {
    assertPath(path2), path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    if (matchFile)
      return matchFile[0];
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
    return matchProtocol ? matchProtocol[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(url2, customBaseUrl, customRootUrl) {
    if (assertPath(url2), this.isDataUrl(url2) || this.isBlobUrl(url2))
      return url2;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    return url2 = this.toPosix(url2), url2.startsWith("/") ? path.join(rootUrl, url2.slice(1)) : this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(path2) {
    if (assertPath(path2), path2.length === 0)
      return ".";
    if (this.isDataUrl(path2) || this.isBlobUrl(path2))
      return path2;
    path2 = this.toPosix(path2);
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    this.hasProtocol(path2) && (protocol = this.rootname(path2), path2 = path2.slice(protocol.length));
    const trailingSeparator = path2.endsWith("/");
    return path2 = normalizeStringPosix(path2), path2.length > 0 && trailingSeparator && (path2 += "/"), isAbsolute ? `/${path2}` : protocol + path2;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(path2) {
    return assertPath(path2), path2 = this.toPosix(path2), this.hasProtocol(path2) ? true : path2.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...segments) {
    if (segments.length === 0)
      return ".";
    let joined;
    for (let i2 = 0; i2 < segments.length; ++i2) {
      const arg = segments[i2];
      if (assertPath(arg), arg.length > 0)
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i2 - 1] ?? "";
          this.joinExtensions.includes(this.extname(prevArg).toLowerCase()) ? joined += `/../${arg}` : joined += `/${arg}`;
        }
    }
    return joined === void 0 ? "." : this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(path2) {
    if (assertPath(path2), path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1, matchedSlash = true;
    const proto = this.getProtocol(path2), origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i2 = path2.length - 1; i2 >= 1; --i2)
      if (code = path2.charCodeAt(i2), code === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else
        matchedSlash = false;
    return end === -1 ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto : hasRoot && end === 1 ? "//" : proto + path2.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(path2) {
    assertPath(path2), path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/") ? root = "/" : root = this.getProtocol(path2), this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      index !== -1 ? root = path2.slice(0, index) : root = path2, root.endsWith("/") || (root += "/");
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(path2, ext) {
    assertPath(path2), ext && assertPath(ext), path2 = removeUrlParams(this.toPosix(path2));
    let start = 0, end = -1, matchedSlash = true, i2;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else
          firstNonSlashEnd === -1 && (matchedSlash = false, firstNonSlashEnd = i2 + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i2) : (extIdx = -1, end = firstNonSlashEnd));
      }
      return start === end ? end = firstNonSlashEnd : end === -1 && (end = path2.length), path2.slice(start, end);
    }
    for (i2 = path2.length - 1; i2 >= 0; --i2)
      if (path2.charCodeAt(i2) === 47) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else
        end === -1 && (matchedSlash = false, end = i2 + 1);
    return end === -1 ? "" : path2.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(path2) {
    assertPath(path2), path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
    for (let i2 = path2.length - 1; i2 >= 0; --i2) {
      const code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = false, end = i2 + 1), code === 46 ? startDot === -1 ? startDot = i2 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path2.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2), isAbsolute || this.hasProtocol(path2) ? start = 1 : start = 0;
    let startDot = -1, startPart = 0, end = -1, matchedSlash = true, i2 = path2.length - 1, preDotState = 0;
    for (; i2 >= start; --i2) {
      if (code = path2.charCodeAt(i2), code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = false, end = i2 + 1), code === 46 ? startDot === -1 ? startDot = i2 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path2.slice(1, end) : ret.base = ret.name = path2.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path2.slice(1, startDot), ret.base = path2.slice(1, end)) : (ret.name = path2.slice(startPart, startDot), ret.base = path2.slice(startPart, end)), ret.ext = path2.slice(startDot, end)), ret.dir = this.dirname(path2), ret;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
let promise;
async function detectVideoAlphaMode() {
  return promise ?? (promise = (async () => {
    const gl2 = document.createElement("canvas").getContext("webgl");
    if (!gl2)
      return ALPHA_MODES.UNPACK;
    const video = await new Promise((resolve2) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve2(video2), video2.onerror = () => resolve2(null), video2.autoplay = false, video2.crossOrigin = "anonymous", video2.preload = "auto", video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", video2.load();
    });
    if (!video)
      return ALPHA_MODES.UNPACK;
    const texture = gl2.createTexture();
    gl2.bindTexture(gl2.TEXTURE_2D, texture);
    const framebuffer = gl2.createFramebuffer();
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer), gl2.framebufferTexture2D(
      gl2.FRAMEBUFFER,
      gl2.COLOR_ATTACHMENT0,
      gl2.TEXTURE_2D,
      texture,
      0
    ), gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), gl2.pixelStorei(gl2.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl2.NONE), gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    return gl2.readPixels(0, 0, 1, 1, gl2.RGBA, gl2.UNSIGNED_BYTE, pixel), gl2.deleteFramebuffer(framebuffer), gl2.deleteTexture(texture), gl2.getExtension("WEBGL_lose_context")?.loseContext(), pixel[0] <= pixel[3] ? ALPHA_MODES.PMA : ALPHA_MODES.UNPACK;
  })()), promise;
}
let supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings.ADAPTER.getWebGLRenderingContext())
        return false;
      const canvas = settings.ADAPTER.createCanvas();
      let gl2 = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
      const success = !!gl2?.getContextAttributes()?.stencil;
      if (gl2) {
        const loseContext = gl2.getExtension("WEBGL_lose_context");
        loseContext && loseContext.loseContext();
      }
      return gl2 = null, success;
    } catch {
      return false;
    }
  }()), supported;
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
}, n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a = function(r2) {
  return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
}, o = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i = /^#([0-9a-f]{3,8})$/i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
}, b = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
}, g = function(r2) {
  return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
}, d = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f = function(r2) {
  return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
}, c = function(r2) {
  return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
}, l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = { string: [[function(r2) {
  var t2 = i.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l.exec(t2) || p.exec(t2);
  if (!n2) return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
  if (!t(n2) || !t(e2) || !t(u2)) return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a2) || !t(o2)) return null;
  var h2 = function(r3) {
    return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
  }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b(h2);
}, "hsv"]] }, N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2) return [e2, t2[n2][1]];
  }
  return [null, void 0];
}, x = function(r2) {
  return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
}, M = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $ = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j = function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w$1({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w$1(M(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w$1({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c(this.rgba);
    return "number" == typeof r3 ? w$1({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w$1(r3).toHex();
  }, r2;
}(), w$1 = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
}, S = [], k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
  });
};
function namesPlugin(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2) r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
k([namesPlugin]);
const _Color = class _Color2 {
  /**
   * @param {PIXI.ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see PIXI.Color.value
   */
  setValue(value) {
    return this.value = value, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link PIXI.Color.multiply multiply},
   *   {@link PIXI.Color.premultiply premultiply} or {@link PIXI.Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   * @type {PIXI.ColorSource}
   */
  set value(value) {
    if (value instanceof _Color2)
      this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);
    else {
      if (value === null)
        throw new Error("Cannot set PIXI.Color#value to null");
      (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  cloneSource(value) {
    return typeof value == "string" || typeof value == "number" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == "object" && value !== null ? { ...value } : value;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    if (type1 !== typeof value2)
      return false;
    if (type1 === "number" || type1 === "string" || value1 instanceof Number)
      return value1 === value2;
    if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))
      return value1.length !== value2.length ? false : value1.every((v2, i2) => v2 === value2[i2]);
    if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1), keys2 = Object.keys(value2);
      return keys1.length !== keys2.length ? false : keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [r2, g2, b2, a2] = this._components;
    return { r: r2, g: g2, b: b2, a: a2 };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [r2, g2, b2] = this._components;
    return { r: r2, g: g2, b: b2 };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b2},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r2, g2, b2] = this._components;
    return out = out ?? [], out[0] = Math.round(r2 * 255), out[1] = Math.round(g2 * 255), out[2] = Math.round(b2 * 255), out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r2, g2, b2] = this._components;
    return out[0] = r2, out[1] = g2, out[2] = b2, out;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {PIXI.ColorSource} value - The color to multiply by.
   */
  multiply(value) {
    const [r2, g2, b2, a2] = _Color2.temp.setValue(value)._components;
    return this._components[0] *= r2, this._components[1] *= g2, this._components[2] *= b2, this._components[3] *= a2, this.refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {PIXI.Color} - Itself.
   */
  premultiply(alpha, applyToRGB = true) {
    return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1)
      return (255 << 24) + this._int;
    if (alpha === 0)
      return applyToRGB ? 0 : this._int;
    let r2 = this._int >> 16 & 255, g2 = this._int >> 8 & 255, b2 = this._int & 255;
    return applyToRGB && (r2 = r2 * alpha + 0.5 | 0, g2 = g2 * alpha + 0.5 | 0, b2 = b2 * alpha + 0.5 | 0), (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
  }
  /**
   * Convert to a hexidecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexidecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const alphaString = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(alpha) {
    return this._components[3] = this._clamp(alpha), this;
  }
  /**
   * Rounds the specified color according to the step. This action is destructive, and will
   * override the previous `value` property to be `null`. The alpha component is not rounded.
   * @param steps - Number of steps which will be used as a cap when rounding colors
   * @deprecated since 7.3.0
   */
  round(steps) {
    const [r2, g2, b2] = this._components;
    return this._components[0] = Math.round(r2 * steps) / steps, this._components[1] = Math.round(g2 * steps) / steps, this._components[2] = Math.round(b2 * steps) / steps, this.refreshInt(), this._value = null, this;
  }
  toArray(out) {
    out = out ?? [];
    const [r2, g2, b2, a2] = this._components;
    return out[0] = r2, out[1] = g2, out[2] = b2, out[3] = a2, out;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  normalize(value) {
    let r2, g2, b2, a2;
    if ((typeof value == "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r2 = (int >> 16 & 255) / 255, g2 = (int >> 8 & 255) / 255, b2 = (int & 255) / 255, a2 = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value), [r2, g2, b2, a2 = 1] = value;
    else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value, 0, 255), [r2, g2, b2, a2 = 255] = value, r2 /= 255, g2 /= 255, b2 /= 255, a2 /= 255;
    else if (typeof value == "string" || typeof value == "object") {
      if (typeof value == "string") {
        const match2 = _Color2.HEX_PATTERN.exec(value);
        match2 && (value = `#${match2[2]}`);
      }
      const color = w$1(value);
      color.isValid() && ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba, r2 /= 255, g2 /= 255, b2 /= 255);
    }
    if (r2 !== void 0)
      this._components[0] = r2, this._components[1] = g2, this._components[2] = b2, this._components[3] = a2, this.refreshInt();
    else
      throw new Error(`Unable to convert color ${value}`);
  }
  /** Refresh the internal color rgb number */
  refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b2] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value, min2 = 0, max2 = 1) {
    return typeof value == "number" ? Math.min(Math.max(value, min2), max2) : (value.forEach((v2, i2) => {
      value[i2] = Math.min(Math.max(v2, min2), max2);
    }), value);
  }
};
_Color.shared = new _Color(), /**
* Temporary Color object for static uses internally.
* As to not conflict with Color.shared.
* @ignore
*/
_Color.temp = new _Color(), /** Pattern for hex strings */
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;
function hex2string(hex) {
  return deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), Color.shared.setValue(hex).toHex();
}
function rgb2hex(rgb) {
  return deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), Color.shared.setValue(rgb).toNumber();
}
function mapPremultipliedBlendModes() {
  const pm = [], npm = [];
  for (let i2 = 0; i2 < 32; i2++)
    pm[i2] = i2, npm[i2] = i2;
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  const array = [];
  return array.push(npm), array.push(pm), array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function createIndicesForQuads(size2, outBuffer = null) {
  const totalIndices = size2 * 6;
  if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4)
    outBuffer[i2 + 0] = j2 + 0, outBuffer[i2 + 1] = j2 + 1, outBuffer[i2 + 2] = j2 + 2, outBuffer[i2 + 3] = j2 + 0, outBuffer[i2 + 4] = j2 + 2, outBuffer[i2 + 5] = j2 + 3;
  return outBuffer;
}
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4)
    return array instanceof Float32Array ? "Float32Array" : array instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array)
      return "Uint16Array";
  } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(v2) {
  return v2 += v2 === 0 ? 1 : 0, --v2, v2 |= v2 >>> 1, v2 |= v2 >>> 2, v2 |= v2 >>> 4, v2 |= v2 >>> 8, v2 |= v2 >>> 16, v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  let r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  let shift2 = (v2 > 255 ? 1 : 0) << 3;
  return v2 >>>= shift2, r2 |= shift2, shift2 = (v2 > 15 ? 1 : 0) << 2, v2 >>>= shift2, r2 |= shift2, shift2 = (v2 > 3 ? 1 : 0) << 1, v2 >>>= shift2, r2 |= shift2, r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  const length2 = arr.length;
  let i2;
  if (startIdx >= length2 || removeCount === 0)
    return;
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  const len = length2 - removeCount;
  for (i2 = startIdx; i2 < len; ++i2)
    arr[i2] = arr[i2 + removeCount];
  arr.length = len;
}
function sign(n2) {
  return n2 === 0 ? 0 : n2 < 0 ? -1 : 1;
}
let nextUid = 0;
function uid() {
  return ++nextUid;
}
const _BoundingBox = class {
  /**
   * @param left - The left coordinate value of the bounding box.
   * @param top - The top coordinate value of the bounding box.
   * @param right - The right coordinate value of the bounding box.
   * @param bottom - The bottom coordinate value of the bounding box.
   */
  constructor(left, top, right, bottom) {
    this.left = left, this.top = top, this.right = right, this.bottom = bottom;
  }
  /** The width of the bounding box. */
  get width() {
    return this.right - this.left;
  }
  /** The height of the bounding box. */
  get height() {
    return this.bottom - this.top;
  }
  /** Determines whether the BoundingBox is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
_BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
let BoundingBox = _BoundingBox;
const ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache)
    TextureCache[key].destroy();
  for (key in BaseTextureCache)
    BaseTextureCache[key].destroy();
}
function clearTextureCache() {
  let key;
  for (key in TextureCache)
    delete TextureCache[key];
  for (key in BaseTextureCache)
    delete BaseTextureCache[key];
}
class CanvasRenderTarget {
  /**
   * @param width - the width for the newly created canvas
   * @param height - the height for the newly created canvas
   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas
   */
  constructor(width, height, resolution) {
    this._canvas = settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = resolution || settings.RESOLUTION, this.resize(width, height);
  }
  /**
   * Clears the canvas that was created by the CanvasRenderTarget class.
   * @private
   */
  clear() {
    this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  /**
   * Resizes the canvas to the specified width and height.
   * @param desiredWidth - the desired width of the canvas
   * @param desiredHeight - the desired height of the canvas
   */
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  /** Destroys this canvas. */
  destroy() {
    this._context = null, this._canvas = null;
  }
  /**
   * The width of the canvas buffer in pixels.
   * @member {number}
   */
  get width() {
    return this._checkDestroyed(), this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed(), this._canvas.width = Math.round(val);
  }
  /**
   * The height of the canvas buffer in pixels.
   * @member {number}
   */
  get height() {
    return this._checkDestroyed(), this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed(), this._canvas.height = Math.round(val);
  }
  /** The Canvas object that belongs to this CanvasRenderTarget. */
  get canvas() {
    return this._checkDestroyed(), this._canvas;
  }
  /** A CanvasRenderingContext2D object representing a two-dimensional rendering context. */
  get context() {
    return this._checkDestroyed(), this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null)
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4)
    if (data[index + 3] !== 0)
      return false;
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride)
    if (data[index + 3] !== 0)
      return false;
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas, context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context2 === null)
    throw new TypeError("Failed to get canvas 2D context");
  const data = context2.getImageData(0, 0, width, height).data;
  let left = 0, top = 0, right = width - 1, bottom = height - 1;
  for (; top < height && checkRow(data, width, top); )
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  for (; checkRow(data, width, bottom); )
    --bottom;
  for (; checkColumn(data, width, left, top, bottom); )
    ++left;
  for (; checkColumn(data, width, right, top, bottom); )
    --right;
  return ++right, ++bottom, new BoundingBox(left, top, right, bottom);
}
function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox(canvas), { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context2 = canvas.getContext("2d");
    if (context2 === null)
      throw new TypeError("Failed to get canvas 2D context");
    data = context2.getImageData(
      boundingBox.left,
      boundingBox.top,
      width,
      height
    );
  }
  return { width, height, data };
}
function determineCrossOrigin(url2, loc = globalThis.location) {
  if (url2.startsWith("data:"))
    return "";
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url2, document.baseURI);
  return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(url2, defaultValue2 = 1) {
  const resolution = settings.RETINA_PREFIX?.exec(url2);
  return resolution ? parseFloat(resolution[1]) : defaultValue2;
}
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => (ExtensionType2.Renderer = "renderer", ExtensionType2.Application = "application", ExtensionType2.RendererSystem = "renderer-webgl-system", ExtensionType2.RendererPlugin = "renderer-webgl-plugin", ExtensionType2.CanvasRendererSystem = "renderer-canvas-system", ExtensionType2.CanvasRendererPlugin = "renderer-canvas-plugin", ExtensionType2.Asset = "asset", ExtensionType2.LoadParser = "load-parser", ExtensionType2.ResolveParser = "resolve-parser", ExtensionType2.CacheParser = "cache-parser", ExtensionType2.DetectionParser = "detection-parser", ExtensionType2))(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext == "function" || typeof ext == "object" && ext.extension) {
    if (!ext.extension)
      throw new Error("Extension class must have an extension object");
    ext = { ...typeof ext.extension != "object" ? { type: ext.extension } : ext.extension, ref: ext };
  }
  if (typeof ext == "object")
    ext = { ...ext };
  else
    throw new Error("Invalid extension type");
  return typeof ext.type == "string" && (ext.type = [ext.type]), ext;
}, normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority, extensions$1 = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove(...extensions2) {
    return extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type2) => this._removeHandlers[type2]?.(ext));
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add(...extensions2) {
    return extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type2) => {
        const handlers2 = this._addHandlers, queue = this._queue;
        handlers2[type2] ? handlers2[type2]?.(ext) : (queue[type2] = queue[type2] || [], queue[type2]?.push(ext));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle(type2, onAdd, onRemove) {
    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;
    if (addHandlers[type2] || removeHandlers[type2])
      throw new Error(`Extension type ${type2} already has a handler`);
    addHandlers[type2] = onAdd, removeHandlers[type2] = onRemove;
    const queue = this._queue;
    return queue[type2] && (queue[type2]?.forEach((ext) => onAdd(ext)), delete queue[type2]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap(type2, map2) {
    return this.handle(
      type2,
      (extension) => {
        extension.name && (map2[extension.name] = extension.ref);
      },
      (extension) => {
        extension.name && delete map2[extension.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList(type2, list, defaultPriority = -1) {
    return this.handle(
      type2,
      (extension) => {
        list.includes(extension.ref) || (list.push(extension.ref), list.sort((a2, b2) => normalizePriority(b2, defaultPriority) - normalizePriority(a2, defaultPriority)));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        index !== -1 && list.splice(index, 1);
      }
    );
  }
};
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    typeof sizeOrBuffer == "number" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Uint16Array`. */
  get uint16View() {
    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type2) {
    return this[`${type2}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  static sizeOf(type2) {
    switch (type2) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type2} isn't a valid view type`);
    }
  }
}
const fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2)
    i2 > 0 && (src += `
else `), i2 < maxIfs - 1 && (src += `if(test == ${i2}.0){}`);
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl2) {
  if (maxIfs === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const shader = gl2.createShader(gl2.FRAGMENT_SHADER);
  for (; ; ) {
    const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    if (gl2.shaderSource(shader, fragmentSrc), gl2.compileShader(shader), !gl2.getShaderParameter(shader, gl2.COMPILE_STATUS))
      maxIfs = maxIfs / 2 | 0;
    else
      break;
  }
  return maxIfs;
}
const BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5;
class State {
  constructor() {
    this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND$1);
  }
  set blend(value) {
    !!(this.data & 1 << BLEND$1) !== value && (this.data ^= 1 << BLEND$1);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET$1);
  }
  set offsets(value) {
    !!(this.data & 1 << OFFSET$1) !== value && (this.data ^= 1 << OFFSET$1);
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING$1);
  }
  set culling(value) {
    !!(this.data & 1 << CULLING$1) !== value && (this.data ^= 1 << CULLING$1);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST$1);
  }
  set depthTest(value) {
    !!(this.data & 1 << DEPTH_TEST$1) !== value && (this.data ^= 1 << DEPTH_TEST$1);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK$1);
  }
  set depthMask(value) {
    !!(this.data & 1 << DEPTH_MASK$1) !== value && (this.data ^= 1 << DEPTH_MASK$1);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING$1);
  }
  set clockwiseFrontFace(value) {
    !!(this.data & 1 << WINDING$1) !== value && (this.data ^= 1 << WINDING$1);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== BLEND_MODES.NONE, this._blendMode = value;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value, this._polygonOffset = value;
  }
  static for2d() {
    const state = new State();
    return state.depthTest = false, state.blend = true, state;
  }
}
State.prototype.toString = function() {
  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
};
const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source)
    return null;
  let extension = "";
  if (typeof source == "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    result && (extension = result[1].toLowerCase());
  }
  for (let i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
    const ResourcePlugin = INSTALLED[i2];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension))
      return new ResourcePlugin(source, options);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
class Runner {
  /**
   * @param {string} name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name2) {
    this.items = [], this._name = name2, this._aliasCount = 0;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    const { name: name2, items } = this;
    this._aliasCount++;
    for (let i2 = 0, len = items.length; i2 < len; i2++)
      items[i2][name2](a0, a1, a2, a3, a4, a5, a6, a7);
    return items === this.items && this._aliasCount--, this;
  }
  ensureNonAliasedItems() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * E.g. A listener passed to this Runner will require a 'complete' function.
   *
   * ```js
   * import { Runner } from '@pixi/runner';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.includes(item);
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items.length = 0, this._name = "";
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @type {string}
   */
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
class Resource {
  /**
   * @param width - Width of the resource
   * @param height - Height of the resource
   */
  constructor(width = 0, height = 0) {
    this._width = width, this._height = height, this.destroyed = false, this.internal = false, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
  }
  /**
   * Bind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  bind(baseTexture) {
    this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }
  /**
   * Unbind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  unbind(baseTexture) {
    this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);
  }
  /**
   * Trigger a resize event
   * @param width - X dimension
   * @param height - Y dimension
   */
  resize(width, height) {
    (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));
  }
  /**
   * Has been validated
   * @readonly
   */
  get valid() {
    return !!this._width && !!this._height;
  }
  /** Has been updated trigger event. */
  update() {
    this.destroyed || this.onUpdate.emit();
  }
  /**
   * This can be overridden to start preloading a resource
   * or do any other prepare step.
   * @protected
   * @returns Handle the validate event
   */
  load() {
    return Promise.resolve(this);
  }
  /**
   * The width of the resource.
   * @readonly
   */
  get width() {
    return this._width;
  }
  /**
   * The height of the resource.
   * @readonly
   */
  get height() {
    return this._height;
  }
  /**
   * Set the style, optional to override
   * @param _renderer - yeah, renderer!
   * @param _baseTexture - the texture
   * @param _glTexture - texture instance for this webgl context
   * @returns - `true` is success
   */
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  /** Clean up anything, this happens when destroying is ready. */
  dispose() {
  }
  /**
   * Call when destroying resource, unbind any BaseTexture object
   * before calling this method, as reference counts are maintained
   * internally.
   */
  destroy() {
    this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }
  /**
   * Abstract, used to auto-detect resource type.
   * @param {*} _source - The source object
   * @param {string} _extension - The extension of source, if set
   */
  static test(_source, _extension) {
    return false;
  }
}
class BufferResource extends Resource {
  /**
   * @param source - Source buffer
   * @param options - Options
   * @param {number} options.width - Width of the texture
   * @param {number} options.height - Height of the texture
   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.
   */
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height)
      throw new Error("BufferResource width or height invalid");
    super(width, height), this.data = source, this.unpackAlignment = options.unpackAlignment ?? 4;
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture - glTexture
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture) {
    const gl2 = renderer.gl;
    gl2.pixelStorei(gl2.UNPACK_ALIGNMENT, this.unpackAlignment), gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth, height = baseTexture.realHeight;
    return glTexture.width === width && glTexture.height === height ? gl2.texSubImage2D(
      baseTexture.target,
      0,
      0,
      0,
      width,
      height,
      baseTexture.format,
      glTexture.type,
      this.data
    ) : (glTexture.width = width, glTexture.height = height, gl2.texImage2D(
      baseTexture.target,
      0,
      glTexture.internalFormat,
      width,
      height,
      0,
      baseTexture.format,
      glTexture.type,
      this.data
    )), true;
  }
  /** Destroy and don't use after this. */
  dispose() {
    this.data = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if buffer source
   */
  static test(source) {
    return source === null || source instanceof Int8Array || source instanceof Uint8Array || source instanceof Uint8ClampedArray || source instanceof Int16Array || source instanceof Uint16Array || source instanceof Int32Array || source instanceof Uint32Array || source instanceof Float32Array;
  }
}
const defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  alphaMode: ALPHA_MODES.NPM
}, _BaseTexture = class _BaseTexture2 extends EventEmitter {
  /**
   * @param {PIXI.Resource|PIXI.ImageSource|string} [resource=null] -
   *        The current resource to use, for things that aren't Resource objects, will be converted
   *        into a Resource.
   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.
   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture
   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture
   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures
   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest
   * @param {PIXI.FORMATS} [options.format] - GL format type
   * @param {PIXI.TYPES} [options.type] - GL data type
   * @param {PIXI.TARGETS} [options.target] - GL texture target
   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha
   * @param {number} [options.width=0] - Width of the texture
   * @param {number} [options.height=0] - Height of the texture
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture
   * @param {object} [options.resourceOptions] - Optional resource options,
   *        see {@link PIXI.autoDetectResource autoDetectResource}
   */
  constructor(resource = null, options = null) {
    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format: format2,
      type: type2,
      target,
      resolution,
      resourceOptions
    } = options;
    resource && !(resource instanceof Resource) && (resource = autoDetectResource(resource, resourceOptions), resource.internal = true), this.resolution = resolution || settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format2, this.type = type2, this.target = target, this.alphaMode = alphaMode, this.uid = uid(), this.touched = 0, this.isPowerOfTwo = false, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = false, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);
  }
  /**
   * Pixel width of the source of this texture
   * @readonly
   */
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  /**
   * Pixel height of the source of this texture
   * @readonly
   */
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  /**
   * Mipmap mode of the texture, affects downscaled images
   * @default PIXI.MIPMAP_MODES.POW2
   */
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);
  }
  /**
   * The scale mode to apply when scaling this texture
   * @default PIXI.SCALE_MODES.LINEAR
   */
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);
  }
  /**
   * How the texture wraps
   * @default PIXI.WRAP_MODES.CLAMP
   */
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);
  }
  /**
   * Changes style options of BaseTexture
   * @param scaleMode - Pixi scalemode
   * @param mipmap - enable mipmaps
   * @returns - this
   */
  setStyle(scaleMode, mipmap) {
    let dirty;
    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = true), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = true), dirty && this.dirtyStyleId++, this;
  }
  /**
   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
   * @param desiredWidth - Desired visual width
   * @param desiredHeight - Desired visual height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setSize(desiredWidth, desiredHeight, resolution) {
    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  /**
   * Sets real size of baseTexture, preserves current resolution.
   * @param realWidth - Full rendered width
   * @param realHeight - Full rendered height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setRealSize(realWidth, realHeight, resolution) {
    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  /**
   * Changes resolution
   * @param resolution - res
   * @returns - this
   */
  setResolution(resolution) {
    const oldResolution = this.resolution;
    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);
  }
  /**
   * Sets the resource if it wasn't set. Throws error if resource already present
   * @param resource - that is managing this BaseTexture
   * @returns - this
   */
  setResource(resource) {
    if (this.resource === resource)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return resource.bind(this), this.resource = resource, this;
  }
  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */
  update() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
  }
  /**
   * Handle errors with resources.
   * @private
   * @param event - Error event emitted.
   */
  onError(event) {
    this.emit("error", this, event);
  }
  /**
   * Destroys this base texture.
   * The method stops if resource doesn't want this texture to be destroyed.
   * Removes texture from all caches.
   * @fires PIXI.BaseTexture#destroyed
   */
  destroy() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.valid = false, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Frees the texture from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.emit("dispose", this);
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this;
  }
  /**
   * Helper function that creates a base texture based on the source you provide.
   * The source can be - image url, image element, canvas element. If the
   * source is an image url or an image element and not in the base texture
   * cache, it will be created and loaded.
   * @static
   * @param {PIXI.ImageSource|string|string[]} source - The
   *        source to create base texture from.
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.BaseTexture} The new base texture.
   */
  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame2 = typeof source == "string";
    let cacheId = null;
    if (isFrame2)
      cacheId = source;
    else {
      if (!source._pixiId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix2}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame2 && strict && !baseTexture)
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    return baseTexture || (baseTexture = new _BaseTexture2(source, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource(buffer, { width, height, ...options?.resourceOptions });
    let format2, type2;
    return buffer instanceof Float32Array ? (format2 = FORMATS.RGBA, type2 = TYPES.FLOAT) : buffer instanceof Int32Array ? (format2 = FORMATS.RGBA_INTEGER, type2 = TYPES.INT) : buffer instanceof Uint32Array ? (format2 = FORMATS.RGBA_INTEGER, type2 = TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format2 = FORMATS.RGBA_INTEGER, type2 = TYPES.SHORT) : buffer instanceof Uint16Array ? (format2 = FORMATS.RGBA_INTEGER, type2 = TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format2 = FORMATS.RGBA, type2 = TYPES.BYTE) : (format2 = FORMATS.RGBA, type2 = TYPES.UNSIGNED_BYTE), resource.internal = true, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type: type2, format: format2 }, options));
  }
  /**
   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
   * @param {string} id - The id that the BaseTexture will be stored against.
   */
  static addToCache(baseTexture, id2) {
    id2 && (baseTexture.textureCacheIds.includes(id2) || baseTexture.textureCacheIds.push(id2), BaseTextureCache[id2] && BaseTextureCache[id2] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id2}] that already had an entry`), BaseTextureCache[id2] = baseTexture);
  }
  /**
   * Remove a BaseTexture from the global BaseTextureCache.
   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.
   */
  static removeFromCache(baseTexture) {
    if (typeof baseTexture == "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2)
        delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
      return baseTexture.textureCacheIds.length = 0, baseTexture;
    }
    return null;
  }
};
_BaseTexture.defaultOptions = {
  /**
   * If mipmapping is enabled for texture.
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  mipmap: MIPMAP_MODES.POW2,
  /** Anisotropic filtering level of texture */
  anisotropicLevel: 0,
  /**
   * Default scale mode, linear, nearest.
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  scaleMode: SCALE_MODES.LINEAR,
  /**
   * Wrap mode for textures.
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  wrapMode: WRAP_MODES.CLAMP,
  /**
   * Pre multiply the image alpha
   * @type {PIXI.ALPHA_MODES}
   * @default PIXI.ALPHA_MODES.UNPACK
   */
  alphaMode: ALPHA_MODES.UNPACK,
  /**
   * GL texture target
   * @type {PIXI.TARGETS}
   * @default PIXI.TARGETS.TEXTURE_2D
   */
  target: TARGETS.TEXTURE_2D,
  /**
   * GL format type
   * @type {PIXI.FORMATS}
   * @default PIXI.FORMATS.RGBA
   */
  format: FORMATS.RGBA,
  /**
   * GL data type
   * @type {PIXI.TYPES}
   * @default PIXI.TYPES.UNSIGNED_BYTE
   */
  type: TYPES.UNSIGNED_BYTE
}, /** Global number of the texture batch, used by multi-texture renderers. */
_BaseTexture._globalBatch = 0;
let BaseTexture = _BaseTexture;
class BatchDrawCall {
  constructor() {
    this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
}
let UID$4 = 0;
class Buffer {
  /**
   * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.
   * @param _static - `true` for static buffer
   * @param index - `true` for index buffer
   */
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
  }
  // TODO could explore flagging only a partial upload?
  /**
   * Flags this buffer as requiring an upload to the GPU.
   * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.
   */
  update(data) {
    data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys the buffer. */
  destroy() {
    this.dispose(), this.data = null;
  }
  /**
   * Flags whether this is an index buffer.
   *
   * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
   * the buffer of type `ARRAY_BUFFER`.
   *
   * For backwards compatibility.
   */
  set index(value) {
    this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  /**
   * Helper function that creates a buffer based on an array or TypedArray
   * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
   * @returns - A new Buffer based on the data provided.
   */
  static from(data) {
    return data instanceof Array && (data = new Float32Array(data)), new Buffer(data);
  }
}
class Attribute {
  /**
   * @param buffer - the id of the buffer that this attribute will look for
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.
   * @param normalized - should the data be normalized.
   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param [instance=false] - Whether the geometry is instanced.
   * @param [divisor=1] - Divisor to use when doing instanced rendering
   */
  constructor(buffer, size2 = 0, normalized = false, type2 = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer, this.size = size2, this.normalized = normalized, this.type = type2, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;
  }
  /** Destroys the Attribute. */
  destroy() {
    this.buffer = null;
  }
  /**
   * Helper function that creates an Attribute based on the information provided
   * @param buffer - the id of the buffer that this attribute will look for
   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param [normalized=false] - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @returns - A new {@link PIXI.Attribute} based on the information provided
   */
  static from(buffer, size2, normalized, type2, stride) {
    return new Attribute(buffer, size2, normalized, type2, stride);
  }
}
const map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes2) {
  let outSize = 0, stride = 0;
  const views = {};
  for (let i2 = 0; i2 < arrays.length; i2++)
    stride += sizes2[i2], outSize += arrays[i2].length;
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null, littleOffset = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const size2 = sizes2[i2], array = arrays[i2], type2 = getBufferType(array);
    views[type2] || (views[type2] = new map$1[type2](buffer)), out = views[type2];
    for (let j2 = 0; j2 < array.length; j2++) {
      const indexStart = (j2 / size2 | 0) * stride + littleOffset, index = j2 % size2;
      out[indexStart + index] = array[j2];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer);
}
const byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
let UID$3 = 0;
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  /**
   * @param buffers - An array of buffers. optional.
   * @param attributes - Of the geometry, optional structure of the attributes layout
   */
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
  }
  /**
   *
   * Adds an attribute to the geometry
   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!
   * @param id - the name of the attribute (matching up to a shader)
   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param normalized - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param instance - Instancing flag
   * @returns - Returns self, useful for chaining.
   */
  addAttribute(id2, buffer, size2 = 0, normalized = false, type2, stride, start, instance = false) {
    if (!buffer)
      throw new Error("You must pass a buffer when creating an attribute");
    buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer(buffer));
    const ids = id2.split("|");
    if (ids.length > 1) {
      for (let i2 = 0; i2 < ids.length; i2++)
        this.addAttribute(ids[i2], buffer, size2, normalized, type2);
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id2] = new Attribute(bufferIndex, size2, normalized, type2, stride, start, instance), this.instanced = this.instanced || instance, this;
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id2) {
    return this.attributes[id2];
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id2) {
    return this.buffers[this.getAttribute(id2).buffer];
  }
  /**
   *
   * Adds an index buffer to the geometry
   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
   * @returns - Returns self, useful for chaining.
   */
  addIndex(buffer) {
    return buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer(buffer)), buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * This function modifies the structure so that all current attributes become interleaved into a single buffer
   * This can be useful if your model remains static as it offers a little performance boost
   * @returns - Returns self, useful for chaining.
   */
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [], sizes2 = [], interleavedBuffer = new Buffer();
    let i2;
    for (i2 in this.attributes) {
      const attribute = this.attributes[i2], buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data), sizes2.push(attribute.size * byteSizeMap$1[attribute.type] / 4), attribute.buffer = 0;
    }
    for (interleavedBuffer.data = interleaveTypedArrays(arrays, sizes2), i2 = 0; i2 < this.buffers.length; i2++)
      this.buffers[i2] !== this.indexBuffer && this.buffers[i2].destroy();
    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }
  /** Get the size of the geometries, in vertices. */
  getSize() {
    for (const i2 in this.attributes) {
      const attribute = this.attributes[i2];
      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys the geometry. */
  destroy() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }
  /**
   * Returns a clone of the geometry.
   * @returns - A new clone of this geometry.
   */
  clone() {
    const geometry = new Geometry();
    for (let i2 = 0; i2 < this.buffers.length; i2++)
      geometry.buffers[i2] = new Buffer(this.buffers[i2].data.slice(0));
    for (const i2 in this.attributes) {
      const attrib = this.attributes[i2];
      geometry.attributes[i2] = new Attribute(
        attrib.buffer,
        attrib.size,
        attrib.normalized,
        attrib.type,
        attrib.stride,
        attrib.start,
        attrib.instance
      );
    }
    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;
  }
  /**
   * Merges an array of geometries into a new single one.
   *
   * Geometry attribute styles must match for this operation to work.
   * @param geometries - array of geometries to merge
   * @returns - Shiny new geometry!
   */
  static merge(geometries) {
    const geometryOut = new Geometry(), arrays = [], sizes2 = [], offsets = [];
    let geometry;
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++)
        sizes2[j2] = sizes2[j2] || 0, sizes2[j2] += geometry.buffers[j2].data.length, offsets[j2] = 0;
    }
    for (let i2 = 0; i2 < geometry.buffers.length; i2++)
      arrays[i2] = new map[getBufferType(geometry.buffers[i2].data)](sizes2[i2]), geometryOut.buffers[i2] = new Buffer(arrays[i2]);
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++)
        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]), offsets[j2] += geometry.buffers[j2].data.length;
    }
    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset2 = 0, stride = 0, offset22 = 0, bufferIndexToCount = 0;
      for (let i2 = 0; i2 < geometry.buffers.length; i2++)
        if (geometry.buffers[i2] !== geometry.indexBuffer) {
          bufferIndexToCount = i2;
          break;
        }
      for (const i2 in geometry.attributes) {
        const attribute = geometry.attributes[i2];
        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap$1[attribute.type] / 4);
      }
      for (let i2 = 0; i2 < geometries.length; i2++) {
        const indexBufferData = geometries[i2].indexBuffer.data;
        for (let j2 = 0; j2 < indexBufferData.length; j2++)
          geometryOut.indexBuffer.data[j2 + offset22] += offset2;
        offset2 += geometries[i2].buffers[bufferIndexToCount].data.length / stride, offset22 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}
class BatchGeometry extends Geometry {
  /**
   * @param {boolean} [_static=false] - Optimization flag, where `false`
   *        is updated every frame, `true` doesn't change frame-to-frame.
   */
  constructor(_static = false) {
    super(), this._buffer = new Buffer(null, _static, false), this._indexBuffer = new Buffer(null, _static, true), this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}
const PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = "POLY", SHAPES2[SHAPES2.RECT = 1] = "RECT", SHAPES2[SHAPES2.CIRC = 2] = "CIRC", SHAPES2[SHAPES2.ELIP = 3] = "ELIP", SHAPES2[SHAPES2.RREC = 4] = "RREC", SHAPES2))(SHAPES || {});
class Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x2 = 0, y2 = 0) {
    this.x = 0, this.y = 0, this.x = x2, this.y = y2;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new Point(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(p2) {
    return this.set(p2.x, p2.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p2) {
    return p2.set(this.x, this.y), p2;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p2) {
    return p2.x === this.x && p2.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(x2 = 0, y2 = x2) {
    return this.x = x2, this.y = y2, this;
  }
}
Point.prototype.toString = function() {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
};
const tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
    this.x = Number(x2), this.y = Number(y2), this.width = Number(width), this.height = Number(height), this.type = SHAPES.RECT;
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** A constant empty rectangle. */
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(rectangle) {
    return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(rectangle) {
    return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(x2, y2) {
    return this.width <= 0 || this.height <= 0 ? false : x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(other, transform2) {
    if (!transform2) {
      const x02 = this.x < other.x ? other.x : this.x;
      if ((this.right > other.right ? other.right : this.right) <= x02)
        return false;
      const y02 = this.y < other.y ? other.y : this.y;
      return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;
    }
    const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0)
      return false;
    const lt = tempPoints$1[0].set(other.left, other.top), lb2 = tempPoints$1[1].set(other.left, other.bottom), rt = tempPoints$1[2].set(other.right, other.top), rb2 = tempPoints$1[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb2.y <= lt.y)
      return false;
    const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
    if (s2 === 0 || (transform2.apply(lt, lt), transform2.apply(lb2, lb2), transform2.apply(rt, rt), transform2.apply(rb2, rb2), Math.max(lt.x, lb2.x, rt.x, rb2.x) <= x0 || Math.min(lt.x, lb2.x, rt.x, rb2.x) >= x1 || Math.max(lt.y, lb2.y, rt.y, rb2.y) <= y0 || Math.min(lt.y, lb2.y, rt.y, rb2.y) >= y1))
      return false;
    const nx = s2 * (lb2.y - lt.y), ny = s2 * (lt.x - lb2.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb2.x + ny * rb2.y)
      return false;
    const mx = s2 * (lt.y - rt.y), my = s2 * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;
    return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb2.x + my * rb2.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1, this;
  }
}
Rectangle.prototype.toString = function() {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
class Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x2 = 0, y2 = 0, radius = 0) {
    this.x = x2, this.y = y2, this.radius = radius, this.type = SHAPES.CIRC;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(x2, y2) {
    if (this.radius <= 0)
      return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x2, dy = this.y - y2;
    return dx *= dx, dy *= dy, dx + dy <= r2;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
}
Circle.prototype.toString = function() {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
};
class Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x2, this.y = y2, this.width = halfWidth, this.height = halfHeight, this.type = SHAPES.ELIP;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {PIXI.Ellipse} A copy of the ellipse
   */
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    let normx = (x2 - this.x) / this.width, normy = (y2 - this.y) / this.height;
    return normx *= normx, normy *= normy, normx + normy <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
}
Ellipse.prototype.toString = function() {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
class Polygon {
  /**
   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] != "number") {
      const p2 = [];
      for (let i2 = 0, il2 = flat.length; i2 < il2; i2++)
        p2.push(flat[i2].x, flat[i2].y);
      flat = p2;
    }
    this.points = flat, this.type = SHAPES.POLY, this.closeStroke = true;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const points = this.points.slice(), polygon = new Polygon(points);
    return polygon.closeStroke = this.closeStroke, polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(x2, y2) {
    let inside = false;
    const length2 = this.points.length / 2;
    for (let i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {
      const xi2 = this.points[i2 * 2], yi2 = this.points[i2 * 2 + 1], xj2 = this.points[j2 * 2], yj2 = this.points[j2 * 2 + 1];
      yi2 > y2 != yj2 > y2 && x2 < (xj2 - xi2) * ((y2 - yi2) / (yj2 - yi2)) + xi2 && (inside = !inside);
    }
    return inside;
  }
}
Polygon.prototype.toString = function() {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
};
class RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.x = x2, this.y = y2, this.width = width, this.height = height, this.radius = radius, this.type = SHAPES.RREC;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    if (x2 >= this.x && x2 <= this.x + this.width && y2 >= this.y && y2 <= this.y + this.height) {
      const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius)
        return true;
      let dx = x2 - (this.x + radius), dy = y2 - (this.y + radius);
      const radius2 = radius * radius;
      if (dx * dx + dy * dy <= radius2 || (dx = x2 - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y2 - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x2 - (this.x + radius), dx * dx + dy * dy <= radius2))
        return true;
    }
    return false;
  }
}
RoundedRectangle.prototype.toString = function() {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
};
class Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
    this.array = null, this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.tx = tx, this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(array) {
    this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(a2, b2, c2, d2, tx, ty) {
    return this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.tx = tx, this.ty = ty, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(transpose, out) {
    this.array || (this.array = new Float32Array(9));
    const array = out || this.array;
    return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, transformed through this matrix
   */
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x2 = pos.x, y2 = pos.y;
    return newPos.x = this.a * x2 + this.c * y2 + this.tx, newPos.y = this.b * x2 + this.d * y2 + this.ty, newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const id2 = 1 / (this.a * this.d + this.c * -this.b), x2 = pos.x, y2 = pos.y;
    return newPos.x = this.d * id2 * x2 + -this.c * id2 * y2 + (this.ty * this.c - this.tx * this.d) * id2, newPos.y = this.a * id2 * y2 + -this.b * id2 * x2 + (-this.ty * this.a + this.tx * this.b) * id2, newPos;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(x2, y2) {
    return this.tx += x2, this.ty += y2, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(x2, y2) {
    return this.a *= x2, this.d *= y2, this.c *= x2, this.b *= y2, this.tx *= x2, this.ty *= y2, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
    return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(matrix) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
    return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x2 - (pivotX * this.a + pivotY * this.c), this.ty = y2 - (pivotX * this.b + pivotY * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a, c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;
    }
    return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(transform2) {
    const a2 = this.a, b2 = this.b, c2 = this.c, d2 = this.d, pivot = transform2.pivot, skewX = -Math.atan2(-c2, d2), skewY = Math.atan2(b2, a2), delta = Math.abs(skewX + skewY);
    return delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5 ? (transform2.rotation = skewY, transform2.skew.x = transform2.skew.y = 0) : (transform2.rotation = 0, transform2.skew.x = skewX, transform2.skew.y = skewY), transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2), transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2), transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2), transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2), transform2;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n2 = a1 * d1 - b1 * c1;
    return this.a = d1 / n2, this.b = -b1 / n2, this.c = -c1 / n2, this.d = a1 / n2, this.tx = (c1 * this.ty - d1 * tx1) / n2, this.ty = -(a1 * this.ty - b1 * tx1) / n2, this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new Matrix();
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(matrix) {
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param {PIXI.Matrix} matrix - The matrix to copy from.
   * @returns {PIXI.Matrix} this
   */
  copyFrom(matrix) {
    return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;
  }
  /**
   * A default (identity) matrix
   * @readonly
   */
  static get IDENTITY() {
    return new Matrix();
  }
  /**
   * A temp matrix
   * @readonly
   */
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}
Matrix.prototype.toString = function() {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
};
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]), _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]), _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]), _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k2 = 0; k2 < 16; k2++)
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0), rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @readonly
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @readonly
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @readonly
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @readonly
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @readonly
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @readonly
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @readonly
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @readonly
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @readonly
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @readonly
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @readonly
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @readonly
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy[ind],
  /**
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD8.S : groupD8.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD8.E : groupD8.W : dy > 0 ? dx > 0 ? groupD8.SE : groupD8.SW : dx > 0 ? groupD8.NE : groupD8.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx, mat.ty = ty, matrix.append(mat);
  }
};
class ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param cb - callback function triggered when `x` and/or `y` are changed
   * @param scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(cb2, scope, x2 = 0, y2 = 0) {
    this._x = x2, this._y = y2, this.cb = cb2, this.scope = scope;
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overridden otherwise they will default
   * to the clone object's values.
   * @override
   * @param cb - The callback function triggered when `x` and/or `y` are changed
   * @param scope - The owner of the callback
   * @returns a copy of this observable point
   */
  clone(cb2 = this.cb, scope = this.scope) {
    return new ObservablePoint(cb2, scope, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(x2 = 0, y2 = x2) {
    return (this._x !== x2 || this._y !== y2) && (this._x = x2, this._y = y2, this.cb.call(this.scope)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
   * @returns The observable point instance itself
   */
  copyFrom(p2) {
    return (this._x !== p2.x || this._y !== p2.y) && (this._x = p2.x, this._y = p2.y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p2) {
    return p2.set(this._x, this._y), p2;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p2) {
    return p2.x === this._x && p2.y === this._y;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x !== value && (this._x = value, this.cb.call(this.scope));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y !== value && (this._y = value, this.cb.call(this.scope));
  }
}
ObservablePoint.prototype.toString = function() {
  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
};
const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  /** Called when a value changes. */
  onChange() {
    this._localID++;
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }
  /** Updates the local transformation matrix. */
  updateLocalTransform() {
    const lt = this.localTransform;
    this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);
  }
  /**
   * Updates the local and the world transformation matrices.
   * @param parentTransform - The parent transform
   */
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {
      const pt2 = parentTransform.worldTransform, wt = this.worldTransform;
      wt.a = lt.a * pt2.a + lt.b * pt2.c, wt.b = lt.a * pt2.b + lt.b * pt2.d, wt.c = lt.c * pt2.a + lt.d * pt2.c, wt.d = lt.c * pt2.b + lt.d * pt2.d, wt.tx = lt.tx * pt2.a + lt.ty * pt2.c + pt2.tx, wt.ty = lt.tx * pt2.b + lt.ty * pt2.d + pt2.ty, this._parentID = parentTransform._worldID, this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this), this._localID++;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation !== value && (this._rotation = value, this.updateSkew());
  }
};
_Transform.IDENTITY = new _Transform();
let Transform = _Transform;
Transform.prototype.toString = function() {
  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
};
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`;
var defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function compileShader(gl2, type2, src) {
  const shader = gl2.createShader(type2);
  return gl2.shaderSource(shader, src), gl2.compileShader(shader), shader;
}
function booleanArray(size2) {
  const array = new Array(size2);
  for (let i2 = 0; i2 < array.length; i2++)
    array[i2] = false;
  return array;
}
function defaultValue(type2, size2) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const uniformParsers = [
  // a float cache layer
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name2) => `
            if(uv["${name2}"] !== ud["${name2}"].value)
            {
                ud["${name2}"].value = uv["${name2}"]
                gl.uniform1f(ud["${name2}"].location, uv["${name2}"])
            }
            `
  },
  // handling samplers
  {
    test: (data, uniform) => (
      // eslint-disable-next-line max-len,no-eq-null,eqeqeq
      (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)
    ),
    code: (name2) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name2}"], t);

            if(ud["${name2}"].value !== t)
            {
                ud["${name2}"].value = t;
                gl.uniform1i(ud["${name2}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  // uploading pixi matrix object to mat3
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name2) => (
      // TODO and some smart caching dirty ids here!
      `
            gl.uniformMatrix3fv(ud["${name2}"].location, false, uv["${name2}"].toArray(true));
            `
    ),
    codeUbo: (name2) => `
                var ${name2}_matrix = uv.${name2}.toArray(true);

                data[offset] = ${name2}_matrix[0];
                data[offset+1] = ${name2}_matrix[1];
                data[offset+2] = ${name2}_matrix[2];
        
                data[offset + 4] = ${name2}_matrix[3];
                data[offset + 5] = ${name2}_matrix[4];
                data[offset + 6] = ${name2}_matrix[5];
        
                data[offset + 8] = ${name2}_matrix[6];
                data[offset + 9] = ${name2}_matrix[7];
                data[offset + 10] = ${name2}_matrix[8];
            `
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name2}"].location, v.x, v.y);
                }`,
    codeUbo: (name2) => `
                v = uv.${name2};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  // caching layer for a vec2
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name2}"].location, v[0], v[1]);
                }
            `
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name2}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  // upload a pixi color as vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name2}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  // upload a pixi color as a vec3 with caching layer
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name2}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  // a caching layer for vec4 uploading
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name2}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];
const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group2, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i2 in group2.uniforms) {
    const data = uniformData[i2];
    if (!data) {
      group2.uniforms[i2]?.group === true && (group2.uniforms[i2].ubo ? funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i2}, '${i2}');
                    `) : funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i2}, syncData);
                    `));
      continue;
    }
    const uniform = group2.uniforms[i2];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++)
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i2, uniform)), parsed = true;
        break;
      }
    if (!parsed) {
      const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`
`));
}
const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.ADAPTER.createCanvas();
    let gl2;
    settings.PREFER_ENV >= ENV.WEBGL2 && (gl2 = canvas.getContext("webgl2", {})), gl2 || (gl2 = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {}), gl2 ? gl2.getExtension("WEBGL_draw_buffers") : gl2 = null), context = gl2;
  }
  return context;
}
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    const gl2 = getTestContext();
    if (gl2 && gl2.getShaderPrecisionFormat) {
      const shaderFragment = gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.HIGH_FLOAT);
      shaderFragment && (maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM);
    }
  }
  return maxFragmentPrecision;
}
function logPrettyShaderError(gl2, shader) {
  const shaderSrc = gl2.getShaderSource(shader).split(`
`).map((line2, index) => `${index}: ${line2}`), shaderLog = gl2.getShaderInfoLog(shader), splitShader = shaderLog.split(`
`), dedupe = {}, lineNumbers = splitShader.map((line2) => parseFloat(line2.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => n2 && !dedupe[n2] ? (dedupe[n2] = true, true) : false), logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join(`
`);
  logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed("click to view full shader code"), console.warn(...logArgs), console.groupEnd();
}
function logProgramError(gl2, program, vertexShader, fragmentShader) {
  gl2.getProgramParameter(program, gl2.LINK_STATUS) || (gl2.getShaderParameter(vertexShader, gl2.COMPILE_STATUS) || logPrettyShaderError(gl2, vertexShader), gl2.getShaderParameter(fragmentShader, gl2.COMPILE_STATUS) || logPrettyShaderError(gl2, fragmentShader), console.error("PixiJS Error: Could not initialize shader."), gl2.getProgramInfoLog(program) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl2.getProgramInfoLog(program)));
}
const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type2) {
  return GLSL_TO_SIZE[type2];
}
let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl2, type2) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl2[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type2];
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    return requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH && (precision = PRECISION.MEDIUM), `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp")
    return src.replace("precision highp", "precision mediump");
  return src;
}
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    unsafeEval = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === true;
  } catch {
    unsafeEval = false;
  }
  return unsafeEval;
}
let UID$2 = 0;
const nameCache = {}, _Program = class _Program2 {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @param extra - Extra data for shader
   */
  constructor(vertexSrc, fragmentSrc, name2 = "pixi-shader", extra = {}) {
    this.extra = {}, this.id = UID$2++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== "#version" && (name2 = name2.replace(/\s+/g, "-"), nameCache[name2] ? (nameCache[name2]++, name2 += `-${nameCache[name2]}`) : nameCache[name2] = 1, this.vertexSrc = `#define SHADER_NAME ${name2}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name2}
${this.fragmentSrc}`, this.vertexSrc = setPrecision(
      this.vertexSrc,
      _Program2.defaultVertexPrecision,
      PRECISION.HIGH
    ), this.fragmentSrc = setPrecision(
      this.fragmentSrc,
      _Program2.defaultFragmentPrecision,
      getMaxFragmentPrecision()
    )), this.glPrograms = {}, this.syncUniforms = null;
  }
  /**
   * The default vertex shader source.
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex$3;
  }
  /**
   * The default fragment shader source.
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultFragment$2;
  }
  /**
   * A short hand function to create a program based of a vertex and fragment shader.
   *
   * This method will also check to see if there is a cached program.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @returns A shiny new PixiJS shader program!
   */
  static from(vertexSrc, fragmentSrc, name2) {
    const key = vertexSrc + fragmentSrc;
    let program = ProgramCache[key];
    return program || (ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name2)), program;
  }
};
_Program.defaultVertexPrecision = PRECISION.HIGH, /**
* Default specify float precision in fragment shader.
* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742
* @static
* @type {PIXI.PRECISION}
* @default PIXI.PRECISION.MEDIUM
*/
_Program.defaultFragmentPrecision = isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;
let Program = _Program;
let UID$1 = 0;
class UniformGroup {
  /**
   * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer.
   * @param isStatic - Uniforms wont be changed after creation.
   * @param isUbo - If true, will treat this uniform group as a uniform buffer object.
   */
  constructor(uniforms, isStatic, isUbo) {
    this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$1++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer ? (this.buffer = uniforms, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = true));
  }
  update() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }
  add(name2, uniforms, _static) {
    if (!this.ubo)
      this.uniforms[name2] = new UniformGroup(uniforms, _static);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  /**
   * A short hand function for creating a static UBO UniformGroup.
   * @param uniforms - the ubo item
   * @param _static - should this be updated each time it is used? defaults to true here!
   */
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}
class Shader {
  /**
   * @param program - The program the shader will use.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(program, uniforms) {
    this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup(uniforms) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner("disposeShader");
  }
  // TODO move to shader system..
  checkUniformExists(name2, group2) {
    if (group2.uniforms[name2])
      return true;
    for (const i2 in group2.uniforms) {
      const uniform = group2.uniforms[i2];
      if (uniform.group === true && this.checkUniformExists(name2, uniform))
        return true;
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
  }
  /**
   * Shader uniform values, shortcut for `uniformGroup.uniforms`.
   * @readonly
   */
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  /**
   * A short hand function to create a shader based of a vertex and fragment shader.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   * @returns A shiny new PixiJS shader!
   */
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}
class BatchShaderGenerator {
  /**
   * @param vertexSrc - Vertex shader
   * @param fragTemplate - Fragment shader template
   */
  constructor(vertexSrc, fragTemplate2) {
    if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate2, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate2.includes("%count%"))
      throw new Error('Fragment template must contain "%count%".');
    if (!fragTemplate2.includes("%forloop%"))
      throw new Error('Fragment template must contain "%forloop%".');
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i2 = 0; i2 < maxTextures; i2++)
        sampleValues[i2] = i2;
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures)), this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += `
`, src += `
`;
    for (let i2 = 0; i2 < maxTextures; i2++)
      i2 > 0 && (src += `
else `), i2 < maxTextures - 1 && (src += `if(vTextureId < ${i2}.5)`), src += `
{`, src += `
	color = texture2D(uSamplers[${i2}], vTextureCoord);`, src += `
}`;
    return src += `
`, src += `
`, src;
  }
}
class BatchTextureArray {
  constructor() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  clear() {
    for (let i2 = 0; i2 < this.count; i2++)
      this.elements[i2] = null;
    this.count = 0;
  }
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max2) {
  let allowMax = true;
  const navigator2 = settings.ADAPTER.getNavigator();
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      const match2 = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
      match2 && parseInt(match2[1], 10) < 11 && (allowMax = false);
    }
    if (isMobile.android.device) {
      const match2 = navigator2.userAgent.match(/Android\s([0-9.]*)/);
      match2 && parseInt(match2[1], 10) < 7 && (allowMax = false);
    }
  }
  return allowMax ? max2 : 4;
}
class ObjectRenderer {
  /**
   * @param renderer - The renderer this manager works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Stub method that should be used to empty the current batch by rendering objects now. */
  flush() {
  }
  /** Generic destruction method that frees all resources. This should be called by subclasses. */
  destroy() {
    this.renderer = null;
  }
  /**
   * Stub method that initializes any state required before
   * rendering starts. It is different from the `prerender`
   * signal, which occurs every frame, in that it is called
   * whenever an object requests _this_ renderer specifically.
   */
  start() {
  }
  /** Stops the renderer. It should free up any state and become dormant. */
  stop() {
    this.flush();
  }
  /**
   * Keeps the object to render. It doesn't have to be
   * rendered immediately.
   * @param {PIXI.DisplayObject} _object - The object to render.
   */
  render(_object) {
  }
}
var defaultFragment$1 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`;
var defaultVertex$2 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer {
  /**
   * This will hook onto the renderer's `contextChange`
   * and `prerender` signals.
   * @param {PIXI.Renderer} renderer - The renderer this works for.
   */
  constructor(renderer) {
    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry, this.vertexSize = 6, this.state = State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];
  }
  /**
   * The maximum textures that this device supports.
   * @static
   * @default 32
   */
  static get defaultMaxTextures() {
    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32), this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   */
  static get canUploadSameBuffer() {
    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer(), this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  /**
   * @see PIXI.BatchRenderer#maxTextures
   * @deprecated since 7.1.0
   * @readonly
   */
  get MAX_TEXTURES() {
    return deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex$2;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentTemplate() {
    return defaultFragment$1;
  }
  /**
   * Set the shader generator.
   * @param {object} [options]
   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source
   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template
   */
  setShaderGenerator({
    vertex: vertex2 = _BatchRenderer2.defaultVertexSrc,
    fragment: fragment2 = _BatchRenderer2.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
  }
  /**
   * Handles the `contextChange` signal.
   *
   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.
   */
  contextChange() {
    const gl2 = this.renderer.gl;
    settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(
      gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS),
      _BatchRenderer2.defaultMaxTextures
    ), this.maxTextures = checkMaxIfStatementsInShader(
      this.maxTextures,
      gl2
    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++)
      this._packedGeometries[i2] = new this.geometryClass();
    this.initFlushBuffers();
  }
  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    for (; _drawCallPool.length < MAX_SPRITES; )
      _drawCallPool.push(new BatchDrawCall());
    for (; _textureArrayPool.length < MAX_TA; )
      _textureArrayPool.push(new BatchTextureArray());
    for (let i2 = 0; i2 < this.maxTextures; i2++)
      this._tempBoundTextures[i2] = null;
  }
  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */
  onPrerender() {
    this._flushId = 0;
  }
  /**
   * Buffers the "batchable" object. It need not be rendered immediately.
   * @param {PIXI.DisplayObject} element - the element to render when
   *    using this renderer
   */
  render(element) {
    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch2 = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i2 = 0; i2 < this._bufferSize; ++i2) {
      const tex = textures[i2];
      textures[i2] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i2), start = i2, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch2, texArray.elements[texArray.count++] = tex);
    }
    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);
    for (let i2 = 0; i2 < boundTextures.length; i2++)
      boundTextures[i2] = null;
    BaseTexture._globalBatch = TICK;
  }
  /**
   * Populating drawcalls for rendering
   * @param texArray
   * @param start
   * @param finish
   */
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this, drawCalls = _BatchRenderer2._drawCallPool;
    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex, drawCall.texArray = texArray;
    for (let i2 = start; i2 < finish; ++i2) {
      const sprite = elements[i2], tex = sprite._texture.baseTexture, spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i2] = null, start < i2 && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i2, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;
    }
    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;
  }
  /**
   * Bind textures for current rendering
   * @param texArray
   */
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j2 = 0; j2 < texArray.count; j2++)
      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]), texArray.elements[j2] = null;
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }
  drawBatches() {
    const dcCount = this._dcIndex, { gl: gl2, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;
    let curTexArray = null;
    for (let i2 = 0; i2 < dcCount; i2++) {
      const { texArray, type: type2, size: size2, start, blend } = drawCalls[i2];
      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl2.drawElements(type2, size2, gl2.UNSIGNED_SHORT, start * 2);
    }
  }
  /** Renders the content _now_ and empties the current batch. */
  flush() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }
  /** Starts a new sprite batch. */
  start() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }
  /** Stops and flushes the current batch. */
  stop() {
    this.flush();
  }
  /** Destroys this `BatchRenderer`. It cannot be used again. */
  destroy() {
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++)
      this._packedGeometries[i2] && this._packedGeometries[i2].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();
  }
  /**
   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.
   * @param size - minimum capacity required
   * @returns - buffer than can hold atleast `size` floats
   */
  getAttributeBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 8)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 8;
    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer = this._aBuffers[roundedSize];
    return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;
  }
  /**
   * Fetches an index buffer from `this._iBuffers` that can
   * have at least `size` capacity.
   * @param size - minimum required capacity
   * @returns - buffer that can fit `size` indices.
   */
  getIndexBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 12)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 12;
    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer = this._iBuffers[roundedSizeIndex];
    return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;
  }
  /**
   * Takes the four batching parameters of `element`, interleaves
   * and pushes them into the batching attribute/index buffers given.
   *
   * It uses these properties: `vertexData` `uvs`, `textureId` and
   * `indicies`. It also uses the "tint" of the base-texture, if
   * present.
   * @param {PIXI.DisplayObject} element - element being rendered
   * @param attributeBuffer - attribute buffer.
   * @param indexBuffer - index buffer
   * @param aIndex - number of floats already in the attribute buffer
   * @param iIndex - number of indices already in `indexBuffer`
   */
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i2 = 0; i2 < vertexData.length; i2 += 2)
      float32View[aIndex++] = vertexData[i2], float32View[aIndex++] = vertexData[i2 + 1], float32View[aIndex++] = uvs[i2], float32View[aIndex++] = uvs[i2 + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;
    for (let i2 = 0; i2 < indicies.length; i2++)
      indexBuffer[iIndex++] = packedVertices + indicies[i2];
  }
};
_BatchRenderer.defaultBatchSize = 4096, /** @ignore */
_BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType.RendererPlugin
}, /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchDrawCall[]}
*/
_BatchRenderer._drawCallPool = [], /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchTextureArray[]}
*/
_BatchRenderer._textureArrayPool = [];
let BatchRenderer = _BatchRenderer;
extensions$1.add(BatchRenderer);
var defaultFragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`;
var defaultVertex$1 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const _Filter = class _Filter2 extends Shader {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(
      vertexSrc || _Filter2.defaultVertexSrc,
      fragmentSrc || _Filter2.defaultFragmentSrc
    );
    super(program, uniforms), this.padding = 0, this.resolution = _Filter2.defaultResolution, this.multisample = _Filter2.defaultMultisample, this.enabled = true, this.autoFit = true, this.state = new State();
  }
  /**
   * Applies the filter
   * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
   * @param {PIXI.RenderTexture} input - The input render target.
   * @param {PIXI.RenderTexture} output - The target to output to.
   * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.
   * @param {object} [_currentState] - It's current state of filter.
   *        There are some useful properties in the currentState :
   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
   */
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Sets the blend mode of the filter.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  /**
   * The resolution of the filter. Setting this to be lower will lower the quality but
   * increase the performance of the filter.
   * If set to `null` or `0`, the resolution of the current render target is used.
   * @default PIXI.Filter.defaultResolution
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex$1;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
};
_Filter.defaultResolution = 1, /**
* Default filter samples for any filter.
* @static
* @type {PIXI.MSAA_QUALITY|null}
* @default PIXI.MSAA_QUALITY.NONE
*/
_Filter.defaultMultisample = MSAA_QUALITY.NONE;
let Filter = _Filter;
class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true, this._backgroundColor = new Color(0), this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param {PIXI.IRendererOptions} options - the options for the background colors
   */
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options, color = background ?? backgroundColor;
    color !== void 0 && (this.color = color), this.alpha = backgroundAlpha;
  }
  /**
   * The background color to fill if not transparent.
   * @member {PIXI.ColorSource}
   */
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  /** The background color object. */
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.backgroundAlpha}
   * @default 1
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundAlpha: 1,
  /**
   * {@link PIXI.IRendererOptions.backgroundColor}
   * @default 0x000000
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundColor: 0,
  /**
   * {@link PIXI.IRendererOptions.clearBeforeRender}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  clearBeforeRender: true
}, /** @ignore */
BackgroundSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions$1.add(BackgroundSystem);
class BatchSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.emptyRenderer = new ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;
  }
  /**
   * Changes the current renderer to the one given in parameter
   * @param objectRenderer - The object renderer to use.
   */
  setObjectRenderer(objectRenderer) {
    this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());
  }
  /**
   * This should be called if you wish to do some custom rendering
   * It will basically render anything that may be batched up such as sprites
   */
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /** Reset the system to an empty renderer */
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /**
   * Handy function for batch renderers: copies bound textures in first maxTextures locations to array
   * sets actual _batchLocation for them
   * @param arr - arr copy destination
   * @param maxTextures - number of copied elements
   */
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i2 = maxTextures - 1; i2 >= 0; --i2)
      arr[i2] = boundTextures[i2] || null, arr[i2] && (arr[i2]._batchLocation = i2);
  }
  /**
   * Assigns batch locations to textures in array based on boundTextures state.
   * All textures in texArray should have `_batchEnabled = _batchId`,
   * and their count should be less than `maxTextures`.
   * @param texArray - textures to bound
   * @param boundTextures - current state of bound textures
   * @param batchId - marker for _batchEnabled param of textures in texArray
   * @param maxTextures - number of texture locations to manipulate
   */
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j2 = 0;
    for (let i2 = 0; i2 < count; i2++) {
      const tex = elements[i2], loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i2] = loc;
        continue;
      }
      for (; j2 < maxTextures; ) {
        const bound = boundTextures[j2];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
          j2++;
          continue;
        }
        ids[i2] = j2, tex._batchLocation = j2, boundTextures[j2] = tex;
        break;
      }
    }
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "batch"
};
extensions$1.add(BatchSystem);
let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: false
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(gl2) {
    this.gl = gl2, this.renderer.gl = gl2, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context)
      this.initFromContext(options.context);
    else {
      const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(gl2) {
    this.gl = gl2, this.validateContext(gl2), this.renderer.gl = gl2, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl2);
    const view = this.renderer.view;
    view.addEventListener !== void 0 && (view.addEventListener("webglcontextlost", this.handleContextLost, false), view.addEventListener("webglcontextrestored", this.handleContextRestored, false));
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param {object} options - context attributes
   */
  initFromOptions(options) {
    const gl2 = this.createContext(this.renderer.view, options);
    this.initFromContext(gl2);
  }
  /**
   * Helper class to create a WebGL Context
   * @param canvas - the canvas element that we will get the context from
   * @param options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  createContext(canvas, options) {
    let gl2;
    if (settings.PREFER_ENV >= ENV.WEBGL2 && (gl2 = canvas.getContext("webgl2", options)), gl2)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, gl2 = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options), !gl2)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = gl2, this.getExtensions(), this.gl;
  }
  /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl: gl2 } = this, common2 = {
      loseContext: gl2.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl2.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl2.getExtension("OES_texture_float_linear"),
      s3tc: gl2.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl2.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: gl2.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl2.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl2.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl2.getExtension("WEBGL_compressed_texture_astc"),
      bptc: gl2.getExtension("EXT_texture_compression_bptc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, common2, {
      drawBuffers: gl2.getExtension("WEBGL_draw_buffers"),
      depthTexture: gl2.getExtension("WEBGL_depth_texture"),
      vertexArrayObject: gl2.getExtension("OES_vertex_array_object") || gl2.getExtension("MOZ_OES_vertex_array_object") || gl2.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: gl2.getExtension("OES_element_index_uint"),
      // Floats and half-floats
      floatTexture: gl2.getExtension("OES_texture_float"),
      floatTextureLinear: gl2.getExtension("OES_texture_float_linear"),
      textureHalfFloat: gl2.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: gl2.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, common2, {
      // Floats and half-floats
      colorBufferFloat: gl2.getExtension("EXT_color_buffer_float")
    });
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(event) {
    event.preventDefault(), setTimeout(() => {
      this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
    }, 0);
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }
  /** Handle the post-render runner event. */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(gl2) {
    const attributes = gl2.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl2 instanceof globalThis.WebGL2RenderingContext;
    isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    const hasuint32 = isWebGl2 || !!gl2.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32, hasuint32 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }
}
ContextSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.context}
   * @default null
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  context: null,
  /**
   * {@link PIXI.IRendererOptions.antialias}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  antialias: false,
  /**
   * {@link PIXI.IRendererOptions.premultipliedAlpha}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  premultipliedAlpha: true,
  /**
   * {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  preserveDrawingBuffer: false,
  /**
   * {@link PIXI.IRendererOptions.powerPreference}
   * @default default
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  powerPreference: "default"
}, /** @ignore */
ContextSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "context"
};
extensions$1.add(ContextSystem);
class Framebuffer {
  /**
   * @param width - Width of the frame buffer
   * @param height - Height of the frame buffer
   */
  constructor(width, height) {
    if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)
      throw new Error("Framebuffer width or height is zero");
    this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
  }
  /**
   * Reference to the colorTexture.
   * @readonly
   */
  get colorTexture() {
    return this.colorTextures[0];
  }
  /**
   * Add texture to the colorTexture array.
   * @param index - Index of the array to add the texture to
   * @param texture - Texture to add to the array
   */
  addColorTexture(index = 0, texture) {
    return this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Add a depth texture to the frame buffer.
   * @param texture - Texture to add.
   */
  addDepthTexture(texture) {
    return this.depthTexture = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable depth on the frame buffer. */
  enableDepth() {
    return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable stencil on the frame buffer. */
  enableStencil() {
    return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Resize the frame buffer
   * @param width - Width of the frame buffer to resize to
   * @param height - Height of the frame buffer to resize to
   */
  resize(width, height) {
    if (width = Math.round(width), height = Math.round(height), !width || !height)
      throw new Error("Framebuffer width and height must not be zero");
    if (!(width === this.width && height === this.height)) {
      this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;
      for (let i2 = 0; i2 < this.colorTextures.length; i2++) {
        const texture = this.colorTextures[i2], resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        const resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    }
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys and removes the depth texture added to this framebuffer. */
  destroyDepthTexture() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }
}
class BaseRenderTexture extends BaseTexture {
  /**
   * @param options
   * @param {number} [options.width=100] - The width of the base render texture.
   * @param {number} [options.height=100] - The height of the base render texture.
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *   for possible values.
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio
   *   of the texture being generated.
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.
   */
  constructor(options = {}) {
    if (typeof options == "number") {
      const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = MSAA_QUALITY.NONE), super(null, options), this.mipmap = MIPMAP_MODES.OFF, this.valid = true, this._clear = new Color([0, 0, 0, 0]), this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];
  }
  /** Color when clearning the texture. */
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  /**
   * Color object when clearning the texture.
   * @readonly
   * @since 7.2.0
   */
  get clear() {
    return this._clear;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the BaseRenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   */
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  /**
   * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.framebuffer.dispose(), super.dispose();
  }
  /** Destroys this texture. */
  destroy() {
    super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }
}
class BaseImageResource extends Resource {
  /**
   * @param {PIXI.ImageSourcee} source
   */
  constructor(source) {
    const sourceAny = source, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.displayWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.displayHeight || sourceAny.height;
    super(width, height), this.source = source, this.noSubImage = false;
  }
  /**
   * Set cross origin based detecting the url and the crossorigin
   * @param element - Element to apply crossOrigin
   * @param url - URL to check
   * @param crossorigin - Cross origin value to use
   */
  static crossOrigin(element, url2, crossorigin) {
    crossorigin === void 0 && !url2.startsWith("data:") ? element.crossOrigin = determineCrossOrigin(url2) : crossorigin !== false && (element.crossOrigin = typeof crossorigin == "string" ? crossorigin : "anonymous");
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture
   * @param {PIXI.ImageSourcee} [source] - (optional)
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture, source) {
    const gl2 = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;
    if (source = source || this.source, typeof HTMLImageElement < "u" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0)
        return false;
    } else if (typeof HTMLVideoElement < "u" && source instanceof HTMLVideoElement && source.readyState <= 1)
      return false;
    return gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl2.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl2.texSubImage2D(gl2.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl2.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source)), true;
  }
  /**
   * Checks if source width/height was changed, resize can cause extra baseTexture update.
   * Triggers one update in any case.
   */
  update() {
    if (this.destroyed)
      return;
    const source = this.source, width = source.naturalWidth || source.videoWidth || source.width, height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height), super.update();
  }
  /** Destroy this {@link PIXI.BaseImageResource} */
  dispose() {
    this.source = null;
  }
}
class ImageResource extends BaseImageResource {
  /**
   * @param source - image source or URL
   * @param options
   * @param {boolean} [options.autoLoad=true] - start loading process
   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create
   *        a bitmap before upload
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap
   */
  constructor(source, options) {
    if (options = options || {}, typeof source == "string") {
      const imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;
    }
    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = false, this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== false && this.load();
  }
  /**
   * Returns a promise when image will be loaded and processed.
   * @param createBitmap - whether process image into bitmap
   */
  load(createBitmap) {
    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve2, reject2) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve2(this.process()) : resolve2(this));
      };
      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = (event) => {
        reject2(event), this.onError.emit(event);
      });
    }), this._load);
  }
  /**
   * Called when we need to convert image into BitmapImage.
   * Can be called multiple times, real promise is cached inside.
   * @returns - Cached promise to fill that bitmap
   */
  process() {
    const source = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    const createImageBitmap2 = globalThis.createImageBitmap, cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    return this._process = fetch(
      source.src,
      {
        mode: cors ? "cors" : "no-cors"
      }
    ).then((r2) => r2.blob()).then((blob) => createImageBitmap2(
      blob,
      0,
      0,
      source.width,
      source.height,
      {
        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      }
    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;
  }
  /**
   * Upload the image resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)
      return super.upload(renderer, baseTexture, glTexture);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return false;
    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return true;
  }
  /** Destroys this resource. */
  dispose() {
    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement
   */
  static test(source) {
    return typeof HTMLImageElement < "u" && (typeof source == "string" || source instanceof HTMLImageElement);
  }
}
class TextureUvs {
  constructor() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  /**
   * Sets the texture Uvs based on the given frame information.
   * @protected
   * @param frame - The frame of the texture
   * @param baseFrame - The base frame of the texture
   * @param rotate - Rotation of frame, see {@link PIXI.groupD8}
   */
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width, th2 = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th2, cX = frame.x / tw + w2, cY = frame.y / th2 + h2;
      rotate = groupD8.add(rotate, groupD8.NW), this.x0 = cX + w2 * groupD8.uX(rotate), this.y0 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x1 = cX + w2 * groupD8.uX(rotate), this.y1 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x2 = cX + w2 * groupD8.uX(rotate), this.y2 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x3 = cX + w2 * groupD8.uX(rotate), this.y3 = cY + h2 * groupD8.uY(rotate);
    } else
      this.x0 = frame.x / tw, this.y0 = frame.y / th2, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th2, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th2, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th2;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }
}
TextureUvs.prototype.toString = function() {
  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
};
const DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function() {
  }, tex.on = function() {
  }, tex.once = function() {
  }, tex.emit = function() {
  };
}
class Texture extends EventEmitter {
  /**
   * @param baseTexture - The base texture source to create the texture from
   * @param frame - The rectangle frame of the texture to show
   * @param orig - The area of original texture
   * @param trim - Trimmed rectangle of original texture
   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}
   * @param anchor - Default anchor point used for sprite placement / rotation
   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}
   */
  constructor(baseTexture, frame, orig, trim2, rotate, anchor, borders2) {
    if (super(), this.noFrame = false, frame || (this.noFrame = true, frame = new Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim2, this.valid = false, this.destroyed = false, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === true)
      this._rotate = 2;
    else if (this._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0), this.defaultBorders = borders2, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);
  }
  /**
   * Updates this texture on the gpu.
   *
   * Calls the TextureResource update.
   *
   * If you adjusted `frame` manually, please call `updateUvs()` instead.
   */
  update() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }
  /**
   * Called when the base texture is updated
   * @protected
   * @param baseTexture - The base texture.
   */
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = true, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }
  /**
   * Destroys this texture
   * @param [destroyBase=false] - Whether to destroy the base texture as well
   * @fires PIXI.Texture#destroyed
   */
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        resource?.url && TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Creates a new texture object that acts the same as this one.
   * @returns - The new texture
   */
  clone() {
    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture(
      this.baseTexture,
      !this.noFrame && clonedFrame,
      clonedOrig,
      this.trim?.clone(),
      this.rotate,
      this.defaultAnchor,
      this.defaultBorders
    );
    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;
  }
  /**
   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
   * Call it after changing the frame
   */
  updateUvs() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }
  /**
   * Helper function that creates a new Texture based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -
   *        Source or array of sources to create texture from
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.Texture} The newly created texture
   */
  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame2 = typeof source == "string";
    let cacheId = null;
    if (isFrame2)
      cacheId = source;
    else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix2}-${uid()}`, BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix2}_${uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = TextureCache[cacheId];
    if (isFrame2 && strict && !texture)
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    return !texture && !(source instanceof BaseTexture) ? (options.resolution || (options.resolution = getResolutionOfUrl(source)), texture = new Texture(new BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)) : !texture && source instanceof BaseTexture && (texture = new Texture(source), Texture.addToCache(texture, cacheId)), texture;
  }
  /**
   * Useful for loading textures via URLs. Use instead of `Texture.from` because
   * it does a better job of handling failed URLs more effectively. This also ignores
   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.
   * @param url - The remote URL or array of URLs to load.
   * @param options - Optional options to include
   * @returns - A Promise that resolves to a Texture.
   */
  static fromURL(url2, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions), texture = Texture.from(url2, Object.assign({ resourceOptions }, options), false), resource = texture.baseTexture.resource;
    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
  }
  /**
   * Create a texture from a source and add to the cache.
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.
   * @param imageUrl - File name of texture, for cache and resolving resolution.
   * @param name - Human readable name for the texture cache. If no name is
   *        specified, only `imageUrl` will be used as the cache ID.
   * @param options
   * @returns - Output texture
   */
  static fromLoader(source, imageUrl, name2, options) {
    const baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl(imageUrl)
    }, options)), { resource } = baseTexture;
    resource instanceof ImageResource && (resource.url = imageUrl);
    const texture = new Texture(baseTexture);
    return name2 || (name2 = imageUrl), BaseTexture.addToCache(texture.baseTexture, name2), Texture.addToCache(texture, name2), name2 !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve2) => {
      texture.baseTexture.once("loaded", () => resolve2(texture));
    });
  }
  /**
   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
   * @param texture - The Texture to add to the cache.
   * @param id - The id that the Texture will be stored against.
   */
  static addToCache(texture, id2) {
    id2 && (texture.textureCacheIds.includes(id2) || texture.textureCacheIds.push(id2), TextureCache[id2] && TextureCache[id2] !== texture && console.warn(`Texture added to the cache with an id [${id2}] that already had an entry`), TextureCache[id2] = texture);
  }
  /**
   * Remove a Texture from the global TextureCache.
   * @param texture - id of a Texture to be removed, or a Texture instance itself
   * @returns - The Texture that was removed
   */
  static removeFromCache(texture) {
    if (typeof texture == "string") {
      const textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i2 = 0; i2 < texture.textureCacheIds.length; ++i2)
        TextureCache[texture.textureCacheIds[i2]] === texture && delete TextureCache[texture.textureCacheIds[i2]];
      return texture.textureCacheIds.length = 0, texture;
    }
    return null;
  }
  /**
   * Returns resolution of baseTexture
   * @readonly
   */
  get resolution() {
    return this.baseTexture.resolution;
  }
  /**
   * The frame specifies the region of the base texture that this texture uses.
   * Please call `updateUvs()` after you change coordinates of `frame` manually.
   */
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame, this.noFrame = false;
    const { x: x2, y: y2, width, height } = frame, xNotFit = x2 + width > this.baseTexture.width, yNotFit = y2 + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or", errorX = `X: ${x2} + ${width} = ${x2 + width} > ${this.baseTexture.width}`, errorY = `Y: ${y2} + ${height} = ${y2 + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();
  }
  /**
   * Indicates whether the texture is rotated inside the atlas
   * set to 2 to compensate for texture packer rotation
   * set to 6 to compensate for spine packer rotation
   * can be used to rotate or mirror sprites
   * See {@link PIXI.groupD8} for explanation
   */
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate, this.valid && this.updateUvs();
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this.baseTexture;
  }
  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
  static get EMPTY() {
    return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;
  }
  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.ADAPTER.createCanvas(16, 16), context2 = canvas.getContext("2d");
      canvas.width = 16, canvas.height = 16, context2.fillStyle = "white", context2.fillRect(0, 0, 16, 16), Texture._WHITE = new Texture(BaseTexture.from(canvas)), removeAllHandlers(Texture._WHITE), removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}
class RenderTexture extends Texture {
  /**
   * @param baseRenderTexture - The base texture object that this texture uses.
   * @param frame - The rectangle frame of the texture to show.
   */
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame), this.valid = true, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();
  }
  /**
   * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
   * @readonly
   */
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the RenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?
   */
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();
  }
  /**
   * Changes the resolution of baseTexture, but does not change framebuffer size.
   * @param resolution - The new resolution to apply to RenderTexture
   */
  setResolution(resolution) {
    const { baseTexture } = this;
    baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, false));
  }
  /**
   * A short hand way of creating a render texture.
   * @param options - Options
   * @param {number} [options.width=100] - The width of the render texture
   * @param {number} [options.height=100] - The height of the render texture
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *    for possible values
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture
   *    being generated
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer
   * @returns The new render texture
   */
  static create(options) {
    return new RenderTexture(new BaseRenderTexture(options));
  }
}
class RenderTexturePool {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
   */
  constructor(textureOptions) {
    this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param realWidth - Width of texture in pixels.
   * @param realHeight - Height of texture in pixels.
   * @param multisample - Number of samples of the framebuffer.
   */
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns The new render texture.
   */
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = nextPow2(minWidth), minHeight = nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key += multisample * 4294967296)) : key = multisample > 1 ? -multisample : -1, this.texturePool[key] || (this.texturePool[key] = []);
    let renderTexture = this.texturePool[key].pop();
    return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   *
   * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   *  It overrides, it does not multiply
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Place a render texture back into the pool.
   * @param renderTexture - The renderTexture to free
   */
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture);
  }
  /**
   * Alias for returnTexture, to be compliant with FilterSystem interface.
   * @param renderTexture - The renderTexture to free
   */
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    if (destroyTextures = destroyTextures !== false, destroyTextures)
      for (const i2 in this.texturePool) {
        const textures = this.texturePool[i2];
        if (textures)
          for (let j2 = 0; j2 < textures.length; j2++)
            textures[j2].destroy(true);
      }
    this.texturePool = {};
  }
  /**
   * If screen size was changed, drops all screen-sized textures,
   * sets new screen size, sets `enableFullScreen` to true
   *
   * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
   * @param size - Initial size of screen.
   */
  setScreenSize(size2) {
    if (!(size2.width === this._pixelsWidth && size2.height === this._pixelsHeight)) {
      this.enableFullScreen = size2.width > 0 && size2.height > 0;
      for (const i2 in this.texturePool) {
        if (!(Number(i2) < 0))
          continue;
        const textures = this.texturePool[i2];
        if (textures)
          for (let j2 = 0; j2 < textures.length; j2++)
            textures[j2].destroy(true);
        this.texturePool[i2] = [];
      }
      this._pixelsWidth = size2.width, this._pixelsHeight = size2.height;
    }
  }
}
RenderTexturePool.SCREEN_KEY = -1;
class Quad extends Geometry {
  constructor() {
    super(), this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}
class QuadUv extends Geometry {
  constructor() {
    super(), this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), this.vertexBuffer = new Buffer(this.vertices), this.uvBuffer = new Buffer(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  /**
   * Maps two Rectangle to the quad.
   * @param targetTextureFrame - The first rectangle
   * @param destinationFrame - The second rectangle
   * @returns - Returns itself.
   */
  map(targetTextureFrame, destinationFrame) {
    let x2 = 0, y2 = 0;
    return this.uvs[0] = x2, this.uvs[1] = y2, this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y2, this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x2, this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height, x2 = destinationFrame.x, y2 = destinationFrame.y, this.vertices[0] = x2, this.vertices[1] = y2, this.vertices[2] = x2 + destinationFrame.width, this.vertices[3] = y2, this.vertices[4] = x2 + destinationFrame.width, this.vertices[5] = y2 + destinationFrame.height, this.vertices[6] = x2, this.vertices[7] = y2 + destinationFrame.height, this.invalidate(), this;
  }
  /**
   * Legacy upload method, just marks buffers dirty.
   * @returns - Returns itself.
   */
  invalidate() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }
}
class FilterState {
  constructor() {
    this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
  }
  /** Clears the state */
  clear() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }
}
const tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$4 = new Matrix();
class FilterSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      // legacy variables
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true), this.forceClear = false, this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an
   * input render-texture for the rest of the filtering pipeline.
   * @param {PIXI.DisplayObject} target - The target of the filter to render.
   * @param filters - The filters to apply.
   */
  push(target, filters2) {
    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), renderTextureSystem = renderer.renderTexture;
    let currentResolution, currentMultisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;
    } else
      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;
    let resolution = filters2[0].resolution || currentResolution, multisample = filters2[0].multisample ?? currentMultisample, padding = filters2[0].padding, autoFit = filters2[0].autoFit, legacy2 = filters2[0].legacy ?? true;
    for (let i2 = 1; i2 < filters2.length; i2++) {
      const filter = filters2[i2];
      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy2 = legacy2 || (filter.legacy ?? true);
    }
    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy2, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true)), state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    renderer.projection.transform && this.transformAABB(
      tempMatrix$4.copyFrom(renderer.projection.transform).invert(),
      sourceFrameProjected
    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(
      state.sourceFrame,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), state.renderTexture = this.getOptimalFilterTexture(
      state.sourceFrame.width,
      state.sourceFrame.height,
      resolution,
      multisample
    ), state.filters = filters2, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /** Pops off the filter and applies it. */
  pop() {
    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters2 = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;
    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    if (this.renderer.framebuffer.blit(), filters2.length === 1)
      filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);
    else {
      let flip2 = state.renderTexture, flop = this.getOptimalFilterTexture(
        flip2.width,
        flip2.height,
        state.resolution
      );
      flop.filterFrame = flip2.filterFrame;
      let i2 = 0;
      for (i2 = 0; i2 < filters2.length - 1; ++i2) {
        i2 === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(
          flip2.width,
          flip2.height,
          state.resolution
        ), flop.filterFrame = flip2.filterFrame), filters2[i2].apply(this, flip2, flop, CLEAR_MODES.CLEAR, state);
        const t2 = flip2;
        flip2 = flop, flop = t2;
      }
      filters2[i2].apply(this, flip2, lastState.renderTexture, CLEAR_MODES.BLEND, state), i2 > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip2), this.returnFilterTexture(flop);
    }
    state.clear(), this.statePool.push(state);
  }
  /**
   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.
   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack
   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}
   */
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else
      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(
        filterTexture,
        this.activeState.bindingSourceFrame,
        this.activeState.bindingDestinationFrame
      );
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /**
   * Draws a filter using the default rendering process.
   *
   * This should be called only by {@link PIXI.Filter#apply}.
   * @param filter - The filter to draw.
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {PIXI.Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(
      destinationFrame.width,
      0,
      0,
      destinationFrame.height,
      sourceFrame.x,
      sourceFrame.y
    ), worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;
  }
  /** Destroys this Filter System. */
  destroy() {
    this.renderer = null, this.texturePool.clear(false);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture in real pixels.
   * @param minHeight - The minimum height of the render texture in real pixels.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns - The new render texture.
   */
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  /**
   * Gets extra render texture to use inside current filter
   * To be compliant with older filters, you can use params in any order
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    if (typeof input == "number") {
      const swap = input;
      input = resolution, resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Frees a render texture back into the pool.
   * @param renderTexture - The renderTarget to free
   */
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  /** Empties the texture pool. */
  emptyPool() {
    this.texturePool.clear(true);
  }
  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * @param matrix - first param
   * @param rect - second param
   */
  transformAABB(matrix, rect) {
    const lt = tempPoints[0], lb2 = tempPoints[1], rt = tempPoints[2], rb2 = tempPoints[3];
    lt.set(rect.left, rect.top), lb2.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb2.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb2, lb2), matrix.apply(rt, rt), matrix.apply(rb2, rb2);
    const x0 = Math.min(lt.x, lb2.x, rt.x, rb2.x), y0 = Math.min(lt.y, lb2.y, rt.y, rb2.y), x1 = Math.max(lt.x, lb2.x, rt.x, rb2.x), y1 = Math.max(lt.y, lb2.y, rt.y, rb2.y);
    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {
      if (transform2) {
        const { a: a2, b: b2, c: c2, d: d2 } = transform2;
        if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4))
          return;
      }
      transform2 = transform2 ? tempMatrix$4.copyFrom(transform2) : tempMatrix$4.identity(), transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
        bindingDestinationFrame.width / bindingSourceFrame.width,
        bindingDestinationFrame.height / bindingSourceFrame.height
      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform2, frame), frame.ceil(resolution), this.transformAABB(transform2.invert(), frame);
    }
  }
}
FilterSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "filter"
};
extensions$1.add(FilterSystem);
class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
}
const tempRectangle = new Rectangle();
class FramebufferSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true);
    const gl2 = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = true, this.writeDepthTexture = true, this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl2.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = false, gl2.drawBuffers = () => {
      }), nativeDepthTextureExtension || (this.writeDepthTexture = false);
    } else
      this.msaaSamples = gl2.getInternalformatParameter(gl2.RENDERBUFFER, gl2.RGBA8, gl2.SAMPLES);
  }
  /**
   * Bind a framebuffer.
   * @param framebuffer
   * @param frame - frame, default is framebuffer size
   * @param mipLevel - optional mip level to set on the framebuffer - defaults to 0
   */
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl: gl2 } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      this.current !== framebuffer && (this.current = framebuffer, gl2.bindFramebuffer(gl2.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));
      for (let i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
        const tex = framebuffer.colorTextures[i2];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {
        const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale = mipWidth / frame.width;
        this.setViewport(
          frame.x * scale,
          frame.y * scale,
          mipWidth,
          mipHeight
        );
      } else {
        const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else
      this.current && (this.current = null, gl2.bindFramebuffer(gl2.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }
  /**
   * Set the WebGLRenderingContext's viewport.
   * @param x - X position of viewport
   * @param y - Y position of viewport
   * @param width - Width of viewport
   * @param height - Height of viewport
   */
  setViewport(x2, y2, width, height) {
    const v2 = this.viewport;
    x2 = Math.round(x2), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) && (v2.x = x2, v2.y = y2, v2.width = width, v2.height = height, this.gl.viewport(x2, y2, width, height));
  }
  /**
   * Get the size of the current width and height. Returns object with `width` and `height` values.
   * @readonly
   */
  get size() {
    return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  /**
   * Clear the color of the context
   * @param r - Red value from 0 to 1
   * @param g - Green value from 0 to 1
   * @param b - Blue value from 0 to 1
   * @param a - Alpha value from 0 to 1
   * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(r2, g2, b2, a2, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl: gl2 } = this;
    gl2.clearColor(r2, g2, b2, a2), gl2.clear(mask);
  }
  /**
   * Initialize framebuffer for this context
   * @protected
   * @param framebuffer
   * @returns - created GLFramebuffer
   */
  initFramebuffer(framebuffer) {
    const { gl: gl2 } = this, fbo = new GLFramebuffer(gl2.createFramebuffer());
    return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;
  }
  /**
   * Resize the framebuffer
   * @param framebuffer
   * @protected
   */
  resizeFramebuffer(framebuffer) {
    const { gl: gl2 } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo.stencil);
      let stencilFormat;
      this.renderer.context.webGLVersion === 1 ? stencilFormat = gl2.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl2.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl2.DEPTH_COMPONENT24 : stencilFormat = gl2.STENCIL_INDEX8, fbo.msaaBuffer ? gl2.renderbufferStorageMultisample(
        gl2.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl2.renderbufferStorage(gl2.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    gl2.drawBuffers || (count = Math.min(count, 1));
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i2 === 0 && fbo.msaaBuffer && (gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo.msaaBuffer), gl2.renderbufferStorageMultisample(
        gl2.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ));
    }
    framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);
  }
  /**
   * Update the framebuffer
   * @param framebuffer
   * @param mipLevel
   * @protected
   */
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl: gl2 } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    gl2.drawBuffers || (count = Math.min(count, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl2.createRenderbuffer() : fbo.msaaBuffer && (gl2.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));
    const activeTextures = [];
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i2 === 0 && fbo.msaaBuffer ? (gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo.msaaBuffer), gl2.renderbufferStorageMultisample(
        gl2.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.RENDERBUFFER, fbo.msaaBuffer)) : (gl2.framebufferTexture2D(
        gl2.FRAMEBUFFER,
        gl2.COLOR_ATTACHMENT0 + i2,
        texture.target,
        parentTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      ), activeTextures.push(gl2.COLOR_ATTACHMENT0 + i2));
    }
    if (activeTextures.length > 1 && gl2.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {
      const depthTexture = framebuffer.depthTexture;
      this.renderer.texture.bind(depthTexture, 0), gl2.framebufferTexture2D(
        gl2.FRAMEBUFFER,
        gl2.DEPTH_ATTACHMENT,
        gl2.TEXTURE_2D,
        depthTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      );
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl2.createRenderbuffer();
      let stencilAttachment, stencilFormat;
      this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl2.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl2.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl2.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl2.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl2.DEPTH_ATTACHMENT, stencilFormat = gl2.DEPTH_COMPONENT24) : (stencilAttachment = gl2.STENCIL_ATTACHMENT, stencilFormat = gl2.STENCIL_INDEX8), gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl2.renderbufferStorageMultisample(
        gl2.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl2.renderbufferStorage(gl2.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, stencilAttachment, gl2.RENDERBUFFER, fbo.stencil);
    } else
      fbo.stencil && (gl2.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);
  }
  /**
   * Returns true if the frame buffer can be multisampled.
   * @param framebuffer
   */
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  /**
   * Detects number of samples that is not more than a param but as close to it as possible
   * @param samples - number of samples
   * @returns - recommended number of samples
   */
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null)
      return res;
    for (let i2 = 0; i2 < msaaSamples.length; i2++)
      if (msaaSamples[i2] <= samples) {
        res = msaaSamples[i2];
        break;
      }
    return res === 1 && (res = MSAA_QUALITY.NONE), res;
  }
  /**
   * Only works with WebGL2
   *
   * blits framebuffer to another of the same or bigger size
   * after that target framebuffer is bound
   *
   * Fails with WebGL warning if blits multisample framebuffer to different size
   * @param framebuffer - by default it blits "into itself", from renderBuffer to texture.
   * @param sourcePixels - source rectangle in pixels
   * @param destPixels - dest rectangle in pixels, assumed to be the same as sourcePixels
   */
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl: gl2, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2 || !current)
      return;
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo)
      return;
    if (!framebuffer) {
      if (!fbo.msaaBuffer)
        return;
      const colorTexture = current.colorTextures[0];
      if (!colorTexture)
        return;
      fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);
    }
    sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer), gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, fbo.framebuffer), gl2.blitFramebuffer(
      sourcePixels.left,
      sourcePixels.top,
      sourcePixels.right,
      sourcePixels.bottom,
      destPixels.left,
      destPixels.top,
      destPixels.right,
      destPixels.bottom,
      gl2.COLOR_BUFFER_BIT,
      sameSize ? gl2.NEAREST : gl2.LINEAR
    ), gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  /**
   * Disposes framebuffer.
   * @param framebuffer - framebuffer that has to be disposed of
   * @param contextLost - If context was lost, we suppress all delete function calls
   */
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl2 = this.gl;
    if (!fbo)
      return;
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl2.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl2.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl2.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
  }
  /**
   * Disposes all framebuffers, but not textures bound to them.
   * @param [contextLost=false] - If context was lost, we suppress all delete function calls
   */
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i2 = 0; i2 < list.length; i2++)
      this.disposeFramebuffer(list[i2], contextLost);
  }
  /**
   * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.
   * Used by MaskSystem, when its time to use stencil mask for Graphics element.
   *
   * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.
   * @private
   */
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer)
      return;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil && framebuffer.stencil)
      return;
    framebuffer.stencil = true;
    const w2 = framebuffer.width, h2 = framebuffer.height, gl2 = this.gl, stencil = fbo.stencil = gl2.createRenderbuffer();
    gl2.bindRenderbuffer(gl2.RENDERBUFFER, stencil);
    let stencilAttachment, stencilFormat;
    this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl2.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl2.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl2.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl2.DEPTH24_STENCIL8) : (stencilAttachment = gl2.STENCIL_ATTACHMENT, stencilFormat = gl2.STENCIL_INDEX8), fbo.msaaBuffer ? gl2.renderbufferStorageMultisample(gl2.RENDERBUFFER, fbo.multisample, stencilFormat, w2, h2) : gl2.renderbufferStorage(gl2.RENDERBUFFER, stencilFormat, w2, h2), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, stencilAttachment, gl2.RENDERBUFFER, stencil);
  }
  /** Resets framebuffer stored state, binds screen framebuffer. Should be called before renderTexture reset(). */
  reset() {
    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions$1.add(FramebufferSystem);
const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true);
    const gl2 = this.gl = this.renderer.gl, context2 = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context2.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl2.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl2.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl2.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = false, gl2.createVertexArray = () => null, gl2.bindVertexArray = () => null, gl2.deleteVertexArray = () => null);
    }
    if (context2.webGLVersion !== 2) {
      const instanceExt = gl2.getExtension("ANGLE_instanced_arrays");
      instanceExt ? (gl2.vertexAttribDivisor = (a2, b2) => instanceExt.vertexAttribDivisorANGLE(a2, b2), gl2.drawElementsInstanced = (a2, b2, c2, d2, e2) => instanceExt.drawElementsInstancedANGLE(a2, b2, c2, d2, e2), gl2.drawArraysInstanced = (a2, b2, c2, d2) => instanceExt.drawArraysInstancedANGLE(a2, b2, c2, d2)) : this.hasInstance = false;
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param shader - Instance of shader to use vao for.
   */
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl: gl2 } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = false;
    vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = true);
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl2.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  reset() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;
    for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
      const buffer = geometry.buffers[i2];
      bufferSystem.update(buffer);
    }
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;
    for (const j2 in shaderAttributes)
      if (!geometryAttributes[j2])
        throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(geometry, program) {
    const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = ["g", geometry.id];
    for (const i2 in attribs)
      shaderAttributes[i2] && strings.push(i2, shaderAttributes[i2].location);
    return strings.join("-");
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param shader - Instance of the shader.
   * @param incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl2 = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;
    program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao)
      return vaoObjectHash[program.id] = vao, vao;
    const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};
    for (const j2 in buffers)
      tempStride[j2] = 0, tempStart[j2] = 0;
    for (const j2 in attributes)
      !attributes[j2].size && program.attributeData[j2] ? attributes[j2].size = program.attributeData[j2].size : attributes[j2].size || console.warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];
    for (const j2 in attributes) {
      const attribute = attributes[j2], attribSize = attribute.size;
      attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type]);
    }
    vao = gl2.createVertexArray(), gl2.bindVertexArray(vao);
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer = buffers[i2];
      bufferSystem.bind(buffer), incRefCount && buffer._glBuffers[CONTEXT_UID].refCount++;
    }
    return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl2.bindVertexArray(null), bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER), vao;
  }
  /**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id])
      return;
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl2 = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;
    if (geometry.disposeRunner.remove(this), !!vaos) {
      if (bufferSystem)
        for (let i2 = 0; i2 < buffers.length; i2++) {
          const buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
          buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i2], contextLost));
        }
      if (!contextLost) {
        for (const vaoId in vaos)
          if (vaoId[0] === "g") {
            const vao = vaos[vaoId];
            this._activeVao === vao && this.unbind(), gl2.deleteVertexArray(vao);
          }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i2 = 0; i2 < all.length; i2++)
      this.disposeGeometry(this.managedGeometries[all[i2]], contextLost);
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(geometry, program) {
    const gl2 = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;
    geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);
    let lastBuffer = null;
    for (const j2 in attributes) {
      const attribute = attributes[j2], buffer = buffers[attribute.buffer], glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j2]) {
        lastBuffer !== glBuffer && (bufferSystem.bind(buffer), lastBuffer = glBuffer);
        const location = program.attributeData[j2].location;
        if (gl2.enableVertexAttribArray(location), gl2.vertexAttribPointer(
          location,
          attribute.size,
          attribute.type || gl2.FLOAT,
          attribute.normalized,
          attribute.stride,
          attribute.start
        ), attribute.instance)
          if (this.hasInstance)
            gl2.vertexAttribDivisor(location, attribute.divisor);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param type - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   */
  draw(type2, size2, start, instanceCount) {
    const { gl: gl2 } = this, geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl2.UNSIGNED_SHORT : gl2.UNSIGNED_INT;
      byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl2.drawElementsInstanced(type2, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl2.drawElements(type2, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");
    } else
      geometry.instanced ? gl2.drawArraysInstanced(type2, start, size2 || geometry.getSize(), instanceCount || 1) : gl2.drawArrays(type2, start, size2 || geometry.getSize());
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "geometry"
};
extensions$1.add(GeometrySystem);
const tempMat$1 = new Matrix();
class TextureMatrix {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this._texture = texture, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > "u" ? 0.5 : clampMargin, this.isSimple = false;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value, this._textureID = -1;
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out) {
    out === void 0 && (out = uvs);
    const mat = this.mapCoord;
    for (let i2 = 0; i2 < uvs.length; i2 += 2) {
      const x2 = uvs[i2], y2 = uvs[i2 + 1];
      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx, out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  }
  /**
   * Updates matrices if texture was changed.
   * @param [forceUpdate=false] - if true, matrices will be updated any case
   * @returns - Whether or not it was updated
   */
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)
      return false;
    this._textureID = tex._updateID, this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig, trim2 = tex.trim;
    trim2 && (tempMat$1.set(
      orig.width / trim2.width,
      0,
      0,
      orig.height / trim2.height,
      -trim2.x / trim2.width,
      -trim2.y / trim2.height
    ), this.mapCoord.append(tempMat$1));
    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset2 = this.clampOffset;
    return frame[0] = (tex._frame.x + margin + offset2) / texBase.width, frame[1] = (tex._frame.y + margin + offset2) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset2) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset2) / texBase.height, this.uClampOffset[0] = offset2 / texBase.realWidth, this.uClampOffset[1] = offset2 / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, true;
  }
}
var fragment$7 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`;
var vertex$4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class SpriteMaskFilter extends Filter {
  /** @ignore */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    typeof vertexSrc != "string" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms), this.maskSprite = sprite, this.maskMatrix = new Matrix();
  }
  /**
   * Sprite mask
   * @type {PIXI.DisplayObject}
   */
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = false);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it.
   */
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite, tex = maskSprite._texture;
    tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));
  }
}
class MaskData {
  /**
   * Create MaskData
   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask
   */
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE, this.autoDetect = true, this.maskObject = maskObject || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = Filter.defaultMultisample, this.enabled = true, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  /**
   * The sprite mask filter.
   * If set to `null`, the default sprite mask filter is used.
   * @default null
   */
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;
  }
  /** Resets the mask data after popMask(). */
  reset() {
    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
  }
  /**
   * Copies counters from maskData above, called from pushMask().
   * @param maskAbove
   */
  copyCountersOrReset(maskAbove) {
    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }
}
class MaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);
  }
  /**
   * Enables the mask and appends it to the current mask stack.
   *
   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.
   * @param {PIXI.DisplayObject} target - Display Object to push the mask to
   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.
   */
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d2 = this.maskDataPool.pop() || new MaskData();
      d2.pooled = true, d2.maskObject = maskDataOrTarget, maskData = d2;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
      }
    maskData.type === MASK_TYPES.SPRITE && this.maskStack.push(maskData);
  }
  /**
   * Removes the last mask from the mask stack and doesn't return it.
   *
   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.
   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from
   */
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!(!maskData || maskData._target !== target)) {
      if (maskData.enabled)
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
        }
      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {
        const maskCurrent = this.maskStack[this.maskStack.length - 1];
        maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);
      }
    }
  }
  /**
   * Sets type of MaskData based on its maskObject.
   * @param maskData
   */
  detect(maskData) {
    const maskObject = maskData.maskObject;
    maskObject ? maskObject.isSprite ? maskData.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = MASK_TYPES.SCISSOR : maskData.type = MASK_TYPES.STENCIL : maskData.type = MASK_TYPES.COLOR;
  }
  /**
   * Applies the Mask and adds it to the current filter stack.
   * @param maskData - Sprite to be used as the mask.
   */
  pushSpriteMask(maskData) {
    const { maskObject } = maskData, target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;
  }
  /**
   * Removes the last filter from the filter stack and doesn't return it.
   * @param maskData - Sprite to be used as the mask.
   */
  popSpriteMask(maskData) {
    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }
  /**
   * Pushes the color mask.
   * @param maskData - The mask data
   */
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  /**
   * Pops the color mask.
   * @param maskData - The mask data
   */
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "mask"
};
extensions$1.add(MaskSystem);
class AbstractMaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.maskStack = [], this.glConst = 0;
  }
  /** Gets count of masks of certain type. */
  getStackLength() {
    return this.maskStack.length;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param {PIXI.MaskData[]} maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    const { gl: gl2 } = this.renderer, curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    newStackLen !== curStackLen && (newStackLen === 0 ? gl2.disable(this.glConst) : (gl2.enable(this.glConst), this._useCurrent()));
  }
  /**
   * Setup renderer to use the current mask data.
   * @private
   */
  _useCurrent() {
  }
  /** Destroys the mask stack. */
  destroy() {
    this.renderer = null, this.maskStack = null;
  }
}
const tempMatrix$3 = new Matrix(), rectPool = [], _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._scissorCounter : 0;
  }
  /**
   * evaluates _boundsTransformed, _scissorRect for MaskData
   * @param maskData
   */
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal)
      return;
    const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
    this.roundFrameToPixels(
      rect,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix)
      return false;
    const { a: a2, b: b2, c: c2, d: d2 } = matrix;
    return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);
  }
  /**
   * Test, whether the object can be scissor mask with current renderer projection.
   * Calls "calcScissorRect()" if its true.
   * @param maskData - mask data
   * @returns whether Whether the object can be scissor mask
   */
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))
      return false;
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
    _ScissorSystem2.isMatrixRotated(transform2) || (transform2 = transform2 ? tempMatrix$3.copyFrom(transform2) : tempMatrix$3.identity(), transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
      bindingDestinationFrame.width / bindingSourceFrame.width,
      bindingDestinationFrame.height / bindingSourceFrame.height
    ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform2, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @author alvin
   * @param maskData - The mask data.
   */
  push(maskData) {
    maskData._scissorRectLocal || this.calcScissorRect(maskData);
    const { gl: gl2 } = this.renderer;
    maskData._scissorRect || gl2.enable(gl2.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();
  }
  /**
   * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the
   * last mask in the stack.
   *
   * This can also be called when you directly modify the scissor box and want to restore PixiJS state.
   * @param maskData - The mask data.
   */
  pop(maskData) {
    const { gl: gl2 } = this.renderer;
    maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl2.disable(gl2.SCISSOR_TEST);
  }
  /**
   * Setup renderer to use the current scissor data.
   * @private
   */
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y2;
    this.renderer.renderTexture.current ? y2 = rect.y : y2 = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  }
};
_ScissorSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "scissor"
};
let ScissorSystem = _ScissorSystem;
extensions$1.add(ScissorSystem);
class StencilSystem extends AbstractMaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._stencilCounter : 0;
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @param maskData - The mask data
   */
  push(maskData) {
    const maskObject = maskData.maskObject, { gl: gl2 } = this.renderer, prevMaskCount = maskData._stencilCounter;
    prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl2.clearStencil(0), gl2.clear(gl2.STENCIL_BUFFER_BIT), gl2.enable(gl2.STENCIL_TEST)), maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    colorMask !== 0 && (maskData._colorMask = 0, gl2.colorMask(false, false, false, false)), gl2.stencilFunc(gl2.EQUAL, prevMaskCount, 4294967295), gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.INCR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl2.colorMask(
      (colorMask & 1) !== 0,
      (colorMask & 2) !== 0,
      (colorMask & 4) !== 0,
      (colorMask & 8) !== 0
    )), this._useCurrent();
  }
  /**
   * Pops stencil mask. MaskData is already removed from stack
   * @param {PIXI.DisplayObject} maskObject - object of popped mask data
   */
  pop(maskObject) {
    const gl2 = this.renderer.gl;
    if (this.getStackLength() === 0)
      gl2.disable(gl2.STENCIL_TEST);
    else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;
      colorMask !== 0 && (maskData._colorMask = 0, gl2.colorMask(false, false, false, false)), gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.DECR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl2.colorMask(
        (colorMask & 1) !== 0,
        (colorMask & 2) !== 0,
        (colorMask & 4) !== 0,
        (colorMask & 8) !== 0
      )), this._useCurrent();
    }
  }
  /**
   * Setup renderer to use the current stencil data.
   * @private
   */
  _useCurrent() {
    const gl2 = this.renderer.gl;
    gl2.stencilFunc(gl2.EQUAL, this.getStackLength(), 4294967295), gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
  }
}
StencilSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "stencil"
};
extensions$1.add(StencilSystem);
class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          return deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          return deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          return deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), renderer.events;
        }
      }
    });
  }
  /**
   * Initialize the plugins.
   * @protected
   */
  init() {
    const staticMap = this.rendererPlugins;
    for (const o2 in staticMap)
      this.plugins[o2] = new staticMap[o2](this.renderer);
  }
  destroy() {
    for (const o2 in this.plugins)
      this.plugins[o2].destroy(), this.plugins[o2] = null;
  }
}
PluginSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions$1.add(PluginSystem);
class ProjectionSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
  }
  /**
   * Updates the projection-matrix based on the sourceFrame → destinationFrame mapping provided.
   *
   * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because
   * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.
   *
   * NOTE-2: {@link PIXI.RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture.
   * It is expected
   * that you dirty the current bindings when calling this manually.
   * @param destinationFrame - The rectangle in the render-target to render the contents into. If rendering to the canvas,
   *  the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.
   * @param sourceFrame - The rectangle in world space that contains the contents being rendered.
   * @param resolution - The resolution of the render-target, which is the ratio of
   *  world-space (or CSS) pixels to physical pixels.
   * @param root - Whether the render-target is the screen. This is required because rendering to textures
   *  is y-flipped (i.e. upside down relative to the screen).
   */
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
  }
  /**
   * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.
   * @param _destinationFrame - The destination frame in the render-target.
   * @param sourceFrame - The source frame in world space.
   * @param _resolution - The render-target's resolution, i.e. ratio of CSS to physical pixels.
   * @param root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection
   *  is y-flipped.
   */
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix, sign3 = root ? -1 : 1;
    pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign3 * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign3 - sourceFrame.y * pm.d;
  }
  /**
   * Sets the transform of the active render target to the given matrix.
   * @param _matrix - The transformation matrix
   */
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "projection"
};
extensions$1.add(ProjectionSystem);
const tempTransform = new Transform(), tempRect$1 = new Rectangle();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer, this._tempMatrix = new Matrix();
  }
  /**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns a shiny new texture of the display object passed in
   */
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect$1) || displayObject.getLocalBounds(tempRect$1, true), resolution = textureOptions.resolution || this.renderer.resolution;
    region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);
    const renderTexture = RenderTexture.create(textureOptions);
    this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;
    const transform2 = displayObject.transform;
    return displayObject.transform = tempTransform, this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    }), displayObject.transform = transform2, renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions$1.add(GenerateTextureSystem);
const tempRect = new Rectangle(), tempRect2 = new Rectangle();
class RenderTextureSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  /**
   * Bind the current render texture.
   * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.
   * @param sourceFrame - Part of world that is mapped to the renderTexture.
   * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.
   */
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture, framebuffer, resolution;
    renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (tempRect.width = renderTexture.frame.width, tempRect.height = renderTexture.frame.height, sourceFrame = tempRect), destinationFrame || (tempRect2.x = renderTexture.frame.x, tempRect2.y = renderTexture.frame.y, tempRect2.width = sourceFrame.width, tempRect2.height = sourceFrame.height, destinationFrame = tempRect2), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (tempRect.width = renderer._view.screen.width, tempRect.height = renderer._view.screen.height, sourceFrame = tempRect), destinationFrame || (destinationFrame = tempRect, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);
  }
  /**
   * Erases the render texture and fills the drawing area with a colour.
   * @param clearColor - The color as rgba, default to use the renderer backgroundColor
   * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color = Color.shared.setValue(clearColor || fallbackColor);
    (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color.premultiply(color.alpha);
    const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x: x2, y: y2, width, height } = this.viewportFrame;
      x2 = Math.round(x2), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x2, y2, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask), clearMask && this.renderer.scissor.pop();
  }
  resize() {
    this.bind(null);
  }
  /** Resets render-texture state. */
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions$1.add(RenderTextureSystem);
class GLProgram {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(program, uniformData) {
    this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }
}
function getAttributeData(program, gl2) {
  const attributes = {}, totalAttributes = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl2.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_"))
      continue;
    const type2 = mapType(gl2, attribData.type), data = {
      type: type2,
      name: attribData.name,
      size: mapSize(type2),
      location: gl2.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl2) {
  const uniforms = {}, totalUniforms = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl2.getActiveUniform(program, i2), name2 = uniformData.name.replace(/\[.*?\]$/, ""), isArray2 = !!uniformData.name.match(/\[.*?\]$/), type2 = mapType(gl2, uniformData.type);
    uniforms[name2] = {
      name: name2,
      index: i2,
      type: type2,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl2, program) {
  const glVertShader = compileShader(gl2, gl2.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader(gl2, gl2.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl2.createProgram();
  gl2.attachShader(webGLProgram, glVertShader), gl2.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings && (typeof gl2.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl2.transformFeedbackVaryings(
    webGLProgram,
    transformFeedbackVaryings.names,
    transformFeedbackVaryings.bufferMode === "separate" ? gl2.SEPARATE_ATTRIBS : gl2.INTERLEAVED_ATTRIBS
  )), gl2.linkProgram(webGLProgram), gl2.getProgramParameter(webGLProgram, gl2.LINK_STATUS) || logProgramError(gl2, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData(webGLProgram, gl2), program.uniformData = getUniformData(webGLProgram, gl2), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
    for (let i2 = 0; i2 < keys.length; i2++)
      program.attributeData[keys[i2]].location = i2, gl2.bindAttribLocation(webGLProgram, i2, keys[i2]);
    gl2.linkProgram(webGLProgram);
  }
  gl2.deleteShader(glVertShader), gl2.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program.uniformData) {
    const data = program.uniformData[i2];
    uniformData[i2] = {
      location: gl2.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  return new GLProgram(webGLProgram, uniformData);
}
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size2 = 0, chunkSize = 0, offset2 = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    if (size2 = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size2 = Math.max(size2, 16) * uboElement.data.size), uboElement.dataLen = size2, chunkSize % size2 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue, offset2 += lineUpValue;
    }
    chunkSize + size2 > 16 ? (offset2 = Math.ceil(offset2 / 16) * 16, uboElement.offset = offset2, offset2 += size2, chunkSize = size2) : (uboElement.offset = offset2, chunkSize += size2, offset2 += size2);
  }
  return offset2 = Math.ceil(offset2 / 16) * 16, { uboElements, size: offset2 };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i2 in uniforms)
    uniformData[i2] && usedUniformDatas.push(uniformData[i2]);
  return usedUniformDatas.sort((a2, b2) => a2.index - b2.index), usedUniformDatas;
}
function generateUniformBufferSync(group2, uniformData) {
  if (!group2.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  const usedUniformDatas = getUBOData(group2.uniforms, uniformData), { uboElements, size: size2 } = createUBOElements(usedUniformDatas), funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2], uniform = group2.uniforms[uboElement.data.name], name2 = uboElement.data.name;
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(
          `offset = ${uboElement.offset / 4};`,
          uniformParsers[j2].codeUbo(uboElement.data.name, uniform)
        ), parsed = true;
        break;
      }
    }
    if (!parsed)
      if (uboElement.data.size > 1) {
        const size22 = mapSize(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size22 / rowSize, remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name2}.value;
                v = uv.${name2};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name2}.value;
                v = uv.${name2};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
  }
  return funcFragments.push(`
       renderer.buffer.update(buffer);
    `), {
    size: size2,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      "buffer",
      funcFragments.join(`
`)
    )
  };
}
let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.destroyed = false, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
  }
  /**
   * Overrideable function by `@pixi/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  systemCheck() {
    if (!unsafeEvalSupported())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }
  contextChange(gl2) {
    this.gl = gl2, this.reset();
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param dontSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(shader, dontSync) {
    shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param uniforms - the uniforms values that be applied to the current shader
   */
  setUniforms(uniforms) {
    const shader = this.shader.program, glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  /**
   * Syncs uniforms on the group
   * @param group - the uniform group to sync
   * @param syncData - this is data that is passed to the sync function and any nested sync functions
   */
  syncUniformGroup(group2, syncData) {
    const glProgram = this.getGlProgram();
    (!group2.static || group2.dirtyId !== glProgram.uniformDirtyGroups[group2.id]) && (glProgram.uniformDirtyGroups[group2.id] = group2.dirtyId, this.syncUniforms(group2, glProgram, syncData));
  }
  /**
   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param glProgram
   * @param syncData
   */
  syncUniforms(group2, glProgram, syncData) {
    (group2.syncUniforms[this.shader.program.id] || this.createSyncGroups(group2))(glProgram.uniformData, group2.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group2) {
    const id2 = this.getSignature(group2, this.shader.program.uniformData, "u");
    return this.cache[id2] || (this.cache[id2] = generateUniformsSync(group2, this.shader.program.uniformData)), group2.syncUniforms[this.shader.program.id] = this.cache[id2], group2.syncUniforms[this.shader.program.id];
  }
  /**
   * Syncs uniform buffers
   * @param group - the uniform buffer group to sync
   * @param name - the name of the uniform buffer
   */
  syncUniformBufferGroup(group2, name2) {
    const glProgram = this.getGlProgram();
    if (!group2.static || group2.dirtyId !== 0 || !glProgram.uniformGroups[group2.id]) {
      group2.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group2.id] || this.createSyncBufferGroup(group2, glProgram, name2);
      group2.buffer.update(), syncFunc(
        glProgram.uniformData,
        group2.uniforms,
        this.renderer,
        defaultSyncData,
        group2.buffer
      );
    }
    this.renderer.buffer.bindBufferBase(group2.buffer, glProgram.uniformBufferBindings[name2]);
  }
  /**
   * Will create a function that uploads a uniform buffer using the STD140 standard.
   * The upload function will then be cached for future calls
   * If a group is manually managed, then a simple upload function is generated
   * @param group - the uniform buffer group to sync
   * @param glProgram - the gl program to attach the uniform bindings to
   * @param name - the name of the uniform buffer (must exist on the shader)
   */
  createSyncBufferGroup(group2, glProgram, name2) {
    const { gl: gl2 } = this.renderer;
    this.renderer.buffer.bind(group2.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name2);
    glProgram.uniformBufferBindings[name2] = this.shader.uniformBindCount, gl2.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    const id2 = this.getSignature(group2, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id2];
    if (uboData || (uboData = this._uboCache[id2] = generateUniformBufferSync(group2, this.shader.program.uniformData)), group2.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group2.buffer.update(data);
    }
    return glProgram.uniformGroups[group2.id] = uboData.syncFunc, glProgram.uniformGroups[group2.id];
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  getSignature(group2, uniformData, preFix) {
    const uniforms = group2.uniforms, strings = [`${preFix}-`];
    for (const i2 in uniforms)
      strings.push(i2), uniformData[i2] && strings.push(uniformData[i2].type);
    return strings.join("-");
  }
  /**
   * Returns the underlying GLShade rof the currently bound shader.
   *
   * This can be handy for when you to have a little more control over the setting of your uniforms.
   * @returns The glProgram for the currently bound Shader for this context
   */
  getGlProgram() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }
  /**
   * Generates a glProgram version of the Shader provided.
   * @param shader - The shader that the glProgram will be based on.
   * @returns A shiny new glProgram!
   */
  generateProgram(shader) {
    const gl2 = this.gl, program = shader.program, glProgram = generateProgram(gl2, program);
    return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;
  }
  /** Resets ShaderSystem state, does not affect WebGL state. */
  reset() {
    this.program = null, this.shader = null;
  }
  /**
   * Disposes shader.
   * If disposing one equals with current shader, set current as null.
   * @param shader - Shader object
   */
  disposeShader(shader) {
    this.shader === shader && (this.shader = null);
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this.renderer = null, this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "shader"
};
extensions$1.add(ShaderSystem);
class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.4.2 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.hello}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  hello: false
}, /** @ignore */
StartupSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions$1.add(StartupSystem);
function mapWebGLBlendModesToPixi(gl2, array = []) {
  return array[BLEND_MODES.NORMAL] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD] = [gl2.ONE, gl2.ONE], array[BLEND_MODES.MULTIPLY] = [gl2.DST_COLOR, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SCREEN] = [gl2.ONE, gl2.ONE_MINUS_SRC_COLOR, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.OVERLAY] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DARKEN] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LIGHTEN] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_DODGE] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_BURN] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HARD_LIGHT] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SOFT_LIGHT] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DIFFERENCE] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.EXCLUSION] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HUE] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SATURATION] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LUMINOSITY] = [gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.NONE] = [0, 0], array[BLEND_MODES.NORMAL_NPM] = [gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD_NPM] = [gl2.SRC_ALPHA, gl2.ONE, gl2.ONE, gl2.ONE], array[BLEND_MODES.SCREEN_NPM] = [gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_COLOR, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SRC_IN] = [gl2.DST_ALPHA, gl2.ZERO], array[BLEND_MODES.SRC_OUT] = [gl2.ONE_MINUS_DST_ALPHA, gl2.ZERO], array[BLEND_MODES.SRC_ATOP] = [gl2.DST_ALPHA, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_OVER] = [gl2.ONE_MINUS_DST_ALPHA, gl2.ONE], array[BLEND_MODES.DST_IN] = [gl2.ZERO, gl2.SRC_ALPHA], array[BLEND_MODES.DST_OUT] = [gl2.ZERO, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_ATOP] = [gl2.ONE_MINUS_DST_ALPHA, gl2.SRC_ALPHA], array[BLEND_MODES.XOR] = [gl2.ONE_MINUS_DST_ALPHA, gl2.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SUBTRACT] = [gl2.ONE, gl2.ONE, gl2.ONE, gl2.ONE, gl2.FUNC_REVERSE_SUBTRACT, gl2.FUNC_ADD], array;
}
const BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, _StateSystem = class _StateSystem2 {
  constructor() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = false, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = true;
  }
  contextChange(gl2) {
    this.gl = gl2, this.blendModes = mapWebGLBlendModesToPixi(gl2), this.set(this.defaultState), this.reset();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(state) {
    if (state = state || this.defaultState, this.stateId !== state.data) {
      let diff = this.stateId ^ state.data, i2 = 0;
      for (; diff; )
        diff & 1 && this.map[i2].call(this, !!(state.data & 1 << i2)), diff = diff >> 1, i2++;
      this.stateId = state.data;
    }
    for (let i2 = 0; i2 < this.checks.length; i2++)
      this.checks[i2](this, state);
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(state) {
    state = state || this.defaultState;
    for (let i2 = 0; i2 < this.map.length; i2++)
      this.map[i2].call(this, !!(state.data & 1 << i2));
    for (let i2 = 0; i2 < this.checks.length; i2++)
      this.checks[i2](this, state);
    this.stateId = state.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(value) {
    this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(value) {
    this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(value) {
    if (value === this.blendMode)
      return;
    this.blendMode = value;
    const mode = this.blendModes[value], gl2 = this.gl;
    mode.length === 2 ? gl2.blendFunc(mode[0], mode[1]) : gl2.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = true, gl2.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = false, gl2.blendEquationSeparate(gl2.FUNC_ADD, gl2.FUNC_ADD));
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  // used
  /** Resets all the logic and disables the VAOs. */
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    value && index === -1 ? this.checks.push(func) : !value && index !== -1 && this.checks.splice(index, 1);
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  /**
   * @ignore
   */
  destroy() {
    this.gl = null;
  }
};
_StateSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "state"
};
let StateSystem = _StateSystem;
extensions$1.add(StateSystem);
class SystemManager extends EventEmitter {
  constructor() {
    super(...arguments), this.runners = {}, this._systemsHash = {};
  }
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  setup(config2) {
    this.addRunners(...config2.runners);
    const priority = (config2.priority ?? []).filter((key) => config2.systems[key]), orderByPriority = [
      ...priority,
      ...Object.keys(config2.systems).filter((key) => !priority.includes(key))
    ];
    for (const i2 of orderByPriority)
      this.addSystem(config2.systems[i2], i2);
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner(runnerId);
    });
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  addSystem(ClassRef, name2) {
    const system = new ClassRef(this);
    if (this[name2])
      throw new Error(`Whoops! The name "${name2}" is already in use`);
    this[name2] = system, this._systemsHash[name2] = system;
    for (const i2 in this.runners)
      this.runners[i2].add(system);
    return this;
  }
  /**
   * A function that will run a runner and call the runners function but pass in different options
   * to each system based on there name.
   *
   * E.g. If you have two systems added called `systemA` and `systemB` you could call do the following:
   *
   * ```js
   * system.emitWithCustomOptions(init, {
   *     systemA: {...optionsForA},
   *     systemB: {...optionsForB},
   * });
   * ```
   *
   * `init` would be called on system A passing `optionsForA` and on system B passing `optionsForB`.
   * @param runner - the runner to target
   * @param options - key value options for each system
   */
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  /** destroy the all runners and systems. Its apps job to */
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    }), this._systemsHash = {};
  }
  // TODO implement!
  // removeSystem(ClassRef: ISystemConstructor, name: string): void
  // {
  // }
}
const _TextureGCSystem = class _TextureGCSystem2 {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem2.defaultMaxIdle, this.checkCountMax = _TextureGCSystem2.defaultCheckCountMax, this.mode = _TextureGCSystem2.defaultMode;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const tm = this.renderer.texture, managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i2 = 0; i2 < managedTextures.length; i2++) {
      const texture = managedTextures[i2];
      texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, true), managedTextures[i2] = null, wasRemoved = true);
    }
    if (wasRemoved) {
      let j2 = 0;
      for (let i2 = 0; i2 < managedTextures.length; i2++)
        managedTextures[i2] !== null && (managedTextures[j2++] = managedTextures[i2]);
      managedTextures.length = j2;
    }
  }
  /**
   * Removes all the textures within the specified displayObject and its children from the GPU.
   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
   */
  unload(displayObject) {
    const tm = this.renderer.texture, texture = displayObject._texture;
    texture && !texture.framebuffer && tm.destroyTexture(texture);
    for (let i2 = displayObject.children.length - 1; i2 >= 0; i2--)
      this.unload(displayObject.children[i2]);
  }
  destroy() {
    this.renderer = null;
  }
};
_TextureGCSystem.defaultMode = GC_MODES.AUTO, /**
* Default maximum idle frames before a texture is destroyed by garbage collection.
* @static
* @default 3600
* @see PIXI.TextureGCSystem#maxIdle
*/
_TextureGCSystem.defaultMaxIdle = 60 * 60, /**
* Default frames between two garbage collections.
* @static
* @default 600
* @see PIXI.TextureGCSystem#checkCountMax
*/
_TextureGCSystem.defaultCheckCountMax = 60 * 10, /** @ignore */
_TextureGCSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "textureGC"
};
let TextureGCSystem = _TextureGCSystem;
extensions$1.add(TextureGCSystem);
class GLTexture {
  constructor(texture) {
    this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
  }
}
function mapInternalFormatToSamplerType(gl2) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl2 instanceof globalThis.WebGL2RenderingContext ? table = {
    [gl2.RGB]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA]: SAMPLER_TYPES.FLOAT,
    [gl2.ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl2.LUMINANCE]: SAMPLER_TYPES.FLOAT,
    [gl2.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl2.R8]: SAMPLER_TYPES.FLOAT,
    [gl2.R8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl2.RG8]: SAMPLER_TYPES.FLOAT,
    [gl2.RG8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB8]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB565]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA4]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB5_A1]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA8]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB10_A2]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB10_A2UI]: SAMPLER_TYPES.FLOAT,
    [gl2.SRGB8]: SAMPLER_TYPES.FLOAT,
    [gl2.SRGB8_ALPHA8]: SAMPLER_TYPES.FLOAT,
    [gl2.R16F]: SAMPLER_TYPES.FLOAT,
    [gl2.RG16F]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB16F]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA16F]: SAMPLER_TYPES.FLOAT,
    [gl2.R32F]: SAMPLER_TYPES.FLOAT,
    [gl2.RG32F]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB32F]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA32F]: SAMPLER_TYPES.FLOAT,
    [gl2.R11F_G11F_B10F]: SAMPLER_TYPES.FLOAT,
    [gl2.RGB9_E5]: SAMPLER_TYPES.FLOAT,
    [gl2.R8I]: SAMPLER_TYPES.INT,
    [gl2.R8UI]: SAMPLER_TYPES.UINT,
    [gl2.R16I]: SAMPLER_TYPES.INT,
    [gl2.R16UI]: SAMPLER_TYPES.UINT,
    [gl2.R32I]: SAMPLER_TYPES.INT,
    [gl2.R32UI]: SAMPLER_TYPES.UINT,
    [gl2.RG8I]: SAMPLER_TYPES.INT,
    [gl2.RG8UI]: SAMPLER_TYPES.UINT,
    [gl2.RG16I]: SAMPLER_TYPES.INT,
    [gl2.RG16UI]: SAMPLER_TYPES.UINT,
    [gl2.RG32I]: SAMPLER_TYPES.INT,
    [gl2.RG32UI]: SAMPLER_TYPES.UINT,
    [gl2.RGB8I]: SAMPLER_TYPES.INT,
    [gl2.RGB8UI]: SAMPLER_TYPES.UINT,
    [gl2.RGB16I]: SAMPLER_TYPES.INT,
    [gl2.RGB16UI]: SAMPLER_TYPES.UINT,
    [gl2.RGB32I]: SAMPLER_TYPES.INT,
    [gl2.RGB32UI]: SAMPLER_TYPES.UINT,
    [gl2.RGBA8I]: SAMPLER_TYPES.INT,
    [gl2.RGBA8UI]: SAMPLER_TYPES.UINT,
    [gl2.RGBA16I]: SAMPLER_TYPES.INT,
    [gl2.RGBA16UI]: SAMPLER_TYPES.UINT,
    [gl2.RGBA32I]: SAMPLER_TYPES.INT,
    [gl2.RGBA32UI]: SAMPLER_TYPES.UINT,
    [gl2.DEPTH_COMPONENT16]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH_COMPONENT24]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH_COMPONENT32F]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH24_STENCIL8]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH32F_STENCIL8]: SAMPLER_TYPES.FLOAT
  } : table = {
    [gl2.RGB]: SAMPLER_TYPES.FLOAT,
    [gl2.RGBA]: SAMPLER_TYPES.FLOAT,
    [gl2.ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl2.LUMINANCE]: SAMPLER_TYPES.FLOAT,
    [gl2.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl2.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT
  }, table;
}
function mapTypeAndFormatToInternalFormat(gl2) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl2 instanceof globalThis.WebGL2RenderingContext ? table = {
    [TYPES.UNSIGNED_BYTE]: {
      [FORMATS.RGBA]: gl2.RGBA8,
      [FORMATS.RGB]: gl2.RGB8,
      [FORMATS.RG]: gl2.RG8,
      [FORMATS.RED]: gl2.R8,
      [FORMATS.RGBA_INTEGER]: gl2.RGBA8UI,
      [FORMATS.RGB_INTEGER]: gl2.RGB8UI,
      [FORMATS.RG_INTEGER]: gl2.RG8UI,
      [FORMATS.RED_INTEGER]: gl2.R8UI,
      [FORMATS.ALPHA]: gl2.ALPHA,
      [FORMATS.LUMINANCE]: gl2.LUMINANCE,
      [FORMATS.LUMINANCE_ALPHA]: gl2.LUMINANCE_ALPHA
    },
    [TYPES.BYTE]: {
      [FORMATS.RGBA]: gl2.RGBA8_SNORM,
      [FORMATS.RGB]: gl2.RGB8_SNORM,
      [FORMATS.RG]: gl2.RG8_SNORM,
      [FORMATS.RED]: gl2.R8_SNORM,
      [FORMATS.RGBA_INTEGER]: gl2.RGBA8I,
      [FORMATS.RGB_INTEGER]: gl2.RGB8I,
      [FORMATS.RG_INTEGER]: gl2.RG8I,
      [FORMATS.RED_INTEGER]: gl2.R8I
    },
    [TYPES.UNSIGNED_SHORT]: {
      [FORMATS.RGBA_INTEGER]: gl2.RGBA16UI,
      [FORMATS.RGB_INTEGER]: gl2.RGB16UI,
      [FORMATS.RG_INTEGER]: gl2.RG16UI,
      [FORMATS.RED_INTEGER]: gl2.R16UI,
      [FORMATS.DEPTH_COMPONENT]: gl2.DEPTH_COMPONENT16
    },
    [TYPES.SHORT]: {
      [FORMATS.RGBA_INTEGER]: gl2.RGBA16I,
      [FORMATS.RGB_INTEGER]: gl2.RGB16I,
      [FORMATS.RG_INTEGER]: gl2.RG16I,
      [FORMATS.RED_INTEGER]: gl2.R16I
    },
    [TYPES.UNSIGNED_INT]: {
      [FORMATS.RGBA_INTEGER]: gl2.RGBA32UI,
      [FORMATS.RGB_INTEGER]: gl2.RGB32UI,
      [FORMATS.RG_INTEGER]: gl2.RG32UI,
      [FORMATS.RED_INTEGER]: gl2.R32UI,
      [FORMATS.DEPTH_COMPONENT]: gl2.DEPTH_COMPONENT24
    },
    [TYPES.INT]: {
      [FORMATS.RGBA_INTEGER]: gl2.RGBA32I,
      [FORMATS.RGB_INTEGER]: gl2.RGB32I,
      [FORMATS.RG_INTEGER]: gl2.RG32I,
      [FORMATS.RED_INTEGER]: gl2.R32I
    },
    [TYPES.FLOAT]: {
      [FORMATS.RGBA]: gl2.RGBA32F,
      [FORMATS.RGB]: gl2.RGB32F,
      [FORMATS.RG]: gl2.RG32F,
      [FORMATS.RED]: gl2.R32F,
      [FORMATS.DEPTH_COMPONENT]: gl2.DEPTH_COMPONENT32F
    },
    [TYPES.HALF_FLOAT]: {
      [FORMATS.RGBA]: gl2.RGBA16F,
      [FORMATS.RGB]: gl2.RGB16F,
      [FORMATS.RG]: gl2.RG16F,
      [FORMATS.RED]: gl2.R16F
    },
    [TYPES.UNSIGNED_SHORT_5_6_5]: {
      [FORMATS.RGB]: gl2.RGB565
    },
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [FORMATS.RGBA]: gl2.RGBA4
    },
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [FORMATS.RGBA]: gl2.RGB5_A1
    },
    [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
      [FORMATS.RGBA]: gl2.RGB10_A2,
      [FORMATS.RGBA_INTEGER]: gl2.RGB10_A2UI
    },
    [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
      [FORMATS.RGB]: gl2.R11F_G11F_B10F
    },
    [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
      [FORMATS.RGB]: gl2.RGB9_E5
    },
    [TYPES.UNSIGNED_INT_24_8]: {
      [FORMATS.DEPTH_STENCIL]: gl2.DEPTH24_STENCIL8
    },
    [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
      [FORMATS.DEPTH_STENCIL]: gl2.DEPTH32F_STENCIL8
    }
  } : table = {
    [TYPES.UNSIGNED_BYTE]: {
      [FORMATS.RGBA]: gl2.RGBA,
      [FORMATS.RGB]: gl2.RGB,
      [FORMATS.ALPHA]: gl2.ALPHA,
      [FORMATS.LUMINANCE]: gl2.LUMINANCE,
      [FORMATS.LUMINANCE_ALPHA]: gl2.LUMINANCE_ALPHA
    },
    [TYPES.UNSIGNED_SHORT_5_6_5]: {
      [FORMATS.RGB]: gl2.RGB
    },
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [FORMATS.RGBA]: gl2.RGBA
    },
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [FORMATS.RGBA]: gl2.RGBA
    }
  }, table;
}
class TextureSystem {
  /**
   * @param renderer - The renderer this system works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = false;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl2 = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(gl2), this.samplerTypes = mapInternalFormatToSamplerType(gl2);
    const maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i2 = 0; i2 < maxTextures; i2++)
      this.boundTextures[i2] = null;
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl2.createTexture());
    gl2.bindTexture(gl2.TEXTURE_2D, emptyTexture2D.texture), gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl2.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl2.TEXTURE_CUBE_MAP] = new GLTexture(gl2.createTexture()), gl2.bindTexture(gl2.TEXTURE_CUBE_MAP, this.emptyTextures[gl2.TEXTURE_CUBE_MAP].texture);
    for (let i2 = 0; i2 < 6; i2++)
      gl2.texImage2D(gl2.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, null);
    gl2.texParameteri(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR), gl2.texParameteri(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
    for (let i2 = 0; i2 < this.boundTextures.length; i2++)
      this.bind(null, i2);
  }
  /**
   * Bind a texture to a specific location
   *
   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
   * @param texture - Texture to bind
   * @param [location=0] - Location to bind at
   */
  bind(texture, location = 0) {
    const { gl: gl2 } = this;
    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl2.activeTexture(gl2.TEXTURE0 + location)), gl2.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl2.activeTexture(gl2.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;
    } else
      this.currentLocation !== location && (this.currentLocation = location, gl2.activeTexture(gl2.TEXTURE0 + location)), gl2.bindTexture(gl2.TEXTURE_2D, this.emptyTextures[gl2.TEXTURE_2D].texture), this.boundTextures[location] = null;
  }
  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */
  reset() {
    this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
    for (let i2 = 0; i2 < this.boundTextures.length; i2++)
      this.boundTextures[i2] = this.unknownTexture;
  }
  /**
   * Unbind a texture.
   * @param texture - Texture to bind
   */
  unbind(texture) {
    const { gl: gl2, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i2 = 0; i2 < boundTextures.length; i2++)
        boundTextures[i2] === this.unknownTexture && this.bind(null, i2);
    }
    for (let i2 = 0; i2 < boundTextures.length; i2++)
      boundTextures[i2] === texture && (this.currentLocation !== i2 && (gl2.activeTexture(gl2.TEXTURE0 + i2), this.currentLocation = i2), gl2.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i2] = null);
  }
  /**
   * Ensures that current boundTextures all have FLOAT sampler type,
   * see {@link PIXI.SAMPLER_TYPES} for explanation.
   * @param maxTextures - number of locations to check
   */
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (hasIntegerTextures)
      for (let i2 = maxTextures - 1; i2 >= 0; --i2) {
        const tex = boundTextures[i2];
        tex && tex._glTextures[CONTEXT_UID].samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);
      }
  }
  /**
   * Initialize a texture
   * @private
   * @param texture - Texture to initialize
   */
  initTexture(texture) {
    const glTexture = new GLTexture(this.gl.createTexture());
    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;
  }
  /**
   * Update a texture
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to initialize
   */
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture)
      return;
    const renderer = this.renderer;
    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))
      glTexture.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = true);
    else {
      const width = texture.realWidth, height = texture.realHeight, gl2 = renderer.gl;
      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl2.texImage2D(
        texture.target,
        0,
        glTexture.internalFormat,
        width,
        height,
        0,
        texture.format,
        glTexture.type,
        null
      ));
    }
    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;
  }
  /**
   * Deletes the texture from WebGL
   * @private
   * @param texture - the texture to destroy
   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
   */
  destroyTexture(texture, skipRemove) {
    const { gl: gl2 } = this;
    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl2.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {
      const i2 = this.managedTextures.indexOf(texture);
      i2 !== -1 && removeItems(this.managedTextures, i2, 1);
    }
  }
  /**
   * Update texture style such as mipmap flag
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to update
   */
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    glTexture && ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = false : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);
  }
  /**
   * Set style for texture
   * @private
   * @param texture - Texture to update
   * @param glTexture
   */
  setStyle(texture, glTexture) {
    const gl2 = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL && gl2.generateMipmap(texture.target), gl2.texParameteri(texture.target, gl2.TEXTURE_WRAP_S, glTexture.wrapMode), gl2.texParameteri(texture.target, gl2.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {
      gl2.texParameteri(texture.target, gl2.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl2.LINEAR_MIPMAP_LINEAR : gl2.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl2.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl2.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else
      gl2.texParameteri(texture.target, gl2.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl2.LINEAR : gl2.NEAREST);
    gl2.texParameteri(texture.target, gl2.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl2.LINEAR : gl2.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "texture"
};
extensions$1.add(TextureSystem);
class TransformFeedbackSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * Bind TransformFeedback and buffers
   * @param transformFeedback - TransformFeedback to bind
   */
  bind(transformFeedback) {
    const { gl: gl2, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  /** Unbind TransformFeedback */
  unbind() {
    const { gl: gl2 } = this;
    gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, null);
  }
  /**
   * Begin TransformFeedback
   * @param drawMode - DrawMode for TransformFeedback
   * @param shader - A Shader used by TransformFeedback. Current bound shader will be used if not provided.
   */
  beginTransformFeedback(drawMode, shader) {
    const { gl: gl2, renderer } = this;
    shader && renderer.shader.bind(shader), gl2.beginTransformFeedback(drawMode);
  }
  /** End TransformFeedback */
  endTransformFeedback() {
    const { gl: gl2 } = this;
    gl2.endTransformFeedback();
  }
  /**
   * Create TransformFeedback and bind buffers
   * @param tf - TransformFeedback
   * @returns WebGLTransformFeedback
   */
  createGLTransformFeedback(tf2) {
    const { gl: gl2, renderer, CONTEXT_UID } = this, glTransformFeedback = gl2.createTransformFeedback();
    tf2._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i2 = 0; i2 < tf2.buffers.length; i2++) {
      const buffer = tf2.buffers[i2];
      buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, i2, buffer._glBuffers[CONTEXT_UID].buffer || null));
    }
    return gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, null), tf2.disposeRunner.add(this), glTransformFeedback;
  }
  /**
   * Disposes TransfromFeedback
   * @param {PIXI.TransformFeedback} tf - TransformFeedback
   * @param {boolean} [contextLost=false] - If context was lost, we suppress delete TransformFeedback
   */
  disposeTransformFeedback(tf2, contextLost) {
    const glTF = tf2._glTransformFeedbacks[this.CONTEXT_UID], gl2 = this.gl;
    tf2.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem)
      for (let i2 = 0; i2 < tf2.buffers.length; i2++) {
        const buffer = tf2.buffers[i2];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer, contextLost));
      }
    glTF && (contextLost || gl2.deleteTransformFeedback(glTF), delete tf2._glTransformFeedbacks[this.CONTEXT_UID]);
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions$1.add(TransformFeedbackSystem);
class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * initiates the view system
   * @param {PIXI.ViewOptions} options - the options for the view
   */
  init(options) {
    this.screen = new Rectangle(0, 0, options.width, options.height), this.element = options.view || settings.ADAPTER.createCanvas(), this.resolution = options.resolution || settings.RESOLUTION, this.autoDensity = !!options.autoDensity;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   */
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit("resize", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.
   */
  destroy(removeView) {
    removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.width}
   * @default 800
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  width: 800,
  /**
   * {@link PIXI.IRendererOptions.height}
   * @default 600
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  height: 600,
  /**
   * {@link PIXI.IRendererOptions.resolution}
   * @type {number}
   * @default PIXI.settings.RESOLUTION
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  resolution: void 0,
  /**
   * {@link PIXI.IRendererOptions.autoDensity}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  autoDensity: false
}, /** @ignore */
ViewSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions$1.add(ViewSystem);
settings.PREFER_ENV = ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
settings.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem.defaultOptions,
  ...ViewSystem.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings, {
  /**
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.wrapMode
   */
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  /**
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.scaleMode
   */
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  /**
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.mipmap
   */
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), BaseTexture.defaultOptions.mipmap = value;
    }
    // MIPMAP_MODES.POW2,
  },
  /**
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.anisotropicLevel
   */
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      deprecation(
        "7.1.0",
        "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"
      ), BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {number|null}
   * @see PIXI.Filter.defaultResolution
   */
  FILTER_RESOLUTION: {
    get() {
      return deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Filter.defaultResolution;
    },
    set(value) {
      Filter.defaultResolution = value;
    }
  },
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {PIXI.MSAA_QUALITY}
   * @see PIXI.Filter.defaultMultisample
   */
  FILTER_MULTISAMPLE: {
    get() {
      return deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Filter.defaultMultisample;
    },
    set(value) {
      Filter.defaultMultisample = value;
    }
  },
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @see PIXI.BatchRenderer.defaultMaxTextures
   * @type {number}
   */
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), BatchRenderer.defaultMaxTextures = value;
    }
  },
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.defaultBatchSize
   * @deprecated since 7.1.0
   * @type {number}
   */
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), BatchRenderer.defaultBatchSize = value;
    }
  },
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.canUploadSameBuffer
   * @deprecated since 7.1.0
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), BatchRenderer.canUploadSameBuffer = value;
    }
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMode
   */
  GC_MODE: {
    get() {
      return TextureGCSystem.defaultMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), TextureGCSystem.defaultMode = value;
    }
  },
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMaxIdle
   */
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), TextureGCSystem.defaultMaxIdle = value;
    }
  },
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultCheckCountMax
   */
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultVertexPrecision
   */
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Program.defaultVertexPrecision = value;
    }
  },
  /**
   * Default specify float precision in fragment shader.
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultFragmentPrecision
   */
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Program.defaultFragmentPrecision = value;
    }
  }
});
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => (UPDATE_PRIORITY2[UPDATE_PRIORITY2.INTERACTION = 50] = "INTERACTION", UPDATE_PRIORITY2[UPDATE_PRIORITY2.HIGH = 25] = "HIGH", UPDATE_PRIORITY2[UPDATE_PRIORITY2.NORMAL = 0] = "NORMAL", UPDATE_PRIORITY2[UPDATE_PRIORITY2.LOW = -25] = "LOW", UPDATE_PRIORITY2[UPDATE_PRIORITY2.UTILITY = -50] = "UTILITY", UPDATE_PRIORITY2))(UPDATE_PRIORITY || {});
class TickerListener {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context2 = null, priority = 0, once2 = false) {
    this.next = null, this.previous = null, this._destroyed = false, this.fn = fn, this.context = context2, this.priority = priority, this.once = once2;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context2 = null) {
    return this.fn === fn && this.context === context2;
  }
  /**
   * Emit by calling the current function.
   * @private
   * @param deltaTime - time since the last emit.
   * @returns Next ticker
   */
  emit(deltaTime) {
    this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));
    const redirect = this.next;
    return this.once && this.destroy(true), this._destroyed && (this.next = null), redirect;
  }
  /**
   * Connect to the list.
   * @private
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @private
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = false) {
    this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const redirect = this.next;
    return this.next = hard ? null : redirect, this.previous = null, redirect;
  }
}
const _Ticker = class _Ticker2 {
  constructor() {
    this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {
      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority, true));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener3) {
    let current = this._head.next, previous = this._head;
    if (!current)
      listener3.connect(previous);
    else {
      for (; current; ) {
        if (listener3.priority > current.priority) {
          listener3.connect(previous);
          break;
        }
        previous = current, current = current.next;
      }
      listener3.previous || listener3.connect(previous);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(fn, context2) {
    let listener3 = this._head.next;
    for (; listener3; )
      listener3.match(fn, context2) ? listener3 = listener3.destroy() : listener3 = listener3.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let count = 0, current = this._head;
    for (; current = current.next; )
      count++;
    return count;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = true, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = false, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener3 = this._head.next;
      for (; listener3; )
        listener3 = listener3.destroy(true);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link PIXI.Ticker#elapsedMS},
   * the current {@link PIXI.Ticker#deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link PIXI.Ticker#lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS)
          return;
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
      const head = this._head;
      let listener3 = head.next;
      for (; listener3; )
        listener3 = listener3.emit(this.deltaTime);
      head.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link PIXI.Ticker#speed}, which is specific
   * to scaling {@link PIXI.Ticker#deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This value is used to cap {@link PIXI.Ticker#deltaTime},
   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps2) {
    const minFPS = Math.min(this.maxFPS, fps2), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This will effect the measured value of {@link PIXI.Ticker#FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(fps2) {
    if (fps2 === 0)
      this._minElapsedMS = 0;
    else {
      const maxFPS = Math.max(this.minFPS, fps2);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
   * {@link PIXI.VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the PIXI.Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {PIXI.Ticker}
   * @static
   */
  static get shared() {
    if (!_Ticker2._shared) {
      const shared = _Ticker2._shared = new _Ticker2();
      shared.autoStart = true, shared._protected = true;
    }
    return _Ticker2._shared;
  }
  /**
   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * @member {PIXI.Ticker}
   * @static
   */
  static get system() {
    if (!_Ticker2._system) {
      const system = _Ticker2._system = new _Ticker2();
      system.autoStart = true, system._protected = true;
    }
    return _Ticker2._system;
  }
};
_Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;
Object.defineProperties(settings, {
  /**
   * Target frames per millisecond.
   * @static
   * @name TARGET_FPMS
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.Ticker.targetFPMS
   */
  TARGET_FPMS: {
    get() {
      return Ticker.targetFPMS;
    },
    set(value) {
      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Ticker.targetFPMS = value;
    }
  }
});
class TickerPlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options), Object.defineProperty(
      this,
      "ticker",
      {
        set(ticker) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        },
        get() {
          return this._ticker;
        }
      }
    ), this.stop = () => {
      this._ticker.stop();
    }, this.start = () => {
      this._ticker.start();
    }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker.shared : new Ticker(), options.autoStart && this.start();
  }
  /**
   * Clean up the ticker, scoped to application.
   * @static
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null, oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = ExtensionType.Application;
extensions$1.add(TickerPlugin);
const renderers = [];
extensions$1.handleByList(ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers)
    if (RendererType.test(options))
      return new RendererType(options);
  throw new Error("Unable to auto-detect a suitable renderer.");
}
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
var $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const defaultVertex = $defaultVertex, defaultFilterVertex = $defaultFilterVertex;
class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl2) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl2.getParameter(gl2.FRAMEBUFFER_BINDING);
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null), samples = gl2.getParameter(gl2.SAMPLES), gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl2.getParameter(gl2.DRAW_FRAMEBUFFER_BINDING);
      gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null), samples = gl2.getParameter(gl2.SAMPLES), gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, framebuffer);
    }
    samples >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : samples >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : samples >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions$1.add(MultisampleSystem);
class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
}
class BufferSystem {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(buffer) {
    const { gl: gl2, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl2.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type2) {
    const { gl: gl2 } = this;
    gl2.bindBuffer(type2, null);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(buffer, index) {
    const { gl: gl2, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer, gl2.bindBufferBase(gl2.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   */
  bindBufferRange(buffer, index, offset2) {
    const { gl: gl2, CONTEXT_UID } = this;
    offset2 = offset2 || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl2.bindBufferRange(gl2.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset2 * 256, 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {PIXI.Buffer} buffer - the buffer to update
   */
  update(buffer) {
    const { gl: gl2, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID !== glBuffer.updateID)
      if (glBuffer.updateID = buffer._updateID, gl2.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength)
        gl2.bufferSubData(buffer.type, 0, buffer.data);
      else {
        const drawType = buffer.static ? gl2.STATIC_DRAW : gl2.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength, gl2.bufferData(buffer.type, buffer.data, drawType);
      }
  }
  /**
   * Disposes buffer
   * @param {PIXI.Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id])
      return;
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl2 = this.gl;
    buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl2.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);
  }
  /**
   * dispose all WebGL resources of all managed buffers
   * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i2 = 0; i2 < all.length; i2++)
      this.dispose(this.managedBuffers[all[i2]], contextLost);
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl: gl2 } = this;
    return buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl2.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "buffer"
};
extensions$1.add(BufferSystem);
class ObjectRendererSystem {
  // renderers scene graph!
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param options - the options to be passed to the renderer
   */
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture, clear2, transform2, skipUpdateTransform;
    if (options && (renderTexture = options.renderTexture, clear2 = options.clear, transform2 = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit("prerender"), renderer.projection.transform = transform2, !renderer.context.isLost) {
      if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {
        const cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);
      }
      renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear2 ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit("postrender");
    }
  }
  destroy() {
    this.renderer = null, this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions$1.add(ObjectRendererSystem);
const _Renderer = class _Renderer2 extends SystemManager {
  /**
   * @param {PIXI.IRendererOptions} [options] - See {@link PIXI.settings.RENDER_OPTIONS} for defaults.
   */
  constructor(options) {
    super(), this.type = RENDERER_TYPE.WEBGL, options = Object.assign({}, settings.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer2.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        // low level WebGL systems
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        // high level pixi specific rendering
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig), "useContextAlpha" in options && (deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied", options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);
  }
  /**
   * Create renderer if WebGL is available. Overrideable
   * by the **@pixi/canvas-renderer** package to allow fallback.
   * throws error if WebGL is not available.
   * @param options
   * @private
   */
  static test(options) {
    return options?.forceCanvas ? false : isWebGLSupported();
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param {object} [options] - Object to use for render options.
   * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.
   * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.
   * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.
   * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?
   */
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   */
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  /**
   * Resets the WebGL state so you can render things however you fancy!
   * @returns Returns itself.
   */
  reset() {
    return this.runners.reset.emit(), this;
  }
  /** Clear the frame buffer. */
  clear() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }
  /**
   * Removes everything from the renderer (event listeners, spritebatch, etc...)
   * @param [removeView=false] - Removes the Canvas element from the DOM.
   *  See: https://github.com/pixijs/pixijs/issues/2233
   */
  destroy(removeView = false) {
    this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    }), super.destroy();
  }
  /** Collection of plugins */
  get plugins() {
    return this._plugin.plugins;
  }
  /** The number of msaa samples of the canvas. */
  get multisample() {
    return this._multisample.multisample;
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this._view.element.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this._view.element.height;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value, this.runners.resolutionChange.emit(value);
  }
  /** Whether CSS dimensions of canvas view should be resized to screen dimensions automatically. */
  get autoDensity() {
    return this._view.autoDensity;
  }
  /** The canvas element that everything is drawn to.*/
  get view() {
    return this._view.element;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   * @member {PIXI.Rectangle}
   */
  get screen() {
    return this._view.screen;
  }
  /** the last object rendered by the renderer. Useful for other plugins like interaction managers */
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  /** Flag if we are rendering to the screen vs renderTexture */
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  /** When logging Pixi to the console, this is the name we will show */
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  /**
   * This sets weather the screen is totally cleared between each frame withthe background color and alpha
   * @deprecated since 7.0.0
   */
  get clearBeforeRender() {
    return deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
  }
  /**
   * Pass-thru setting for the canvas' context `alpha` property. This is typically
   * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.
   * @deprecated since 7.0.0
   * @member {boolean}
   */
  get useContextAlpha() {
    return deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
  }
  /**
   * readonly drawing buffer preservation
   * we can only know this if Pixi created the context
   * @deprecated since 7.0.0
   */
  get preserveDrawingBuffer() {
    return deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
  }
  /**
   * The background color to fill if not transparent
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundColor() {
    return deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
  }
  set backgroundColor(value) {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = value;
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundAlpha() {
    return deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
  }
  /**
   * @deprecated since 7.0.0
   */
  set backgroundAlpha(value) {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = value;
  }
  /**
   * @deprecated since 7.0.0
   */
  get powerPreference() {
    return deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
  }
  /**
   * Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns A texture of the graphics object.
   */
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
_Renderer.extension = {
  type: ExtensionType.Renderer,
  priority: 1
}, /**
* Collection of installed plugins. These are included by default in PIXI, but can be excluded
* by creating a custom build. Consult the README for more information about creating custom
* builds and excluding plugins.
* @private
*/
_Renderer.__plugins = {}, /**
* The collection of installed systems.
* @private
*/
_Renderer.__systems = {};
let Renderer = _Renderer;
extensions$1.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
extensions$1.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
extensions$1.add(Renderer);
class AbstractMultiResource extends Resource {
  /**
   * @param length
   * @param options - Options to for Resource constructor
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(length2, options) {
    const { width, height } = options || {};
    super(width, height), this.items = [], this.itemDirtyIds = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const partTexture = new BaseTexture();
      this.items.push(partTexture), this.itemDirtyIds.push(-2);
    }
    this.length = length2, this._load = null, this.baseTexture = null;
  }
  /**
   * Used from ArrayResource and CubeResource constructors.
   * @param resources - Can be resources, image elements, canvas, etc. ,
   *  length should be same as constructor length
   * @param options - Detect options for resources
   */
  initFromArray(resources, options) {
    for (let i2 = 0; i2 < this.length; i2++)
      resources[i2] && (resources[i2].castToBaseTexture ? this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2) : resources[i2] instanceof Resource ? this.addResourceAt(resources[i2], i2) : this.addResourceAt(autoDetectResource(resources[i2], options), i2));
  }
  /** Destroy this BaseImageResource. */
  dispose() {
    for (let i2 = 0, len = this.length; i2 < len; i2++)
      this.items[i2].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }
  /**
   * Set a resource by ID
   * @param resource
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addResourceAt(resource, index) {
    if (!this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;
  }
  /**
   * Set the parent base texture.
   * @param baseTexture
   */
  bind(baseTexture) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    super.bind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++)
      this.items[i2].parentTextureArray = baseTexture, this.items[i2].on("update", baseTexture.update, baseTexture);
  }
  /**
   * Unset the parent base texture.
   * @param baseTexture
   */
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++)
      this.items[i2].parentTextureArray = null, this.items[i2].off("update", baseTexture.update, baseTexture);
  }
  /**
   * Load all the resources simultaneously
   * @returns - When load is resolved
   */
  load() {
    if (this._load)
      return this._load;
    const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());
    return this._load = Promise.all(promises).then(
      () => {
        const { realWidth, realHeight } = this.items[0];
        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);
      }
    ), this._load;
  }
}
class ArrayResource extends AbstractMultiResource {
  /**
   * @param source - Number of items in array or the collection
   *        of image URLs to use. Can also be resources, image elements, canvas, etc.
   * @param options - Options to apply to {@link PIXI.autoDetectResource}
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(source, options) {
    const { width, height } = options || {};
    let urls, length2;
    Array.isArray(source) ? (urls = source, length2 = source.length) : length2 = source, super(length2, { width, height }), urls && this.initFromArray(urls, options);
  }
  /**
   * Set a baseTexture by ID,
   * ArrayResource just takes resource from it, nothing more
   * @param baseTexture
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource)
      this.addResourceAt(baseTexture.resource, index);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }
  /**
   * Add binding
   * @param baseTexture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  /**
   * Upload the resources to the GPU.
   * @param renderer
   * @param texture
   * @param glTexture
   * @returns - whether texture was uploaded
   */
  upload(renderer, texture, glTexture) {
    const { length: length2, itemDirtyIds, items } = this, { gl: gl2 } = renderer;
    glTexture.dirtyId < 0 && gl2.texImage3D(
      gl2.TEXTURE_2D_ARRAY,
      0,
      glTexture.internalFormat,
      this._width,
      this._height,
      length2,
      0,
      texture.format,
      glTexture.type,
      null
    );
    for (let i2 = 0; i2 < length2; i2++) {
      const item = items[i2];
      itemDirtyIds[i2] < item.dirtyId && (itemDirtyIds[i2] = item.dirtyId, item.valid && gl2.texSubImage3D(
        gl2.TEXTURE_2D_ARRAY,
        0,
        0,
        // xoffset
        0,
        // yoffset
        i2,
        // zoffset
        item.resource.width,
        item.resource.height,
        1,
        texture.format,
        glTexture.type,
        item.resource.source
      ));
    }
    return true;
  }
}
class CanvasResource extends BaseImageResource {
  /**
   * @param source - Canvas element to use
   */
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(source) {
    super(source);
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas
   */
  static test(source) {
    const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
    return OffscreenCanvas2 && source instanceof OffscreenCanvas2 ? true : globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}
const _CubeResource = class _CubeResource2 extends AbstractMultiResource {
  /**
   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources
   *        to use as the sides of the cube.
   * @param options - ImageResource options
   * @param {number} [options.width] - Width of resource
   * @param {number} [options.height] - Height of resource
   * @param {number} [options.autoLoad=true] - Whether to auto-load resources
   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,
   *   whether to copy them or use
   */
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource2.SIDES)
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    super(6, { width, height });
    for (let i2 = 0; i2 < _CubeResource2.SIDES; i2++)
      this.items[i2].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
    this.linkBaseTexture = linkBaseTexture !== false, source && this.initFromArray(source, options), autoLoad !== false && this.load();
  }
  /**
   * Add binding.
   * @param baseTexture - parent base texture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)
      if (baseTexture.resource)
        this.addResourceAt(baseTexture.resource, index);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;
    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;
  }
  /**
   * Upload the resource
   * @param renderer
   * @param _baseTexture
   * @param glTexture
   * @returns {boolean} true is success
   */
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i2 = 0; i2 < _CubeResource2.SIDES; i2++) {
      const side = this.items[i2];
      (dirty[i2] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i2] = side.dirtyId) : dirty[i2] < -1 && (renderer.gl.texImage2D(
        side.target,
        0,
        glTexture.internalFormat,
        _baseTexture.realWidth,
        _baseTexture.realHeight,
        0,
        _baseTexture.format,
        glTexture.type,
        null
      ), dirty[i2] = -1));
    }
    return true;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is an array of 6 elements
   */
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource2.SIDES;
  }
};
_CubeResource.SIDES = 6;
let CubeResource = _CubeResource;
class ImageBitmapResource extends BaseImageResource {
  /**
   * @param source - ImageBitmap or URL to use.
   * @param options - Options to use.
   */
  constructor(source, options) {
    options = options || {};
    let baseSource, url2, ownsImageBitmap;
    typeof source == "string" ? (baseSource = ImageBitmapResource.EMPTY, url2 = source, ownsImageBitmap = true) : (baseSource = source, url2 = null, ownsImageBitmap = false), super(baseSource), this.url = url2, this.crossOrigin = options.crossOrigin ?? true, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== false && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise(async (resolve2, reject2) => {
      if (this.url === null) {
        resolve2(this);
        return;
      }
      try {
        const response = await settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed) {
          imageBitmap.close();
          return;
        }
        this.source = imageBitmap, this.update(), resolve2(this);
      } catch (e2) {
        if (this.destroyed)
          return;
        reject2(e2), this.onError.emit(e2);
      }
    }), this._load);
  }
  /**
   * Upload the image bitmap resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), false);
  }
  /** Destroys this resource. */
  dispose() {
    this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap
   */
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof source == "string" || source instanceof ImageBitmap);
  }
  /**
   * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.
   * Only for internal usage.
   * @returns The cached placeholder canvas.
   */
  static get EMPTY() {
    return ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0), ImageBitmapResource._EMPTY;
  }
}
const _SVGResource = class _SVGResource2 extends BaseImageResource {
  /**
   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.
   * @param {object} [options] - Options to use
   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...
   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.
   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.
   * @param {boolean} [options.autoLoad=true] - Start loading right away.
   */
  constructor(sourceBase64, options) {
    options = options || {}, super(settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== false && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise((resolve2) => {
      if (this._resolve = () => {
        this.update(), resolve2(this);
      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    }), this._load);
  }
  /** Loads an SVG image from `imageUrl` or `data URL`. */
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {
      this._resolve && (tempImage.onerror = null, this.onError.emit(event));
    }, tempImage.onload = () => {
      if (!this._resolve)
        return;
      const svgWidth = tempImage.width, svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight)
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      let width = svgWidth * this.scale, height = svgHeight * this.scale;
      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);
      const canvas = this.source;
      canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${uid()}`, canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;
    };
  }
  /**
   * Get size from an svg string using a regular expression.
   * @param svgString - a serialized svg element
   * @returns - image extension
   */
  static getSize(svgString) {
    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size2 = {};
    return sizeMatch && (size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size2;
  }
  /** Destroys this texture. */
  dispose() {
    super.dispose(), this._resolve = null, this._crossorigin = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} - If the source is a SVG source or data file
   */
  static test(source, extension) {
    return extension === "svg" || typeof source == "string" && source.startsWith("data:image/svg+xml") || typeof source == "string" && _SVGResource2.SVG_XML.test(source);
  }
  // eslint-disable-line max-len
};
_SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, /**
* Regular expression for SVG size.
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
* @readonly
*/
_SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
let SVGResource = _SVGResource;
class VideoFrameResource extends BaseImageResource {
  /**
   * @param source - Image element to use
   */
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(source) {
    super(source);
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is an VideoFrame
   */
  static test(source) {
    return !!globalThis.VideoFrame && source instanceof globalThis.VideoFrame;
  }
}
const _VideoResource = class _VideoResource2 extends BaseImageResource {
  /**
   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.
   * @param {object} [options] - Options to use
   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately
   * @param {boolean} [options.autoPlay=true] - Start playing video immediately
   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.
   * If 0, `requestVideoFrameCallback` is used to update the texture.
   * If `requestVideoFrameCallback` is not available, the texture is updated every render.
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {boolean} [options.loop=false] - Loops the video
   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay
   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices
   */
  constructor(source, options) {
    if (options = options || {}, !(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      options.autoLoad !== false && videoElement.setAttribute("preload", "auto"), options.playsinline !== false && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", "")), options.muted === true && (videoElement.setAttribute("muted", ""), videoElement.muted = true), options.loop === true && videoElement.setAttribute("loop", ""), options.autoPlay !== false && videoElement.setAttribute("autoplay", ""), typeof source == "string" && (source = [source]);
      const firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i2 = 0; i2 < source.length; ++i2) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i2];
        if (src = src || source[i2], src.startsWith("data:"))
          mime = src.slice(5, src.indexOf(";"));
        else if (!src.startsWith("blob:")) {
          const baseSrc = src.split("?").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source), this.noSubImage = true, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== false, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== false && this.load();
  }
  /**
   * Trigger updating of the texture.
   * @param _deltaTime - time delta since last tick
   */
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(
        /* deltaTime*/
      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }
  _videoFrameRequestCallback() {
    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<void>} Handle the validate event
   */
  load() {
    if (this._load)
      return this._load;
    const source = this.source;
    return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = true), source.addEventListener("play", this._onPlayStart), source.addEventListener("pause", this._onPlayStop), source.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener("canplay", this._onCanPlay), source.addEventListener("canplaythrough", this._onCanPlay), source.addEventListener("error", this._onError, true)), this._load = new Promise((resolve2, reject2) => {
      this.valid ? resolve2(this) : (this._resolve = resolve2, this._reject = reject2, source.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event
   */
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);
  }
  /**
   * Returns true if the underlying source is playing.
   * @returns - True if playing.
   */
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended;
  }
  /**
   * Returns true if the underlying source is ready for playing.
   * @returns - True if ready.
   */
  _isSourceReady() {
    return this.source.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.valid || this._onCanPlay(), this._configureAutoUpdate();
  }
  /** Fired when a pause event is triggered, stops the update loop. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Fired when the video is completed seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);
  }
  /** Fired when the video is loaded and ready to play. */
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();
  }
  /** Destroys this texture. */
  dispose() {
    this._configureAutoUpdate();
    const source = this.source;
    source && (source.removeEventListener("play", this._onPlayStart), source.removeEventListener("pause", this._onPlayStop), source.removeEventListener("seeked", this._onSeeked), source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay), source.removeEventListener("error", this._onError, true), source.pause(), source.src = "", source.load()), super.dispose();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video. If 0, `requestVideoFrameCallback` is used to
   * update the texture. If `requestVideoFrameCallback` is not available, the texture is updated every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
  }
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker.shared.add(this.update, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} `true` if video source
   */
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);
  }
};
_VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], /**
* Map of video MIME types that can't be directly derived from file extensions.
* @readonly
*/
_VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let VideoResource = _VideoResource;
INSTALLED.push(
  ImageBitmapResource,
  ImageResource,
  CanvasResource,
  VideoResource,
  VideoFrameResource,
  SVGResource,
  BufferResource,
  CubeResource,
  ArrayResource
);
class Bounds {
  constructor() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** Clears the bounds and resets. */
  clear() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
  }
  /**
   * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
   * It is not guaranteed that it will return tempRect
   * @param rect - Temporary object will be used if AABB is not empty
   * @returns - A rectangle of the bounds
   */
  getRectangle(rect) {
    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (rect = rect || new Rectangle(0, 0, 1, 1), rect.x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect);
  }
  /**
   * This function should be inlined when its possible.
   * @param point - The point to add.
   */
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x), this.maxX = Math.max(this.maxX, point.x), this.minY = Math.min(this.minY, point.y), this.maxY = Math.max(this.maxY, point.y);
  }
  /**
   * Adds a point, after transformed. This should be inlined when its possible.
   * @param matrix
   * @param point
   */
  addPointMatrix(matrix, point) {
    const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix, x2 = a2 * point.x + c2 * point.y + tx, y2 = b2 * point.x + d2 * point.y + ty;
    this.minX = Math.min(this.minX, x2), this.maxX = Math.max(this.maxX, x2), this.minY = Math.min(this.minY, y2), this.maxY = Math.max(this.maxY, y2);
  }
  /**
   * Adds a quad, not transformed
   * @param vertices - The verts to add.
   */
  addQuad(vertices) {
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x2 = vertices[0], y2 = vertices[1];
    minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[2], y2 = vertices[3], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[4], y2 = vertices[5], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[6], y2 = vertices[7], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds sprite frame, transformed.
   * @param transform - transform to apply
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  addFrame(transform2, x0, y0, x1, y1) {
    this.addFrameMatrix(transform2.worldTransform, x0, y0, x1, y1);
  }
  /**
   * Adds sprite frame, multiplied by matrix
   * @param matrix - matrix to apply
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x2 = a2 * x0 + c2 * y0 + tx, y2 = b2 * x0 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x1 + c2 * y0 + tx, y2 = b2 * x1 + d2 * y0 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x0 + c2 * y1 + tx, y2 = b2 * x0 + d2 * y1 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x1 + c2 * y1 + tx, y2 = b2 * x1 + d2 * y1 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   */
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const x2 = vertexData[i2], y2 = vertexData[i2 + 1];
      minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Add an array of mesh vertices
   * @param transform - mesh transform
   * @param vertices - mesh coordinates in array
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   */
  addVertices(transform2, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform2.worldTransform, vertices, beginOffset, endOffset);
  }
  /**
   * Add an array of mesh vertices.
   * @param matrix - mesh matrix
   * @param vertices - mesh coordinates in array
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param padX - x padding
   * @param padY - y padding
   */
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const rawX = vertices[i2], rawY = vertices[i2 + 1], x2 = a2 * rawX + c2 * rawY + tx, y2 = d2 * rawY + b2 * rawX + ty;
      minX = Math.min(minX, x2 - padX), maxX = Math.max(maxX, x2 + padX), minY = Math.min(minY, y2 - padY), maxY = Math.max(maxY, y2 + padY);
    }
    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds other {@link PIXI.Bounds}.
   * @param bounds - The Bounds to be added
   */
  addBounds(bounds) {
    const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX, this.minY = bounds.minY < minY ? bounds.minY : minY, this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX, this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param bounds - The Bounds to be added.
   * @param mask - TODO
   */
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX, _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY, _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX, _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  /**
   * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.
   * @param bounds - other bounds
   * @param matrix - multiplicator
   */
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  /**
   * Adds other Bounds, masked with Rectangle.
   * @param bounds - TODO
   * @param area - TODO
   */
  addBoundsArea(bounds, area2) {
    const _minX = bounds.minX > area2.x ? bounds.minX : area2.x, _minY = bounds.minY > area2.y ? bounds.minY : area2.y, _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width, _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.isEmpty() || (this.minX -= paddingX, this.maxX += paddingX, this.minY -= paddingY, this.maxY += paddingY);
  }
  /**
   * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param padX - padding X
   * @param padY - padding Y
   */
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX, y0 -= padY, x1 += padX, y1 += padY, this.minX = this.minX < x0 ? this.minX : x0, this.maxX = this.maxX > x1 ? this.maxX : x1, this.minY = this.minY < y0 ? this.minY : y0, this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}
class DisplayObject extends EventEmitter {
  constructor() {
    super(), this.tempDisplayObjectParent = null, this.transform = new Transform(), this.alpha = 1, this.visible = true, this.renderable = true, this.cullable = false, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Bounds(), this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = false, this.isSprite = false, this.isMask = false;
  }
  /**
   * Mixes all enumerable properties and methods from a source object to DisplayObject.
   * @param source - The source of properties and methods to mix in.
   */
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i2 = 0; i2 < keys.length; ++i2) {
      const propertyName = keys[i2];
      Object.defineProperty(
        DisplayObject.prototype,
        propertyName,
        Object.getOwnPropertyDescriptor(source, propertyName)
      );
    }
  }
  /**
   * Fired when this DisplayObject is added to a Container.
   * @instance
   * @event added
   * @param {PIXI.Container} container - The container added to.
   */
  /**
   * Fired when this DisplayObject is removed from a Container.
   * @instance
   * @event removed
   * @param {PIXI.Container} container - The container removed from.
   */
  /**
   * Fired when this DisplayObject is destroyed. This event is emitted once
   * destroy is finished.
   * @instance
   * @event destroyed
   */
  /** Readonly flag for destroyed display objects. */
  get destroyed() {
    return this._destroyed;
  }
  /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */
  _recursivePostUpdateTransform() {
    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }
  /** Updates the object transform for rendering. TODO - Optimization pass! */
  updateTransform() {
    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.
   *
   * This method is expensive on containers with a large subtree (like the stage). This is because the bounds
   * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to
   * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update
   * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using
   * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,
   * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as
   * its height increases.
   *
   * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.
   * The world bounds of all display objects in a container's **subtree** will also be recalculated.
   *
   * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds
   * calculation if needed.
   *
   * ```js
   * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);
   * ```
   *
   * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This
   * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more
   * details.
   *
   * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms
   * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain
   * cases.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   */
  getBounds(skipUpdate, rect) {
    return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), rect || (this._boundsRect || (this._boundsRect = new Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect);
  }
  /**
   * Retrieves the local bounds of the displayObject as a rectangle object.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @returns - The rectangular bounding area.
   */
  getLocalBounds(rect) {
    rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
    const transformRef = this.transform, parentRef = this.parent;
    this.parent = null, this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1, this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds, worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    return this.parent = parentRef, this.transform = transformRef, this._bounds = worldBounds, this._bounds.updateID += this._boundsID - worldBoundsID, bounds;
  }
  /**
   * Calculates the global position of the display object.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   */
  toGlobal(position2, point, skipUpdate = false) {
    return skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position2, point);
  }
  /**
   * Calculates the local position of the display object relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The DisplayObject to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   */
  toLocal(position2, from2, point, skipUpdate) {
    return from2 && (position2 = from2.toGlobal(position2, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position2, point);
  }
  /**
   * Set the parent Container of this DisplayObject.
   * @param container - The Container to add this DisplayObject to.
   * @returns - The Container that this DisplayObject was added to.
   */
  setParent(container) {
    if (!container || !container.addChild)
      throw new Error("setParent: Argument must be a Container");
    return container.addChild(this), container;
  }
  /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  /**
   * Convenience function to set the position, scale, skew and pivot at once.
   * @param x - The X position
   * @param y - The Y position
   * @param scaleX - The X scale value
   * @param scaleY - The Y scale value
   * @param rotation - The rotation
   * @param skewX - The X skew value
   * @param skewY - The Y skew value
   * @param pivotX - The X pivot value
   * @param pivotY - The Y pivot value
   * @returns - The DisplayObject instance
   */
  setTransform(x2 = 0, y2 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    return this.position.x = x2, this.position.y = y2, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this;
  }
  /**
   * Base destroy method for generic display objects. This will automatically
   * remove the display object from its parent Container as well as remove
   * all current event listeners and internal references. Do not use a DisplayObject
   * after calling `destroy()`.
   * @param _options
   */
  destroy(_options) {
    this.removeFromParent(), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
  }
  /**
   * @protected
   * @member {PIXI.Container}
   */
  get _tempDisplayObjectParent() {
    return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
  }
  /**
   * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.
   *
   * ```js
   * const cacheParent = elem.enableTempParent();
   * elem.updateTransform();
   * elem.disableTempParent(cacheParent);
   * ```
   * @returns - Current parent
   */
  enableTempParent() {
    const myParent = this.parent;
    return this.parent = this._tempDisplayObjectParent, myParent;
  }
  /**
   * Pair method for `enableTempParent`
   * @param cacheParent - Actual parent of element
   */
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  /**
   * The position of the displayObject on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  /**
   * The position of the displayObject on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    return this.transform.worldTransform;
  }
  /**
   * Current transform of the object based on local factors: position, scale, other stuff.
   * @readonly
   */
  get localTransform() {
    return this.transform.localTransform;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.transform.rotation * RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * DEG_TO_RAD;
  }
  /**
   * The zIndex of the displayObject.
   *
   * If a container has the sortableChildren property set to true, children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see PIXI.Container#sortableChildren
   */
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex !== value && (this._zIndex = value, this.parent && (this.parent.sortDirty = true));
  }
  /**
   * Indicates if the object is globally visible.
   * @readonly
   */
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible)
        return false;
      item = item.parent;
    } while (item);
    return true;
  }
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @todo At the moment, CanvasRenderer doesn't support Sprite as mask.
   */
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask !== value) {
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        maskObject && (maskObject._maskRefCount--, maskObject._maskRefCount === 0 && (maskObject.renderable = true, maskObject.isMask = false));
      }
      if (this._mask = value, this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        maskObject && (maskObject._maskRefCount === 0 && (maskObject.renderable = false, maskObject.isMask = true), maskObject._maskRefCount++);
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments), this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
const tempMatrix$2 = new Matrix();
function sortChildren(a2, b2) {
  return a2.zIndex === b2.zIndex ? a2._lastSortedIndex - b2._lastSortedIndex : a2.zIndex - b2.zIndex;
}
const _Container = class _Container2 extends DisplayObject {
  constructor() {
    super(), this.children = [], this.sortableChildren = _Container2.defaultSortableChildren, this.sortDirty = false;
  }
  /**
   * Overridable method that can be used by Container subclasses whenever the children array is modified.
   * @param _length
   */
  onChildrenChange(_length) {
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container
   * @returns {PIXI.DisplayObject} - The first child that was added.
   */
  addChild(...children) {
    if (children.length > 1)
      for (let i2 = 0; i2 < children.length; i2++)
        this.addChild(children[i2]);
    else {
      const child = children[0];
      child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = true, child.transform._parentID = -1, this.children.push(child), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", child, this, this.children.length - 1), child.emit("added", this);
    }
    return children[0];
  }
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {PIXI.DisplayObject} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {PIXI.DisplayObject} The child that was added.
   */
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length)
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    return child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = true, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit("added", this), this.emit("childAdded", child, this, index), child;
  }
  /**
   * Swaps the position of 2 Display Objects within this container.
   * @param child - First display object to swap
   * @param child2 - Second display object to swap
   */
  swapChildren(child, child2) {
    if (child === child2)
      return;
    const index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
    this.children[index1] = child2, this.children[index2] = child, this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  /**
   * Returns the index position of a child DisplayObject instance
   * @param child - The DisplayObject instance to identify
   * @returns - The index position of the child display object to identify
   */
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1)
      throw new Error("The supplied DisplayObject must be a child of the caller");
    return index;
  }
  /**
   * Changes the position of an existing child in the display object container
   * @param child - The child DisplayObject instance for which you want to change the index number
   * @param index - The resulting index number for the child display object
   */
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length)
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    const currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1), this.children.splice(index, 0, child), this.onChildrenChange(index);
  }
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   */
  getChildAt(index) {
    if (index < 0 || index >= this.children.length)
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    return this.children[index];
  }
  /**
   * Removes one or more children from the container.
   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove
   * @returns {PIXI.DisplayObject} The first child that was removed.
   */
  removeChild(...children) {
    if (children.length > 1)
      for (let i2 = 0; i2 < children.length; i2++)
        this.removeChild(children[i2]);
    else {
      const child = children[0], index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   */
  removeChildAt(index) {
    const child = this.getChildAt(index);
    return child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index), child;
  }
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   */
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex, end = endIndex, range2 = end - begin;
    let removed;
    if (range2 > 0 && range2 <= end) {
      removed = this.children.splice(begin, range2);
      for (let i2 = 0; i2 < removed.length; ++i2)
        removed[i2].parent = null, removed[i2].transform && (removed[i2].transform._parentID = -1);
      this._boundsID++, this.onChildrenChange(beginIndex);
      for (let i2 = 0; i2 < removed.length; ++i2)
        removed[i2].emit("removed", this), this.emit("childRemoved", removed[i2], this, i2);
      return removed;
    } else if (range2 === 0 && this.children.length === 0)
      return [];
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */
  sortChildren() {
    let sortRequired = false;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      child._lastSortedIndex = i2, !sortRequired && child.zIndex !== 0 && (sortRequired = true);
    }
    sortRequired && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = false;
  }
  /** Updates the transform on all children of this container for rendering. */
  updateTransform() {
    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      child.visible && child.updateTransform();
    }
  }
  /**
   * Recalculates the bounds of the container.
   *
   * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds
   * is limited to its mask's bounds or filterArea, if any is applied.
   */
  calculateBounds() {
    this._bounds.clear(), this._calculateBounds();
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (!(!child.visible || !child.renderable))
        if (child.calculateBounds(), child._mask) {
          const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
          maskObject ? (maskObject.calculateBounds(), this._bounds.addBoundsMask(child._bounds, maskObject._bounds)) : this._bounds.addBounds(child._bounds);
        } else
          child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }
  /**
   * Retrieves the local bounds of the displayObject as a rectangle object.
   *
   * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()
   * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,
   *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.
   * @returns - The rectangular bounding area.
   */
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate)
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        const child = this.children[i2];
        child.visible && child.updateTransform();
      }
    return result;
  }
  /**
   * Recalculates the content bounds of this object. This should be overriden to
   * calculate the bounds of this specific object (not including children).
   * @protected
   */
  _calculateBounds() {
  }
  /**
   * Renders this object and its children with culling.
   * @protected
   * @param {PIXI.Renderer} renderer - The renderer
   */
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0))
      return;
    let bounds, transform2;
    this.cullArea ? (bounds = this.cullArea, transform2 = this.worldTransform) : this._render !== _Container2.prototype._render && (bounds = this.getBounds(true));
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform && (transform2 ? (transform2 = tempMatrix$2.copyFrom(transform2), transform2.prepend(projectionTransform)) : transform2 = projectionTransform), bounds && sourceFrame.intersects(bounds, transform2))
      this._render(renderer);
    else if (this.cullArea)
      return;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2], childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea, child.render(renderer), child.cullable = childCullable;
    }
  }
  /**
   * Renders the object using the WebGL renderer.
   *
   * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the
   * container itself. This `render` method will invoke it, and also invoke the `render` methods of all
   * children afterward.
   *
   * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and
   * the bounds of this object are out of frame, this implementation will entirely skip rendering.
   * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,
   * setting alpha to zero is not recommended for purely skipping rendering.
   *
   * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is
   * advised to employ **culling** to automatically skip rendering objects outside of the current screen.
   * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.
   * Other culling methods might be better suited for a large number static objects; see
   * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and
   * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.
   *
   * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or
   * filtering is applied on a container. This does, however, break batching and can affect performance when
   * masking and filtering is applied extensively throughout the scene graph.
   * @param renderer - The renderer
   */
  render(renderer) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters?.length)
        this.renderAdvanced(renderer);
      else if (this.cullable)
        this._renderWithCulling(renderer);
      else {
        this._render(renderer);
        for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2)
          this.children[i2].render(renderer);
      }
  }
  /**
   * Render the object using the WebGL renderer and advanced features.
   * @param renderer - The renderer
   */
  renderAdvanced(renderer) {
    const filters2 = this.filters, mask = this._mask;
    if (filters2) {
      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
      for (let i2 = 0; i2 < filters2.length; i2++)
        filters2[i2].enabled && this._enabledFilters.push(filters2[i2]);
    }
    const flush = filters2 && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush && renderer.batch.flush(), filters2 && this._enabledFilters?.length && renderer.filter.push(this, this._enabledFilters), mask && renderer.mask.push(this, this._mask), this.cullable)
      this._renderWithCulling(renderer);
    else {
      this._render(renderer);
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2)
        this.children[i2].render(renderer);
    }
    flush && renderer.batch.flush(), mask && renderer.mask.pop(this), filters2 && this._enabledFilters?.length && renderer.filter.pop();
  }
  /**
   * To be overridden by the subclasses.
   * @param _renderer - The renderer
   */
  _render(_renderer) {
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    super.destroy(), this.sortDirty = false;
    const destroyChildren = typeof options == "boolean" ? options : options?.children, oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren)
      for (let i2 = 0; i2 < oldChildren.length; ++i2)
        oldChildren[i2].destroy(options);
  }
  /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    width !== 0 ? this.scale.x = value / width : this.scale.x = 1, this._width = value;
  }
  /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    height !== 0 ? this.scale.y = value / height : this.scale.y = 1, this._height = value;
  }
};
_Container.defaultSortableChildren = false;
let Container = _Container;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
Object.defineProperties(settings, {
  /**
   * Sets the default value for the container property 'sortableChildren'.
   * @static
   * @name SORTABLE_CHILDREN
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {boolean}
   * @see PIXI.Container.defaultSortableChildren
   */
  SORTABLE_CHILDREN: {
    get() {
      return Container.defaultSortableChildren;
    },
    set(value) {
      deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), Container.defaultSortableChildren = value;
    }
  }
});
const tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends Container {
  /** @param texture - The texture for this sprite. */
  constructor(texture) {
    super(), this._anchor = new ObservablePoint(
      this._onAnchorUpdate,
      this,
      texture ? texture.defaultAnchor.x : 0,
      texture ? texture.defaultAnchor.y : 0
    ), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.pluginName = "batch", this.isSprite = true, this._roundPixels = settings.ROUND_PIXELS;
  }
  /** When the texture is updated, this event will fire to update the scale and frame. */
  _onTextureUpdate() {
    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);
  }
  /** Called when the anchor position updates. */
  _onAnchorUpdate() {
    this._transformID = -1, this._transformTrimmedID = -1;
  }
  /** Calculates worldTransform * vertices, store it in vertexData. */
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)
      return;
    this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = texture._updateID;
    const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, trim2 = texture.trim, orig = texture.orig, anchor = this._anchor;
    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
    if (trim2 ? (w1 = trim2.x - anchor._x * orig.width, w0 = w1 + trim2.width, h1 = trim2.y - anchor._y * orig.height, h0 = h1 + trim2.height) : (w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height), vertexData[0] = a2 * w1 + c2 * h1 + tx, vertexData[1] = d2 * h1 + b2 * w1 + ty, vertexData[2] = a2 * w0 + c2 * h1 + tx, vertexData[3] = d2 * h1 + b2 * w0 + ty, vertexData[4] = a2 * w0 + c2 * h0 + tx, vertexData[5] = d2 * h0 + b2 * w0 + ty, vertexData[6] = a2 * w1 + c2 * h0 + tx, vertexData[7] = d2 * h0 + b2 * w1 + ty, this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2)
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
    }
  }
  /**
   * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.
   *
   * This is used to ensure that the true width and height of a trimmed texture is respected.
   */
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData)
      this.vertexTrimmedData = new Float32Array(8);
    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
      return;
    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture, vertexData = this.vertexTrimmedData, orig = texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height;
    if (vertexData[0] = a2 * w1 + c2 * h1 + tx, vertexData[1] = d2 * h1 + b2 * w1 + ty, vertexData[2] = a2 * w0 + c2 * h1 + tx, vertexData[3] = d2 * h1 + b2 * w0 + ty, vertexData[4] = a2 * w0 + c2 * h0 + tx, vertexData[5] = d2 * h0 + b2 * w0 + ty, vertexData[6] = a2 * w1 + c2 * h0 + tx, vertexData[7] = d2 * h0 + b2 * w1 + ty, this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2)
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
    }
  }
  /**
   *
   * Renders the object using the WebGL renderer
   * @param renderer - The webgl renderer to use.
   */
  _render(renderer) {
    this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this);
  }
  /** Updates the bounds of the sprite. */
  _calculateBounds() {
    const trim2 = this._texture.trim, orig = this._texture.orig;
    !trim2 || trim2.width === orig.width && trim2.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
  }
  /**
   * Gets the local bounds of the sprite object.
   * @param rect - Optional output rectangle.
   * @returns The bounds.
   */
  getLocalBounds(rect) {
    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
  }
  /**
   * Tests if a point is inside this sprite
   * @param point - the point to test
   * @returns The result of the test
   */
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    const width = this._texture.orig.width, height = this._texture.orig.height, x1 = -width * this.anchor.x;
    let y1 = 0;
    return tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height);
  }
  /**
   * Destroys this sprite and optionally its texture and children.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param [options.children=false] - if set to true, all the children will have their destroy
   *      method called as well. 'options' will be passed on to those calls.
   * @param [options.texture=false] - Should it destroy the current texture of the sprite as well
   * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
   */
  destroy(options) {
    if (super.destroy(options), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof options == "boolean" ? options : options?.texture) {
      const destroyBaseTexture = typeof options == "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  // some helper functions..
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source
   *     - Source to create texture from
   * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
   * @returns The newly created sprite
   */
  static from(source, options) {
    const texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite(texture);
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   *
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   *
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
   * @default false
   */
  set roundPixels(value) {
    this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1), this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._texture.orig.width, this._width = value;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._texture.orig.height, this._height = value;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(Texture.WHITE);
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  /**
   * Get the tint as a RGB integer.
   * @ignore
   */
  get tintValue() {
    return this._tintColor.toNumber();
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture !== value && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = value || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once("update", this._onTextureUpdate, this)));
  }
}
const _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  }
}
Object.defineProperties(DisplayObject.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number|null} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number|null} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snapshot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value)
        return;
      this._cacheAsBitmap = value;
      let data;
      value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea);
    }
  }
});
DisplayObject.prototype._renderCached = function(renderer) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));
};
DisplayObject.prototype._initCachedDisplayObject = function(renderer) {
  if (this._cacheData?.sprite)
    return;
  const cacheAlpha = this.alpha;
  this.alpha = 1, renderer.batch.flush();
  const bounds = this.getLocalBounds(new Rectangle(), true);
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  const resolution = this.cacheAsBitmapResolution || renderer.resolution;
  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
  const cachedRenderTexture = renderer.renderTexture.current, cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(), cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(), cachedProjectionTransform = renderer.projection.transform, renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  }), textureCacheId = `cacheAsBitmap_${uid()}`;
  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);
  const m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender, renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false }), renderer.framebuffer.blit(), renderer.projection.transform = cachedProjectionTransform, renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function(renderer) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {
  if (this._cacheData?.sprite)
    return;
  const bounds = this.getLocalBounds(new Rectangle(), true), cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext, cachedProjectionTransform = renderer._projTransform, resolution = this.cacheAsBitmapResolution || renderer.resolution;
  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
  const renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution
  }), textureCacheId = `cacheAsBitmap_${uid()}`;
  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);
  const m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2), m2.invert(), m2.tx -= bounds.x, m2.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false }), renderer.canvasContext.activeContext = cachedRenderTarget, renderer._projTransform = cachedProjectionTransform, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(true), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function(options) {
  this.cacheAsBitmap = false, this.destroy(options);
};
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function(name2, deep) {
  for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++)
    if (this.children[i2].name === name2)
      return this.children[i2];
  if (deep)
    for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
      const child = this.children[i2];
      if (!child.getChildByName)
        continue;
      const target = child.getChildByName(name2, true);
      if (target)
        return target;
    }
  return null;
};
DisplayObject.prototype.getGlobalPosition = function(point = new Point(), skipUpdate = false) {
  return this.parent ? this.parent.toGlobal(this.position, point, skipUpdate) : (point.x = this.position.x, point.y = this.position.y), point;
};
var fragment$6 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class AlphaFilter extends Filter {
  /**
   * @param alpha - Amount of alpha from 0 to 1, where 0 is transparent
   */
  constructor(alpha = 1) {
    super(defaultVertex, fragment$6, { uAlpha: 1 }), this.alpha = alpha;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize], halfLength = kernel.length;
  let fragSource = fragTemplate, blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    value = i2, i2 >= halfLength && (value = kernelSize - i2 - 1), blur = blur.replace("%value%", kernel[value].toString()), blurLoop += blur, blurLoop += `
`;
  }
  return fragSource = fragSource.replace("%blur%", blurLoop), fragSource = fragSource.replace("%size%", kernelSize.toString()), fragSource;
}
const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x2) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate, blurLoop = "", template;
  x2 ? template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", `${i2 - (halfLength - 1)}.0`), blurLoop += blur, blurLoop += `
`;
  }
  return vertSource = vertSource.replace("%blur%", blurLoop), vertSource = vertSource.replace("%size%", kernelSize.toString()), vertSource;
}
class BlurFilterPass extends Filter {
  /**
   * @param horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param strength - The strength of the blur filter.
   * @param quality - The quality of the blur filter.
   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.
   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource(kernelSize, horizontal), fragSrc = generateBlurFragSource(kernelSize);
    super(
      // vertex shader
      vertSrc,
      // fragment shader
      fragSrc
    ), this.horizontal = horizontal, this.resolution = resolution, this._quality = 0, this.quality = quality, this.blur = strength;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    if (output ? this.horizontal ? this.uniforms.strength = 1 / output.width * (output.width / input.width) : this.uniforms.strength = 1 / output.height * (output.height / input.height) : this.horizontal ? this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width) : this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
      filterManager.applyFilter(this, input, output, clearMode);
    else {
      const renderTarget = filterManager.getFilterTexture(), renderer = filterManager.renderer;
      let flip2 = input, flop = renderTarget;
      this.state.blend = false, filterManager.applyFilter(this, flip2, flop, CLEAR_MODES.CLEAR);
      for (let i2 = 1; i2 < this.passes - 1; i2++) {
        filterManager.bindAndClear(flip2, CLEAR_MODES.BLIT), this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip2, flip2 = temp, renderer.shader.bind(this), renderer.geometry.draw(5);
      }
      this.state.blend = true, filterManager.applyFilter(this, flop, output, clearMode), filterManager.returnFilterTexture(renderTarget);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2, this.strength = value;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality bluring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value, this.passes = value;
  }
}
class BlurFilter extends Filter {
  /**
   * @param strength - The strength of the blur filter.
   * @param quality - The quality of the blur filter.
   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.
   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    super(), this._repeatEdgePixels = false, this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize), this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize), this.resolution = resolution, this.quality = quality, this.blur = strength, this.repeatEdgePixels = false;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength), yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR), this.blurYFilter.apply(filterManager, renderTarget, output, clearMode), filterManager.returnFilterTexture(renderTarget);
    } else
      yStrength ? this.blurYFilter.apply(filterManager, input, output, clearMode) : this.blurXFilter.apply(filterManager, input, output, clearMode);
  }
  updatePadding() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   */
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the number of passes for blur. More passes means higher quality bluring.
   * @default 1
   */
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  /**
   * Sets the strength of the blurX property
   * @default 2
   */
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the strength of the blurY property
   * @default 2
   */
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the blendmode of the filter
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  /**
   * If set to true the edge of the target will be clamped
   * @default false
   */
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value, this.updatePadding();
  }
}
var fragment$5 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class ColorMatrixFilter extends Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(defaultFilterVertex, fragment$5, uniforms), this.alpha = 1;
  }
  /**
   * Transforms current matrix and set the new one
   * @param {number[]} matrix - 5x4 matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  _loadMatrix(matrix, multiply2 = false) {
    let newMatrix = matrix;
    multiply2 && (this._multiply(newMatrix, this.uniforms.m, matrix), newMatrix = this._colorMatrix(newMatrix)), this.uniforms.m = newMatrix;
  }
  /**
   * Multiplies two mat5's
   * @private
   * @param out - 5x4 matrix the receiving matrix
   * @param a - 5x4 matrix the first operand
   * @param b - 5x4 matrix the second operand
   * @returns {number[]} 5x4 matrix
   */
  _multiply(out, a2, b2) {
    return out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15], out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16], out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17], out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18], out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4], out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15], out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16], out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17], out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18], out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9], out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15], out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16], out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17], out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18], out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14], out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15], out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16], out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17], out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18], out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19], out;
  }
  /**
   * Create a Float32 Array and normalize the offset component to 0-1
   * @param {number[]} matrix - 5x4 matrix
   * @returns {number[]} 5x4 matrix with all values between 0-1
   */
  _colorMatrix(matrix) {
    const m2 = new Float32Array(matrix);
    return m2[4] /= 255, m2[9] /= 255, m2[14] /= 255, m2[19] /= 255, m2;
  }
  /**
   * Adjusts brightness
   * @param b - value of the brigthness (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  brightness(b2, multiply2) {
    const matrix = [
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Sets each channel on the diagonal of the color matrix.
   * This can be used to achieve a tinting effect on Containers similar to the tint field of some
   * display objects like Sprite, Text, Graphics, and Mesh.
   * @param color - Color of the tint. This is a hex value.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  tint(color, multiply2) {
    const [r2, g2, b2] = Color.shared.setValue(color).toArray(), matrix = [
      r2,
      0,
      0,
      0,
      0,
      0,
      g2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Set the matrices in grey scales
   * @param scale - value of the grey (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  greyscale(scale, multiply2) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Set the black and white matrice.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  blackAndWhite(multiply2) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Set the hue property of the color
   * @param rotation - in degrees
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  hue(rotation, multiply2) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation), sinR = Math.sin(rotation), sqrt = Math.sqrt, w2 = 1 / 3, sqrW = sqrt(w2), a00 = cosR + (1 - cosR) * w2, a01 = w2 * (1 - cosR) - sqrW * sinR, a02 = w2 * (1 - cosR) + sqrW * sinR, a10 = w2 * (1 - cosR) + sqrW * sinR, a11 = cosR + w2 * (1 - cosR), a12 = w2 * (1 - cosR) - sqrW * sinR, a20 = w2 * (1 - cosR) - sqrW * sinR, a21 = w2 * (1 - cosR) + sqrW * sinR, a22 = cosR + w2 * (1 - cosR), matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Set the contrast matrix, increase the separation between dark and bright
   * Increase contrast : shadows darker and highlights brighter
   * Decrease contrast : bring the shadows up and the highlights down
   * @param amount - value of the contrast (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  contrast(amount, multiply2) {
    const v2 = (amount || 0) + 1, o2 = -0.5 * (v2 - 1), matrix = [
      v2,
      0,
      0,
      0,
      o2,
      0,
      v2,
      0,
      0,
      o2,
      0,
      0,
      v2,
      0,
      o2,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Set the saturation matrix, increase the separation between colors
   * Increase saturation : increase contrast, brightness, and sharpness
   * @param amount - The saturation amount (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  saturate(amount = 0, multiply2) {
    const x2 = amount * 2 / 3 + 1, y2 = (x2 - 1) * -0.5, matrix = [
      x2,
      y2,
      y2,
      0,
      0,
      y2,
      x2,
      y2,
      0,
      0,
      y2,
      y2,
      x2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /** Desaturate image (remove color) Call the saturate function */
  desaturate() {
    this.saturate(-1);
  }
  /**
   * Negative image (inverse of classic rgb matrix)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  negative(multiply2) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Sepia image
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  sepia(multiply2) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  technicolor(multiply2) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Polaroid filter
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  polaroid(multiply2) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Filter who transforms : Red -> Blue and Blue -> Red
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  toBGR(multiply2) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  kodachrome(multiply2) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Brown delicious browni filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  browni(multiply2) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Vintage filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  vintage(multiply2) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * We don't know exactly what it does, kind of gradient map, but funny to play with!
   * @param desaturation - Tone values.
   * @param toned - Tone values.
   * @param lightColor - Tone values, example: `0xFFE580`
   * @param darkColor - Tone values, example: `0xFFE580`
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  colorTone(desaturation, toned, lightColor, darkColor, multiply2) {
    desaturation = desaturation || 0.2, toned = toned || 0.15, lightColor = lightColor || 16770432, darkColor = darkColor || 3375104;
    const temp = Color.shared, [lR, lG, lB] = temp.setValue(lightColor).toArray(), [dR, dG, dB] = temp.setValue(darkColor).toArray(), matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Night effect
   * @param intensity - The intensity of the night effect.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  night(intensity, multiply2) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * Predator effect
   *
   * Erase the current matrix by setting a new indepent one
   * @param amount - how much the predator feels his future victim
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  predator(amount, multiply2) {
    const matrix = [
      // row 1
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      // row 2
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      // row 3
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      // row 4
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /**
   * LSD effect
   *
   * Multiply the current matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  lsd(multiply2) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply2);
  }
  /** Erase the current matrix by setting the default one. */
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  /**
   * The matrix of the color matrix filter
   * @member {number[]}
   * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
   */
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  /**
   * The opacity value to use when mixing the original and resultant colors.
   *
   * When the value is 0, the original color is used without modification.
   * When the value is 1, the result color is used.
   * When in the range (0, 1) the color is interpolated between the original and result by this amount.
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
var fragment$4 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`;
var vertex$3 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class DisplacementFilter extends Filter {
  /**
   * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)
   * @param scale - The scale of the displacement
   */
  constructor(sprite, scale) {
    const maskMatrix = new Matrix();
    sprite.renderable = false, super(vertex$3, fragment$4, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }), this.maskSprite = sprite, this.maskMatrix = maskMatrix, scale == null && (scale = 20), this.scale = new Point(scale, scale);
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - clearMode.
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform, lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b), lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    lenX !== 0 && lenY !== 0 && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY), filterManager.applyFilter(this, input, output, clearMode);
  }
  /** The texture used for the displacement map. Must be power of 2 sized texture. */
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}
var fragment$3 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
var vertex$2 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class FXAAFilter extends Filter {
  constructor() {
    super(vertex$2, fragment$3);
  }
}
var fragment$2 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class NoiseFilter extends Filter {
  /**
   * @param {number} [noise=0.5] - The noise intensity, should be a normalized value in the range [0, 1].
   * @param {number} [seed] - A random seed for the noise generation. Default is `Math.random()`.
   */
  constructor(noise = 0.5, seed = Math.random()) {
    super(defaultFilterVertex, fragment$2, {
      uNoise: 0,
      uSeed: 0
    }), this.noise = noise, this.seed = seed;
  }
  /**
   * The amount of noise to apply, this value should be in the range (0, 1].
   * @default 0.5
   */
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}
const filters = {
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.AlphaFilter
   */
  AlphaFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.BlurFilter
   */
  BlurFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.BlurFilterPass
   */
  BlurFilterPass,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.ColorMatrixFilter
   */
  ColorMatrixFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.DisplacementFilter
   */
  DisplacementFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.FXAAFilter
   */
  FXAAFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.NoiseFilter
   */
  NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      return deprecation("7.1.0", `filters.${key} has moved to ${key}`), FilterClass;
    }
  });
});
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this.tickerAdded = false, this._pauseUpdate = true;
  }
  /**
   * Initializes the event ticker.
   * @param events - The event system.
   */
  init(events) {
    this.removeTickerListener(), this.events = events, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this.tickerAdded = false, this._pauseUpdate = true;
  }
  /** Whether to pause the update checks or not. */
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  /** Adds the ticker listener. */
  addTickerListener() {
    this.tickerAdded || !this.domElement || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = true);
  }
  /** Removes the ticker listener. */
  removeTickerListener() {
    this.tickerAdded && (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
  }
  /** Sets flag to not fire extra events when the user has already moved there mouse */
  pointerMoved() {
    this._didMove = true;
  }
  /** Updates the state of interactive objects. */
  update() {
    if (!this.domElement || this._pauseUpdate)
      return;
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events.rootPointerEvent;
    this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  /**
   * Updates the state of interactive objects if at least {@link PIXI.EventsTicker#interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.
   * @param deltaTime - time delta since the last call
   */
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
  }
}
const EventsTicker = new EventsTickerClass();
class FederatedEvent {
  /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  constructor(manager) {
    this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = new Point(), this.page = new Point(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  /** @readonly */
  get layerX() {
    return this.layer.x;
  }
  /** @readonly */
  get layerY() {
    return this.layer.y;
  }
  /** @readonly */
  get pageX() {
    return this.page.x;
  }
  /** @readonly */
  get pageY() {
    return this.page.y;
  }
  /**
   * Fallback for the deprecated @code{PIXI.InteractionEvent.data}.
   * @deprecated since 7.0.0
   */
  get data() {
    return this;
  }
  /** The propagation path for this event. Alias for {@link PIXI.EventBoundary.propagationPath}. */
  composedPath() {
    return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
   * @deprecated
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /** Prevent default behavior of PixiJS and the user agent. */
  preventDefault() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
  }
  /**
   * Stop this event from propagating to any addition listeners, including on the
   * {@link PIXI.FederatedEventTarget.currentTarget currentTarget} and also the following
   * event targets on the propagation path.
   */
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  /**
   * Stop this event from propagating to the next {@link PIXI.FederatedEventTarget}. The rest of the listeners
   * on the {@link PIXI.FederatedEventTarget.currentTarget currentTarget} will still be notified.
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}
class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = new Point(), this.movement = new Point(), this.offset = new Point(), this.global = new Point(), this.screen = new Point();
  }
  /** @readonly */
  get clientX() {
    return this.client.x;
  }
  /** @readonly */
  get clientY() {
    return this.client.y;
  }
  /**
   * Alias for {@link PIXI.FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */
  get x() {
    return this.clientX;
  }
  /**
   * Alias for {@link PIXI.FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */
  get y() {
    return this.clientY;
  }
  /** @readonly */
  get movementX() {
    return this.movement.x;
  }
  /** @readonly */
  get movementY() {
    return this.movement.y;
  }
  /** @readonly */
  get offsetX() {
    return this.offset.x;
  }
  /** @readonly */
  get offsetY() {
    return this.offset.y;
  }
  /** @readonly */
  get globalX() {
    return this.global.x;
  }
  /** @readonly */
  get globalY() {
    return this.global.y;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
   * @readonly
   */
  get screenX() {
    return this.screen.x;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
   * @readonly
   */
  get screenY() {
    return this.screen.y;
  }
  /**
   * This will return the local coordinates of the specified displayObject for this InteractionData
   * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
   *  coords off
   * @param {PIXI.IPointData} point - A Point object in which to store the value, optional (otherwise
   *  will create a new point)
   * @param {PIXI.IPointData} globalPos - A Point object containing your custom global coords, optional
   *  (otherwise will use the current global coords)
   * @returns - A point containing the coordinates of the InteractionData position relative
   *  to the DisplayObject
   */
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   */
  // eslint-disable-next-line max-params
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}
class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
  }
  // Only included for completeness for now
  getCoalescedEvents() {
    return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];
  }
  // Only included for completeness for now
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, /** Units specified in lines. */
FederatedWheelEvent.DOM_DELTA_LINE = 1, /** Units specified in pages. */
FederatedWheelEvent.DOM_DELTA_PAGE = 2;
const PROPAGATION_LIMIT = 2048, tempHitLocation = new Point(), tempLocalMapping = new Point();
class EventBoundary {
  /**
   * @param rootTarget - The holder of the event boundary.
   */
  constructor(rootTarget) {
    this.dispatch = new EventEmitter(), this.moveOnAll = false, this.enableGlobalMoveEvents = true, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = false, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
  }
  /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */
  addEventMapping(type2, fn) {
    this.mappingTable[type2] || (this.mappingTable[type2] = []), this.mappingTable[type2].push({
      fn,
      priority: 0
    }), this.mappingTable[type2].sort((a2, b2) => a2.priority - b2.priority);
  }
  /**
   * Dispatches the given event
   * @param e
   * @param type
   */
  dispatchEvent(e2, type2) {
    e2.propagationStopped = false, e2.propagationImmediatelyStopped = false, this.propagate(e2, type2), this.dispatch.emit(type2 || e2.type, e2);
  }
  /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e
   */
  mapEvent(e2) {
    if (!this.rootTarget)
      return;
    const mappers = this.mappingTable[e2.type];
    if (mappers)
      for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++)
        mappers[i2].fn(e2);
    else
      console.warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
  }
  /**
   * Finds the DisplayObject that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x
   * @param y
   */
  hitTest(x2, y2) {
    EventsTicker.pauseUpdate = true;
    const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", invertedPath = this[fn](
      this.rootTarget,
      this.rootTarget.eventMode,
      tempHitLocation.set(x2, y2),
      this.hitTestFn,
      this.hitPruneFn
    );
    return invertedPath && invertedPath[0];
  }
  /**
   * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its
   * target {@code e.target}.
   * @param e - The event to propagate.
   * @param type
   */
  propagate(e2, type2) {
    if (!e2.target)
      return;
    const composedPath = e2.composedPath();
    e2.eventPhase = e2.CAPTURING_PHASE;
    for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++)
      if (e2.currentTarget = composedPath[i2], this.notifyTarget(e2, type2), e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    if (e2.eventPhase = e2.AT_TARGET, e2.currentTarget = e2.target, this.notifyTarget(e2, type2), !(e2.propagationStopped || e2.propagationImmediatelyStopped)) {
      e2.eventPhase = e2.BUBBLING_PHASE;
      for (let i2 = composedPath.length - 2; i2 >= 0; i2--)
        if (e2.currentTarget = composedPath[i2], this.notifyTarget(e2, type2), e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
    }
  }
  /**
   * Emits the event {@code e} to all interactive display objects. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */
  all(e2, type2, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e2.eventPhase = e2.BUBBLING_PHASE;
    const events = Array.isArray(type2) ? type2 : [type2];
    for (let i2 = targets.length - 1; i2 >= 0; i2--)
      events.forEach((event) => {
        e2.currentTarget = targets[i2], this.notifyTarget(e2, event);
      });
  }
  /**
   * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed
   * {@code target}. The last element in the path is {@code target}.
   * @param target
   */
  propagationPath(target) {
    const propagationPath = [target];
    for (let i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
      if (!target.parent)
        throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = false), currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2], nestedHit = this.hitTestMoveRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn,
          ignore || pruneFn(currentTarget, location)
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
            continue;
          const isInteractive = currentTarget.isInteractive();
          (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
    return isInteractiveMode && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
  }
  /**
   * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.
   * @param currentTarget - The DisplayObject that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the display object.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))
      return null;
    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = false), currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2], nestedHit = this.hitTestRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
            continue;
          const isInteractive = currentTarget.isInteractive();
          return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
    return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === "none" || displayObject.eventMode === "passive" && !displayObject.interactiveChildren || displayObject.isMask);
  }
  /**
   * Checks whether the display object or any of its children cannot pass the hit test at all.
   *
   * {@link PIXI.EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}
   * and {@link PIXI.DisplayObject._mask} for pruning.
   * @param displayObject
   * @param location
   */
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))
      return true;
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location))
        return true;
    }
    return false;
  }
  /**
   * Checks whether the display object passes hit testing for the given location.
   * @param displayObject
   * @param location
   * @returns - Whether `displayObject` passes hit testing for `location`.
   */
  hitTestFn(displayObject, location) {
    return displayObject.eventMode === "passive" ? false : displayObject.hitArea ? true : displayObject.containsPoint ? displayObject.containsPoint(location) : false;
  }
  /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type
   */
  notifyTarget(e2, type2) {
    type2 = type2 ?? e2.type;
    const handlerKey = `on${type2}`;
    e2.currentTarget[handlerKey]?.(e2);
    const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type2}capture` : type2;
    this.notifyListeners(e2, key), e2.eventPhase === e2.AT_TARGET && this.notifyListeners(e2, type2);
  }
  /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from
   */
  mapPointerDown(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e2 = this.createPointerEvent(from2);
    if (this.dispatchEvent(e2, "pointerdown"), e2.pointerType === "touch")
      this.dispatchEvent(e2, "touchstart");
    else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
      const isRightButton = e2.button === 2;
      this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from2.pointerId);
    trackingData.pressTargetsByButton[from2.button] = e2.composedPath(), this.freeEvent(e2);
  }
  /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */
  mapPointerMove(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = true;
    const e2 = this.createPointerEvent(from2);
    this._isPointerMoveEvent = false;
    const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen", trackingData = this.trackingData(from2.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
      const outType = from2.type === "mousemove" ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from2, outType, outTarget);
      if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e2.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e2.composedPath().includes(leaveEvent.target); )
          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e2.target) {
      const overType = from2.type === "mousemove" ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e2, overType);
      this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e2.target; )
        overTargetAncestor = overTargetAncestor.parent;
      if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
        const enterEvent = this.clonePointerEvent(e2, "pointerenter");
        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )
          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove"), allowGlobalPointerEvents && allMethods.push("globalpointermove"), e2.pointerType === "touch" && (this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove"), allowGlobalPointerEvents && allMethods.push("globaltouchmove")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove"), allowGlobalPointerEvents && allMethods.push("globalmousemove"), this.cursor = e2.target?.cursor), allMethods.length > 0 && this.all(e2, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e2.composedPath(), this.freeEvent(e2);
  }
  /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */
  mapPointerOver(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId), e2 = this.createPointerEvent(from2), isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
    this.dispatchEvent(e2, "pointerover"), isMouse && this.dispatchEvent(e2, "mouseover"), e2.pointerType === "mouse" && (this.cursor = e2.target?.cursor);
    const enterEvent = this.clonePointerEvent(e2, "pointerenter");
    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )
      enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
    trackingData.overTargets = e2.composedPath(), this.freeEvent(e2), this.freeEvent(enterEvent);
  }
  /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */
  mapPointerOut(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from2.pointerType === "mouse" || from2.pointerType === "pen", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from2, "pointerout", outTarget);
      this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
      for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )
        leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
      trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */
  mapPointerUp(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now(), e2 = this.createPointerEvent(from2);
    if (this.dispatchEvent(e2, "pointerup"), e2.pointerType === "touch")
      this.dispatchEvent(e2, "touchend");
    else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
      const isRightButton = e2.button === 2;
      this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from2.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e2.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      for (; currentTarget && !e2.composedPath().includes(currentTarget); ) {
        if (e2.currentTarget = currentTarget, this.notifyTarget(e2, "pointerupoutside"), e2.pointerType === "touch")
          this.notifyTarget(e2, "touchendoutside");
        else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from2.button], clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e2, "click");
      clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from2.button] || (trackingData.clicksByButton[from2.button] = {
        clickCount: 0,
        target: clickEvent.target,
        timeStamp: now
      });
      const clickHistory = trackingData.clicksByButton[from2.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else
        clickEvent.pointerType === "touch" && this.dispatchEvent(clickEvent, "tap");
      this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
    }
    this.freeEvent(e2);
  }
  /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link PIXI.EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */
  mapPointerUpOutside(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]), e2 = this.createPointerEvent(from2);
    if (pressTarget) {
      let currentTarget = pressTarget;
      for (; currentTarget; )
        e2.currentTarget = currentTarget, this.notifyTarget(e2, "pointerupoutside"), e2.pointerType === "touch" ? this.notifyTarget(e2, "touchendoutside") : (e2.pointerType === "mouse" || e2.pointerType === "pen") && this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
      delete trackingData.pressTargetsByButton[from2.button];
    }
    this.freeEvent(e2);
  }
  /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */
  mapWheel(from2) {
    if (!(from2 instanceof FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from2);
    this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
  }
  /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */
  findMountedTarget(propagationPath) {
    if (!propagationPath)
      return null;
    let currentTarget = propagationPath[0];
    for (let i2 = 1; i2 < propagationPath.length && propagationPath[i2].parent === currentTarget; i2++)
      currentTarget = propagationPath[i2];
    return currentTarget;
  }
  /**
   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The {@code originalEvent} for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */
  createPointerEvent(from2, type2, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from2, event), this.copyMouseData(from2, event), this.copyData(from2, event), event.nativeEvent = from2.nativeEvent, event.originalEvent = from2, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type2 == "string" && (event.type = type2), event;
  }
  /**
   * Creates a wheel event whose {@code originalEvent} is {@code from}.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */
  createWheelEvent(from2) {
    const event = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from2, event), this.copyMouseData(from2, event), this.copyData(from2, event), event.nativeEvent = from2.nativeEvent, event.originalEvent = from2, event.target = this.hitTest(event.global.x, event.global.y), event;
  }
  /**
   * Clones the event {@code from}, with an optional {@code type} override.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */
  clonePointerEvent(from2, type2) {
    const event = this.allocateEvent(FederatedPointerEvent);
    return event.nativeEvent = from2.nativeEvent, event.originalEvent = from2.originalEvent, this.copyPointerData(from2, event), this.copyMouseData(from2, event), this.copyData(from2, event), event.target = from2.target, event.path = from2.composedPath().slice(), event.type = type2 ?? event.type, event;
  }
  /**
   * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from
   * @param to
   */
  copyWheelData(from2, to) {
    to.deltaMode = from2.deltaMode, to.deltaX = from2.deltaX, to.deltaY = from2.deltaY, to.deltaZ = from2.deltaZ;
  }
  /**
   * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from
   * @param to
   */
  copyPointerData(from2, to) {
    from2 instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from2.pointerId, to.width = from2.width, to.height = from2.height, to.isPrimary = from2.isPrimary, to.pointerType = from2.pointerType, to.pressure = from2.pressure, to.tangentialPressure = from2.tangentialPressure, to.tiltX = from2.tiltX, to.tiltY = from2.tiltY, to.twist = from2.twist);
  }
  /**
   * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from
   * @param to
   */
  copyMouseData(from2, to) {
    from2 instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from2.altKey, to.button = from2.button, to.buttons = from2.buttons, to.client.copyFrom(from2.client), to.ctrlKey = from2.ctrlKey, to.metaKey = from2.metaKey, to.movement.copyFrom(from2.movement), to.screen.copyFrom(from2.screen), to.shiftKey = from2.shiftKey, to.global.copyFrom(from2.global));
  }
  /**
   * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyData(from2, to) {
    to.isTrusted = from2.isTrusted, to.srcElement = from2.srcElement, to.timeStamp = performance.now(), to.type = from2.type, to.detail = from2.detail, to.view = from2.view, to.which = from2.which, to.layer.copyFrom(from2.layer), to.page.copyFrom(from2.page);
  }
  /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */
  trackingData(id2) {
    return this.mappingState.trackingData[id2] || (this.mappingState.trackingData[id2] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id2];
  }
  /**
   * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   */
  allocateEvent(constructor) {
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;
  }
  /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);
  }
  /**
   * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */
  notifyListeners(e2, type2) {
    const listeners = e2.currentTarget._events[type2];
    if (listeners && e2.currentTarget.isInteractive())
      if ("fn" in listeners)
        listeners.once && e2.currentTarget.removeListener(type2, listeners.fn, void 0, true), listeners.fn.call(listeners.context, e2);
      else
        for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++)
          listeners[i2].once && e2.currentTarget.removeListener(type2, listeners[i2].fn, void 0, true), listeners[i2].fn.call(listeners[i2].context, e2);
  }
}
const MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
}, _EventSystem = class _EventSystem2 {
  /**
   * @param {PIXI.Renderer} renderer
   */
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = renderer, this.rootBoundary = new EventBoundary(null), EventsTicker.init(this), this.autoPreventDefault = true, this.eventsAdded = false, this.rootPointerEvent = new FederatedPointerEvent(null), this.rootWheelEvent = new FederatedWheelEvent(null), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
      set: (target, key, value) => (key === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = value), target[key] = value, true)
    }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
  }
  /**
   * The default interaction mode for all display objects.
   * @see PIXI.DisplayObject.eventMode
   * @type {PIXI.EventMode}
   * @readonly
   * @since 7.2.0
   */
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view), this.resolution = resolution, _EventSystem2._defaultEventMode = options.eventMode ?? "auto", Object.assign(this.features, options.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  /**
   * Handle changing resolution.
   * @ignore
   */
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  /** Destroys all event listeners and detaches the renderer. */
  destroy() {
    this.setTargetElement(null), this.renderer = null;
  }
  /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * @param mode - cursor mode, a key from the cursorStyles dictionary
   */
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (applyStyles = false), this.currentCursor === mode)
      return;
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style)
      switch (typeof style) {
        case "string":
          applyStyles && (this.domElement.style.cursor = style);
          break;
        case "function":
          style(mode);
          break;
        case "object":
          applyStyles && Object.assign(this.domElement.style, style);
          break;
      }
    else
      applyStyles && typeof mode == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode) && (this.domElement.style.cursor = mode);
  }
  /**
   * The global pointer event.
   * Useful for getting the pointer position without listening to events.
   * @since 7.2.0
   */
  get pointer() {
    return this.rootPointerEvent;
  }
  /**
   * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const events = this.normalizeToPointerData(nativeEvent);
    this.autoPreventDefault && events[0].isNormalized && (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
    for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
      const nativeEvent2 = events[i2], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    const outside = target !== this.domElement ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      event.type += outside, this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Passive handler for `wheel` events on {@link PIXI.EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(wheelEvent);
  }
  /**
   * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.
   *
   * To deregister the current DOM element without setting a new one, pass {@code null}.
   * @param element - The new DOM element.
   */
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, EventsTicker.domElement = element, this.addEvents();
  }
  /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */
  addEvents() {
    if (this.eventsAdded || !this.domElement)
      return;
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    style && (globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "none", style.msTouchAction = "none") : this.supportsPointerEvents && (style.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, true), this.domElement.addEventListener("pointerdown", this.onPointerDown, true), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true), this.domElement.addEventListener("pointerover", this.onPointerOverOut, true), globalThis.addEventListener("pointerup", this.onPointerUp, true)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, true), this.domElement.addEventListener("mousedown", this.onPointerDown, true), this.domElement.addEventListener("mouseout", this.onPointerOverOut, true), this.domElement.addEventListener("mouseover", this.onPointerOverOut, true), globalThis.addEventListener("mouseup", this.onPointerUp, true), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, true), this.domElement.addEventListener("touchend", this.onPointerUp, true), this.domElement.addEventListener("touchmove", this.onPointerMove, true))), this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    }), this.eventsAdded = true;
  }
  /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */
  removeEvents() {
    if (!this.eventsAdded || !this.domElement)
      return;
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "", style.msTouchAction = "") : this.supportsPointerEvents && (style.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, true), this.domElement.removeEventListener("pointerdown", this.onPointerDown, true), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true), globalThis.removeEventListener("pointerup", this.onPointerUp, true)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, true), this.domElement.removeEventListener("mousedown", this.onPointerDown, true), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true), globalThis.removeEventListener("mouseup", this.onPointerUp, true), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, true), this.domElement.removeEventListener("touchend", this.onPointerUp, true), this.domElement.removeEventListener("touchmove", this.onPointerMove, true))), this.domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
  }
  /**
   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
   * resulting value is stored in the point. This takes into account the fact that the DOM
   * element could be scaled and positioned anywhere on the screen.
   * @param  {PIXI.IPointData} point - the point that the result will be stored in
   * @param  {number} x - the x coord of the position to map
   * @param  {number} y - the y coord of the position to map
   */
  mapPositionToPoint(point, x2, y2) {
    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    }, resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier, point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent)
      for (let i2 = 0, li2 = event.changedTouches.length; i2 < li2; i2++) {
        const touch2 = event.changedTouches[i2];
        typeof touch2.button > "u" && (touch2.button = 0), typeof touch2.buttons > "u" && (touch2.buttons = 1), typeof touch2.isPrimary > "u" && (touch2.isPrimary = event.touches.length === 1 && event.type === "touchstart"), typeof touch2.width > "u" && (touch2.width = touch2.radiusX || 1), typeof touch2.height > "u" && (touch2.height = touch2.radiusY || 1), typeof touch2.tiltX > "u" && (touch2.tiltX = 0), typeof touch2.tiltY > "u" && (touch2.tiltY = 0), typeof touch2.pointerType > "u" && (touch2.pointerType = "touch"), typeof touch2.pointerId > "u" && (touch2.pointerId = touch2.identifier || 0), typeof touch2.pressure > "u" && (touch2.pressure = touch2.force || 0.5), typeof touch2.twist > "u" && (touch2.twist = 0), typeof touch2.tangentialPressure > "u" && (touch2.tangentialPressure = 0), typeof touch2.layerX > "u" && (touch2.layerX = touch2.offsetX = touch2.clientX), typeof touch2.layerY > "u" && (touch2.layerY = touch2.offsetY = touch2.clientY), touch2.isNormalized = true, touch2.type = event.type, normalizedEvents.push(touch2);
      }
    else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      typeof tempEvent.isPrimary > "u" && (tempEvent.isPrimary = true), typeof tempEvent.width > "u" && (tempEvent.width = 1), typeof tempEvent.height > "u" && (tempEvent.height = 1), typeof tempEvent.tiltX > "u" && (tempEvent.tiltX = 0), typeof tempEvent.tiltY > "u" && (tempEvent.tiltY = 0), typeof tempEvent.pointerType > "u" && (tempEvent.pointerType = "mouse"), typeof tempEvent.pointerId > "u" && (tempEvent.pointerId = MOUSE_POINTER_ID), typeof tempEvent.pressure > "u" && (tempEvent.pressure = 0.5), typeof tempEvent.twist > "u" && (tempEvent.twist = 0), typeof tempEvent.tangentialPressure > "u" && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
    } else
      normalizedEvents.push(event);
    return normalizedEvents;
  }
  /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    return this.transferMouseData(event, nativeEvent), event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ, event.deltaMode = nativeEvent.deltaMode, this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  /**
   * Normalizes the `nativeEvent` into a federateed {@link PIXI.FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */
  bootstrapEvent(event, nativeEvent) {
    return event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent), this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.isTrusted = nativeEvent.isTrusted, event.type === "pointerleave" && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  /**
   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
   * @param event
   * @param nativeEvent
   */
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = performance.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null, event.shiftKey = nativeEvent.shiftKey;
  }
};
_EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ]
}, /**
* The event features that are enabled by the EventSystem
* This option only is available when using **@pixi/events** package
* (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.
* @since 7.2.0
*/
_EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
let EventSystem = _EventSystem;
extensions$1.add(EventSystem);
function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  /**
   * Property-based event handler for the `click` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onclick = (event) => {
   *  //some function here that happens on click
   * }
   */
  onclick: null,
  /**
   * Property-based event handler for the `mousedown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmousedown = (event) => {
   *  //some function here that happens on mousedown
   * }
   */
  onmousedown: null,
  /**
   * Property-based event handler for the `mouseenter` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseenter = (event) => {
   *  //some function here that happens on mouseenter
   * }
   */
  onmouseenter: null,
  /**
   * Property-based event handler for the `mouseleave` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseleave = (event) => {
   *  //some function here that happens on mouseleave
   * }
   */
  onmouseleave: null,
  /**
   * Property-based event handler for the `mousemove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmousemove = (event) => {
   *  //some function here that happens on mousemove
   * }
   */
  onmousemove: null,
  /**
   * Property-based event handler for the `globalmousemove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobalmousemove = (event) => {
   *  //some function here that happens on globalmousemove
   * }
   */
  onglobalmousemove: null,
  /**
   * Property-based event handler for the `mouseout` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseout = (event) => {
   *  //some function here that happens on mouseout
   * }
   */
  onmouseout: null,
  /**
   * Property-based event handler for the `mouseover` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseover = (event) => {
   *  //some function here that happens on mouseover
   * }
   */
  onmouseover: null,
  /**
   * Property-based event handler for the `mouseup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseup = (event) => {
   *  //some function here that happens on mouseup
   * }
   */
  onmouseup: null,
  /**
   * Property-based event handler for the `mouseupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseupoutside = (event) => {
   *  //some function here that happens on mouseupoutside
   * }
   */
  onmouseupoutside: null,
  /**
   * Property-based event handler for the `pointercancel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointercancel = (event) => {
   *  //some function here that happens on pointercancel
   * }
   */
  onpointercancel: null,
  /**
   * Property-based event handler for the `pointerdown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerdown = (event) => {
   *  //some function here that happens on pointerdown
   * }
   */
  onpointerdown: null,
  /**
   * Property-based event handler for the `pointerenter` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerenter = (event) => {
   *  //some function here that happens on pointerenter
   * }
   */
  onpointerenter: null,
  /**
   * Property-based event handler for the `pointerleave` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerleave = (event) => {
   *  //some function here that happens on pointerleave
   * }
   */
  onpointerleave: null,
  /**
   * Property-based event handler for the `pointermove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointermove = (event) => {
   *  //some function here that happens on pointermove
   * }
   */
  onpointermove: null,
  /**
   * Property-based event handler for the `globalpointermove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobalpointermove = (event) => {
   *  //some function here that happens on globalpointermove
   * }
   */
  onglobalpointermove: null,
  /**
   * Property-based event handler for the `pointerout` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerout = (event) => {
   *  //some function here that happens on pointerout
   * }
   */
  onpointerout: null,
  /**
   * Property-based event handler for the `pointerover` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerover = (event) => {
   *  //some function here that happens on pointerover
   * }
   */
  onpointerover: null,
  /**
   * Property-based event handler for the `pointertap` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointertap = (event) => {
   *  //some function here that happens on pointertap
   * }
   */
  onpointertap: null,
  /**
   * Property-based event handler for the `pointerup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerup = (event) => {
   *  //some function here that happens on pointerup
   * }
   */
  onpointerup: null,
  /**
   * Property-based event handler for the `pointerupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerupoutside = (event) => {
   *  //some function here that happens on pointerupoutside
   * }
   */
  onpointerupoutside: null,
  /**
   * Property-based event handler for the `rightclick` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightclick = (event) => {
   *  //some function here that happens on rightclick
   * }
   */
  onrightclick: null,
  /**
   * Property-based event handler for the `rightdown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightdown = (event) => {
   *  //some function here that happens on rightdown
   * }
   */
  onrightdown: null,
  /**
   * Property-based event handler for the `rightup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightup = (event) => {
   *  //some function here that happens on rightup
   * }
   */
  onrightup: null,
  /**
   * Property-based event handler for the `rightupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightupoutside = (event) => {
   *  //some function here that happens on rightupoutside
   * }
   */
  onrightupoutside: null,
  /**
   * Property-based event handler for the `tap` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontap = (event) => {
   *  //some function here that happens on tap
   * }
   */
  ontap: null,
  /**
   * Property-based event handler for the `touchcancel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchcancel = (event) => {
   *  //some function here that happens on touchcancel
   * }
   */
  ontouchcancel: null,
  /**
   * Property-based event handler for the `touchend` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchend = (event) => {
   *  //some function here that happens on touchend
   * }
   */
  ontouchend: null,
  /**
   * Property-based event handler for the `touchendoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchendoutside = (event) => {
   *  //some function here that happens on touchendoutside
   * }
   */
  ontouchendoutside: null,
  /**
   * Property-based event handler for the `touchmove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchmove = (event) => {
   *  //some function here that happens on touchmove
   * }
   */
  ontouchmove: null,
  /**
   * Property-based event handler for the `globaltouchmove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobaltouchmove = (event) => {
   *  //some function here that happens on globaltouchmove
   * }
   */
  onglobaltouchmove: null,
  /**
   * Property-based event handler for the `touchstart` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchstart = (event) => {
   *  //some function here that happens on touchstart
   * }
   */
  ontouchstart: null,
  /**
   * Property-based event handler for the `wheel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onwheel = (event) => {
   *  //some function here that happens on wheel
   * }
   */
  onwheel: null,
  /**
   * @ignore
   */
  _internalInteractive: void 0,
  /**
   * Enable interaction events for the DisplayObject. Touch, pointer and mouse
   * @memberof PIXI.DisplayObject#
   */
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
  },
  set interactive(value) {
    deprecation(
      "7.2.0",
      // eslint-disable-next-line max-len
      "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."
    ), this._internalInteractive = value, this.eventMode = value ? "static" : "auto";
  },
  /**
   * @ignore
   */
  _internalEventMode: void 0,
  /**
   * Enable interaction events for the DisplayObject. Touch, pointer and mouse.
   * This now replaces the `interactive` property.
   * There are 5 types of interaction settings:
   * - `'none'`: Ignores all interaction events, even on its children.
   * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
   * Interactive children will still emit events.
   * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
   * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
   * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
   * allow for interaction when the mouse isn't moving
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.on('tap', (event) => {
   *     // Handle event
   * });
   * @memberof PIXI.DisplayObject#
   * @since 7.2.0
   */
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value), this._internalEventMode = value;
  },
  /**
   * Determines if the displayObject is interactive or not
   * @returns {boolean} Whether the displayObject is interactive or not
   * @memberof PIXI.DisplayObject#
   * @since 7.2.0
   * @example
   * import { Sprite } from 'pixi.js';
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'dynamic';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'none';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'passive';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'auto';
   * sprite.isInteractive(); // false
   */
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  /**
   * Determines if the children to the displayObject can be clicked/touched
   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
   * @memberof PIXI.Container#
   */
  interactiveChildren: true,
  /**
   * Interaction shape. Children will be hit first, then this shape will be checked.
   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
   * @example
   * import { Rectangle, Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.interactive = true;
   * sprite.hitArea = new Rectangle(0, 0, 100, 100);
   * @member {PIXI.IHitArea}
   * @memberof PIXI.DisplayObject#
   */
  hitArea: null,
  /**
   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
   * seeks to be compatible with the DOM's `addEventListener` with support for options.
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param type - The type of event to listen to.
   * @param listener - The listener callback or object.
   * @param options - Listener options, used for capture phase.
   * @example
   * // Tell the user whether they did a single, double, triple, or nth click.
   * button.addEventListener('click', {
   *     handleEvent(e): {
   *         let prefix;
   *
   *         switch (e.detail) {
   *             case 1: prefix = 'single'; break;
   *             case 2: prefix = 'double'; break;
   *             case 3: prefix = 'triple'; break;
   *             default: prefix = e.detail + 'th'; break;
   *         }
   *
   *         console.log('That was a ' + prefix + 'click');
   *     }
   * });
   *
   * // But skip the first click!
   * button.parent.addEventListener('click', function blockClickOnce(e) {
   *     e.stopImmediatePropagation();
   *     button.parent.removeEventListener('click', blockClickOnce, true);
   * }, {
   *     capture: true,
   * });
   */
  addEventListener(type2, listener3, options) {
    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, signal = typeof options == "object" ? options.signal : void 0, once2 = typeof options == "object" ? options.once === true : false, context2 = typeof listener3 == "function" ? void 0 : listener3;
    type2 = capture ? `${type2}capture` : type2;
    const listenerFn = typeof listener3 == "function" ? listener3 : listener3.handleEvent, emitter = this;
    signal && signal.addEventListener("abort", () => {
      emitter.off(type2, listenerFn, context2);
    }), once2 ? emitter.once(type2, listenerFn, context2) : emitter.on(type2, listenerFn, context2);
  },
  /**
   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
   * seeks to be compatible with the DOM's `removeEventListener` with support for options.
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param type - The type of event the listener is bound to.
   * @param listener - The listener callback or object.
   * @param options - The original listener options. This is required to deregister a capture phase listener.
   */
  removeEventListener(type2, listener3, options) {
    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context2 = typeof listener3 == "function" ? void 0 : listener3;
    type2 = capture ? `${type2}capture` : type2, listener3 = typeof listener3 == "function" ? listener3 : listener3.handleEvent, this.off(type2, listener3, context2);
  },
  /**
   * Dispatch the event on this {@link PIXI.DisplayObject} using the event's {@link PIXI.EventBoundary}.
   *
   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
   *
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param e - The event to dispatch.
   * @returns Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.
   * @example
   * // Reuse a click event!
   * button.dispatchEvent(clickEvent);
   */
  dispatchEvent(e2) {
    if (!(e2 instanceof FederatedEvent))
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e2.defaultPrevented = false, e2.path = null, e2.target = this, e2.manager.dispatchEvent(e2), !e2.defaultPrevented;
  }
};
DisplayObject.mixin(FederatedDisplayObject);
const accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: false,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: false,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
const KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  // 2fps
  /**
   * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile.tablet || isMobile.phone) && this.createTouchHook();
    const div2 = document.createElement("div");
    div2.style.width = `${DIV_TOUCH_SIZE}px`, div2.style.height = `${DIV_TOUCH_SIZE}px`, div2.style.position = "absolute", div2.style.top = `${DIV_TOUCH_POS_X}px`, div2.style.left = `${DIV_TOUCH_POS_Y}px`, div2.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = div2, this.renderer = renderer, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @member {boolean}
   * @readonly
   */
  get isActive() {
    return this._isActive;
  }
  /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @member {boolean}
   * @readonly
   */
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  /**
   * Creates the touch hooks.
   * @private
   */
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`, hookDiv.style.height = `${DIV_HOOK_SIZE}px`, hookDiv.style.position = "absolute", hookDiv.style.top = `${DIV_HOOK_POS_X}px`, hookDiv.style.left = `${DIV_HOOK_POS_Y}px`, hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString(), hookDiv.style.backgroundColor = "#FF0000", hookDiv.title = "select to enable accessibility for this content", hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true, this.activate(), this.destroyTouchHook();
    }), document.body.appendChild(hookDiv), this._hookDiv = hookDiv;
  }
  /**
   * Destroys the touch hooks.
   * @private
   */
  destroyTouchHook() {
    this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }
  /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */
  activate() {
    this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div));
  }
  /**
   * Deactivating will cause the Accessibility layer to be hidden.
   * This is called when a user moves the mouse.
   * @private
   */
  deactivate() {
    !this._isActive || this._isMobileAccessibility || (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div));
  }
  /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {PIXI.Container} displayObject - The DisplayObject to check.
   */
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren)
      return;
    displayObject.accessible && displayObject.isInteractive() && (displayObject._accessibleActive || this.addChild(displayObject), displayObject.renderId = this.renderId);
    const children = displayObject.children;
    if (children)
      for (let i2 = 0; i2 < children.length; i2++)
        this.updateAccessibleObjects(children[i2]);
  }
  /**
   * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
   * @private
   */
  update() {
    const now = performance.now();
    if (isMobile.android.device && now < this.androidUpdateCount || (this.androidUpdateCount = now + this.androidUpdateFrequency, !this.renderer.renderingToScreen))
      return;
    this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    const { x: x2, y: y2, width, height } = this.renderer.view.getBoundingClientRect(), { width: viewWidth, height: viewHeight, resolution } = this.renderer, sx = width / viewWidth * resolution, sy = height / viewHeight * resolution;
    let div2 = this.div;
    div2.style.left = `${x2}px`, div2.style.top = `${y2}px`, div2.style.width = `${viewWidth}px`, div2.style.height = `${viewHeight}px`;
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (child.renderId !== this.renderId)
        child._accessibleActive = false, removeItems(this.children, i2, 1), this.div.removeChild(child._accessibleDiv), this.pool.push(child._accessibleDiv), child._accessibleDiv = null, i2--;
      else {
        div2 = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        child.hitArea ? (div2.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`, div2.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`, div2.style.width = `${hitArea.width * wt.a * sx}px`, div2.style.height = `${hitArea.height * wt.d * sy}px`) : (hitArea = child.getBounds(), this.capHitArea(hitArea), div2.style.left = `${hitArea.x * sx}px`, div2.style.top = `${hitArea.y * sy}px`, div2.style.width = `${hitArea.width * sx}px`, div2.style.height = `${hitArea.height * sy}px`, div2.title !== child.accessibleTitle && child.accessibleTitle !== null && (div2.title = child.accessibleTitle), div2.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null && div2.setAttribute("aria-label", child.accessibleHint)), (child.accessibleTitle !== div2.title || child.tabIndex !== div2.tabIndex) && (div2.title = child.accessibleTitle, div2.tabIndex = child.tabIndex, this.debug && this.updateDebugHTML(div2));
      }
    }
    this.renderId++;
  }
  /**
   * private function that will visually add the information to the
   * accessability div
   * @param {HTMLElement} div -
   */
  updateDebugHTML(div2) {
    div2.innerHTML = `type: ${div2.type}</br> title : ${div2.title}</br> tabIndex: ${div2.tabIndex}`;
  }
  /**
   * Adjust the hit area based on the bounds of a display object
   * @param {PIXI.Rectangle} hitArea - Bounds of the child
   */
  capHitArea(hitArea) {
    hitArea.x < 0 && (hitArea.width += hitArea.x, hitArea.x = 0), hitArea.y < 0 && (hitArea.height += hitArea.y, hitArea.y = 0);
    const { width: viewWidth, height: viewHeight } = this.renderer;
    hitArea.x + hitArea.width > viewWidth && (hitArea.width = viewWidth - hitArea.x), hitArea.y + hitArea.height > viewHeight && (hitArea.height = viewHeight - hitArea.y);
  }
  /**
   * Adds a DisplayObject to the accessibility manager
   * @private
   * @param {PIXI.DisplayObject} displayObject - The child to make accessible.
   */
  addChild(displayObject) {
    let div2 = this.pool.pop();
    div2 || (div2 = document.createElement("button"), div2.style.width = `${DIV_TOUCH_SIZE}px`, div2.style.height = `${DIV_TOUCH_SIZE}px`, div2.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", div2.style.position = "absolute", div2.style.zIndex = DIV_TOUCH_ZINDEX.toString(), div2.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? div2.setAttribute("aria-live", "off") : div2.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? div2.setAttribute("aria-relevant", "additions") : div2.setAttribute("aria-relevant", "text"), div2.addEventListener("click", this._onClick.bind(this)), div2.addEventListener("focus", this._onFocus.bind(this)), div2.addEventListener("focusout", this._onFocusOut.bind(this))), div2.style.pointerEvents = displayObject.accessiblePointerEvents, div2.type = displayObject.accessibleType, displayObject.accessibleTitle && displayObject.accessibleTitle !== null ? div2.title = displayObject.accessibleTitle : (!displayObject.accessibleHint || displayObject.accessibleHint === null) && (div2.title = `displayObject ${displayObject.tabIndex}`), displayObject.accessibleHint && displayObject.accessibleHint !== null && div2.setAttribute("aria-label", displayObject.accessibleHint), this.debug && this.updateDebugHTML(div2), displayObject._accessibleActive = true, displayObject._accessibleDiv = div2, div2.displayObject = displayObject, this.children.push(displayObject), this.div.appendChild(displayObject._accessibleDiv), displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */
  _dispatchEvent(e2, type2) {
    const { displayObject: target } = e2.target, boundry = this.renderer.events.rootBoundary, event = Object.assign(new FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered, type2.forEach((type22) => boundry.dispatchEvent(event, type22));
  }
  /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */
  _onClick(e2) {
    this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */
  _onFocus(e2) {
    e2.target.getAttribute("aria-live") || e2.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e2, ["mouseover"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */
  _onFocusOut(e2) {
    e2.target.getAttribute("aria-live") || e2.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e2, ["mouseout"]);
  }
  /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */
  _onKeyDown(e2) {
    e2.keyCode === KEY_CODE_TAB && this.activate();
  }
  /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */
  _onMouseMove(e2) {
    e2.movementX === 0 && e2.movementY === 0 || this.deactivate();
  }
  /** Destroys the accessibility manager */
  destroy() {
    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    ExtensionType.RendererPlugin,
    ExtensionType.CanvasRendererPlugin
  ]
};
extensions$1.add(AccessibilityManager);
const _Application = class _Application2 {
  /**
   * @param options - The optional application and renderer parameters.
   */
  constructor(options) {
    this.stage = new Container(), options = Object.assign({
      forceCanvas: false
    }, options), this.renderer = autoDetectRenderer(options), _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render(this.stage);
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {PIXI.ICanvas}
   * @readonly
   */
  get view() {
    return this.renderer?.view;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @member {PIXI.Rectangle}
   * @readonly
   */
  get screen() {
    return this.renderer?.screen;
  }
  /**
   * Destroy and don't use after this.
   * @param {boolean} [removeView=false] - Automatically remove canvas from DOM.
   * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'stageOptions' will be passed on to those calls.
   * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
   *  to true. Should it destroy the texture of the child sprite
   * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
   *  to true. Should it destroy the base texture of the child sprite
   */
  destroy(removeView, stageOptions) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse(), plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    }), this.stage.destroy(stageOptions), this.stage = null, this.renderer.destroy(removeView), this.renderer = null;
  }
};
_Application._plugins = [];
let Application = _Application;
extensions$1.handleByList(ExtensionType.Application, Application._plugins);
class ResizePlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    Object.defineProperty(
      this,
      "resizeTo",
      /**
       * The HTML element or window to automatically resize the
       * renderer's view element to match width and height.
       * @member {Window|HTMLElement}
       * @name resizeTo
       * @memberof PIXI.Application#
       */
      {
        set(dom2) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = dom2, dom2 && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = () => {
      this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
    }, this.cancelResize = () => {
      this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
    }, this.resize = () => {
      if (!this._resizeTo)
        return;
      this.cancelResize();
      let width, height;
      if (this._resizeTo === globalThis.window)
        width = globalThis.innerWidth, height = globalThis.innerHeight;
      else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth, height = clientHeight;
      }
      this.renderer.resize(width, height), this.render();
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = options.resizeTo || null;
  }
  /**
   * Clean up the ticker, scoped to application
   * @static
   * @private
   */
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }
}
ResizePlugin.extension = ExtensionType.Application;
extensions$1.add(ResizePlugin);
const assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions$1.handle(ExtensionType.Asset, (extension) => {
  const ref2 = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref2[key]).forEach(([key, type2]) => extensions$1.add(Object.assign(
    ref2[key],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: ref2[key].extension ?? type2 }
  )));
}, (extension) => {
  const ref2 = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref2[key]).forEach((key) => extensions$1.remove(ref2[key]));
});
class BackgroundLoader {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader, this._assetList = [], this._isLoading = false, this._maxConcurrent = 1, this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a2) => {
      this._assetList.push(a2);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [], toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i2 = 0; i2 < toLoadAmount; i2++)
        toLoad.push(this._assetList.pop());
      await this._loader.load(toLoad), this._isLoading = false, this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    this._isActive !== value && (this._isActive = value, value && !this._isLoading && this._next());
  }
}
function checkDataUrl(url2, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes)
      if (url2.startsWith(`data:${mime}`))
        return true;
    return false;
  }
  return url2.startsWith(`data:${mimes}`);
}
function checkExtension(url2, extension) {
  const tempURL = url2.split("?")[0], ext = path.extname(tempURL).toLowerCase();
  return Array.isArray(extension) ? extension.includes(ext) : ext === extension;
}
const convertToList = (input, transform2, forceTransform = false) => (Array.isArray(input) || (input = [input]), transform2 ? input.map((item) => typeof item == "string" || forceTransform ? transform2(item) : item) : input);
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  return searchParams && (targetUrl += `?${searchParams}`), targetUrl;
};
function processX(base, ids, depth, result, tags) {
  const id2 = ids[depth];
  for (let i2 = 0; i2 < id2.length; i2++) {
    const value = id2[i2];
    depth < ids.length - 1 ? processX(base.replace(result[depth], value), ids, depth + 1, result, tags) : tags.push(base.replace(result[depth], value));
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g, result = string.match(regex), tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    }), processX(string, ids, 0, result, tags);
  } else
    tags.push(string);
  return tags;
}
const isSingleItem = (item) => !Array.isArray(item);
class CacheClass {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(key) {
    return this._cache.has(key);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(key) {
    const result = this._cache.get(key);
    return result || console.warn(`[Assets] Asset id ${key} was not found in the Cache`), result;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(key, value) {
    const keys = convertToList(key);
    let cacheableAssets;
    for (let i2 = 0; i2 < this.parsers.length; i2++) {
      const parser = this.parsers[i2];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    cacheableAssets || (cacheableAssets = {}, keys.forEach((key2) => {
      cacheableAssets[key2] = value;
    }));
    const cacheKeys = Object.keys(cacheableAssets), cachedAssets = {
      cacheKeys,
      keys
    };
    if (keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    }), cacheKeys.forEach((key2) => {
      this._cache.has(key2) && this._cache.get(key2) !== value && console.warn("[Cache] already has key:", key2), this._cache.set(key2, cacheableAssets[key2]);
    }), value instanceof Texture) {
      const texture = value;
      keys.forEach((key2) => {
        texture.baseTexture !== Texture.EMPTY.baseTexture && BaseTexture.addToCache(texture.baseTexture, key2), Texture.addToCache(texture, key2);
      });
    }
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(key) {
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    cacheMap.cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    }), cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();
let Loader$1 = class Loader3 {
  constructor() {
    this._parsers = [], this._parsersValidated = false, this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => (this._parsersValidated = false, target[key] = value, true)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url2, data) {
    const result = {
      promise: null,
      parser: null
    };
    return result.promise = (async () => {
      let asset = null, parser = null;
      if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`)), !parser) {
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parserX = this.parsers[i2];
          if (parserX.load && parserX.test?.(url2, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser)
          return console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      asset = await parser.load(url2, data, this), result.parser = parser;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser2 = this.parsers[i2];
        parser2.parse && parser2.parse && await parser2.testParse?.(asset, data, this) && (asset = await parser2.parse(asset, data, this) || asset, result.parser = parser2);
      }
      return asset;
    })(), result;
  }
  async load(assetsToLoadIn, onProgress) {
    this._parsersValidated || this._validateParsers();
    let count = 0;
    const assets = {}, singleAsset = isSingleItem(assetsToLoadIn), assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item
    })), total = assetsToLoad.length, promises = assetsToLoad.map(async (asset) => {
      const url2 = path.toAbsolute(asset.src);
      if (!assets[asset.src])
        try {
          this.promiseCache[url2] || (this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset)), assets[asset.src] = await this.promiseCache[url2].promise, onProgress && onProgress(++count / total);
        } catch (e2) {
          throw delete this.promiseCache[url2], delete assets[asset.src], new Error(`[Loader.load] Failed to load ${url2}.
${e2}`);
        }
    });
    return await Promise.all(promises), singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const promises = convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    })).map(async (asset) => {
      const url2 = path.toAbsolute(asset.src), loadPromise = this.promiseCache[url2];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url2], loadPromise.parser?.unload?.(loadedAsset, asset, this);
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true, this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash2, parser) => (hash2[parser.name] && console.warn(`[Assets] loadParser name conflict "${parser.name}"`), { ...hash2, [parser.name]: parser }), {});
  }
};
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => (LoaderParserPriority2[LoaderParserPriority2.Low = 0] = "Low", LoaderParserPriority2[LoaderParserPriority2.Normal = 1] = "Normal", LoaderParserPriority2[LoaderParserPriority2.High = 2] = "High", LoaderParserPriority2))(LoaderParserPriority || {});
const validJSONExtension = ".json", validJSONMIME = "application/json", loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url2) {
    return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
  },
  async load(url2) {
    return await (await settings.ADAPTER.fetch(url2)).json();
  }
};
extensions$1.add(loadJson);
const validTXTExtension = ".txt", validTXTMIME = "text/plain", loadTxt = {
  name: "loadTxt",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  test(url2) {
    return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
  },
  async load(url2) {
    return await (await settings.ADAPTER.fetch(url2)).text();
  }
};
extensions$1.add(loadTxt);
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"], validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url2) {
  const ext = path.extname(url2), nameTokens = path.basename(url2, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token2 of nameTokens)
    if (!token2.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  let fontFamilyName = nameTokens.join(" ");
  return valid || (fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`), fontFamilyName;
}
const validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function encodeURIWhenNeeded(uri2) {
  return validURICharactersRegex.test(uri2) ? uri2 : encodeURI(uri2);
}
const loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url2) {
    return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
  },
  async load(url2, options) {
    const fonts2 = settings.ADAPTER.getFontFaceSet();
    if (fonts2) {
      const fontFaces = [], name2 = options.data?.family ?? getFontFamilyName(url2), weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"], data = options.data ?? {};
      for (let i2 = 0; i2 < weights.length; i2++) {
        const weight = weights[i2], font = new FontFace(name2, `url(${encodeURIWhenNeeded(url2)})`, {
          ...data,
          weight
        });
        await font.load(), fonts2.add(font), fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t2) => settings.ADAPTER.getFontFaceSet().delete(t2));
  }
};
extensions$1.add(loadWebFont);
const WORKER_CODE$1 = `(function() {
  "use strict";
  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  async function checkImageBitmap() {
    try {
      if (typeof createImageBitmap != "function")
        return !1;
      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap.width === 1 && imageBitmap.height === 1;
    } catch {
      return !1;
    }
  }
  checkImageBitmap().then((result) => {
    self.postMessage(result);
  });
})();
`;
let WORKER_URL$1 = null;
let WorkerInstance$1 = class WorkerInstance2 {
  constructor() {
    WORKER_URL$1 || (WORKER_URL$1 = URL.createObjectURL(new Blob([WORKER_CODE$1], { type: "application/javascript" }))), this.worker = new Worker(WORKER_URL$1);
  }
};
WorkerInstance$1.revokeObjectURL = function() {
  WORKER_URL$1 && (URL.revokeObjectURL(WORKER_URL$1), WORKER_URL$1 = null);
};
const WORKER_CODE = `(function() {
  "use strict";
  async function loadImageBitmap(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  self.onmessage = async (event) => {
    try {
      const imageBitmap = await loadImageBitmap(event.data.data[0]);
      self.postMessage({
        data: imageBitmap,
        uuid: event.data.uuid,
        id: event.data.id
      }, [imageBitmap]);
    } catch (e) {
      self.postMessage({
        error: e,
        uuid: event.data.uuid,
        id: event.data.id
      });
    }
  };
})();
`;
let WORKER_URL = null;
class WorkerInstance {
  constructor() {
    WORKER_URL || (WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }))), this.worker = new Worker(WORKER_URL);
  }
}
WorkerInstance.revokeObjectURL = function() {
  WORKER_URL && (URL.revokeObjectURL(WORKER_URL), WORKER_URL = null);
};
let UUID = 0, MAX_WORKERS;
class WorkerManagerClass {
  constructor() {
    this._initialized = false, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {};
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((resolve2) => {
      const { worker } = new WorkerInstance$1();
      worker.addEventListener("message", (event) => {
        worker.terminate(), WorkerInstance$1.revokeObjectURL(), resolve2(event.data);
      });
    }), this._isImageBitmapSupported);
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = true);
  }
  getWorker() {
    MAX_WORKERS === void 0 && (MAX_WORKERS = navigator.hardwareConcurrency || 4);
    let worker = this.workerPool.pop();
    return !worker && this._createdWorkers < MAX_WORKERS && (this._createdWorkers++, worker = new WorkerInstance().worker, worker.addEventListener("message", (event) => {
      this.complete(event.data), this.returnWorker(event.target), this.next();
    })), worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    data.error !== void 0 ? this.resolveHash[data.uuid].reject(data.error) : this.resolveHash[data.uuid].resolve(data.data), this.resolveHash[data.uuid] = null;
  }
  async _run(id2, args) {
    await this._initWorkers();
    const promise2 = new Promise((resolve2, reject2) => {
      this.queue.push({ id: id2, arguments: args, resolve: resolve2, reject: reject2 });
    });
    return this.next(), promise2;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker)
      return;
    const toDo = this.queue.pop(), id2 = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject }, worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id: id2
    });
  }
}
const WorkerManager = new WorkerManagerClass();
function createTexture$1(base, loader, url2) {
  base.resource.internal = true;
  const texture = new Texture(base), unload = () => {
    delete loader.promiseCache[url2], Cache.has(url2) && Cache.remove(url2);
  };
  return texture.baseTexture.once("destroyed", () => {
    url2 in loader.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."), unload());
  }), texture.once("destroyed", () => {
    base.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), unload());
  }), texture;
}
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"], validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url2) {
  const response = await settings.ADAPTER.fetch(url2);
  if (!response.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
  const imageBlob = await response.blob();
  return await createImageBitmap(imageBlob);
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url2) {
    return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
  },
  async load(url2, asset, loader) {
    const useImageBitmap = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
    let src;
    useImageBitmap ? this.config.preferWorkers && await WorkerManager.isImageBitmapSupported() ? src = await WorkerManager.loadImageBitmap(url2) : src = await loadImageBitmap(url2) : src = await new Promise((resolve2, reject2) => {
      const src2 = new Image();
      src2.crossOrigin = this.config.crossOrigin, src2.src = url2, src2.complete ? resolve2(src2) : (src2.onload = () => resolve2(src2), src2.onerror = (e2) => reject2(e2));
    });
    const options = { ...asset.data };
    options.resolution ?? (options.resolution = getResolutionOfUrl(url2)), useImageBitmap && options.resourceOptions?.ownsImageBitmap === void 0 && (options.resourceOptions = { ...options.resourceOptions }, options.resourceOptions.ownsImageBitmap = true);
    const base = new BaseTexture(src, options);
    return base.resource.src = url2, createTexture$1(base, loader, url2);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
extensions$1.add(loadTextures);
const validSVGExtension = ".svg", validSVGMIME = "image/svg+xml", loadSVG = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url2) {
    return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
  },
  async testParse(data) {
    return SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new BaseTexture(src, {
      resolution: getResolutionOfUrl(asset),
      ...data?.data
    });
    return base.resource.src = data.src, createTexture$1(base, loader, data.src);
  },
  async load(url2, _options) {
    return (await settings.ADAPTER.fetch(url2)).text();
  },
  unload: loadTextures.unload
};
extensions$1.add(loadSVG);
const validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogv"], validVideoMIMEs = [
  "video/mp4",
  "video/webm",
  "video/ogg"
], loadVideo = {
  name: "loadVideo",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    defaultAutoPlay: true,
    defaultUpdateFPS: 0,
    defaultLoop: false,
    defaultMuted: false,
    defaultPlaysinline: true
  },
  test(url2) {
    return checkDataUrl(url2, validVideoMIMEs) || checkExtension(url2, validVideoExtensions);
  },
  async load(url2, loadAsset, loader) {
    let texture;
    const blob = await (await settings.ADAPTER.fetch(url2)).blob(), blobURL = URL.createObjectURL(blob);
    try {
      const options = {
        autoPlay: this.config.defaultAutoPlay,
        updateFPS: this.config.defaultUpdateFPS,
        loop: this.config.defaultLoop,
        muted: this.config.defaultMuted,
        playsinline: this.config.defaultPlaysinline,
        ...loadAsset?.data?.resourceOptions,
        autoLoad: true
      }, src = new VideoResource(blobURL, options);
      await src.load();
      const base = new BaseTexture(src, {
        alphaMode: await detectVideoAlphaMode(),
        resolution: getResolutionOfUrl(url2),
        ...loadAsset?.data
      });
      base.resource.src = url2, texture = createTexture$1(base, loader, url2), texture.baseTexture.once("destroyed", () => {
        URL.revokeObjectURL(blobURL);
      });
    } catch (e2) {
      throw URL.revokeObjectURL(blobURL), e2;
    }
    return texture;
  },
  unload(texture) {
    texture.destroy(true);
  }
};
extensions$1.add(loadVideo);
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer), prefer.priority || (prefer.priority = Object.keys(prefer.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath2) {
    this._basePath = basePath2;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams == "string")
      this._defaultSearchParams = searchParams;
    else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, name: name2, src, srcs } = asset;
    return convertToList(
      alias || name2 || src || srcs,
      (value) => typeof value == "string" ? value : Array.isArray(value) ? value.map((v2) => v2?.src ?? v2?.srcs ?? v2) : value?.src || value?.srcs ? value.src ?? value.srcs : value,
      true
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = manifest, manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    Array.isArray(assets) ? assets.forEach((asset) => {
      const srcs = asset.src ?? asset.srcs, aliases = asset.alias ?? asset.name;
      let ids;
      if (typeof aliases == "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId), ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name2) => this._createBundleAssetId(bundleId, name2));
        assetNames.push(...bundleIds), ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        alias: ids,
        src: srcs
      });
    }) : Object.keys(assets).forEach((key) => {
      const aliases = [key, this._createBundleAssetId(bundleId, key)];
      if (typeof assets[key] == "string")
        this.add({
          alias: aliases,
          src: assets[key]
        });
      else if (Array.isArray(assets[key]))
        this.add({
          alias: aliases,
          src: assets[key]
        });
      else {
        const asset = assets[key], assetSrc = asset.src ?? asset.srcs;
        this.add({
          ...asset,
          alias: aliases,
          src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
        });
      }
      assetNames.push(...aliases);
    }), this._bundles[bundleId] = assetNames;
  }
  add(aliases, srcs, data, format2, loadParser) {
    const assets = [];
    typeof aliases == "string" || Array.isArray(aliases) && typeof aliases[0] == "string" ? (deprecation("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`), assets.push({ alias: aliases, src: srcs, data, format: format2, loadParser })) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);
    let keyCheck;
    keyCheck = (key) => {
      this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);
    }, convertToList(assets).forEach((asset) => {
      const { src, srcs: srcs2 } = asset;
      let { data: data2, format: format22, loadParser: loadParser2 } = asset;
      const srcsToUse = convertToList(src || srcs2).map((src2) => typeof src2 == "string" ? createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]), aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs3) => {
        srcs3.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 != "object") {
            formattedAsset.src = src2;
            for (let i2 = 0; i2 < this._parsers.length; i2++) {
              const parser = this._parsers[i2];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else
            data2 = src2.data ?? data2, format22 = src2.format ?? format22, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          if (!aliasesToUse)
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          formattedAsset = this.buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data: data2,
            format: format22,
            loadParser: loadParser2
          }), resolvedAssets.push(formattedAsset);
        });
      }), aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    return bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames), assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    }), singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key != "string") {
      const out = {};
      for (const i2 in result)
        out[i2] = result[i2].src;
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    return keys.forEach((key) => {
      if (!this._resolverHash[key])
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const bestAsset = assets[0], preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => asset[priorityKey] ? asset[priorityKey] === value : false);
              filteredAssets.length && (assets = filteredAssets);
            });
          }), this._resolverHash[key] = assets[0] ?? bestAsset;
        } else
          this._resolverHash[key] = this.buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
      result[key] = this._resolverHash[key];
    }), singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key) {
    return !!this._assetMap[key];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key) {
    return !!this._bundles[key];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i2 = 0; i2 < assets.length; i2++) {
      const asset = assets[0], preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred)
        return preferred;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url2) {
    if (!this._defaultSearchParams)
      return url2;
    const paramConnector = /\?/.test(url2) ? "&" : "?";
    return `${url2}${paramConnector}${this._defaultSearchParams}`;
  }
  buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, format: format2 } = data;
    return (this._basePath || this._rootPath) && (formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = { ...assetData || {}, ...formattedAsset.data }, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format2 ?? formattedAsset.format ?? path.extname(formattedAsset.src).slice(1), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;
  }
}
class AssetsClass {
  constructor() {
    this._detections = [], this._initialized = false, this.resolver = new Resolver(), this.loader = new Loader$1(), this.cache = Cache, this._backgroundLoader = new BackgroundLoader(this.loader), this._backgroundLoader.active = true, this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Asset class to work, only if you want to set any initial properties
   * @param options - options to initialize the Asset manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    if (this._initialized = true, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {
      let manifest = options.manifest;
      typeof manifest == "string" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == "number" ? [resolutionPref] : resolutionPref, formats2 = await this._detectFormats({
      preferredFormats: options.texturePreference?.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats2,
        resolution
      }
    }), options.preferences && this.setPreferences(options.preferences);
  }
  add(aliases, srcs, data, format2, loadParser) {
    this.resolver.add(aliases, srcs, data, format2, loadParser);
  }
  async load(urls, onProgress) {
    this._initialized || await this.init();
    const singleAsset = isSingleItem(urls), urlArray = convertToList(urls).map((url2) => {
      if (typeof url2 != "string") {
        const aliases = this.resolver.getAlias(url2);
        return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url2), Array.isArray(aliases) ? aliases[0] : aliases;
      }
      return this.resolver.hasKey(url2) || this.add({ alias: url2, src: url2 }), url2;
    }), resolveResults = this.resolver.resolve(urlArray), out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    this._initialized || await this.init();
    let singleAsset = false;
    typeof bundleIds == "string" && (singleAsset = true, bundleIds = [bundleIds]);
    const resolveResults = this.resolver.resolveBundle(bundleIds), out = {}, keys = Object.keys(resolveResults);
    let count = 0, total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    }, promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your inital load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    this._initialized || await this.init(), typeof urls == "string" && (urls = [urls]);
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    this._initialized || await this.init(), typeof bundleIds == "string" && (bundleIds = [bundleIds]);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = false;
  }
  get(keys) {
    if (typeof keys == "string")
      return Cache.get(keys);
    const assets = {};
    for (let i2 = 0; i2 < keys.length; i2++)
      assets[i2] = Cache.get(keys[i2]);
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    return resolveArray.forEach((resolveResult, i2) => {
      const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];
      resolveResult.alias && keys.push(...resolveResult.alias), out[resolveKeys[i2]] = asset, Cache.set(keys, asset);
    }), out;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    this._initialized || await this.init();
    const urlArray = convertToList(urls).map((url2) => typeof url2 != "string" ? url2.src : url2), resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    this._initialized || await this.init(), bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    }), await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats2 = [];
    options.preferredFormats && (formats2 = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);
    for (const detection of options.detections)
      options.skipDetections || await detection.test() ? formats2 = await detection.add(formats2) : options.skipDetections || (formats2 = await detection.remove(formats2));
    return formats2 = formats2.filter((format2, index) => formats2.indexOf(format2) === index), formats2;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * @deprecated since 7.2.0
   * @see {@link Assets.setPreferences}
   */
  get preferWorkers() {
    return loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({ preferWorkers: value });
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
extensions$1.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
const cacheTextureArray = {
  extension: ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    return keys.forEach((key) => {
      asset.forEach((item, i2) => {
        out[key + (i2 === 0 ? "" : i2 + 1)] = item;
      });
    }), out;
  }
};
extensions$1.add(cacheTextureArray);
async function testImageFormat(imageData) {
  if ("Image" in globalThis)
    return new Promise((resolve2) => {
      const image = new Image();
      image.onload = () => {
        resolve2(true);
      }, image.onerror = () => {
        resolve2(false);
      }, image.src = imageData;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch {
      return false;
    }
    return true;
  }
  return false;
}
const detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => testImageFormat(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (formats2) => [...formats2, "avif"],
  remove: async (formats2) => formats2.filter((f2) => f2 !== "avif")
};
extensions$1.add(detectAvif);
const detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testImageFormat(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (formats2) => [...formats2, "webp"],
  remove: async (formats2) => formats2.filter((f2) => f2 !== "webp")
};
extensions$1.add(detectWebp);
const imageFormats = ["png", "jpg", "jpeg"], detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats2) => [...formats2, ...imageFormats],
  remove: async (formats2) => formats2.filter((f2) => !imageFormats.includes(f2))
};
extensions$1.add(detectDefaults);
const inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function testVideoFormat(mimeType) {
  return inWorker ? false : document.createElement("video").canPlayType(mimeType) !== "";
}
const detectWebm = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/webm"),
  add: async (formats2) => [...formats2, "webm"],
  remove: async (formats2) => formats2.filter((f2) => f2 !== "webm")
};
extensions$1.add(detectWebm);
const detectMp4 = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/mp4"),
  add: async (formats2) => [...formats2, "mp4", "m4v"],
  remove: async (formats2) => formats2.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
};
extensions$1.add(detectMp4);
const detectOgv = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/ogg"),
  add: async (formats2) => [...formats2, "ogv"],
  remove: async (formats2) => formats2.filter((f2) => f2 !== "ogv")
};
extensions$1.add(detectOgv);
const resolveTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: path.extname(value).slice(1),
    src: value
  })
};
extensions$1.add(resolveTextureUrl);
var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => (INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", INTERNAL_FORMATS2))(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  // WEBGL_compressed_texture_s3tc
  33776: 0.5,
  33777: 0.5,
  33778: 1,
  33779: 1,
  // WEBGL_compressed_texture_s3tc
  35916: 0.5,
  35917: 0.5,
  35918: 1,
  35919: 1,
  // WEBGL_compressed_texture_etc
  37488: 0.5,
  37489: 0.5,
  37490: 1,
  37491: 1,
  37492: 0.5,
  37496: 1,
  37493: 0.5,
  37497: 1,
  37494: 0.5,
  // ~~
  37495: 0.5,
  // ~~
  // WEBGL_compressed_texture_pvrtc
  35840: 0.5,
  35842: 0.5,
  35841: 0.25,
  35843: 0.25,
  // WEBGL_compressed_texture_etc1
  36196: 0.5,
  // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
  // WEBGL_compressed_texture_atc
  35986: 0.5,
  35987: 1,
  34798: 1,
  // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
  // WEBGL_compressed_texture_astc
  /* eslint-disable-next-line camelcase */
  37808: 1,
  // @see https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_compression_bptc.txt
  // EXT_texture_compression_bptc
  36492: 1,
  36493: 1,
  36494: 1,
  36495: 1
};
let storedGl, extensions;
function getCompressedTextureExtensions() {
  extensions = {
    bptc: storedGl.getExtension("EXT_texture_compression_bptc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    /* eslint-disable-line camelcase */
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const gl2 = settings.ADAPTER.createCanvas().getContext("webgl");
    return gl2 ? (storedGl = gl2, true) : (console.warn("WebGL not available for compressed textures."), false);
  },
  add: async (formats2) => {
    extensions || getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions)
      extensions[extensionName] && textureFormats.push(extensionName);
    return [...textureFormats, ...formats2];
  },
  remove: async (formats2) => (extensions || getCompressedTextureExtensions(), formats2.filter((f2) => !(f2 in extensions)))
};
extensions$1.add(detectCompressedTextures);
class BlobResource extends BufferResource {
  /**
   * @param source - The buffer/URL of the texture file.
   * @param {PIXI.IBlobResourceOptions} [options]
   * @param {boolean} [options.autoLoad=false] - Whether to fetch the data immediately;
   *  you can fetch it later via {@link PIXI.BlobResource#load}.
   * @param {number} [options.width=1] - The width in pixels.
   * @param {number} [options.height=1] - The height in pixels.
   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.
   */
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin, data;
    typeof source == "string" ? (origin = source, data = new Uint8Array()) : (origin = null, data = source), super(data, options), this.origin = origin, this.buffer = data ? new ViewableBuffer(data) : null, this._load = null, this.loaded = false, this.origin !== null && options.autoLoad !== false && this.load(), this.origin === null && this.buffer && (this._load = Promise.resolve(this), this.loaded = true, this.onBlobLoaded(this.buffer.rawBinaryData));
  }
  onBlobLoaded(_data) {
  }
  /** Loads the blob */
  load() {
    return this._load ? this._load : (this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => (this.data = new Uint32Array(arrayBuffer), this.buffer = new ViewableBuffer(arrayBuffer), this.loaded = true, this.onBlobLoaded(arrayBuffer), this.update(), this)), this._load);
  }
}
class CompressedTextureResource extends BlobResource {
  /**
   * @param source - the buffer/URL holding the compressed texture data
   * @param options
   * @param {PIXI.INTERNAL_FORMATS} options.format - the compression format
   * @param {number} options.width - the image width in pixels.
   * @param {number} options.height - the image height in pixels.
   * @param {number} [options.level=1] - the mipmap levels stored in the compressed texture, including level 0.
   * @param {number} [options.levelBuffers] - the buffers for each mipmap level. `CompressedTextureResource` can allows you
   *      to pass `null` for `source`, for cases where each level is stored in non-contiguous memory.
   */
  constructor(source, options) {
    super(source, options), this.format = options.format, this.levels = options.levels || 1, this._width = options.width, this._height = options.height, this._extension = CompressedTextureResource._formatToExtension(this.format), (options.levelBuffers || this.buffer) && (this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(
      source instanceof Uint8Array ? source : this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      this.width,
      this.height
    ));
  }
  /**
   * @override
   * @param renderer - A reference to the current renderer
   * @param _texture - the texture
   * @param _glTexture - texture instance for this webgl context
   */
  upload(renderer, _texture, _glTexture) {
    const gl2 = renderer.gl;
    if (!renderer.context.extensions[this._extension])
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    if (!this._levelBuffers)
      return false;
    gl2.pixelStorei(gl2.UNPACK_ALIGNMENT, 4);
    for (let i2 = 0, j2 = this.levels; i2 < j2; i2++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i2];
      gl2.compressedTexImage2D(gl2.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  /** @protected */
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      this.width,
      this.height
    );
  }
  /**
   * Returns the key (to ContextSystem#extensions) for the WebGL extension supporting the compression format
   * @private
   * @param format - the compression format to get the extension for.
   */
  static _formatToExtension(format2) {
    if (format2 >= 33776 && format2 <= 33779)
      return "s3tc";
    if (format2 >= 35916 && format2 <= 35919)
      return "s3tc_sRGB";
    if (format2 >= 37488 && format2 <= 37497)
      return "etc";
    if (format2 >= 35840 && format2 <= 35843)
      return "pvrtc";
    if (format2 === 36196)
      return "etc1";
    if (format2 === 35986 || format2 === 35987 || format2 === 34798)
      return "atc";
    if (format2 >= 36492 && format2 <= 36495)
      return "bptc";
    if (format2 === 37808)
      return "astc";
    throw new Error(`Invalid (compressed) texture format given: ${format2}`);
  }
  /**
   * Pre-creates buffer views for each mipmap level
   * @private
   * @param buffer -
   * @param format - compression formats
   * @param levels - mipmap levels
   * @param blockWidth -
   * @param blockHeight -
   * @param imageWidth - width of the image in pixels
   * @param imageHeight - height of the image in pixels
   */
  static _createLevelBuffers(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset2 = buffer.byteOffset, levelWidth = imageWidth, levelHeight = imageHeight, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (let i2 = 0; i2 < levels; i2++)
      buffers[i2] = {
        levelID: i2,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset2, levelSize)
      }, offset2 += levelSize, levelWidth = levelWidth >> 1 || 1, levelHeight = levelHeight >> 1 || 1, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    return buffers;
  }
}
const DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
}, DXGI_TO_FORMAT = {
  // WEBGL_compressed_texture_s3tc
  70: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  71: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  73: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  74: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  76: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  77: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  // WEBGL_compressed_texture_s3tc_srgb
  72: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  75: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  78: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  // EXT_texture_compression_bptc
  // BC6H
  96: INTERNAL_FORMATS.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
  95: INTERNAL_FORMATS.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
  // BC7
  98: INTERNAL_FORMATS.COMPRESSED_RGBA_BPTC_UNORM_EXT,
  99: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  if (data[0] !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), height = header[DDS_FIELDS.HEIGHT], width = header[DDS_FIELDS.WIDTH], mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT], pixelFormat = new Uint32Array(
    arrayBuffer,
    DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
    DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT
  ), formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC], dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, texData = new Uint8Array(arrayBuffer, dataOffset2);
      return [new CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
        // CompressedTextureResource will separate the levelBuffers for us!
      })];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, dx10Header = new Uint32Array(
      data.buffer,
      dx10Offset,
      DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
    ), dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT], resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION], miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG], arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE], internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0)
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (resourceDimension === 6)
      throw new Error("DDSParser does not supported 3D texture data");
    const imageBuffers = new Array(), dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1)
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    else {
      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0, levelWidth = width, levelHeight = height;
      for (let i2 = 0; i2 < mipmapCount; i2++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & -4), alignedLevelHeight = Math.max(1, levelHeight + 3 & -4), levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize, levelWidth = levelWidth >>> 1, levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i2 = 0; i2 < arraySize; i2++)
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize)), imageOffset += imageSize;
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  throw formatFlags & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : formatFlags & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : formatFlags & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : formatFlags & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = {
  [TYPES.UNSIGNED_BYTE]: 1,
  [TYPES.UNSIGNED_SHORT]: 2,
  [TYPES.INT]: 4,
  [TYPES.UNSIGNED_INT]: 4,
  [TYPES.FLOAT]: 4,
  [TYPES.HALF_FLOAT]: 8
}, FORMATS_TO_COMPONENTS = {
  [FORMATS.RGBA]: 4,
  [FORMATS.RGB]: 3,
  [FORMATS.RG]: 2,
  [FORMATS.RED]: 1,
  [FORMATS.LUMINANCE]: 1,
  [FORMATS.LUMINANCE_ALPHA]: 2,
  [FORMATS.ALPHA]: 1
}, TYPES_TO_BYTES_PER_PIXEL = {
  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url2, dataView))
    return null;
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS, glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian), glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian), glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian), pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian), pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1, pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1, numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1, numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian), numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian), bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1)
    throw new Error("Only 2D textures are supported");
  if (numberOfFaces !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (numberOfArrayElements !== 1)
    throw new Error("WebGL does not support array textures");
  const blockWidth = 4, blockHeight = 4, alignedWidth = pixelWidth + 3 & -4, alignedHeight = pixelHeight + 3 & -4, imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  glType === 0 && (imagePixels = alignedWidth * alignedHeight);
  let imagePixelByteSize;
  if (glType !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[glType] ? imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat] : imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType] : imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat], imagePixelByteSize === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  let mipByteSize = imagePixels * imagePixelByteSize, mipWidth = pixelWidth, mipHeight = pixelHeight, alignedMipWidth = alignedWidth, alignedMipHeight = alignedHeight, imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      mips || (mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels)), mips[mipmapLevel] = {
        levelID: mipmapLevel,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      }, elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4, imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset, mipWidth = mipWidth >> 1 || 1, mipHeight = mipHeight >> 1 || 1, alignedMipWidth = mipWidth + blockWidth - 1 & -4, alignedMipHeight = mipHeight + blockHeight - 1 & -4, mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  return glType !== 0 ? {
    uncompressed: imageBuffers.map((levelBuffers) => {
      let buffer = levelBuffers[0].levelBuffer, convertToInt = false;
      return glType === TYPES.FLOAT ? buffer = new Float32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      ) : glType === TYPES.UNSIGNED_INT ? (convertToInt = true, buffer = new Uint32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      )) : glType === TYPES.INT && (convertToInt = true, buffer = new Int32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      )), {
        resource: new BufferResource(
          buffer,
          {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }
        ),
        type: glType,
        format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
      };
    }),
    kvData
  } : {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url2, dataView) {
  for (let i2 = 0; i2 < FILE_IDENTIFIER.length; i2++)
    if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2])
      return console.error(`${url2} is not a valid *.ktx file!`), false;
  return true;
}
function convertFormatToInteger(format2) {
  switch (format2) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format2;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  for (; bytesIntoKeyValueData < bytesOfKeyValueData; ) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian), keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4, valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize && dataView.getUint8(keyAndValueByteOffset + keyNulByte) !== 0; keyNulByte++)
      ;
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(
      new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte)
    ), value = new DataView(
      dataView.buffer,
      keyAndValueByteOffset + keyNulByte + 1,
      keyAndValueByteSize - keyNulByte - 1
    );
    kvData.set(key, value), bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
const loadDDS = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url2) {
    return checkExtension(url2, ".dds");
  },
  async load(url2, asset, loader) {
    const arrayBuffer = await (await settings.ADAPTER.fetch(url2)).arrayBuffer(), textures = parseDDS(arrayBuffer).map((resource) => {
      const base = new BaseTexture(resource, {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: getResolutionOfUrl(url2),
        ...asset.data
      });
      return createTexture$1(base, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    Array.isArray(texture) ? texture.forEach((t2) => t2.destroy(true)) : texture.destroy(true);
  }
};
extensions$1.add(loadDDS);
const loadKTX = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url2) {
    return checkExtension(url2, ".ktx");
  },
  async load(url2, asset, loader) {
    const arrayBuffer = await (await settings.ADAPTER.fetch(url2)).arrayBuffer(), { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer), resources = compressed ?? uncompressed, options = {
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: getResolutionOfUrl(url2),
      ...asset.data
    }, textures = resources.map((resource) => {
      resources === uncompressed && Object.assign(options, {
        type: resource.type,
        format: resource.format
      });
      const res = resource.resource ?? resource, base = new BaseTexture(res, options);
      return base.ktxKeyValueData = kvData, createTexture$1(base, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    Array.isArray(texture) ? texture.forEach((t2) => t2.destroy(true)) : texture.destroy(true);
  }
};
extensions$1.add(loadKTX);
const knownFormats = ["s3tc", "s3tc_sRGB", "etc", "etc1", "pvrtc", "atc", "astc", "bptc"], resolveCompressedTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value) => {
    const extension = path.extname(value).slice(1);
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const parts2 = value.split("."), extension = parts2.pop();
    if (["ktx", "dds"].includes(extension)) {
      const textureFormat = parts2.pop();
      if (knownFormats.includes(textureFormat))
        return {
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: textureFormat,
          src: value
        };
    }
    return {
      resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: extension,
      src: value
    };
  }
};
extensions$1.add(resolveCompressedTextureUrl);
const TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, _Extract = class _Extract2 {
  /**
   * @param renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.renderer = renderer, this._rendererPremultipliedAlpha = false;
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  /**
   * Will return a HTML Image of the target
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns - HTML Image of the target
   */
  async image(target, format2, quality, frame) {
    const image = new Image();
    return image.src = await this.base64(target, format2, quality, frame), image;
  }
  /**
   * Will return a base64 encoded string of this target. It works by calling
   *  `Extract.canvas` and then running toDataURL on that.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns - A base64 encoded string of the texture.
   */
  async base64(target, format2, quality, frame) {
    const canvas = this.canvas(target, frame);
    if (canvas.toBlob !== void 0)
      return new Promise((resolve2, reject2) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject2(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve2(reader.result), reader.onerror = reject2, reader.readAsDataURL(blob);
        }, format2, quality);
      });
    if (canvas.toDataURL !== void 0)
      return canvas.toDataURL(format2, quality);
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format2, quality });
      return new Promise((resolve2, reject2) => {
        const reader = new FileReader();
        reader.onload = () => resolve2(reader.result), reader.onerror = reject2, reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns - A Canvas element with the texture rendered on.
   */
  canvas(target, frame) {
    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
    flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels);
    const canvasBuffer = new CanvasRenderTarget(width, height, 1), imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    return canvasBuffer.context.putImageData(imageData, 0, 0), canvasBuffer.canvas;
  }
  /**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns - One-dimensional array containing the pixel data of the entire texture
   */
  pixels(target, frame) {
    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
    return flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels), pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer)
      throw new Error("The Extract has already been destroyed");
    let resolution, flipY = false, premultipliedAlpha = false, renderTexture, generated = false;
    target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {
      region: frame,
      resolution: renderer.resolution,
      multisample: renderer.multisample
    }), generated = true, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));
    const gl2 = renderer.gl;
    if (renderTexture) {
      if (resolution = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = false, premultipliedAlpha = renderTexture.baseTexture.alphaMode > 0 && renderTexture.baseTexture.format === FORMATS.RGBA, !generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);
      }
    } else
      resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution), flipY = true, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();
    const width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    return gl2.readPixels(
      Math.round(frame.x * resolution),
      Math.round(frame.y * resolution),
      width,
      height,
      gl2.RGBA,
      gl2.UNSIGNED_BYTE,
      pixels
    ), generated && renderTexture?.destroy(true), { pixels, width, height, flipY, premultipliedAlpha };
  }
  /** Destroys the extract. */
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w2 = width << 2, h2 = height >> 1, temp = new Uint8Array(w2);
    for (let y2 = 0; y2 < h2; y2++) {
      const t2 = y2 * w2, b2 = (height - y2 - 1) * w2;
      temp.set(pixels.subarray(t2, t2 + w2)), pixels.copyWithin(t2, b2, b2 + w2), pixels.set(temp, b2);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));
    const n2 = pixels.length;
    for (let i2 = 0; i2 < n2; i2 += 4) {
      const alpha = pixels[i2 + 3];
      if (alpha !== 0) {
        const a2 = 255.001 / alpha;
        pixels[i2] = pixels[i2] * a2 + 0.5, pixels[i2 + 1] = pixels[i2 + 1] * a2 + 0.5, pixels[i2 + 2] = pixels[i2 + 2] * a2 + 0.5;
      }
    }
  }
};
_Extract.extension = {
  name: "extract",
  type: ExtensionType.RendererSystem
};
let Extract = _Extract;
extensions$1.add(Extract);
const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x2, y2, dx, dy, rx, ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x2 = circle.x, y2 = circle.y, rx = ry = circle.radius, dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x2 = ellipse.x, y2 = ellipse.y, rx = ellipse.width, ry = ellipse.height, dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape, halfWidth = roundedRect.width / 2, halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth, y2 = roundedRect.y + halfHeight, rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight))), dx = halfWidth - rx, dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry)), m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (points.length = m2, m2 === 0)
      return;
    if (n2 === 0) {
      points.length = 8, points[0] = points[6] = x2 + dx, points[1] = points[3] = y2 + dy, points[2] = points[4] = x2 - dx, points[5] = points[7] = y2 - dy;
      return;
    }
    let j1 = 0, j2 = n2 * 4 + (dx ? 2 : 0) + 2, j3 = j2, j4 = m2;
    {
      const x0 = dx + rx, y0 = dy, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0;
      if (points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x22, dy) {
        const y22 = y2 - y0;
        points[j3++] = x22, points[j3++] = y22, points[--j4] = y22, points[--j4] = x1;
      }
    }
    for (let i2 = 1; i2 < n2; i2++) {
      const a2 = Math.PI / 2 * (i2 / n2), x0 = dx + Math.cos(a2) * rx, y0 = dy + Math.sin(a2) * ry, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0, y22 = y2 - y0;
      points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x22, points[j3++] = x22, points[j3++] = y22, points[--j4] = y22, points[--j4] = x1;
    }
    {
      const x0 = dx, y0 = dy + ry, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0, y22 = y2 - y0;
      points[j1++] = x1, points[j1++] = y1, points[--j4] = y22, points[--j4] = x1, dx && (points[j1++] = x22, points[j1++] = y1, points[--j4] = y22, points[--j4] = x22);
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points, verts = graphicsGeometry.points, indices3 = graphicsGeometry.indices;
    if (points.length === 0)
      return;
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x2, y2;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x2 = circle.x, y2 = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x2 = roundedRect.x + roundedRect.width / 2, y2 = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(
      graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2,
      graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2
    ), vertPos++, verts.push(points[0], points[1]);
    for (let i2 = 2; i2 < points.length; i2 += 2)
      verts.push(points[i2], points[i2 + 1]), indices3.push(vertPos++, center, vertPos);
    indices3.push(center + 1, center, vertPos);
  }
};
function fixOrientation(points, hole = false) {
  const m2 = points.length;
  if (m2 < 6)
    return;
  let area2 = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    const x2 = points[i2], y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1), x1 = x2, y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    const n2 = m2 / 2;
    for (let i2 = n2 + n2 % 2; i2 < m2; i2 += 2) {
      const i1 = m2 - i2 - 2, i22 = m2 - i2 - 1, i3 = i2, i4 = i2 + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]], [points[i22], points[i4]] = [points[i4], points[i22]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes, verts = graphicsGeometry.points, indices3 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i2 = 0; i2 < holes.length; i2++) {
        const hole = holes[i2];
        fixOrientation(hole.points, true), holeArray.push(points.length / 2), points = points.concat(hole.points);
      }
      const triangles = earcut$1(points, holeArray, 2);
      if (!triangles)
        return;
      const vertPos = verts.length / 2;
      for (let i2 = 0; i2 < triangles.length; i2 += 3)
        indices3.push(triangles[i2] + vertPos), indices3.push(triangles[i2 + 1] + vertPos), indices3.push(triangles[i2 + 2] + vertPos);
      for (let i2 = 0; i2 < points.length; i2++)
        verts.push(points[i2]);
    }
  }
};
const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape, x2 = rectData.x, y2 = rectData.y, width = rectData.width, height = rectData.height, points = graphicsData.points;
    points.length = 0, width >= 0 && height >= 0 && points.push(
      x2,
      y2,
      x2 + width,
      y2,
      x2 + width,
      y2 + height,
      x2,
      y2 + height
    );
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points, verts = graphicsGeometry.points;
    if (points.length === 0)
      return;
    const vertPos = verts.length / 2;
    verts.push(
      points[0],
      points[1],
      points[2],
      points[3],
      points[6],
      points[7],
      points[4],
      points[5]
    ), graphicsGeometry.indices.push(
      vertPos,
      vertPos + 1,
      vertPos + 2,
      vertPos + 1,
      vertPos + 2,
      vertPos + 3
    );
  }
};
const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};
var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => (LINE_JOIN2.MITER = "miter", LINE_JOIN2.BEVEL = "bevel", LINE_JOIN2.ROUND = "round", LINE_JOIN2))(LINE_JOIN || {}), LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => (LINE_CAP2.BUTT = "butt", LINE_CAP2.ROUND = "round", LINE_CAP2.SQUARE = "square", LINE_CAP2))(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length2, defaultSegments = 20) {
    if (!this.adaptive || !length2 || isNaN(length2))
      return defaultSegments;
    let result = Math.ceil(length2 / this.maxLength);
    return result < this.minSegments ? result = this.minSegments : result > this.maxSegments && (result = this.maxSegments), result;
  }
};
class ArcUtils {
  /**
   * Calculate information of the arc for {@link PIXI.Graphics.arcTo}.
   * @private
   * @param x1 - The x-coordinate of the first control point of the arc
   * @param y1 - The y-coordinate of the first control point of the arc
   * @param x2 - The x-coordinate of the second control point of the arc
   * @param y2 - The y-coordinate of the second control point of the arc
   * @param radius - The radius of the arc
   * @param points - Collection of points to add to
   * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.
   */
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2], a1 = points[points.length - 1] - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0)
      return (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) && points.push(x1, y1), null;
    const dd2 = a1 * a1 + b1 * b1, cc2 = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd2) / mm, k2 = radius * Math.sqrt(cc2) / mm, j1 = k1 * tt / dd2, j2 = k2 * tt / cc2, cx2 = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx2), endAngle = Math.atan2(qy - cy, qx - cx2);
    return {
      cx: cx2 + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  /**
   * The arc method creates an arc/curve (used to create circles, or parts of circles).
   * @private
   * @param _startX - Start x location of arc
   * @param _startY - Start y location of arc
   * @param cx - The x-coordinate of the center of the circle
   * @param cy - The y-coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position
   *  of the arc's circle)
   * @param endAngle - The ending angle, in radians
   * @param _anticlockwise - Specifies whether the drawing should be
   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
   *  indicates counter-clockwise.
   * @param points - Collection of points to add to
   */
  static arc(_startX, _startY, cx2, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle, n2 = curves._segmentsCount(
      Math.abs(sweep) * radius,
      Math.ceil(Math.abs(sweep) / PI_2) * 40
    ), theta = sweep / (n2 * 2), theta2 = theta * 2, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = n2 - 1, remainder = segMinus % 1 / segMinus;
    for (let i2 = 0; i2 <= segMinus; ++i2) {
      const real = i2 + remainder * i2, angle = theta + startAngle + theta2 * real, c2 = Math.cos(angle), s2 = -Math.sin(angle);
      points.push(
        (cTheta * c2 + sTheta * s2) * radius + cx2,
        (cTheta * -s2 + sTheta * c2) * radius + cy
      );
    }
  }
}
class BatchPart {
  constructor() {
    this.reset();
  }
  /**
   * Begin batch part.
   * @param style
   * @param startIndex
   * @param attribStart
   */
  begin(style, startIndex, attribStart) {
    this.reset(), this.style = style, this.start = startIndex, this.attribStart = attribStart;
  }
  /**
   * End batch part.
   * @param endIndex
   * @param endAttrib
   */
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart, this.size = endIndex - this.start;
  }
  reset() {
    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
  }
}
class BezierUtils {
  /**
   * Calculate length of bezier curve.
   * Analytical solution is impossible, since it involves an integral that does not integrate in general.
   * Therefore numerical solution is used.
   * @private
   * @param fromX - Starting point x
   * @param fromY - Starting point y
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns - Length of bezier curve
   */
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    let result = 0, t2 = 0, t22 = 0, t3 = 0, nt = 0, nt2 = 0, nt3 = 0, x2 = 0, y2 = 0, dx = 0, dy = 0, prevX = fromX, prevY = fromY;
    for (let i2 = 1; i2 <= 10; ++i2)
      t2 = i2 / 10, t22 = t2 * t2, t3 = t22 * t2, nt = 1 - t2, nt2 = nt * nt, nt3 = nt2 * nt, x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX, y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY, dx = prevX - x2, dy = prevY - y2, prevX = x2, prevY = y2, result += Math.sqrt(dx * dx + dy * dy);
    return result;
  }
  /**
   * Calculate the points for a bezier curve and then draws it.
   *
   * Ignored from docs since it is not directly exposed.
   * @ignore
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @param points - Path array to push points into
   */
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2], fromY = points[points.length - 1];
    points.length -= 2;
    const n2 = curves._segmentsCount(
      BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)
    );
    let dt = 0, dt2 = 0, dt3 = 0, t2 = 0, t3 = 0;
    points.push(fromX, fromY);
    for (let i2 = 1, j2 = 0; i2 <= n2; ++i2)
      j2 = i2 / n2, dt = 1 - j2, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j2 * j2, t3 = t2 * j2, points.push(
        dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
        dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY
      );
  }
}
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight, iy = y2 - ny * innerWeight, ox = x2 + nx * outerWeight, oy = y2 + ny * outerWeight;
  let exx, eyy;
  clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);
  const eix = ix + exx, eiy = iy + eyy, eox = ox + exx, eoy = oy + eyy;
  return verts.push(
    eix,
    eiy,
    eox,
    eoy
  ), 2;
}
function round(cx2, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx2, cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y), angle1 = Math.atan2(ex - cx2, ey - cy);
  clockwise && angle0 < angle1 ? angle0 += Math.PI * 2 : !clockwise && angle0 > angle1 && (angle1 += Math.PI * 2);
  let startAngle = angle0;
  const angleDiff = angle1 - angle0, absAngleDiff = Math.abs(angleDiff), radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y), segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1, angleInc = angleDiff / segCount;
  if (startAngle += angleInc, clockwise) {
    verts.push(
      cx2,
      cy,
      sx,
      sy
    );
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc)
      verts.push(
        cx2,
        cy,
        cx2 + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    verts.push(
      cx2,
      cy,
      ex,
      ey
    );
  } else {
    verts.push(
      sx,
      sy,
      cx2,
      cy
    );
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc)
      verts.push(
        cx2 + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius,
        cx2,
        cy
      );
    verts.push(
      ex,
      ey,
      cx2,
      cy
    );
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0)
    return;
  const style = graphicsData.lineStyle, firstPoint = new Point(points[0], points[1]), lastPoint = new Point(points[points.length - 2], points[points.length - 1]), closedShape = shape.type !== SHAPES.POLY || shape.closeStroke, closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1]));
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5, midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points, length2 = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2, width = style.width / 2, widthSquared = width * width, miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0], y0 = points[1], x1 = points[2], y1 = points[3], x2 = 0, y2 = 0, perpx = -(y0 - y1), perpy = x0 - x1, perp1x = 0, perp1y = 0, dist2 = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist2, perpy /= dist2, perpx *= width, perpy *= width;
  const ratio = style.alignment, innerWeight = (1 - ratio) * 2, outerWeight = ratio * 2;
  closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(
    x0 - perpx * (innerWeight - outerWeight) * 0.5,
    y0 - perpy * (innerWeight - outerWeight) * 0.5,
    x0 - perpx * innerWeight,
    y0 - perpy * innerWeight,
    x0 + perpx * outerWeight,
    y0 + perpy * outerWeight,
    verts,
    true
  ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts))), verts.push(
    x0 - perpx * innerWeight,
    y0 - perpy * innerWeight,
    x0 + perpx * outerWeight,
    y0 + perpy * outerWeight
  );
  for (let i2 = 1; i2 < length2 - 1; ++i2) {
    x0 = points[(i2 - 1) * 2], y0 = points[(i2 - 1) * 2 + 1], x1 = points[i2 * 2], y1 = points[i2 * 2 + 1], x2 = points[(i2 + 1) * 2], y2 = points[(i2 + 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist2 = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist2, perpy /= dist2, perpx *= width, perpy *= width, perp1x = -(y1 - y2), perp1y = x1 - x2, dist2 = Math.sqrt(perp1x * perp1x + perp1y * perp1y), perp1x /= dist2, perp1y /= dist2, perp1x *= width, perp1y *= width;
    const dx0 = x1 - x0, dy0 = y0 - y1, dx1 = x1 - x2, dy1 = y2 - y1, dot = dx0 * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dx0, clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        x1 + perpx * outerWeight,
        y1 + perpy * outerWeight
      ), dot >= 0 && (style.join === LINE_JOIN.ROUND ? indexCount += round(
        x1,
        y1,
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        x1 - perp1x * innerWeight,
        y1 - perp1y * innerWeight,
        verts,
        false
      ) + 4 : indexCount += 2, verts.push(
        x1 - perp1x * outerWeight,
        y1 - perp1y * outerWeight,
        x1 + perp1x * innerWeight,
        y1 + perp1y * innerWeight
      ));
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0), c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2), px = (dx0 * c2 - dx1 * c1) / cross, py = (dy1 * c1 - dy0 * c2) / cross, pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1), imx = x1 + (px - x1) * innerWeight, imy = y1 + (py - y1) * innerWeight, omx = x1 - (px - x1) * outerWeight, omy = y1 - (py - y1) * outerWeight, smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1), insideWeight = clockwise ? innerWeight : outerWeight, smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared, insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared && (join = LINE_JOIN.BEVEL), insideMiterOk)
      switch (join) {
        case LINE_JOIN.MITER: {
          verts.push(
            imx,
            imy,
            omx,
            omy
          );
          break;
        }
        case LINE_JOIN.BEVEL: {
          clockwise ? verts.push(
            imx,
            imy,
            // inner miter point
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            // first segment's outer vertex
            imx,
            imy,
            // inner miter point
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight
          ) : verts.push(
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            // first segment's inner vertex
            omx,
            omy,
            // outer miter point
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            // second segment's outer vertex
            omx,
            omy
          ), indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          clockwise ? (verts.push(
            imx,
            imy,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight
          ), indexCount += round(
            x1,
            y1,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4, verts.push(
            imx,
            imy,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight
          )) : (verts.push(
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            omx,
            omy
          ), indexCount += round(
            x1,
            y1,
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4, verts.push(
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            omx,
            omy
          ));
          break;
        }
      }
    else {
      switch (verts.push(
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        // first segment's inner vertex
        x1 + perpx * outerWeight,
        y1 + perpy * outerWeight
      ), join) {
        case LINE_JOIN.MITER: {
          clockwise ? verts.push(
            omx,
            omy,
            // inner miter point
            omx,
            omy
          ) : verts.push(
            imx,
            imy,
            // outer miter point
            imx,
            imy
          ), indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          clockwise ? indexCount += round(
            x1,
            y1,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2 : indexCount += round(
            x1,
            y1,
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
          break;
        }
      }
      verts.push(
        x1 - perp1x * innerWeight,
        y1 - perp1y * innerWeight,
        // second segment's inner vertex
        x1 + perp1x * outerWeight,
        y1 + perp1y * outerWeight
      ), indexCount += 2;
    }
  }
  x0 = points[(length2 - 2) * 2], y0 = points[(length2 - 2) * 2 + 1], x1 = points[(length2 - 1) * 2], y1 = points[(length2 - 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist2 = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist2, perpy /= dist2, perpx *= width, perpy *= width, verts.push(
    x1 - perpx * innerWeight,
    y1 - perpy * innerWeight,
    x1 + perpx * outerWeight,
    y1 + perpy * outerWeight
  ), closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(
    x1 - perpx * (innerWeight - outerWeight) * 0.5,
    y1 - perpy * (innerWeight - outerWeight) * 0.5,
    x1 - perpx * innerWeight,
    y1 - perpy * innerWeight,
    x1 + perpx * outerWeight,
    y1 + perpy * outerWeight,
    verts,
    false
  ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts)));
  const indices3 = graphicsGeometry.indices, eps2 = curves.epsilon * curves.epsilon;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2)
    x0 = verts[i2 * 2], y0 = verts[i2 * 2 + 1], x1 = verts[(i2 + 1) * 2], y1 = verts[(i2 + 1) * 2 + 1], x2 = verts[(i2 + 2) * 2], y2 = verts[(i2 + 2) * 2 + 1], !(Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) && indices3.push(i2, i2 + 1, i2 + 2);
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i2 = 0;
  const shape = graphicsData.shape, points = graphicsData.points || shape.points, closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points, indices3 = graphicsGeometry.indices, length2 = points.length / 2, startIndex = verts.length / 2;
  let currentIndex = startIndex;
  for (verts.push(points[0], points[1]), i2 = 1; i2 < length2; i2++)
    verts.push(points[i2 * 2], points[i2 * 2 + 1]), indices3.push(currentIndex, currentIndex + 1), currentIndex++;
  closedShape && indices3.push(currentIndex, startIndex);
}
function buildLine(graphicsData, graphicsGeometry) {
  graphicsData.lineStyle.native ? buildNativeLine(graphicsData, graphicsGeometry) : buildNonNativeLine(graphicsData, graphicsGeometry);
}
class QuadraticUtils {
  /**
   * Calculate length of quadratic curve
   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
   * for the detailed explanation of math behind this.
   * @private
   * @param fromX - x-coordinate of curve start point
   * @param fromY - y-coordinate of curve start point
   * @param cpX - x-coordinate of curve control point
   * @param cpY - y-coordinate of curve control point
   * @param toX - x-coordinate of curve end point
   * @param toY - y-coordinate of curve end point
   * @returns - Length of quadratic curve
   */
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX, ay = fromY - 2 * cpY + toY, bx = 2 * cpX - 2 * fromX, by = 2 * cpY - 2 * fromY, a2 = 4 * (ax * ax + ay * ay), b2 = 4 * (ax * bx + ay * by), c2 = bx * bx + by * by, s2 = 2 * Math.sqrt(a2 + b2 + c2), a22 = Math.sqrt(a2), a32 = 2 * a2 * a22, c22 = 2 * Math.sqrt(c2), ba = b2 / a22;
    return (a32 * s2 + a22 * b2 * (s2 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba + s2) / (ba + c22))) / (4 * a32);
  }
  /**
   * Calculate the points for a quadratic bezier curve and then draws it.
   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
   * @private
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @param points - Points to add segments to.
   */
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2], fromY = points[points.length - 1], n2 = curves._segmentsCount(
      QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)
    );
    let xa = 0, ya2 = 0;
    for (let i2 = 1; i2 <= n2; ++i2) {
      const j2 = i2 / n2;
      xa = fromX + (cpX - fromX) * j2, ya2 = fromY + (cpY - fromY) * j2, points.push(
        xa + (cpX + (toX - cpX) * j2 - xa) * j2,
        ya2 + (cpY + (toY - cpY) * j2 - ya2) * j2
      );
    }
  }
}
const FILL_COMMANDS = {
  [SHAPES.POLY]: buildPoly,
  [SHAPES.CIRC]: buildCircle,
  [SHAPES.ELIP]: buildCircle,
  [SHAPES.RECT]: buildRectangle,
  [SHAPES.RREC]: buildRoundedRectangle
}, BATCH_POOL = [], DRAW_CALL_POOL = [];
class GraphicsData {
  /**
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param fillStyle - the width of the line to draw
   * @param lineStyle - the color of the line to draw
   * @param matrix - Transform matrix
   */
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [], this.holes = [], this.shape = shape, this.lineStyle = lineStyle, this.fillStyle = fillStyle, this.matrix = matrix, this.type = shape.type;
  }
  /**
   * Creates a new GraphicsData object with the same values as this one.
   * @returns - Cloned GraphicsData object
   */
  clone() {
    return new GraphicsData(
      this.shape,
      this.fillStyle,
      this.lineStyle,
      this.matrix
    );
  }
  /** Destroys the Graphics data. */
  destroy() {
    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
  }
}
const tmpPoint = new Point(), _GraphicsGeometry = class _GraphicsGeometry2 extends BatchGeometry {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = false, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new Bounds(), this.boundsDirty = -1;
  }
  /**
   * Get the current bounds of the graphic geometry.
   *
   * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.
   * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered
   * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}
   * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.
   * @readonly
   */
  get bounds() {
    return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
  }
  /** Call if you changed graphicsData manually. Empties all batch buffers. */
  invalidate() {
    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++)
      this.drawCalls[i2].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i2]);
    this.drawCalls.length = 0;
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const batchPart = this.batches[i2];
      batchPart.reset(), BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  /**
   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
   * @returns - This GraphicsGeometry object. Good for chaining method calls
   */
  clear() {
    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
  }
  /**
   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param fillStyle - Defines style of the fill.
   * @param lineStyle - Defines style of the lines.
   * @param matrix - Transform applied to the points of the shape.
   * @returns - Returns geometry for chaining.
   */
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    return this.graphicsData.push(data), this.dirty++, this;
  }
  /**
   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param matrix - Transform applied to the points of the shape.
   * @returns - Returns geometry for chaining.
   */
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length)
      return null;
    const data = new GraphicsData(shape, null, null, matrix), lastShape = this.graphicsData[this.graphicsData.length - 1];
    return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, this;
  }
  /** Destroys the GraphicsGeometry object. */
  destroy() {
    super.destroy();
    for (let i2 = 0; i2 < this.graphicsData.length; ++i2)
      this.graphicsData[i2].destroy();
    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i2 = 0; i2 < graphicsData.length; ++i2) {
      const data = graphicsData[i2];
      if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {
        let hitHole = false;
        if (data.holes) {
          for (let i22 = 0; i22 < data.holes.length; i22++)
            if (data.holes[i22].shape.contains(tmpPoint.x, tmpPoint.y)) {
              hitHole = true;
              break;
            }
        }
        if (!hitHole)
          return true;
      }
    }
    return false;
  }
  /**
   * Generates intermediate batch data. Either gets converted to drawCalls
   * or used to convert to batch objects directly by the Graphics object.
   */
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching())
      return;
    this.cacheDirty = this.dirty;
    const uvs = this.uvs, graphicsData = this.graphicsData;
    let batchPart = null, currentStyle = null;
    this.batches.length > 0 && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);
    for (let i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
      this.shapeIndex++;
      const data = graphicsData[i2], fillStyle = data.fillStyle, lineStyle = data.lineStyle;
      FILL_COMMANDS[data.type].build(data), data.matrix && this.transformPoints(data.points, data.matrix), (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);
      for (let j2 = 0; j2 < 2; j2++) {
        const style = j2 === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture, index2 = this.indices.length, attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT, j2 === 0 ? this.processFill(data) : this.processLine(data);
        const size2 = this.points.length / 2 - attribIndex;
        size2 !== 0 && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = BATCH_POOL.pop() || new BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix));
      }
    }
    const index = this.indices.length, attrib = this.points.length / 2;
    if (batchPart && batchPart.end(index, attrib), this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
  }
  /**
   * Affinity check
   * @param styleA
   * @param styleB
   */
  _compareStyles(styleA, styleB) {
    return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);
  }
  /** Test geometry for batching process. */
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length)
      return false;
    for (let i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
      const data = this.graphicsData[i2], fill = data.fillStyle, line2 = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid || line2 && !line2.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  /** Offset the indices so that it works with the batcher. */
  packBatches() {
    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i2 = 0, l2 = batches.length; i2 < l2; i2++) {
      const batch = batches[i2];
      for (let j2 = 0; j2 < batch.size; j2++) {
        const index = batch.start + j2;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  /**
   * Checks to see if this graphics geometry can be batched.
   * Currently it needs to be small enough and not contain any native lines.
   */
  isBatchable() {
    if (this.points.length > 65535 * 2)
      return false;
    const batches = this.batches;
    for (let i2 = 0; i2 < batches.length; i2++)
      if (batches[i2].style.native)
        return false;
    return this.points.length < _GraphicsGeometry2.BATCHABLE_SIZE * 2;
  }
  /** Converts intermediate batches data to drawCalls. */
  buildDrawCalls() {
    let TICK = ++BaseTexture._globalBatch;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++)
      this.drawCalls[i2].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i2]);
    this.drawCalls.length = 0;
    const colors2 = this.colors, textureIds = this.textureIds;
    let currentGroup = DRAW_CALL_POOL.pop();
    currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), currentGroup.texArray.count = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = DRAW_MODES.TRIANGLES;
    let textureCount = 0, currentTexture = null, textureId = 0, native = false, drawMode = DRAW_MODES.TRIANGLES, index = 0;
    this.drawCalls.push(currentGroup);
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const data = this.batches[i2], maxTextures = 8, style = data.style, nextTexture = style.texture.baseTexture;
      native !== !!style.native && (native = !!style.native, drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = maxTextures, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture, nextTexture._batchEnabled !== TICK && (textureCount === maxTextures && (TICK++, textureCount = 0, currentGroup.size > 0 && (currentGroup = DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._batchLocation = textureCount, nextTexture.wrapMode = WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture, textureCount++)), currentGroup.size += data.size, index += data.size, textureId = nextTexture._batchLocation, this.addColors(colors2, style.color, style.alpha, data.attribSize, data.attribStart), this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK, this.packAttributes();
  }
  /** Packs attributes to single buffer. */
  packAttributes() {
    const verts = this.points, uvs = this.uvs, colors2 = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(verts.length * 3 * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);
    let p2 = 0;
    for (let i2 = 0; i2 < verts.length / 2; i2++)
      f32[p2++] = verts[i2 * 2], f32[p2++] = verts[i2 * 2 + 1], f32[p2++] = uvs[i2 * 2], f32[p2++] = uvs[i2 * 2 + 1], u32[p2++] = colors2[i2], f32[p2++] = textureIds[i2];
    this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16);
  }
  /**
   * Process fill part of Graphics.
   * @param data
   */
  processFill(data) {
    data.holes.length ? buildPoly.triangulate(data, this) : FILL_COMMANDS[data.type].triangulate(data, this);
  }
  /**
   * Process line part of Graphics.
   * @param data
   */
  processLine(data) {
    buildLine(data, this);
    for (let i2 = 0; i2 < data.holes.length; i2++)
      buildLine(data.holes[i2], this);
  }
  /**
   * Process the holes data.
   * @param holes
   */
  processHoles(holes) {
    for (let i2 = 0; i2 < holes.length; i2++) {
      const hole = holes[i2];
      FILL_COMMANDS[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix);
    }
  }
  /** Update the local bounds of the object. Expensive to use performance-wise. */
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear(), bounds.addVertexData(this.points, 0, this.points.length), bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  /**
   * Transform points using matrix.
   * @param points - Points to transform
   * @param matrix - Transform matrix
   */
  transformPoints(points, matrix) {
    for (let i2 = 0; i2 < points.length / 2; i2++) {
      const x2 = points[i2 * 2], y2 = points[i2 * 2 + 1];
      points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx, points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
    }
  }
  /**
   * Add colors.
   * @param colors - List of colors to add to
   * @param color - Color to add
   * @param alpha - Alpha to use
   * @param size - Number of colors to add
   * @param offset
   */
  addColors(colors2, color, alpha, size2, offset2 = 0) {
    const bgr = Color.shared.setValue(color).toLittleEndianNumber(), result = Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors2.length = Math.max(colors2.length, offset2 + size2);
    for (let i2 = 0; i2 < size2; i2++)
      colors2[offset2 + i2] = result;
  }
  /**
   * Add texture id that the shader/fragment wants to use.
   * @param textureIds
   * @param id
   * @param size
   * @param offset
   */
  addTextureIds(textureIds, id2, size2, offset2 = 0) {
    textureIds.length = Math.max(textureIds.length, offset2 + size2);
    for (let i2 = 0; i2 < size2; i2++)
      textureIds[offset2 + i2] = id2;
  }
  /**
   * Generates the UVs for a shape.
   * @param verts - Vertices
   * @param uvs - UVs
   * @param texture - Reference to Texture
   * @param start - Index buffer start index.
   * @param size - The size/length for index buffer.
   * @param matrix - Optional transform for all points.
   */
  addUvs(verts, uvs, texture, start, size2, matrix = null) {
    let index = 0;
    const uvsStart = uvs.length, frame = texture.frame;
    for (; index < size2; ) {
      let x2 = verts[(start + index) * 2], y2 = verts[(start + index) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty, x2 = nx;
      }
      index++, uvs.push(x2 / frame.width, y2 / frame.height);
    }
    const baseTexture = texture.baseTexture;
    (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size2);
  }
  /**
   * Modify uvs array according to position of texture region
   * Does not work with rotated or trimmed textures
   * @param uvs - array
   * @param texture - region
   * @param start - starting index for uvs
   * @param size - how many points to adjust
   */
  adjustUvs(uvs, texture, start, size2) {
    const baseTexture = texture.baseTexture, eps = 1e-6, finish = start + size2 * 2, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + eps), minY = Math.floor(uvs[start + 1] + eps);
    for (let i2 = start + 2; i2 < finish; i2 += 2)
      minX = Math.min(minX, Math.floor(uvs[i2] + eps)), minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
    offsetX -= minX, offsetY -= minY;
    for (let i2 = start; i2 < finish; i2 += 2)
      uvs[i2] = (uvs[i2] + offsetX) * scaleX, uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
  }
};
_GraphicsGeometry.BATCHABLE_SIZE = 100;
let GraphicsGeometry = _GraphicsGeometry;
class FillStyle {
  constructor() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = false, this.reset();
  }
  /** Clones the object */
  clone() {
    const obj = new FillStyle();
    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj;
  }
  /** Reset */
  reset() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = false;
  }
  /** Destroy and don't use after this. */
  destroy() {
    this.texture = null, this.matrix = null;
  }
}
class LineStyle extends FillStyle {
  constructor() {
    super(...arguments), this.width = 0, this.alignment = 0.5, this.native = false, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;
  }
  /** Clones the object. */
  clone() {
    const obj = new LineStyle();
    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj.width = this.width, obj.alignment = this.alignment, obj.native = this.native, obj.cap = this.cap, obj.join = this.join, obj.miterLimit = this.miterLimit, obj;
  }
  /** Reset the line style to default. */
  reset() {
    super.reset(), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = false, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;
  }
}
const DEFAULT_SHADERS = {}, _Graphics = class _Graphics2 extends Container {
  /**
   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.
   */
  constructor(geometry = null) {
    super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new FillStyle(), this._lineStyle = new LineStyle(), this._matrix = null, this._holeMode = false, this.state = State.for2d(), this._geometry = geometry || new GraphicsGeometry(), this._geometry.refCount++, this._transformID = -1, this._tintColor = new Color(16777215), this.blendMode = BLEND_MODES.NORMAL;
  }
  /**
   * Includes vertex positions, face indices, normals, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
   * @readonly
   */
  get geometry() {
    return this._geometry;
  }
  /**
   * Creates a new Graphics object with the same values as this one.
   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)
   * @returns - A clone of the graphics object
   */
  clone() {
    return this.finishPoly(), new _Graphics2(this._geometry);
  }
  /**
   * The blend mode to be applied to the graphic shape. Apply a value of
   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
   * primitive in the GraphicsGeometry list is rendered sequentially, modes
   * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
   * be applied per-primitive.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  /**
   * The tint applied to each graphic shape. This is a hex value. A value of
   * 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  /**
   * The current fill style.
   * @readonly
   */
  get fill() {
    return this._fillStyle;
  }
  /**
   * The current line style.
   * @readonly
   */
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    return typeof options == "number" && (options = { width: options, color, alpha, alignment, native }), this.lineTextureStyle(options);
  }
  /**
   * Like line style but support texture for line fill.
   * @param [options] - Collection of options for setting line style.
   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style
   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use
   * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.
   *  Default 0xFFFFFF if texture present.
   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style
   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture
   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).
   *        WebGL only.
   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style
   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style
   * @param {number}[options.miterLimit=10] - miter limit ratio
   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls
   */
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();
    const visible = options.width > 0 && options.alpha > 0;
    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, { visible }, options)) : this._lineStyle.reset(), this;
  }
  /**
   * Start a polygon object internally.
   * @protected
   */
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points, len = this.currentPath.points.length;
      len > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = false, this.currentPath.points.push(points[len - 2], points[len - 1]));
    } else
      this.currentPath = new Polygon(), this.currentPath.closeStroke = false;
  }
  /**
   * Finish the polygon object.
   * @protected
   */
  finishPoly() {
    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
  }
  /**
   * Moves the current drawing position to x, y.
   * @param x - the X coordinate to move to
   * @param y - the Y coordinate to move to
   * @returns - This Graphics object. Good for chaining method calls
   */
  moveTo(x2, y2) {
    return this.startPoly(), this.currentPath.points[0] = x2, this.currentPath.points[1] = y2, this;
  }
  /**
   * Draws a line using the current line style from the current drawing position to (x, y);
   * The current drawing position is then set to (x, y).
   * @param x - the X coordinate to draw to
   * @param y - the Y coordinate to draw to
   * @returns - This Graphics object. Good for chaining method calls
   */
  lineTo(x2, y2) {
    this.currentPath || this.moveTo(0, 0);
    const points = this.currentPath.points, fromX = points[points.length - 2], fromY = points[points.length - 1];
    return (fromX !== x2 || fromY !== y2) && points.push(x2, y2), this;
  }
  /**
   * Initialize the curve
   * @param x
   * @param y
   */
  _initCurve(x2 = 0, y2 = 0) {
    this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x2, y2]) : this.moveTo(x2, y2);
  }
  /**
   * Calculate the points for a quadratic bezier curve and then draws it.
   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns - This Graphics object. Good for chaining method calls
   */
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;
  }
  /**
   * Calculate the points for a bezier curve and then draws it.
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns This Graphics object. Good for chaining method calls
   */
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    return this._initCurve(), BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;
  }
  /**
   * The `arcTo` method creates an arc/curve between two tangents on the canvas.
   * The first tangent is from the start point to the first control point,
   * and the second tangent is from the first control point to the second control point.
   * Note that the second control point is not necessarily the end point of the arc.
   *
   * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
   * @param x1 - The x-coordinate of the first control point of the arc
   * @param y1 - The y-coordinate of the first control point of the arc
   * @param x2 - The x-coordinate of the second control point of the arc
   * @param y2 - The y-coordinate of the second control point of the arc
   * @param radius - The radius of the arc
   * @returns - This Graphics object. Good for chaining method calls
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points, result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx: cx2, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx2, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  /**
   * The arc method creates an arc/curve (used to create circles, or parts of circles).
   * @param cx - The x-coordinate of the center of the circle
   * @param cy - The y-coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position
   *  of the arc's circle)
   * @param endAngle - The ending angle, in radians
   * @param anticlockwise - Specifies whether the drawing should be
   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
   *  indicates counter-clockwise.
   * @returns - This Graphics object. Good for chaining method calls
   */
  arc(cx2, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle)
      return this;
    if (!anticlockwise && endAngle <= startAngle ? endAngle += PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += PI_2), endAngle - startAngle === 0)
      return this;
    const startX = cx2 + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX), yDiff = Math.abs(points[points.length - 1] - startY);
      xDiff < eps && yDiff < eps || points.push(startX, startY);
    } else
      this.moveTo(startX, startY), points = this.currentPath.points;
    return ArcUtils.arc(startX, startY, cx2, cy, radius, startAngle, endAngle, anticlockwise, points), this;
  }
  /**
   * Specifies a simple one-color fill that subsequent calls to other Graphics methods
   * (such as lineTo() or drawCircle()) use when drawing.
   * @param {PIXI.ColorSource} color - the color of the fill
   * @param alpha - the alpha of the fill, will override the color's alpha
   * @returns - This Graphics object. Suitable for chaining method calls
   */
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  }
  /**
   * Normalize the color input from options for line style or fill
   * @param {PIXI.IFillStyleOptions} options - Fill style object.
   */
  normalizeColor(options) {
    const temp = Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber(), options.alpha ?? (options.alpha = temp.alpha);
  }
  /**
   * Begin the texture fill.
   * Note: The wrap mode of the texture is forced to REPEAT on render.
   * @param options - Fill style object.
   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill
   * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture
   * @param {number} [options.alpha] - Alpha of fill, overrides the color's alpha
   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix
   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls
   */
  beginTextureFill(options) {
    const defaultOptions2 = {
      texture: Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions2, options), this.normalizeColor(options), this.currentPath && this.startPoly();
    const visible = options.alpha > 0;
    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, { visible }, options)) : this._fillStyle.reset(), this;
  }
  /**
   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
   * @returns - This Graphics object. Good for chaining method calls
   */
  endFill() {
    return this.finishPoly(), this._fillStyle.reset(), this;
  }
  /**
   * Draws a rectangle shape.
   * @param x - The X coord of the top-left of the rectangle
   * @param y - The Y coord of the top-left of the rectangle
   * @param width - The width of the rectangle
   * @param height - The height of the rectangle
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawRect(x2, y2, width, height) {
    return this.drawShape(new Rectangle(x2, y2, width, height));
  }
  /**
   * Draw a rectangle shape with rounded/beveled corners.
   * @param x - The X coord of the top-left of the rectangle
   * @param y - The Y coord of the top-left of the rectangle
   * @param width - The width of the rectangle
   * @param height - The height of the rectangle
   * @param radius - Radius of the rectangle corners
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawRoundedRect(x2, y2, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
  }
  /**
   * Draws a circle.
   * @param x - The X coordinate of the center of the circle
   * @param y - The Y coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawCircle(x2, y2, radius) {
    return this.drawShape(new Circle(x2, y2, radius));
  }
  /**
   * Draws an ellipse.
   * @param x - The X coordinate of the center of the ellipse
   * @param y - The Y coordinate of the center of the ellipse
   * @param width - The half width of the ellipse
   * @param height - The half height of the ellipse
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawEllipse(x2, y2, width, height) {
    return this.drawShape(new Ellipse(x2, y2, width, height));
  }
  /**
   * Draws a polygon using the given path.
   * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawPolygon(...path2) {
    let points, closeStroke = true;
    const poly = path2[0];
    poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path2[0]) ? points = path2[0] : points = path2;
    const shape = new Polygon(points);
    return shape.closeStroke = closeStroke, this.drawShape(shape), this;
  }
  /**
   * Draw any shape.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawShape(shape) {
    return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(
      shape,
      this._fillStyle.clone(),
      this._lineStyle.clone(),
      this._matrix
    ), this;
  }
  /**
   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
   * @returns - This Graphics object. Good for chaining method calls
   */
  clear() {
    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = false, this.currentPath = null, this;
  }
  /**
   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
   * masked with gl.scissor.
   * @returns - True if only 1 rect.
   */
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  /**
   * Renders the object using the WebGL renderer
   * @param renderer - The renderer
   */
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches(), geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));
  }
  /** Populating batches for rendering. */
  _populateBatches() {
    const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;
    this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.batches.length = len, this.vertexData = new Float32Array(geometry.points);
    for (let i2 = 0; i2 < len; i2++) {
      const gI = geometry.batches[i2], color = gI.style.color, vertexData = new Float32Array(
        this.vertexData.buffer,
        gI.attribStart * 4 * 2,
        gI.attribSize * 2
      ), uvs = new Float32Array(
        geometry.uvsFloat32.buffer,
        gI.attribStart * 4 * 2,
        gI.attribSize * 2
      ), indices3 = new Uint16Array(
        geometry.indicesUint16.buffer,
        gI.start * 2,
        gI.size
      ), batch = {
        vertexData,
        blendMode,
        indices: indices3,
        uvs,
        _batchRGB: Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i2] = batch;
    }
  }
  /**
   * Renders the batches using the BathedRenderer plugin
   * @param renderer - The renderer
   */
  _renderBatched(renderer) {
    if (this.batches.length) {
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
      for (let i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
        const batch = this.batches[i2];
        batch.worldAlpha = this.worldAlpha * batch.alpha, renderer.plugins[this.pluginName].render(batch);
      }
    }
  }
  /**
   * Renders the graphics direct
   * @param renderer - The renderer
   */
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform, Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint), renderer.shader.bind(shader), renderer.geometry.bind(geometry, shader), renderer.state.set(this.state);
    for (let i2 = 0, l2 = drawCalls.length; i2 < l2; i2++)
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
  }
  /**
   * Renders specific DrawCall
   * @param renderer
   * @param drawCall
   */
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type: type2, size: size2, start } = drawCall, groupTextureCount = texArray.count;
    for (let j2 = 0; j2 < groupTextureCount; j2++)
      renderer.texture.bind(texArray.elements[j2], j2);
    renderer.geometry.draw(type2, size2, start);
  }
  /**
   * Resolves shader for direct rendering
   * @param renderer - The renderer
   */
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName], sampleValues = new Int32Array(maxTextures);
        for (let i2 = 0; i2 < maxTextures; i2++)
          sampleValues[i2] = i2;
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        }, program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  /**
   * Retrieves the bounds of the graphic shape as a rectangle object.
   * @see PIXI.GraphicsGeometry#bounds
   */
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length)
      return;
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  /**
   * Tests if a point is inside this graphics object
   * @param point - the point to test
   * @returns - the result of the test
   */
  containsPoint(point) {
    return this.worldTransform.applyInverse(point, _Graphics2._TEMP_POINT), this._geometry.containsPoint(_Graphics2._TEMP_POINT);
  }
  /** Recalculate the tint by applying tint to batches using Graphics tint. */
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i2 = 0; i2 < this.batches.length; i2++) {
        const batch = this.batches[i2];
        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID)
      return;
    this._transformID = wtID;
    const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, data = this._geometry.points, vertexData = this.vertexData;
    let count = 0;
    for (let i2 = 0; i2 < data.length; i2 += 2) {
      const x2 = data[i2], y2 = data[i2 + 1];
      vertexData[count++] = a2 * x2 + c2 * y2 + tx, vertexData[count++] = d2 * y2 + b2 * x2 + ty;
    }
  }
  /**
   * Closes the current path.
   * @returns - Returns itself.
   */
  closePath() {
    const currentPath = this.currentPath;
    return currentPath && (currentPath.closeStroke = true, this.finishPoly()), this;
  }
  /**
   * Apply a matrix to the positional data.
   * @param matrix - Matrix to use for transform current shape.
   * @returns - Returns itself.
   */
  setMatrix(matrix) {
    return this._matrix = matrix, this;
  }
  /**
   * Begin adding holes to the last draw shape
   * IMPORTANT: holes must be fully inside a shape to work
   * Also weirdness ensues if holes overlap!
   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
   * @returns - Returns itself.
   */
  beginHole() {
    return this.finishPoly(), this._holeMode = true, this;
  }
  /**
   * End adding holes to the last draw shape.
   * @returns - Returns itself.
   */
  endHole() {
    return this.finishPoly(), this._holeMode = false, this;
  }
  /**
   * Destroys the Graphics object.
   * @param options - Options parameter. A boolean will act as if all
   *  options have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have
   *  their destroy method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(options);
  }
};
_Graphics.curves = curves, /**
* Temporary point to use for containsPoint.
* @private
*/
_Graphics._TEMP_POINT = new Point();
let Graphics = _Graphics;
class MeshBatchUvs {
  /**
   * @param uvBuffer - Buffer with normalized uv's
   * @param uvMatrix - Material UV matrix
   */
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
  }
  /**
   * Updates
   * @param forceUpdate - force the update
   */
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
      return;
    this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    (!this.data || this.data.length !== data.length) && (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++;
  }
}
const tempPoint$1 = new Point(), tempPolygon = new Polygon(), _Mesh = class _Mesh2 extends Container {
  /**
   * @param geometry - The geometry the mesh will use.
   * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.
   * @param state - The state that the WebGL context is required to be in to render the mesh
   *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.
   * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.
   */
  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
    super(), this.geometry = geometry, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null;
  }
  /**
   * Includes vertex positions, face indices, normals, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh objects.
   */
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
  }
  /**
   * To change mesh uv's, change its uvBuffer data and increment its _updateID.
   * @readonly
   */
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  /**
   * To change mesh vertices, change its uvBuffer data and increment its _updateID.
   * Incrementing _updateID is optional because most of Mesh objects do it anyway.
   * @readonly
   */
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  /** Alias for {@link PIXI.Mesh#shader}. */
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  /**
   * The blend mode to be applied to the Mesh. Apply a value of
   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
   * @default PIXI.BLEND_MODES.NORMAL;
   */
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
   * @default false
   */
  set roundPixels(value) {
    this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  /**
   * The multiply tint applied to the Mesh. This is a hex value. A value of
   * `0xFFFFFF` will remove any tint effect.
   *
   * Null for non-MeshMaterial shaders
   * @default 0xFFFFFF
   */
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  /**
   * The tint color as a RGB integer
   * @ignore
   */
  get tintValue() {
    return this.shader.tintValue;
  }
  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  /**
   * Standard renderer draw.
   * @param renderer - Instance to renderer.
   */
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);
  }
  /**
   * Standard non-batching way of rendering.
   * @param renderer - Instance to renderer.
   */
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  /**
   * Rendering by using the Batch system.
   * @param renderer - Instance to renderer.
   */
  _renderToBatch(renderer) {
    const geometry = this.geometry, shader = this.shader;
    shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);
  }
  /** Updates vertexData field based on transform and vertices. */
  calculateVertices() {
    const verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data, vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)
      return;
    this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));
    const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData;
    for (let i2 = 0; i2 < vertexData.length / 2; i2++) {
      const x2 = vertices[i2 * 2], y2 = vertices[i2 * 2 + 1];
      vertexData[i2 * 2] = a2 * x2 + c2 * y2 + tx, vertexData[i2 * 2 + 1] = b2 * x2 + d2 * y2 + ty;
    }
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2)
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
    }
    this.vertexDirty = vertexDirtyId;
  }
  /** Updates uv field based on from geometry uv's or batchUvs. */
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1], shader = this.shader;
    shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
  }
  /**
   * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
   * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
   */
  _calculateBounds() {
    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  /**
   * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
   * @param point - The point to test.
   * @returns - The result of the test.
   */
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y))
      return false;
    this.worldTransform.applyInverse(point, tempPoint$1);
    const vertices = this.geometry.getBuffer("aVertexPosition").data, points = tempPolygon.points, indices3 = this.geometry.getIndex().data, len = indices3.length, step = this.drawMode === 4 ? 3 : 1;
    for (let i2 = 0; i2 + 2 < len; i2 += step) {
      const ind0 = indices3[i2] * 2, ind1 = indices3[i2 + 1] * 2, ind2 = indices3[i2 + 2] * 2;
      if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(tempPoint$1.x, tempPoint$1.y))
        return true;
    }
    return false;
  }
  destroy(options) {
    super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
  }
};
_Mesh.BATCHABLE_SIZE = 100;
let Mesh = _Mesh;
class MeshGeometry extends Geometry {
  /**
   * @param {Float32Array|number[]} [vertices] - Positional data on geometry.
   * @param {Float32Array|number[]} [uvs] - Texture UVs.
   * @param {Uint16Array|number[]} [index] - IndexBuffer
   */
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new Buffer(vertices), uvsBuffer = new Buffer(uvs, true), indexBuffer = new Buffer(index, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer), this._updateId = -1;
  }
  /**
   * If the vertex position is updated.
   * @readonly
   * @private
   */
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
var fragment$1 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`;
var vertex$1 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class MeshMaterial extends Shader {
  /**
   * @param uSampler - Texture that material uses to render.
   * @param options - Additional options
   * @param {number} [options.alpha=1] - Default alpha.
   * @param {PIXI.ColorSource} [options.tint=0xFFFFFF] - Default tint.
   * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.
   * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.
   * @param {object} [options.uniforms] - Custom uniforms.
   */
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options), options.uniforms && Object.assign(uniforms, options.uniforms), super(options.program || Program.from(vertex$1, fragment$1), uniforms), this._colorDirty = false, this.uvMatrix = new TextureMatrix(uSampler), this.batchable = options.program === void 0, this.pluginName = options.pluginName, this._tintColor = new Color(options.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = true, this.alpha = options.alpha;
  }
  /** Reference to the texture being rendered. */
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    this.uniforms.uSampler !== value && (!this.uniforms.uSampler.baseTexture.alphaMode != !value.baseTexture.alphaMode && (this._colorDirty = true), this.uniforms.uSampler = value, this.uvMatrix.texture = value);
  }
  /**
   * This gets automatically set by the object using this.
   * @default 1
   */
  set alpha(value) {
    value !== this._alpha && (this._alpha = value, this._colorDirty = true);
  }
  get alpha() {
    return this._alpha;
  }
  /**
   * Multiply tint for the material.
   * @default 0xFFFFFF
   */
  set tint(value) {
    value !== this.tint && (this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = true);
  }
  get tint() {
    return this._tintColor.value;
  }
  /**
   * Get the internal number from tint color
   * @ignore
   */
  get tintValue() {
    return this._tintColor.toNumber();
  }
  /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link PIXI.MeshMaterial} objects. */
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const applyToChannels = this.texture.baseTexture.alphaMode;
      Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }
}
class ParticleBuffer {
  /**
   * @param {object} properties - The properties to upload.
   * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.
   * @param {number} size - The size of the batch.
   */
  constructor(properties2, dynamicPropertyFlags, size2) {
    this.geometry = new Geometry(), this.indexBuffer = null, this.size = size2, this.dynamicProperties = [], this.staticProperties = [];
    for (let i2 = 0; i2 < properties2.length; ++i2) {
      let property = properties2[i2];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      }, dynamicPropertyFlags[i2] ? this.dynamicProperties.push(property) : this.staticProperties.push(property);
    }
    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
  }
  /** Sets up the renderer context and necessary buffers. */
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new Buffer(createIndicesForQuads(this.size), true, true), geometry.addIndex(this.indexBuffer), this.dynamicStride = 0;
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      property.offset = dynamicOffset, dynamicOffset += property.size, this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer), this.dynamicDataUint32 = new Uint32Array(dynBuffer), this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      property.offset = staticOffset, staticOffset += property.size, this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer), this.staticDataUint32 = new Uint32Array(statBuffer), this.staticBuffer = new Buffer(this.staticData, true, false);
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      geometry.addAttribute(
        property.attributeName,
        this.dynamicBuffer,
        0,
        property.type === TYPES.UNSIGNED_BYTE,
        property.type,
        this.dynamicStride * 4,
        property.offset * 4
      );
    }
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      geometry.addAttribute(
        property.attributeName,
        this.staticBuffer,
        0,
        property.type === TYPES.UNSIGNED_BYTE,
        property.type,
        this.staticStride * 4,
        property.offset * 4
      );
    }
  }
  /**
   * Uploads the dynamic properties.
   * @param children - The children to upload.
   * @param startIndex - The index to start at.
   * @param amount - The number to upload.
   */
  uploadDynamic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.dynamicProperties.length; i2++) {
      const property = this.dynamicProperties[i2];
      property.uploadFunction(
        children,
        startIndex,
        amount,
        property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,
        this.dynamicStride,
        property.offset
      );
    }
    this.dynamicBuffer._updateID++;
  }
  /**
   * Uploads the static properties.
   * @param children - The children to upload.
   * @param startIndex - The index to start at.
   * @param amount - The number to upload.
   */
  uploadStatic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.staticProperties.length; i2++) {
      const property = this.staticProperties[i2];
      property.uploadFunction(
        children,
        startIndex,
        amount,
        property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
        this.staticStride,
        property.offset
      );
    }
    this.staticBuffer._updateID++;
  }
  /** Destroys the ParticleBuffer. */
  destroy() {
    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
  }
}
var fragment = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`;
var vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class ParticleRenderer extends ObjectRenderer {
  /**
   * @param renderer - The renderer this sprite batch works for.
   */
  constructor(renderer) {
    super(renderer), this.shader = null, this.properties = null, this.tempMatrix = new Matrix(), this.properties = [
      // verticesData
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      // positionData
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      // rotationData
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      // uvsData
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      // tintData
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ], this.shader = Shader.from(vertex, fragment, {}), this.state = State.for2d();
  }
  /**
   * Renders the particle container object.
   * @param container - The container to render using this ParticleRenderer.
   */
  render(container) {
    const children = container.children, maxSize = container._maxSize, batchSize = container._batchSize, renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0)
      return;
    totalChildren > maxSize && !container.autoResize && (totalChildren = maxSize);
    let buffers = container._buffers;
    buffers || (buffers = container._buffers = this.generateBuffers(container));
    const baseTexture = children[0]._texture.baseTexture, premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied), renderer.state.set(this.state);
    const gl2 = renderer.gl, m2 = container.worldTransform.copyTo(this.tempMatrix);
    m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = m2.toArray(true), this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = baseTexture, this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
      let amount = totalChildren - i2;
      amount > batchSize && (amount = batchSize), j2 >= buffers.length && buffers.push(this._generateOneMoreBuffer(container));
      const buffer = buffers[j2];
      buffer.uploadDynamic(children, i2, amount);
      const bid = container._bufferUpdateIDs[j2] || 0;
      updateStatic = updateStatic || buffer._updateID < bid, updateStatic && (buffer._updateID = container._updateID, buffer.uploadStatic(children, i2, amount)), renderer.geometry.bind(buffer.geometry), gl2.drawElements(gl2.TRIANGLES, amount * 6, gl2.UNSIGNED_SHORT, 0);
    }
  }
  /**
   * Creates one particle buffer for each child in the container we want to render and updates internal properties.
   * @param container - The container to render using this ParticleRenderer
   * @returns - The buffers
   */
  generateBuffers(container) {
    const buffers = [], size2 = container._maxSize, batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
    for (let i2 = 0; i2 < size2; i2 += batchSize)
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    return buffers;
  }
  /**
   * Creates one more particle buffer, because container has autoResize feature.
   * @param container - The container to render using this ParticleRenderer
   * @returns - The generated buffer
   */
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  /**
   * Uploads the vertices.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their vertices uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadVertices(children, startIndex, amount, array, stride, offset2) {
    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite = children[startIndex + i2], texture = sprite._texture, sx = sprite.scale.x, sy = sprite.scale.y, trim2 = texture.trim, orig = texture.orig;
      trim2 ? (w1 = trim2.x - sprite.anchor.x * orig.width, w0 = w1 + trim2.width, h1 = trim2.y - sprite.anchor.y * orig.height, h0 = h1 + trim2.height) : (w0 = orig.width * (1 - sprite.anchor.x), w1 = orig.width * -sprite.anchor.x, h0 = orig.height * (1 - sprite.anchor.y), h1 = orig.height * -sprite.anchor.y), array[offset2] = w1 * sx, array[offset2 + 1] = h1 * sy, array[offset2 + stride] = w0 * sx, array[offset2 + stride + 1] = h1 * sy, array[offset2 + stride * 2] = w0 * sx, array[offset2 + stride * 2 + 1] = h0 * sy, array[offset2 + stride * 3] = w1 * sx, array[offset2 + stride * 3 + 1] = h0 * sy, offset2 += stride * 4;
    }
  }
  /**
   * Uploads the position.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their positions uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadPosition(children, startIndex, amount, array, stride, offset2) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spritePosition = children[startIndex + i2].position;
      array[offset2] = spritePosition.x, array[offset2 + 1] = spritePosition.y, array[offset2 + stride] = spritePosition.x, array[offset2 + stride + 1] = spritePosition.y, array[offset2 + stride * 2] = spritePosition.x, array[offset2 + stride * 2 + 1] = spritePosition.y, array[offset2 + stride * 3] = spritePosition.x, array[offset2 + stride * 3 + 1] = spritePosition.y, offset2 += stride * 4;
    }
  }
  /**
   * Uploads the rotation.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadRotation(children, startIndex, amount, array, stride, offset2) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spriteRotation = children[startIndex + i2].rotation;
      array[offset2] = spriteRotation, array[offset2 + stride] = spriteRotation, array[offset2 + stride * 2] = spriteRotation, array[offset2 + stride * 3] = spriteRotation, offset2 += stride * 4;
    }
  }
  /**
   * Uploads the UVs.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadUvs(children, startIndex, amount, array, stride, offset2) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const textureUvs = children[startIndex + i2]._texture._uvs;
      textureUvs ? (array[offset2] = textureUvs.x0, array[offset2 + 1] = textureUvs.y0, array[offset2 + stride] = textureUvs.x1, array[offset2 + stride + 1] = textureUvs.y1, array[offset2 + stride * 2] = textureUvs.x2, array[offset2 + stride * 2 + 1] = textureUvs.y2, array[offset2 + stride * 3] = textureUvs.x3, array[offset2 + stride * 3 + 1] = textureUvs.y3, offset2 += stride * 4) : (array[offset2] = 0, array[offset2 + 1] = 0, array[offset2 + stride] = 0, array[offset2 + stride + 1] = 0, array[offset2 + stride * 2] = 0, array[offset2 + stride * 2 + 1] = 0, array[offset2 + stride * 3] = 0, array[offset2 + stride * 3 + 1] = 0, offset2 += stride * 4);
    }
  }
  /**
   * Uploads the tint.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadTint(children, startIndex, amount, array, stride, offset2) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite = children[startIndex + i2], result = Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset2] = result, array[offset2 + stride] = result, array[offset2 + stride * 2] = result, array[offset2 + stride * 3] = result, offset2 += stride * 4;
    }
  }
  /** Destroys the ParticleRenderer. */
  destroy() {
    super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(ParticleRenderer);
var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => (TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", TEXT_GRADIENT2))(TEXT_GRADIENT || {});
const contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: true
}, _TextMetrics = class _TextMetrics2 {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see PIXI.TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics2._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param wordWrap - Override for if word-wrap should be applied to the text.
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns Measured width and height of the text.
   */
  static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {
    wordWrap = wordWrap ?? style.wordWrap;
    const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);
    fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);
    const context2 = canvas.getContext("2d", contextSettings);
    context2.font = font;
    const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/), lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const lineWidth = _TextMetrics2._measureText(lines[i2], style.letterSpacing, context2);
      lineWidths[i2] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    style.dropShadow && (width += style.dropShadowDistance);
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);
    return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(
      text,
      style,
      width,
      height,
      lines,
      lineWidths,
      lineHeight + style.leading,
      maxLineWidth,
      fontProperties
    );
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context2.letterSpacing = `${letterSpacing}px`, context2.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = true) : (context2.letterSpacing = "0px", context2.textLetterSpacing = "0px"));
    let width = context2.measureText(text).width;
    return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static wordWrap(text, style, canvas = _TextMetrics2._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0, line2 = "", lines = "";
    const cache2 = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);
    for (let i2 = 0; i2 < tokens.length; i2++) {
      let token2 = tokens[i2];
      if (_TextMetrics2.isNewline(token2)) {
        if (!collapseNewlines) {
          lines += _TextMetrics2.addLine(line2), canPrependSpaces = !collapseSpaces, line2 = "", width = 0;
          continue;
        }
        token2 = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token2), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line2[line2.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace)
          continue;
      }
      const tokenWidth = _TextMetrics2.getFromCache(token2, letterSpacing, cache2, context2);
      if (tokenWidth > wordWrapWidth)
        if (line2 !== "" && (lines += _TextMetrics2.addLine(line2), line2 = "", width = 0), _TextMetrics2.canBreakWords(token2, style.breakWords)) {
          const characters2 = _TextMetrics2.wordWrapSplit(token2);
          for (let j2 = 0; j2 < characters2.length; j2++) {
            let char2 = characters2[j2], lastChar = char2, k2 = 1;
            for (; characters2[j2 + k2]; ) {
              const nextChar = characters2[j2 + k2];
              if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token2, j2, style.breakWords))
                char2 += nextChar;
              else
                break;
              lastChar = nextChar, k2++;
            }
            j2 += k2 - 1;
            const characterWidth = _TextMetrics2.getFromCache(char2, letterSpacing, cache2, context2);
            characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line2), canPrependSpaces = false, line2 = "", width = 0), line2 += char2, width += characterWidth;
          }
        } else {
          line2.length > 0 && (lines += _TextMetrics2.addLine(line2), line2 = "", width = 0);
          const isLastToken = i2 === tokens.length - 1;
          lines += _TextMetrics2.addLine(token2, !isLastToken), canPrependSpaces = false, line2 = "", width = 0;
        }
      else
        tokenWidth + width > wordWrapWidth && (canPrependSpaces = false, lines += _TextMetrics2.addLine(line2), line2 = "", width = 0), (line2.length > 0 || !_TextMetrics2.isBreakingSpace(token2) || canPrependSpaces) && (line2 += token2, width += tokenWidth);
    }
    return lines += _TextMetrics2.addLine(line2, false), lines;
  }
  /**
   * Convienience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static addLine(line2, newLine = true) {
    return line2 = _TextMetrics2.trimRight(line2), line2 = newLine ? `${line2}
` : line2, line2;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static getFromCache(key, letterSpacing, cache2, context2) {
    let width = cache2[key];
    return typeof width != "number" && (width = _TextMetrics2._measureText(key, letterSpacing, context2) + letterSpacing, cache2[key] = width), width;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static trimRight(text) {
    if (typeof text != "string")
      return "";
    for (let i2 = text.length - 1; i2 >= 0; i2--) {
      const char2 = text[i2];
      if (!_TextMetrics2.isBreakingSpace(char2))
        break;
      text = text.slice(0, -1);
    }
    return text;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static isNewline(char2) {
    return typeof char2 != "string" ? false : _TextMetrics2._newlines.includes(char2.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(char2, _nextChar) {
    return typeof char2 != "string" ? false : _TextMetrics2._breakingSpaces.includes(char2.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static tokenize(text) {
    const tokens = [];
    let token2 = "";
    if (typeof text != "string")
      return tokens;
    for (let i2 = 0; i2 < text.length; i2++) {
      const char2 = text[i2], nextChar = text[i2 + 1];
      if (_TextMetrics2.isBreakingSpace(char2, nextChar) || _TextMetrics2.isNewline(char2)) {
        token2 !== "" && (tokens.push(token2), token2 = ""), tokens.push(char2);
        continue;
      }
      token2 += char2;
    }
    return token2 !== "" && tokens.push(token2), tokens;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see TextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(token2) {
    return _TextMetrics2.graphemeSegmenter(token2);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(font) {
    if (_TextMetrics2._fonts[font])
      return _TextMetrics2._fonts[font];
    const properties2 = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    }, canvas = _TextMetrics2._canvas, context2 = _TextMetrics2._context;
    context2.font = font;
    const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context2.measureText(metricsString).width);
    let baseline = Math.ceil(context2.measureText(_TextMetrics2.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)
      return _TextMetrics2._fonts[font] = properties2, properties2;
    canvas.width = width, canvas.height = height, context2.fillStyle = "#f00", context2.fillRect(0, 0, width, height), context2.font = font, context2.textBaseline = "alphabetic", context2.fillStyle = "#000", context2.fillText(metricsString, 0, baseline);
    const imagedata = context2.getImageData(0, 0, width, height).data, pixels = imagedata.length, line2 = width * 4;
    let i2 = 0, idx = 0, stop = false;
    for (i2 = 0; i2 < baseline; ++i2) {
      for (let j2 = 0; j2 < line2; j2 += 4)
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      if (!stop)
        idx += line2;
      else
        break;
    }
    for (properties2.ascent = baseline - i2, idx = pixels - line2, stop = false, i2 = height; i2 > baseline; --i2) {
      for (let j2 = 0; j2 < line2; j2 += 4)
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      if (!stop)
        idx -= line2;
      else
        break;
    }
    return properties2.descent = i2 - baseline, properties2.fontSize = properties2.ascent + properties2.descent, _TextMetrics2._fonts[font] = properties2, properties2;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(font = "") {
    font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!_TextMetrics2.__canvas) {
      let canvas;
      try {
        const c2 = new OffscreenCanvas(0, 0);
        if (c2.getContext("2d", contextSettings)?.measureText)
          return _TextMetrics2.__canvas = c2, c2;
        canvas = settings.ADAPTER.createCanvas();
      } catch {
        canvas = settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;
    }
    return _TextMetrics2.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext("2d", contextSettings)), _TextMetrics2.__context;
  }
};
_TextMetrics.METRICS_STRING = "|ÉqÅ", /** Baseline symbol for calculate font metrics. */
_TextMetrics.BASELINE_SYMBOL = "M", /** Baseline multiplier for calculate font metrics. */
_TextMetrics.BASELINE_MULTIPLIER = 1.4, /** Height multiplier for setting height of canvas to calculate font metrics. */
_TextMetrics.HEIGHT_MULTIPLIER = 2, /**
* A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,
* such as letters with diacritical marks (e.g. `'\u0065\u0301'`, letter e with acute)
* or emojis with modifiers (e.g. `'\uD83E\uDDD1\u200D\uD83D\uDCBB'`, technologist).
* The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,
* PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.
* If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),
* you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}
* or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be
* relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.
*/
_TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter == "function") {
    const segmenter = new Intl.Segmenter();
    return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
  }
  return (s2) => [...s2];
})(), /**
* New rendering behavior for letter-spacing which uses Chrome's new native API. This will
* lead to more accurate letter-spacing results because it does not try to manually draw
* each character. However, this Chrome API is experimental and may not serve all cases yet.
* @see PIXI.TextMetrics.experimentalLetterSpacingSupported
*/
_TextMetrics.experimentalLetterSpacing = false, /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */
_TextMetrics._fonts = {}, /** Cache of new line chars. */
_TextMetrics._newlines = [
  10,
  // line feed
  13
  // carriage return
], /** Cache of breaking spaces. */
_TextMetrics._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
let TextMetrics = _TextMetrics;
const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], _TextStyle = class _TextStyle2 {
  /**
   * @param style - TextStyle properties to be set on the text. See {@link PIXI.TextStyle.defaultStyle}
   *       for the default values.
   */
  constructor(style) {
    this.styleID = 0, this.reset(), deepCopyProperties(this, style, style);
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * Note that the only the properties of the object are cloned.
   *
   * @return New cloned TextStyle object
   */
  clone() {
    const clonedProperties = {};
    return deepCopyProperties(clonedProperties, this, _TextStyle2.defaultStyle), new _TextStyle2(clonedProperties);
  }
  /** Resets all properties to the defaults specified in TextStyle.prototype._default */
  reset() {
    deepCopyProperties(this, _TextStyle2.defaultStyle, _TextStyle2.defaultStyle);
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   *
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(align) {
    this._align !== align && (this._align = align, this.styleID++);
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    this._breakWords !== breakWords && (this._breakWords = breakWords, this.styleID++);
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    this._dropShadow !== dropShadow && (this._dropShadow = dropShadow, this.styleID++);
  }
  /** Set alpha for the drop shadow. */
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    this._dropShadowAlpha !== dropShadowAlpha && (this._dropShadowAlpha = dropShadowAlpha, this.styleID++);
  }
  /** Set a angle of the drop shadow. */
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    this._dropShadowAngle !== dropShadowAngle && (this._dropShadowAngle = dropShadowAngle, this.styleID++);
  }
  /** Set a shadow blur radius. */
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    this._dropShadowBlur !== dropShadowBlur && (this._dropShadowBlur = dropShadowBlur, this.styleID++);
  }
  /** A fill style to be used on the dropshadow e.g., 'red', '#00FF00'. */
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    this._dropShadowColor !== outputColor && (this._dropShadowColor = outputColor, this.styleID++);
  }
  /** Set a distance of the drop shadow. */
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    this._dropShadowDistance !== dropShadowDistance && (this._dropShadowDistance = dropShadowDistance, this.styleID++);
  }
  /**
   * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.
   *
   * Can be an array to create a gradient e.g., `['#000000','#FFFFFF']`
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
   *
   * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    this._fill !== outputColor && (this._fill = outputColor, this.styleID++);
  }
  /**
   * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
   *
   * @type {PIXI.TEXT_GRADIENT}
   */
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    this._fillGradientType !== fillGradientType && (this._fillGradientType = fillGradientType, this.styleID++);
  }
  /**
   * If fill is an array of colours to create a gradient, this array can set the stop points
   * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
   */
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    areArraysEqual(this._fillGradientStops, fillGradientStops) || (this._fillGradientStops = fillGradientStops, this.styleID++);
  }
  /**
   * The font family, can be a single font name, or a list of names where the first
   * is the preferred font.
   */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    this.fontFamily !== fontFamily && (this._fontFamily = fontFamily, this.styleID++);
  }
  /**
   * The font size
   * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
   */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    this._fontSize !== fontSize && (this._fontSize = fontSize, this.styleID++);
  }
  /**
   * The font style.
   *
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    this._fontStyle !== fontStyle && (this._fontStyle = fontStyle, this.styleID++);
  }
  /**
   * The font variant.
   *
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    this._fontVariant !== fontVariant && (this._fontVariant = fontVariant, this.styleID++);
  }
  /**
   * The font weight.
   *
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    this._fontWeight !== fontWeight && (this._fontWeight = fontWeight, this.styleID++);
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    this._letterSpacing !== letterSpacing && (this._letterSpacing = letterSpacing, this.styleID++);
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    this._lineHeight !== lineHeight && (this._lineHeight = lineHeight, this.styleID++);
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    this._leading !== leading && (this._leading = leading, this.styleID++);
  }
  /**
   * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
   * Default is 'miter' (creates a sharp corner).
   *
   * @member {'miter'|'round'|'bevel'}
   */
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    this._lineJoin !== lineJoin && (this._lineJoin = lineJoin, this.styleID++);
  }
  /**
   * The miter limit to use when using the 'miter' lineJoin mode.
   *
   * This can reduce or increase the spikiness of rendered text.
   */
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    this._miterLimit !== miterLimit && (this._miterLimit = miterLimit, this.styleID++);
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    this._padding !== padding && (this._padding = padding, this.styleID++);
  }
  /**
   * A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'
   */
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    this._stroke !== outputColor && (this._stroke = outputColor, this.styleID++);
  }
  /**
   * A number that represents the thickness of the stroke.
   *
   * @default 0
   */
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    this._strokeThickness !== strokeThickness && (this._strokeThickness = strokeThickness, this.styleID++);
  }
  /**
   * The baseline of the text that is rendered.
   *
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    this._textBaseline !== textBaseline && (this._textBaseline = textBaseline, this.styleID++);
  }
  /** Trim transparent borders. */
  get trim() {
    return this._trim;
  }
  set trim(trim2) {
    this._trim !== trim2 && (this._trim = trim2, this.styleID++);
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   *
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    this._whiteSpace !== whiteSpace && (this._whiteSpace = whiteSpace, this.styleID++);
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    this._wordWrap !== wordWrap && (this._wordWrap = wordWrap, this.styleID++);
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    this._wordWrapWidth !== wordWrapWidth && (this._wordWrapWidth = wordWrapWidth, this.styleID++);
  }
  /**
   * Generates a font style string to use for `TextMetrics.measureFont()`.
   *
   * @return Font style string, for passing to `TextMetrics.measureFont()`
   */
  toFontString() {
    const fontSizeString = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    Array.isArray(this.fontFamily) || (fontFamilies = this.fontFamily.split(","));
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      !/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily) && (fontFamily = `"${fontFamily}"`), fontFamilies[i2] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
_TextStyle.defaultStyle = {
  /**
   * See {@link PIXI.TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link PIXI.TextStyle.breakWords} */
  breakWords: false,
  /** See {@link PIXI.TextStyle.dropShadow} */
  dropShadow: false,
  /** See {@link PIXI.TextStyle.dropShadowAlpha} */
  dropShadowAlpha: 1,
  /**
   * See {@link PIXI.TextStyle.dropShadowAngle}
   * @type {number}
   * @default Math.PI / 6
   */
  dropShadowAngle: Math.PI / 6,
  /** See {@link PIXI.TextStyle.dropShadowBlur} */
  dropShadowBlur: 0,
  /**
   * See {@link PIXI.TextStyle.dropShadowColor}
   * @type {string|number}
   */
  dropShadowColor: "black",
  /** See {@link PIXI.TextStyle.dropShadowDistance} */
  dropShadowDistance: 5,
  /**
   * See {@link PIXI.TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link PIXI.TextStyle.fillGradientType}
   * @type {PIXI.TEXT_GRADIENT}
   * @default PIXI.TEXT_GRADIENT.LINEAR_VERTICAL
   */
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  /**
   * See {@link PIXI.TextStyle.fillGradientStops}
   * @type {number[]}
   * @default []
   */
  fillGradientStops: [],
  /**
   * See {@link PIXI.TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link PIXI.TextStyle.fontSize}
   * @type {number|string} 
   */
  fontSize: 26,
  /**
   * See {@link PIXI.TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link PIXI.TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link PIXI.TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link PIXI.TextStyle.leading} */
  leading: 0,
  /** See {@link PIXI.TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link PIXI.TextStyle.lineHeight} */
  lineHeight: 0,
  /**
   * See {@link PIXI.TextStyle.lineJoin}
   * @type {'miter'|'round'|'bevel'}
   */
  lineJoin: "miter",
  /** See {@link PIXI.TextStyle.miterLimit} */
  miterLimit: 10,
  /** See {@link PIXI.TextStyle.padding} */
  padding: 0,
  /**
   * See {@link PIXI.TextStyle.stroke}
   * @type {string|number}
   */
  stroke: "black",
  /** See {@link PIXI.TextStyle.strokeThickness} */
  strokeThickness: 0,
  /**
   * See {@link PIXI.TextStyle.textBaseline} 
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link PIXI.TextStyle.trim} */
  trim: false,
  /**
   * See {@link PIXI.TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link PIXI.TextStyle.wordWrap} */
  wordWrap: false,
  /** See {@link PIXI.TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let TextStyle = _TextStyle;
function getColor(color) {
  const temp = Color.shared, format2 = (color2) => {
    const res = temp.setValue(color2);
    return res.alpha === 1 ? res.toHex() : res.toRgbaString();
  };
  return Array.isArray(color) ? color.map(format2) : format2(color);
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length)
    return false;
  for (let i2 = 0; i2 < array1.length; ++i2)
    if (array1[i2] !== array2[i2])
      return false;
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj)
    Array.isArray(source[prop]) ? target[prop] = source[prop].slice() : target[prop] = source[prop];
}
const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
}, _Text = class _Text2 extends Sprite {
  /**
   * @param text - The string that you would like the text to display
   * @param style - The style parameters
   * @param canvas - The canvas element for drawing text
   */
  constructor(text, style, canvas) {
    let ownCanvas = false;
    canvas || (canvas = settings.ADAPTER.createCanvas(), ownCanvas = true), canvas.width = 3, canvas.height = 3;
    const texture = Texture.from(canvas);
    texture.orig = new Rectangle(), texture.trim = new Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext("2d", {
      // required for trimming to work without warnings
      willReadFrequently: true
    }), this._resolution = _Text2.defaultResolution ?? settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = text, this.style = style, this.localStyleID = -1;
  }
  /**
   * @see PIXI.TextMetrics.experimentalLetterSpacing
   * @deprecated since 7.1.0
   */
  static get experimentalLetterSpacing() {
    return TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    deprecation(
      "7.1.0",
      "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"
    ), TextMetrics.experimentalLetterSpacing = value;
  }
  /**
   * Renders text to its canvas, and updates its texture.
   *
   * By default this is used internally to ensure the texture is correct before rendering,
   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
   * and then shared across multiple Sprites.
   * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
   */
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID && (this.dirty = true, this.localStyleID = style.styleID), !this.dirty && respectDirty)
      return;
    this._font = this._style.toFontString();
    const context2 = this.context, measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), width = measured.width, height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context2.scale(this._resolution, this._resolution), context2.clearRect(0, 0, this.canvas.width, this.canvas.height), context2.font = this._font, context2.lineWidth = style.strokeThickness, context2.textBaseline = style.textBaseline, context2.lineJoin = style.lineJoin, context2.miterLimit = style.miterLimit;
    let linePositionX, linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i2 = 0; i2 < passesCount; ++i2) {
      const isShadowPass = style.dropShadow && i2 === 0, dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0, dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black", context2.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * this._resolution, dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context2.shadowBlur = dropShadowBlur, context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else
        context2.fillStyle = this._generateFillStyle(style, lines, measured), context2.strokeStyle = style.stroke, context2.shadowColor = "black", context2.shadowBlur = 0, context2.shadowOffsetX = 0, context2.shadowOffsetY = 0;
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);
      for (let i22 = 0; i22 < lines.length; i22++)
        linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === "right" ? linePositionX += maxLineWidth - lineWidths[i22] : style.align === "center" && (linePositionX += (maxLineWidth - lineWidths[i22]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(
          lines[i22],
          linePositionX + style.padding,
          linePositionY + style.padding - dsOffsetText,
          true
        ), style.fill && this.drawLetterSpacing(
          lines[i22],
          linePositionX + style.padding,
          linePositionY + style.padding - dsOffsetText
        );
    }
    this.updateTexture();
  }
  /**
   * Render the text with letter-spacing.
   * @param text - The text to draw
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Is this drawing for the outside stroke of the
   *  text? If not, it's for the inside fill
   */
  drawLetterSpacing(text, x2, y2, isStroke = false) {
    const letterSpacing = this._style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = true) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), letterSpacing === 0 || useExperimentalLetterSpacing) {
      isStroke ? this.context.strokeText(text, x2, y2) : this.context.fillText(text, x2, y2);
      return;
    }
    let currentPosition = x2;
    const stringArray = TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width, currentWidth = 0;
    for (let i2 = 0; i2 < stringArray.length; ++i2) {
      const currentChar = stringArray[i2];
      isStroke ? this.context.strokeText(currentChar, currentPosition, y2) : this.context.fillText(currentChar, currentPosition, y2);
      let textStr = "";
      for (let j2 = i2 + 1; j2 < stringArray.length; ++j2)
        textStr += stringArray[j2];
      currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;
    }
  }
  /** Updates texture size based on canvas size. */
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = trimCanvas(canvas);
      trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));
    }
    const texture = this._texture, style = this._style, padding = style.trim ? 0 : style.padding, baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = false;
  }
  /**
   * Renders the object using the WebGL renderer
   * @param renderer - The renderer
   */
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._render(renderer);
  }
  /** Updates the transform on all children of this container for rendering. */
  updateTransform() {
    this.updateText(true), super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    return this.updateText(true), this._textureID === -1 && (skipUpdate = false), super.getBounds(skipUpdate, rect);
  }
  /**
   * Gets the local bounds of the text object.
   * @param rect - The output rectangle.
   * @returns The bounds.
   */
  getLocalBounds(rect) {
    return this.updateText(true), super.getLocalBounds.call(this, rect);
  }
  /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */
  _calculateBounds() {
    this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }
  /**
   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
   * @param style - The style.
   * @param lines - The lines of text.
   * @param metrics
   * @returns The fill style
   */
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (Array.isArray(fillStyle)) {
      if (fillStyle.length === 1)
        return fillStyle[0];
    } else
      return fillStyle;
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2, height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i2 = 1; i2 < lengthPlus1; ++i2)
        fillGradientStops.push(i2 / lengthPlus1);
    }
    if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight, thisLineTop = metrics.lineHeight * i2;
        let thisLineGradientStart = thisLineTop;
        i2 > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);
        const thisLineBottom = thisLineTop + textHeight, nextLineTop = metrics.lineHeight * (i2 + 1);
        let thisLineGradientEnd = thisLineBottom;
        i2 + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j2 = 0; j2 < fill.length; j2++) {
          let lineStop = 0;
          typeof fillGradientStops[j2] == "number" ? lineStop = fillGradientStops[j2] : lineStop = j2 / fill.length;
          let globalStop = Math.min(1, Math.max(
            0,
            thisLineGradientStart / height + lineStop * gradStopLineHeight
          ));
          globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j2]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i2 = 0; i2 < fill.length; i2++) {
        let stop;
        typeof fillGradientStops[i2] == "number" ? stop = fillGradientStops[i2] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i2]), currentIteration++;
      }
    }
    return gradient;
  }
  /**
   * Destroys this text object.
   *
   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
   * the majority of the time the texture will not be shared with any other Sprites.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their
   *  destroy method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
   */
  destroy(options) {
    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
  }
  /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._texture.orig.width, this._width = value;
  }
  /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._texture.orig.height, this._height = value;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link PIXI.ITextStyle}.
   */
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {}, style instanceof TextStyle ? this._style = style : this._style = new TextStyle(style), this.localStyleID = -1, this.dirty = true;
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = true);
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   *
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
  }
};
_Text.defaultAutoResolution = true;
let Text = _Text;
class CountLimiter {
  /**
   * @param maxItemsPerFrame - The maximum number of items that can be prepared each frame.
   */
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame, this.itemsLeft = 0;
  }
  /** Resets any counting properties to start fresh on a new frame. */
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  /**
   * Checks to see if another item can be uploaded. This should only be called once per item.
   * @returns If the item is allowed to be uploaded.
   */
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}
function findMultipleBaseTextures(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i2 = 0; i2 < item._textures.length; i2++)
      if (item._textures[i2] instanceof Texture) {
        const baseTexture = item._textures[i2].baseTexture;
        queue.includes(baseTexture) || (queue.push(baseTexture), result = true);
      }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    const texture = item.baseTexture;
    return queue.includes(texture) || queue.push(texture), true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    const texture = item._texture.baseTexture;
    return queue.includes(texture) || queue.push(texture), true;
  }
  return false;
}
function drawText(_helper, item) {
  return item instanceof Text ? (item.updateText(true), true) : false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    const font = item.toFontString();
    return TextMetrics.measureFont(font), true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    queue.includes(item.style) || queue.push(item.style), queue.includes(item) || queue.push(item);
    const texture = item._texture.baseTexture;
    return queue.includes(texture) || queue.push(texture), true;
  }
  return false;
}
function findTextStyle(item, queue) {
  return item instanceof TextStyle ? (queue.includes(item) || queue.push(item), true) : false;
}
const _BasePrepare = class _BasePrepare2 {
  /**
   * @param {PIXI.IRenderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.limiter = new CountLimiter(_BasePrepare2.uploadsPerFrame), this.renderer = renderer, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = false, this.delayedTick = () => {
      this.queue && this.prepareItems();
    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
  }
  /**
   * Upload all the textures and graphics to the GPU.
   * @method PIXI.BasePrepare#upload
   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} [item] -
   *        Container or display object to search for items to upload or the items to upload themselves,
   *        or optionally ommitted, if items have been added using {@link PIXI.BasePrepare#add `prepare.add`}.
   */
  upload(item) {
    return new Promise((resolve2) => {
      item && this.add(item), this.queue.length ? (this.completes.push(resolve2), this.ticking || (this.ticking = true, Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY))) : resolve2();
    });
  }
  /**
   * Handle tick update
   * @private
   */
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  /**
   * Actually prepare items. This is handled outside of the tick because it will take a while
   * and we do NOT want to block the current animation frame from rendering.
   * @private
   */
  prepareItems() {
    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i2 = 0, len = this.uploadHooks.length; i2 < len; i2++)
          if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
            this.queue.shift(), uploaded = true;
            break;
          }
      }
      uploaded || this.queue.shift();
    }
    if (this.queue.length)
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    else {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i2 = 0, len = completes.length; i2 < len; i2++)
        completes[i2]();
    }
  }
  /**
   * Adds hooks for finding items.
   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
   *          function must return `true` if it was able to add item to the queue.
   * @returns Instance of plugin for chaining.
   */
  registerFindHook(addHook) {
    return addHook && this.addHooks.push(addHook), this;
  }
  /**
   * Adds hooks for uploading items.
   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
   *          function must return `true` if it was able to handle upload of item.
   * @returns Instance of plugin for chaining.
   */
  registerUploadHook(uploadHook) {
    return uploadHook && this.uploadHooks.push(uploadHook), this;
  }
  /**
   * Manually add an item to the uploading queue.
   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
   *        add to the queue
   * @returns Instance of plugin for chaining.
   */
  add(item) {
    for (let i2 = 0, len = this.addHooks.length; i2 < len && !this.addHooks[i2](item, this.queue); i2++)
      ;
    if (item instanceof Container)
      for (let i2 = item.children.length - 1; i2 >= 0; i2--)
        this.add(item.children[i2]);
    return this;
  }
  /** Destroys the plugin, don't use after this. */
  destroy() {
    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = false, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
  }
};
_BasePrepare.uploadsPerFrame = 4;
let BasePrepare = _BasePrepare;
Object.defineProperties(settings, {
  /**
   * Default number of uploads per frame using prepare plugin.
   * @static
   * @memberof PIXI.settings
   * @name UPLOADS_PER_FRAME
   * @deprecated since 7.1.0
   * @see PIXI.BasePrepare.uploadsPerFrame
   * @type {number}
   */
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.uploadsPerFrame;
    },
    set(value) {
      deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), BasePrepare.uploadsPerFrame = value;
    }
  }
});
function uploadBaseTextures(renderer, item) {
  return item instanceof BaseTexture ? (item._glTextures[renderer.CONTEXT_UID] || renderer.texture.bind(item), true) : false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics))
    return false;
  const { geometry } = item;
  item.finishPoly(), geometry.updateBatches();
  const { batches } = geometry;
  for (let i2 = 0; i2 < batches.length; i2++) {
    const { texture } = batches[i2].style;
    texture && uploadBaseTextures(renderer, texture.baseTexture);
  }
  return geometry.batchable || renderer.geometry.bind(geometry, item._resolveDirectShader(renderer)), true;
}
function findGraphics(item, queue) {
  return item instanceof Graphics ? (queue.push(item), true) : false;
}
class Prepare extends BasePrepare {
  /**
   * @param {PIXI.Renderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    super(renderer), this.uploadHookHelper = this.renderer, this.registerFindHook(findGraphics), this.registerUploadHook(uploadBaseTextures), this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: ExtensionType.RendererSystem
};
extensions$1.add(Prepare);
var gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`;
var gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
var gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`;
var gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const tempMat = new Matrix();
class TilingSpriteRenderer extends ObjectRenderer {
  /**
   * constructor for renderer
   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.
   */
  constructor(renderer) {
    super(renderer), renderer.runners.contextChange.add(this), this.quad = new QuadUv(), this.state = State.for2d();
  }
  /** Creates shaders when context is initialized. */
  contextChange() {
    const renderer = this.renderer, uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms), this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  }
  /**
   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered
   */
  render(ts) {
    const renderer = this.renderer, quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0, anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs, vertices[0] = vertices[6] = -anchorX, vertices[1] = vertices[3] = -anchorY, vertices[2] = vertices[4] = 1 - anchorX, vertices[5] = vertices[7] = 1 - anchorY, quad.invalidate();
    const tex = ts._texture, baseTex = tex.baseTexture, premultiplied = baseTex.alphaMode > 0, lt = ts.tileTransform.localTransform, uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP : baseTex.wrapMode === WRAP_MODES.CLAMP && (baseTex.wrapMode = WRAP_MODES.REPEAT));
    const shader = isSimple ? this.simpleShader : this.shader, w2 = tex.width, h2 = tex.height, W2 = ts._width, H2 = ts._height;
    tempMat.set(
      lt.a * w2 / W2,
      lt.b * w2 / H2,
      lt.c * h2 / W2,
      lt.d * h2 / H2,
      lt.tx / W2,
      lt.ty / H2
    ), tempMat.invert(), isSimple ? tempMat.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(true), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = tempMat.toArray(true), shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied), renderer.state.set(this.state), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(TilingSpriteRenderer);
const _Spritesheet = class _Spritesheet2 {
  /** @ignore */
  constructor(optionsOrTexture, arg1, arg2) {
    this.linkedSheets = [], (optionsOrTexture instanceof BaseTexture || optionsOrTexture instanceof Texture) && (optionsOrTexture = { texture: optionsOrTexture, data: arg1, resolutionFilename: arg2 });
    const { texture, data, resolutionFilename = null, cachePrefix = "" } = optionsOrTexture;
    this.cachePrefix = cachePrefix, this._texture = texture instanceof Texture ? texture : null, this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Generate the resolution from the filename or fallback
   * to the meta.scale field of the JSON data.
   * @param resolutionFilename - The filename to use for resolving
   *        the default resolution.
   * @returns Resolution to use for spritesheet.
   */
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = getResolutionOfUrl(resolutionFilename, null);
    return resolution === null && (resolution = typeof scale == "number" ? scale : parseFloat(scale ?? "1")), resolution !== 1 && this.baseTexture.setResolution(resolution), resolution;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   * @method PIXI.Spritesheet#parse
   */
  parse() {
    return new Promise((resolve2) => {
      this._callback = resolve2, this._batchIndex = 0, this._frameKeys.length <= _Spritesheet2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet2.BATCH_SIZE;
    for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length; ) {
      const i2 = this._frameKeys[frameIndex], data = this._frames[i2], rect = data.frame;
      if (rect) {
        let frame = null, trim2 = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame, orig = new Rectangle(
          0,
          0,
          Math.floor(sourceSize.w) / this.resolution,
          Math.floor(sourceSize.h) / this.resolution
        );
        data.rotated ? frame = new Rectangle(
          Math.floor(rect.x) / this.resolution,
          Math.floor(rect.y) / this.resolution,
          Math.floor(rect.h) / this.resolution,
          Math.floor(rect.w) / this.resolution
        ) : frame = new Rectangle(
          Math.floor(rect.x) / this.resolution,
          Math.floor(rect.y) / this.resolution,
          Math.floor(rect.w) / this.resolution,
          Math.floor(rect.h) / this.resolution
        ), data.trimmed !== false && data.spriteSourceSize && (trim2 = new Rectangle(
          Math.floor(data.spriteSourceSize.x) / this.resolution,
          Math.floor(data.spriteSourceSize.y) / this.resolution,
          Math.floor(rect.w) / this.resolution,
          Math.floor(rect.h) / this.resolution
        )), this.textures[i2] = new Texture(
          this.baseTexture,
          frame,
          orig,
          trim2,
          data.rotated ? 2 : 0,
          data.anchor,
          data.borders
        ), Texture.addToCache(this.textures[i2], this.cachePrefix + i2.toString());
      }
      frameIndex++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const animations2 = this.data.animations || {};
    for (const animName in animations2) {
      this.animations[animName] = [];
      for (let i2 = 0; i2 < animations2[animName].length; i2++) {
        const frameName = animations2[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const callback = this._callback;
    this._callback = null, this._batchIndex = 0, callback.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(destroyBase = false) {
    for (const i2 in this.textures)
      this.textures[i2].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, destroyBase && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
  }
};
_Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;
const validImages = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "s3tc",
  "s3tc_sRGB",
  "etc",
  "etc1",
  "pvrtc",
  "atc",
  "astc",
  "bptc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  if (keys.forEach((key) => {
    out[key] = asset;
  }), Object.keys(asset.textures).forEach((key) => {
    out[`${asset.cachePrefix}${key}`] = asset.textures[key];
  }), !ignoreMultiPack) {
    const basePath2 = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i2) => {
      Object.assign(out, getCacheableAssets(
        [`${basePath2}/${asset.data.meta.related_multi_packs[i2]}`],
        item,
        true
      ));
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (asset) => asset instanceof Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  /** Resolve the the resolution of the asset. */
  resolver: {
    test: (value) => {
      const split = value.split("?")[0].split("."), extension = split.pop(), format2 = split.pop();
      return extension === "json" && validImages.includes(format2);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into PIXI.Spritesheet
   * All textures in the sprite sheet are then added to the cache
   * @ignore
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      const {
        texture: imageTexture,
        // if user need to use preloaded texture
        imageFilename,
        // if user need to use custom filename (not from jsonFile.meta.image)
        cachePrefix
        // if user need to use custom cache prefix
      } = options?.data ?? {};
      let basePath2 = path.dirname(options.src);
      basePath2 && basePath2.lastIndexOf("/") !== basePath2.length - 1 && (basePath2 += "/");
      let texture;
      if (imageTexture && imageTexture.baseTexture)
        texture = imageTexture;
      else {
        const imagePath = copySearchParams(basePath2 + (imageFilename ?? asset.meta.image), options.src);
        texture = (await loader.load([imagePath]))[imagePath];
      }
      const spritesheet = new Spritesheet({
        texture: texture.baseTexture,
        data: asset,
        resolutionFilename: options.src,
        cachePrefix
      });
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item != "string")
            continue;
          let itemUrl = basePath2 + item;
          options.data?.ignoreMultiPack || (itemUrl = copySearchParams(itemUrl, options.src), promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          })));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res, res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
extensions$1.add(spritesheetAsset);
class BitmapFontData {
  constructor() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }
}
class TextFormat {
  /**
   * Check if resource refers to txt font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    return typeof data == "string" && data.startsWith("info face=");
  }
  /**
   * Convert text font data to a javascript object.
   * @param txt - Raw string data to be converted
   * @returns - Parsed font data
   */
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm), rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i2 in items) {
      const name2 = items[i2].match(/^[a-z]+/gm)[0], attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), itemData = {};
      for (const i22 in attributeList) {
        const split = attributeList[i22].split("="), key = split[0], strValue = split[1].replace(/"/gm, ""), floatValue = parseFloat(strValue), value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name2].push(itemData);
    }
    const font = new BitmapFontData();
    return rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    })), rawData.common.forEach((common2) => font.common.push({
      lineHeight: parseInt(common2.lineHeight, 10)
    })), rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    })), rawData.char.forEach((char2) => font.char.push({
      id: parseInt(char2.id, 10),
      page: parseInt(char2.page, 10),
      x: parseInt(char2.x, 10),
      y: parseInt(char2.y, 10),
      width: parseInt(char2.width, 10),
      height: parseInt(char2.height, 10),
      xoffset: parseInt(char2.xoffset, 10),
      yoffset: parseInt(char2.yoffset, 10),
      xadvance: parseInt(char2.xadvance, 10)
    })), rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    })), rawData.distanceField.forEach((df2) => font.distanceField.push({
      distanceRange: parseInt(df2.distanceRange, 10),
      fieldType: df2.fieldType
    })), font;
  }
}
class XMLFormat {
  /**
   * Check if resource refers to xml font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    const xml = data;
    return typeof data != "string" && "getElementsByTagName" in data && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  /**
   * Convert the XML into BitmapFontData that we can use.
   * @param xml
   * @returns - Data to use for BitmapFont
   */
  static parse(xml) {
    const data = new BitmapFontData(), info = xml.getElementsByTagName("info"), common2 = xml.getElementsByTagName("common"), page = xml.getElementsByTagName("page"), char2 = xml.getElementsByTagName("char"), kerning = xml.getElementsByTagName("kerning"), distanceField = xml.getElementsByTagName("distanceField");
    for (let i2 = 0; i2 < info.length; i2++)
      data.info.push({
        face: info[i2].getAttribute("face"),
        size: parseInt(info[i2].getAttribute("size"), 10)
      });
    for (let i2 = 0; i2 < common2.length; i2++)
      data.common.push({
        lineHeight: parseInt(common2[i2].getAttribute("lineHeight"), 10)
      });
    for (let i2 = 0; i2 < page.length; i2++)
      data.page.push({
        id: parseInt(page[i2].getAttribute("id"), 10) || 0,
        file: page[i2].getAttribute("file")
      });
    for (let i2 = 0; i2 < char2.length; i2++) {
      const letter = char2[i2];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i2 = 0; i2 < kerning.length; i2++)
      data.kerning.push({
        first: parseInt(kerning[i2].getAttribute("first"), 10),
        second: parseInt(kerning[i2].getAttribute("second"), 10),
        amount: parseInt(kerning[i2].getAttribute("amount"), 10)
      });
    for (let i2 = 0; i2 < distanceField.length; i2++)
      data.distanceField.push({
        fieldType: distanceField[i2].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
      });
    return data;
  }
}
class XMLStringFormat {
  /**
   * Check if resource refers to text xml font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    return typeof data == "string" && data.includes("<font>") ? XMLFormat.test(settings.ADAPTER.parseXML(data)) : false;
  }
  /**
   * Convert the text XML into BitmapFontData that we can use.
   * @param xmlTxt
   * @returns - Data to use for BitmapFont
   */
  static parse(xmlTxt) {
    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
  }
}
const formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i2 = 0; i2 < formats.length; i2++)
    if (formats[i2].test(data))
      return formats[i2];
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (Array.isArray(fillStyle)) {
    if (fillStyle.length === 1)
      return fillStyle[0];
  } else
    return fillStyle;
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = canvas.width / resolution - dropShadowCorrection - padding * 2, height = canvas.height / resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i2 = 1; i2 < lengthPlus1; ++i2)
      fillGradientStops.push(i2 / lengthPlus1);
  }
  if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const gradStopLineHeight = (metrics.fontProperties.fontSize + style.strokeThickness) / height;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const thisLineTop = metrics.lineHeight * i2;
      for (let j2 = 0; j2 < fill.length; j2++) {
        let lineStop = 0;
        typeof fillGradientStops[j2] == "number" ? lineStop = fillGradientStops[j2] : lineStop = j2 / fill.length;
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1), gradient.addColorStop(clampedStop, fill[j2]), lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i2 = 0; i2 < fill.length; i2++) {
      let stop;
      typeof fillGradientStops[i2] == "number" ? stop = fillGradientStops[i2] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i2]), currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x2, y2, resolution, style) {
  const char2 = metrics.text, fontProperties = metrics.fontProperties;
  context2.translate(x2, y2), context2.scale(resolution, resolution);
  const tx = style.strokeThickness / 2, ty = -(style.strokeThickness / 2);
  if (context2.font = style.toFontString(), context2.lineWidth = style.strokeThickness, context2.textBaseline = style.textBaseline, context2.lineJoin = style.lineJoin, context2.miterLimit = style.miterLimit, context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char2], metrics), context2.strokeStyle = style.stroke, style.dropShadow) {
    const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * resolution, dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context2.shadowBlur = dropShadowBlur, context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else
    context2.shadowColor = "black", context2.shadowBlur = 0, context2.shadowOffsetX = 0, context2.shadowOffsetY = 0;
  style.stroke && style.strokeThickness && context2.strokeText(char2, tx, ty + metrics.lineHeight - fontProperties.descent), style.fill && context2.fillText(char2, tx, ty + metrics.lineHeight - fontProperties.descent), context2.setTransform(1, 0, 0, 1, 0, 0), context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
function resolveCharacters(chars) {
  typeof chars == "string" && (chars = [chars]);
  const result = [];
  for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      const startCode = item[0].charCodeAt(0), endCode = item[1].charCodeAt(0);
      if (endCode < startCode)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++)
        result.push(String.fromCharCode(i22));
    } else
      result.push(...splitTextToCharacters(item));
  }
  if (result.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return result;
}
const _BitmapFont = class _BitmapFont2 {
  /**
   * @param data
   * @param textures
   * @param ownsTextures - Setting to `true` will destroy page textures
   *        when the font is uninstalled.
   */
  constructor(data, textures, ownsTextures) {
    const [info] = data.info, [common2] = data.common, [page] = data.page, [distanceField] = data.distanceField, res = getResolutionOfUrl(page.file), pageTextures = {};
    this._ownsTextures = ownsTextures, this.font = info.face, this.size = info.size, this.lineHeight = common2.lineHeight / res, this.chars = {}, this.pageTextures = pageTextures;
    for (let i2 = 0; i2 < data.page.length; i2++) {
      const { id: id2, file } = data.page[i2];
      pageTextures[id2] = textures instanceof Array ? textures[i2] : textures[file], distanceField?.fieldType && distanceField.fieldType !== "none" && (pageTextures[id2].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, pageTextures[id2].baseTexture.mipmap = MIPMAP_MODES.OFF);
    }
    for (let i2 = 0; i2 < data.char.length; i2++) {
      const { id: id2, page: page2 } = data.char[i2];
      let { x: x2, y: y2, width, height, xoffset, yoffset, xadvance } = data.char[i2];
      x2 /= res, y2 /= res, width /= res, height /= res, xoffset /= res, yoffset /= res, xadvance /= res;
      const rect = new Rectangle(
        x2 + pageTextures[page2].frame.x / res,
        y2 + pageTextures[page2].frame.y / res,
        width,
        height
      );
      this.chars[id2] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(
          pageTextures[page2].baseTexture,
          rect
        ),
        page: page2
      };
    }
    for (let i2 = 0; i2 < data.kerning.length; i2++) {
      let { first: first2, second, amount } = data.kerning[i2];
      first2 /= res, second /= res, amount /= res, this.chars[second] && (this.chars[second].kerning[first2] = amount);
    }
    this.distanceFieldRange = distanceField?.distanceRange, this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  /** Remove references to created glyph textures. */
  destroy() {
    for (const id2 in this.chars)
      this.chars[id2].texture.destroy(), this.chars[id2].texture = null;
    for (const id2 in this.pageTextures)
      this._ownsTextures && this.pageTextures[id2].destroy(true), this.pageTextures[id2] = null;
    this.chars = null, this.pageTextures = null;
  }
  /**
   * Register a new bitmap font.
   * @param data - The
   *        characters map that could be provided as xml or raw string.
   * @param textures - List of textures for each page.
   * @param ownsTextures - Set to `true` to destroy page textures
   *        when the font is uninstalled. By default fonts created with
   *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.
   * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight
   *         and char fields.
   */
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData)
      fontData = data;
    else {
      const format2 = autoDetectFormat(data);
      if (!format2)
        throw new Error("Unrecognized data format for font.");
      fontData = format2.parse(data);
    }
    textures instanceof Texture && (textures = [textures]);
    const font = new _BitmapFont2(fontData, textures, ownsTextures);
    return _BitmapFont2.available[font.font] = font, font;
  }
  /**
   * Remove bitmap font by name.
   * @param name - Name of the font to uninstall.
   */
  static uninstall(name2) {
    const font = _BitmapFont2.available[name2];
    if (!font)
      throw new Error(`No font found named '${name2}'`);
    font.destroy(), delete _BitmapFont2.available[name2];
  }
  /**
   * Generates a bitmap-font for the given style and character set. This does not support
   * kernings yet. With `style` properties, only the following non-layout properties are used:
   *
   * - {@link PIXI.TextStyle#dropShadow|dropShadow}
   * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}
   * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}
   * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}
   * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}
   * - {@link PIXI.TextStyle#fill|fill}
   * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}
   * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}
   * - {@link PIXI.TextStyle#fontFamily|fontFamily}
   * - {@link PIXI.TextStyle#fontSize|fontSize}
   * - {@link PIXI.TextStyle#fontVariant|fontVariant}
   * - {@link PIXI.TextStyle#fontWeight|fontWeight}
   * - {@link PIXI.TextStyle#lineJoin|lineJoin}
   * - {@link PIXI.TextStyle#miterLimit|miterLimit}
   * - {@link PIXI.TextStyle#stroke|stroke}
   * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}
   * - {@link PIXI.TextStyle#textBaseline|textBaseline}
   * @param name - The name of the custom font to use with BitmapText.
   * @param textStyle - Style options to render with BitmapFont.
   * @param options - Setup options for font or name of the font.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.from('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText('This is the title', { fontName: 'TitleFont' });
   */
  static from(name2, textStyle, options) {
    if (!name2)
      throw new Error("[BitmapFont] Property `name` is required.");
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont2.defaultOptions, options), charsList = resolveCharacters(chars), style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle), lineWidth = textureWidth, fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    }, fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0, positionY = 0, canvas, context2, baseTexture, maxCharHeight = 0;
    const textures = [];
    for (let i2 = 0; i2 < charsList.length; i2++) {
      canvas || (canvas = settings.ADAPTER.createCanvas(), canvas.width = textureWidth, canvas.height = textureHeight, context2 = canvas.getContext("2d"), baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions }), textures.push(new Texture(baseTexture)), fontData.page.push({
        id: textures.length - 1,
        file: ""
      }));
      const character2 = charsList[i2], metrics = TextMetrics.measureText(character2, style, false, canvas), width = metrics.width, height = Math.ceil(metrics.height), textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0)
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character2}')`);
        --i2, canvas = null, context2 = null, baseTexture = null, positionY = 0, positionX = 0, maxCharHeight = 0;
        continue;
      }
      if (maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight), textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0)
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character2}')`);
        --i2, positionY += maxCharHeight * resolution, positionY = Math.ceil(positionY), positionX = 0, maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
      const id2 = extractCharCode(metrics.text);
      fontData.char.push({
        id: id2,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      }), positionX += (textureGlyphWidth + 2 * padding) * resolution, positionX = Math.ceil(positionX);
    }
    if (!options?.skipKerning)
      for (let i2 = 0, len = charsList.length; i2 < len; i2++) {
        const first2 = charsList[i2];
        for (let j2 = 0; j2 < len; j2++) {
          const second = charsList[j2], c1 = context2.measureText(first2).width, c2 = context2.measureText(second).width, amount = context2.measureText(first2 + second).width - (c1 + c2);
          amount && fontData.kerning.push({
            first: extractCharCode(first2),
            second: extractCharCode(second),
            amount
          });
        }
      }
    const font = new _BitmapFont2(fontData, textures, true);
    return _BitmapFont2.available[name2] !== void 0 && _BitmapFont2.uninstall(name2), _BitmapFont2.available[name2] = font, font;
  }
};
_BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "], /**
* This character set includes all decimal digits (from 0 to 9).
* @type {string[][]}
* @example
* BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })
*/
_BitmapFont.NUMERIC = [["0", "9"]], /**
* This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.
* @type {string[][]}
*/
_BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], /**
* This character set consists of all the ASCII table.
* @member {string[][]}
* @see http://www.asciitable.com/
*/
_BitmapFont.ASCII = [[" ", "~"]], /**
* Collection of default options when using `BitmapFont.from`.
* @property {number} [resolution=1] -
* @property {number} [textureWidth=512] -
* @property {number} [textureHeight=512] -
* @property {number} [padding=4] -
* @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC
*/
_BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
}, /** Collection of available/installed fonts. */
_BitmapFont.available = {};
let BitmapFont = _BitmapFont;
var msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`;
var msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [], _BitmapText = class _BitmapText2 extends Container {
  /**
   * @param text - A string that you would like the text to display.
   * @param style - The style parameters.
   * @param {string} style.fontName - The installed BitmapFont name.
   * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,
   *.     this will default to the BitmapFont size.
   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),
   *      does not affect single line text.
   * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.
   * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.
   * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.
   */
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(
      {},
      _BitmapText2.styleDefaults,
      style
    );
    if (!BitmapFont.available[fontName])
      throw new Error(`Missing BitmapFont "${fontName}"`);
    this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = align, this._tintColor = new Color(tint), this._font = void 0, this._fontName = fontName, this._fontSize = fontSize, this.text = text, this._maxWidth = maxWidth, this._maxLineHeight = 0, this._letterSpacing = letterSpacing, this._anchor = new ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0), this._roundPixels = settings.ROUND_PIXELS, this.dirty = true, this._resolution = settings.RESOLUTION, this._autoResolution = true, this._textureCache = {};
  }
  /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */
  updateText() {
    const data = BitmapFont.available[this._fontName], fontSize = this.fontSize, scale = fontSize / data.size, pos = new Point(), chars = [], lineWidths = [], lineSpaces = [], text = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", charsInput = splitTextToCharacters(text), maxWidth = this._maxWidth * data.size / fontSize, pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null, lastLineWidth = 0, maxLineWidth = 0, line2 = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, maxLineHeight = 0, spaceCount = 0;
    for (let i2 = 0; i2 < charsInput.length; i2++) {
      const char2 = charsInput[i2], charCode = extractCharCode(char2);
      if (/(?:\s)/.test(char2) && (lastBreakPos = i2, lastBreakWidth = lastLineWidth, spaceCount++), char2 === "\r" || char2 === `
`) {
        lineWidths.push(lastLineWidth), lineSpaces.push(-1), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line2, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData)
        continue;
      prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]);
      const charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture, charRenderData.line = line2, charRenderData.charCode = charCode, charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2), charRenderData.position.y = Math.round(pos.y + charData.yOffset), charRenderData.prevSpaces = spaceCount, chars.push(charRenderData), lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width), pos.x += charData.xAdvance + this._letterSpacing, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (++spacesRemoved, removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos), i2 = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line2++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);
    }
    const lastChar = charsInput[charsInput.length - 1];
    lastChar !== "\r" && lastChar !== `
` && (/(?:\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), lineSpaces.push(-1));
    const lineAlignOffsets = [];
    for (let i2 = 0; i2 <= line2; i2++) {
      let alignOffset = 0;
      this._align === "right" ? alignOffset = maxLineWidth - lineWidths[i2] : this._align === "center" ? alignOffset = (maxLineWidth - lineWidths[i2]) / 2 : this._align === "justify" && (alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2]), lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length, pagesMeshData = {}, newPagesMeshData = [], activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i2 = 0; i2 < lenChars; i2++) {
      const texture = chars[i2].texture, baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new MeshGeometry();
          let material, meshBlendMode;
          data.distanceFieldType === "none" ? (material = new MeshMaterial(Texture.EMPTY), meshBlendMode = BLEND_MODES.NORMAL) : (material = new MeshMaterial(
            Texture.EMPTY,
            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }
          ), meshBlendMode = BLEND_MODES.NORMAL_NPM);
          const mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode, pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0, pageMeshData.indexCount = 0, pageMeshData.vertexCount = 0, pageMeshData.uvsCount = 0, pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture), pageMeshData.mesh.texture = _textureCache[baseTextureUid], pageMeshData.mesh.tint = this._tintColor.value, newPagesMeshData.push(pageMeshData), pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i2 = 0; i2 < activePagesMeshData.length; i2++)
      newPagesMeshData.includes(activePagesMeshData[i2]) || this.removeChild(activePagesMeshData[i2].mesh);
    for (let i2 = 0; i2 < newPagesMeshData.length; i2++)
      newPagesMeshData[i2].mesh.parent !== this && this.addChild(newPagesMeshData[i2].mesh);
    this._activePagesMeshData = newPagesMeshData;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2], total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)
        pageMeshData.vertices = new Float32Array(4 * 2 * total), pageMeshData.uvs = new Float32Array(4 * 2 * total), pageMeshData.indices = new Uint16Array(6 * total);
      else {
        const total2 = pageMeshData.total, vertices = pageMeshData.vertices;
        for (let i22 = total2 * 4 * 2; i22 < vertices.length; i22++)
          vertices[i22] = 0;
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i2 = 0; i2 < lenChars; i2++) {
      const char2 = chars[i2];
      let offset2 = char2.position.x + lineAlignOffsets[char2.line] * (this._align === "justify" ? char2.prevSpaces : 1);
      this._roundPixels && (offset2 = Math.round(offset2));
      const xPos = offset2 * scale, yPos = char2.position.y * scale, texture = char2.texture, pageMesh = pagesMeshData[texture.baseTexture.uid], textureFrame = texture.frame, textureUvs = texture._uvs, index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4, pageMesh.indices[index * 6 + 1] = 1 + index * 4, pageMesh.indices[index * 6 + 2] = 2 + index * 4, pageMesh.indices[index * 6 + 3] = 0 + index * 4, pageMesh.indices[index * 6 + 4] = 2 + index * 4, pageMesh.indices[index * 6 + 5] = 3 + index * 4, pageMesh.vertices[index * 8 + 0] = xPos, pageMesh.vertices[index * 8 + 1] = yPos, pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 3] = yPos, pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale, pageMesh.vertices[index * 8 + 6] = xPos, pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale, pageMesh.uvs[index * 8 + 0] = textureUvs.x0, pageMesh.uvs[index * 8 + 1] = textureUvs.y0, pageMesh.uvs[index * 8 + 2] = textureUvs.x1, pageMesh.uvs[index * 8 + 3] = textureUvs.y1, pageMesh.uvs[index * 8 + 4] = textureUvs.x2, pageMesh.uvs[index * 8 + 5] = textureUvs.y2, pageMesh.uvs[index * 8 + 6] = textureUvs.x3, pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x, anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i22 = 0; i22 < pageMeshData.total; i22++)
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition"), textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord"), indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices, textureBuffer.data = pageMeshData.uvs, indexBuffer.data = pageMeshData.indices, vertexBuffer.update(), textureBuffer.update(), indexBuffer.update();
    }
    for (let i2 = 0; i2 < chars.length; i2++)
      charRenderDataPool.push(chars[i2]);
    this._font = data, this.dirty = false;
  }
  updateTransform() {
    this.validate(), this.containerUpdateTransform();
  }
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true);
    const { distanceFieldRange, distanceFieldType, size: size2 } = BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a: a2, b: b2, c: c2, d: d2 } = this.worldTransform, dx = Math.sqrt(a2 * a2 + b2 * b2), dy = Math.sqrt(c2 * c2 + d2 * d2), worldScale = (Math.abs(dx) + Math.abs(dy)) / 2, fontScale = this.fontSize / size2, resolution = renderer._view.resolution;
      for (const mesh of this._activePagesMeshData)
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
    }
    super._render(renderer);
  }
  /**
   * Validates text before calling parent's getLocalBounds
   * @returns - The rectangular bounding area
   */
  getLocalBounds() {
    return this.validate(), super.getLocalBounds();
  }
  /**
   * Updates text when needed
   * @private
   */
  validate() {
    const font = BitmapFont.available[this._fontName];
    if (!font)
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    this._font !== font && (this.dirty = true), this.dirty && this.updateText();
  }
  /**
   * The tint of the BitmapText object.
   * @default 0xffffff
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint !== value) {
      this._tintColor.setValue(value);
      for (let i2 = 0; i2 < this._activePagesMeshData.length; i2++)
        this._activePagesMeshData[i2].mesh.tint = value;
    }
  }
  /**
   * The alignment of the BitmapText object.
   * @member {string}
   * @default 'left'
   */
  get align() {
    return this._align;
  }
  set align(value) {
    this._align !== value && (this._align = value, this.dirty = true);
  }
  /** The name of the BitmapFont. */
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.available[value])
      throw new Error(`Missing BitmapFont "${value}"`);
    this._fontName !== value && (this._fontName = value, this.dirty = true);
  }
  /** The size of the font to display. */
  get fontSize() {
    return this._fontSize ?? BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    this._fontSize !== value && (this._fontSize = value, this.dirty = true);
  }
  /**
   * The anchor sets the origin point of the text.
   *
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value == "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** The text of the BitmapText object. */
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = true);
  }
  /**
   * The max width of this bitmap text in pixels. If the text provided is longer than the
   * value provided, line breaks will be automatically inserted in the last whitespace.
   * Disable by setting the value to 0.
   */
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    this._maxWidth !== value && (this._maxWidth = value, this.dirty = true);
  }
  /**
   * The max line height. This is useful when trying to use the total height of the Text,
   * i.e. when trying to vertically align.
   * @readonly
   */
  get maxLineHeight() {
    return this.validate(), this._maxLineHeight;
  }
  /**
   * The width of the overall text, different from fontSize,
   * which is defined in the style object.
   * @readonly
   */
  get textWidth() {
    return this.validate(), this._textWidth;
  }
  /** Additional space between characters. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = true);
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
   * @default PIXI.settings.ROUND_PIXELS
   */
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    value !== this._roundPixels && (this._roundPixels = value, this.dirty = true);
  }
  /**
   * The height of the overall text, different from fontSize,
   * which is defined in the style object.
   * @readonly
   */
  get textHeight() {
    return this.validate(), this._textHeight;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   *
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
  }
  destroy(options) {
    const { _textureCache } = this, pageMeshDataPool = BitmapFont.available[this._fontName].distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData)
      this.removeChild(pageMeshData.mesh);
    this._activePagesMeshData = [], pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = Texture.EMPTY;
    });
    for (const id2 in _textureCache)
      _textureCache[id2].destroy(), delete _textureCache[id2];
    this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(options);
  }
};
_BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};
const validExtensions = [".xml", ".fnt"], loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url2) {
    return validExtensions.includes(path.extname(url2).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.test(data) || XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset), { src } = data, { page: pages } = fontData, textureUrls = [];
    for (let i2 = 0; i2 < pages.length; ++i2) {
      const pageFile = pages[i2].file;
      let imagePath = path.join(path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src), textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls), textures = textureUrls.map((url2) => loadedTextures[url2]);
    return BitmapFont.install(fontData, textures, true);
  },
  async load(url2, _options) {
    return (await settings.ADAPTER.fetch(url2)).text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions$1.add(loadBitmapFont);
const _HTMLTextStyle = class _HTMLTextStyle2 extends TextStyle {
  constructor() {
    super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = false;
  }
  /**
   * Convert a TextStyle to HTMLTextStyle
   * @param originalStyle
   * @example
   * import {TextStyle } from 'pixi.js';
   * import {HTMLTextStyle} from '@pixi/text-html';
   * const style = new TextStyle();
   * const htmlStyle = HTMLTextStyle.from(style);
   */
  static from(originalStyle) {
    return new _HTMLTextStyle2(
      Object.keys(_HTMLTextStyle2.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {})
    );
  }
  /** Clear the current font */
  cleanFonts() {
    this._fonts.length > 0 && (this._fonts.forEach((font) => {
      URL.revokeObjectURL(font.src), font.refs--, font.refs === 0 && (font.fontFace && document.fonts.delete(font.fontFace), delete _HTMLTextStyle2.availableFonts[font.originalUrl]);
    }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = true);
  }
  /**
   * Because of how HTMLText renders, fonts need to be imported
   * @param url
   * @param options
   */
  loadFont(url2, options = {}) {
    const { availableFonts } = _HTMLTextStyle2;
    if (availableFonts[url2]) {
      const font = availableFonts[url2];
      return this._fonts.push(font), font.refs++, this.styleID++, this.fontsDirty = true, Promise.resolve();
    }
    return settings.ADAPTER.fetch(url2).then((response) => response.blob()).then(async (blob) => new Promise((resolve2, reject2) => {
      const src = URL.createObjectURL(blob), reader = new FileReader();
      reader.onload = () => resolve2([src, reader.result]), reader.onerror = reject2, reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: path.basename(url2, path.extname(url2)),
        weight: "normal",
        style: "normal",
        display: "auto",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url2,
        fontFace: null
      }, options);
      availableFonts[url2] = font, this._fonts.push(font), this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style,
        display: font.display
      });
      font.fontFace = fontFace, await fontFace.load(), document.fonts.add(fontFace), await document.fonts.ready, this.styleID++, this.fontsDirty = true;
    });
  }
  /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   */
  addOverride(...value) {
    const toAdd = value.filter((v2) => !this._overrides.includes(v2));
    toAdd.length > 0 && (this._overrides.push(...toAdd), this.styleID++);
  }
  /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   */
  removeOverride(...value) {
    const toRemove = value.filter((v2) => this._overrides.includes(v2));
    toRemove.length > 0 && (this._overrides = this._overrides.filter((v2) => !toRemove.includes(v2)), this.styleID++);
  }
  /**
   * Internally converts all of the style properties into CSS equivalents.
   * @param scale
   * @returns The CSS style string, for setting `style` property of root HTMLElement.
   */
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      "transform-origin: top left",
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  /** Get the font CSS styles from the loaded font, If available. */
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style};
                font-display: ${font.display};
            }`, this._stylesheet);
  }
  /** Internal stylesheet contents, useful for creating rules for rendering */
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    this._stylesheet !== value && (this._stylesheet = value, this.styleID++);
  }
  /**
   * Convert numerical colors into hex-strings
   * @param color
   */
  normalizeColor(color) {
    return Array.isArray(color) && (color = rgb2hex(color)), typeof color == "number" ? hex2string(color) : color;
  }
  /** Convert the internal drop-shadow settings to CSS text-shadow */
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha, x2 = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance), y2 = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    color.startsWith("#") && alpha < 1 && (color += (alpha * 255 | 0).toString(16).padStart(2, "0"));
    const position2 = `${x2}px ${y2}px`;
    return this.dropShadowBlur > 0 ? `text-shadow: ${position2} ${this.dropShadowBlur}px ${color}` : `text-shadow: ${position2} ${color}`;
  }
  /** Resets all properties to the defaults specified in TextStyle.prototype._default */
  reset() {
    Object.assign(this, _HTMLTextStyle2.defaultOptions);
  }
  /**
   * Called after the image is loaded but before drawing to the canvas.
   * Mostly used to handle Safari's font loading bug.
   * @ignore
   */
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    return this.fontsDirty = false, this.isSafari && this._fonts.length > 0 && prevFontsDirty ? new Promise((resolve2) => setTimeout(resolve2, 100)) : Promise.resolve();
  }
  /**
   * Proving that Safari is the new IE
   * @ignore
   */
  get isSafari() {
    const { userAgent: userAgent2 } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent2);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
_HTMLTextStyle.availableFonts = {}, /**
* List of default options, these are largely the same as TextStyle,
* with the exception of whiteSpace, which is set to 'normal' by default.
*/
_HTMLTextStyle.defaultOptions = {
  /** Align */
  align: "left",
  /** Break words */
  breakWords: false,
  /** Drop shadow */
  dropShadow: false,
  /** Drop shadow alpha */
  dropShadowAlpha: 1,
  /**
   * Drop shadow angle
   * @type {number}
   * @default Math.PI / 6
   */
  dropShadowAngle: Math.PI / 6,
  /** Drop shadow blur */
  dropShadowBlur: 0,
  /** Drop shadow color */
  dropShadowColor: "black",
  /** Drop shadow distance */
  dropShadowDistance: 5,
  /** Fill */
  fill: "black",
  /** Font family */
  fontFamily: "Arial",
  /** Font size */
  fontSize: 26,
  /** Font style */
  fontStyle: "normal",
  /** Font variant */
  fontVariant: "normal",
  /** Font weight */
  fontWeight: "normal",
  /** Letter spacing */
  letterSpacing: 0,
  /** Line height */
  lineHeight: 0,
  /** Padding */
  padding: 0,
  /** Stroke */
  stroke: "black",
  /** Stroke thickness */
  strokeThickness: 0,
  /** White space */
  whiteSpace: "normal",
  /** Word wrap */
  wordWrap: false,
  /** Word wrap width */
  wordWrapWidth: 100
};
let HTMLTextStyle = _HTMLTextStyle;
const _HTMLText = class _HTMLText2 extends Sprite {
  /**
   * @param {string} [text] - Text contents
   * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.
   *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle
   *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.
   */
  constructor(text = "", style = {}) {
    super(Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = true, this.localStyleID = -1, this.dirty = false, this._updateID = 0, this.ownsStyle = false;
    const image = new Image(), texture = Texture.from(image, {
      scaleMode: settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new Rectangle(), texture.trim = new Rectangle(), this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg", nsxhtml = "http://www.w3.org/1999/xhtml", svgRoot = document.createElementNS(nssvg, "svg"), foreignObject = document.createElementNS(nssvg, "foreignObject"), domElement = document.createElementNS(nsxhtml, "div"), styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000"), foreignObject.setAttribute("height", "10000"), foreignObject.style.overflow = "hidden", svgRoot.appendChild(foreignObject), this.maxWidth = _HTMLText2.defaultMaxWidth, this.maxHeight = _HTMLText2.defaultMaxHeight, this._domElement = domElement, this._styleElement = styleElement, this._svgRoot = svgRoot, this._foreignObject = foreignObject, this._foreignObject.appendChild(styleElement), this._foreignObject.appendChild(domElement), this._image = image, this._loadImage = new Image(), this._autoResolution = _HTMLText2.defaultAutoResolution, this._resolution = _HTMLText2.defaultResolution ?? settings.RESOLUTION, this.text = text, this.style = style;
  }
  /**
   * Calculate the size of the output text without actually drawing it.
   * This includes the `padding` in the `style` object.
   * This can be used as a fast-pass to do things like text-fitting.
   * @param {object} [overrides] - Overrides for the text, style, and resolution.
   * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.
   * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.
   * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.
   * @returns {PIXI.ISize} Width and height of the measured text.
   */
  measureText(overrides) {
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    }), this._styleElement.textContent = style.toGlobalCSS(), document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const { width, height } = contentBounds;
    (width > this.maxWidth || height > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
    const contentWidth = Math.min(this.maxWidth, Math.ceil(width)), contentHeight = Math.min(this.maxHeight, Math.ceil(height));
    return this._svgRoot.setAttribute("width", contentWidth.toString()), this._svgRoot.setAttribute("height", contentHeight.toString()), text !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, { style: this._style?.toCSS(resolution) }), this._styleElement.textContent = this._style?.toGlobalCSS()), {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  /**
   * Manually refresh the text.
   * @public
   * @param {boolean} respectDirty - Whether to abort updating the
   *        text if the Text isn't dirty and the function is called.
   */
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID && (this.dirty = true, this.localStyleID = style.styleID), !this.dirty && respectDirty)
      return;
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width)), image.height = loadImage.height = Math.ceil(Math.max(1, height)), this._updateID++;
    const updateID = this._updateID;
    await new Promise((resolve2) => {
      loadImage.onload = async () => {
        if (updateID < this._updateID) {
          resolve2();
          return;
        }
        await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = "", this.updateTexture(), resolve2();
      };
      const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
      loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
    });
  }
  /** The raw image element that is rendered under-the-hood. */
  get source() {
    return this._image;
  }
  /**
   * Update the texture resource.
   * @private
   */
  updateTexture() {
    const { style, texture, _image: image, resolution } = this, { padding } = style, { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution, texture.trim.height = texture._frame.height = image.height / resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(image.width, image.height, resolution), this.dirty = false;
  }
  /**
   * Renders the object using the WebGL renderer
   * @param {PIXI.Renderer} renderer - The renderer
   * @private
   */
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._render(renderer);
  }
  /**
   * Renders the object using the Canvas Renderer.
   * @private
   * @param {PIXI.CanvasRenderer} renderer - The renderer
   */
  _renderCanvas(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._renderCanvas(renderer);
  }
  /**
   * Get the local bounds.
   * @param {PIXI.Rectangle} rect - Input rectangle.
   * @returns {PIXI.Rectangle} Local bounds
   */
  getLocalBounds(rect) {
    return this.updateText(true), super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }
  /**
   * Handle dirty style changes
   * @private
   */
  _onStyleChange() {
    this.dirty = true;
  }
  /**
   * Destroy this Text object. Don't use after calling.
   * @param {boolean|object} options - Same as Sprite destroy options.
   */
  destroy(options) {
    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, _HTMLText2.defaultDestroyOptions, options), super.destroy(options);
    const forceClear = null;
    this.ownsStyle && this._style?.cleanFonts(), this._style = forceClear, this._svgRoot?.remove(), this._svgRoot = forceClear, this._domElement?.remove(), this._domElement = forceClear, this._foreignObject?.remove(), this._foreignObject = forceClear, this._styleElement?.remove(), this._styleElement = forceClear, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = forceClear, this._image.src = "", this._image = forceClear;
  }
  /**
   * Get the width in pixels.
   * @member {number}
   */
  get width() {
    return this.updateText(true), Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._image.width / this.resolution, this._width = value;
  }
  /**
   * Get the height in pixels.
   * @member {number}
   */
  get height() {
    return this.updateText(true), Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._image.height / this.resolution, this._height = value;
  }
  /** The base style to render with text. */
  get style() {
    return this._style;
  }
  set style(style) {
    this._style !== style && (style = style || {}, style instanceof HTMLTextStyle ? (this.ownsStyle = false, this._style = style) : style instanceof TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = true, this._style = HTMLTextStyle.from(style)) : (this.ownsStyle = true, this._style = new HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = true);
  }
  /**
   * Contents of text. This can be HTML text and include tags.
   * @example
   * const text = new HTMLText('This is a <em>styled</em> text!');
   * @member {string}
   */
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text), text = this.sanitiseText(text), this._text !== text && (this._text = text, this.dirty = true);
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @member {number}
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
  }
  /**
   * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`
   * @param text
   * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3
   */
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
_HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
}, /** Default maxWidth, set at construction */
_HTMLText.defaultMaxWidth = 2024, /** Default maxHeight, set at construction */
_HTMLText.defaultMaxHeight = 2024, /** Default autoResolution for all HTMLText objects */
_HTMLText.defaultAutoResolution = true;
var __defProp = Object.defineProperty;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject2) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject2(e2);
      }
    };
    var step = (x2) => x2.done ? resolve2(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const LOGICAL_WIDTH = 2;
const LOGICAL_HEIGHT = 2;
var CubismConfig;
((CubismConfig2) => {
  CubismConfig2.supportMoreMaskDivisions = true;
  CubismConfig2.setOpacityFromMotion = false;
})(CubismConfig || (CubismConfig = {}));
const LOG_LEVEL_VERBOSE = 0;
const LOG_LEVEL_WARNING = 1;
const LOG_LEVEL_ERROR = 2;
const LOG_LEVEL_NONE = 999;
const config$1 = {
  LOG_LEVEL_VERBOSE,
  LOG_LEVEL_WARNING,
  LOG_LEVEL_ERROR,
  LOG_LEVEL_NONE,
  /**
   * Global log level.
   * @default config.LOG_LEVEL_WARNING
   */
  logLevel: LOG_LEVEL_WARNING,
  /**
   * Enabling sound for motions.
   */
  sound: true,
  /**
   * Deferring motion and corresponding sound until both are loaded.
   */
  motionSync: true,
  /**
   * Default fading duration for motions without such value specified.
   */
  motionFadingDuration: 500,
  /**
   * Default fading duration for idle motions without such value specified.
   */
  idleMotionFadingDuration: 2e3,
  /**
   * Default fading duration for expressions without such value specified.
   */
  expressionFadingDuration: 500,
  /**
   * If false, expression will be reset to default when playing non-idle motions.
   */
  preserveExpressionOnMotion: true,
  cubism4: CubismConfig
};
const logger = {
  log(tag, ...messages2) {
  },
  warn(tag, ...messages2) {
    {
      console.warn(`[${tag}]`, ...messages2);
    }
  },
  error(tag, ...messages2) {
    {
      console.error(`[${tag}]`, ...messages2);
    }
  }
};
function clamp(num, lower, upper) {
  return num < lower ? lower : num > upper ? upper : num;
}
function rand(min2, max2) {
  return Math.random() * (max2 - min2) + min2;
}
function copyProperty(type2, from2, to, fromKey, toKey) {
  const value = from2[fromKey];
  if (value !== null && typeof value === type2) {
    to[toKey] = value;
  }
}
function copyArray(type2, from2, to, fromKey, toKey) {
  const array = from2[fromKey];
  if (Array.isArray(array)) {
    to[toKey] = array.filter((item) => item !== null && typeof item === type2);
  }
}
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
      if (name2 !== "constructor") {
        Object.defineProperty(
          derivedCtor.prototype,
          name2,
          Object.getOwnPropertyDescriptor(baseCtor.prototype, name2)
        );
      }
    });
  });
}
function folderName(url2) {
  let lastSlashIndex = url2.lastIndexOf("/");
  if (lastSlashIndex != -1) {
    url2 = url2.slice(0, lastSlashIndex);
  }
  lastSlashIndex = url2.lastIndexOf("/");
  if (lastSlashIndex !== -1) {
    url2 = url2.slice(lastSlashIndex + 1);
  }
  return url2;
}
function remove$1(array, item) {
  const index = array.indexOf(item);
  if (index !== -1) {
    array.splice(index, 1);
  }
}
class ExpressionManager extends EventEmitter {
  constructor(settings2, options) {
    super();
    __publicField(this, "tag");
    __publicField(this, "settings");
    __publicField(this, "expressions", []);
    __publicField(this, "defaultExpression");
    __publicField(this, "currentExpression");
    __publicField(this, "reserveExpressionIndex", -1);
    __publicField(this, "destroyed", false);
    this.settings = settings2;
    this.tag = `ExpressionManager(${settings2.name})`;
  }
  /**
   * Should be called in the constructor of derived class.
   */
  init() {
    this.defaultExpression = this.createExpression({}, void 0);
    this.currentExpression = this.defaultExpression;
    this.stopAllExpressions();
  }
  /**
   * Loads an Expression. Errors in this method will not be thrown,
   * but be emitted with an "expressionLoadError" event.
   * @param index - Index of the expression in definitions.
   * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
   * @emits {@link ExpressionManagerEvents.expressionLoaded}
   * @emits {@link ExpressionManagerEvents.expressionLoadError}
   */
  loadExpression(index) {
    return __async(this, null, function* () {
      if (!this.definitions[index]) {
        logger.warn(this.tag, `Undefined expression at [${index}]`);
        return void 0;
      }
      if (this.expressions[index] === null) {
        logger.warn(
          this.tag,
          `Cannot set expression at [${index}] because it's already failed in loading.`
        );
        return void 0;
      }
      if (this.expressions[index]) {
        return this.expressions[index];
      }
      const expression = yield this._loadExpression(index);
      this.expressions[index] = expression;
      return expression;
    });
  }
  /**
   * Loads the Expression. Will be implemented by Live2DFactory in order to avoid circular dependency.
   * @ignore
   */
  _loadExpression(index) {
    throw new Error("Not implemented.");
  }
  /**
   * Sets a random Expression that differs from current one.
   * @return Promise that resolves with true if succeeded, with false otherwise.
   */
  setRandomExpression() {
    return __async(this, null, function* () {
      if (this.definitions.length) {
        const availableIndices = [];
        for (let i2 = 0; i2 < this.definitions.length; i2++) {
          if (this.expressions[i2] !== null && this.expressions[i2] !== this.currentExpression && i2 !== this.reserveExpressionIndex) {
            availableIndices.push(i2);
          }
        }
        if (availableIndices.length) {
          const index = Math.floor(Math.random() * availableIndices.length);
          return this.setExpression(index);
        }
      }
      return false;
    });
  }
  /**
   * Resets model's expression using {@link ExpressionManager#defaultExpression}.
   */
  resetExpression() {
    this._setExpression(this.defaultExpression);
  }
  /**
   * Restores model's expression to {@link currentExpression}.
   */
  restoreExpression() {
    this._setExpression(this.currentExpression);
  }
  /**
   * Sets an Expression.
   * @param index - Either the index, or the name of the expression.
   * @return Promise that resolves with true if succeeded, with false otherwise.
   */
  setExpression(index) {
    return __async(this, null, function* () {
      if (typeof index !== "number") {
        index = this.getExpressionIndex(index);
      }
      if (!(index > -1 && index < this.definitions.length)) {
        return false;
      }
      if (index === this.expressions.indexOf(this.currentExpression)) {
        return false;
      }
      this.reserveExpressionIndex = index;
      const expression = yield this.loadExpression(index);
      if (!expression || this.reserveExpressionIndex !== index) {
        return false;
      }
      this.reserveExpressionIndex = -1;
      this.currentExpression = expression;
      this._setExpression(expression);
      return true;
    });
  }
  /**
   * Updates parameters of the core model.
   * @return True if the parameters are actually updated.
   */
  update(model, now) {
    if (!this.isFinished()) {
      return this.updateParameters(model, now);
    }
    return false;
  }
  /**
   * Destroys the instance.
   * @emits {@link ExpressionManagerEvents.destroy}
   */
  destroy() {
    this.destroyed = true;
    this.emit("destroy");
    const self2 = this;
    self2.definitions = void 0;
    self2.expressions = void 0;
  }
}
const EPSILON = 0.01;
const MAX_SPEED = 40 / 7.5;
const ACCELERATION_TIME = 1 / (0.15 * 1e3);
class FocusController {
  constructor() {
    __publicField(this, "targetX", 0);
    __publicField(this, "targetY", 0);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "vx", 0);
    __publicField(this, "vy", 0);
  }
  /**
   * Sets the focus position.
   * @param x - X position in range `[-1, 1]`.
   * @param y - Y position in range `[-1, 1]`.
   * @param instant - Should the focus position be instantly applied.
   */
  focus(x2, y2, instant = false) {
    this.targetX = clamp(x2, -1, 1);
    this.targetY = clamp(y2, -1, 1);
    if (instant) {
      this.x = this.targetX;
      this.y = this.targetY;
    }
  }
  /**
   * Updates the interpolation.
   * @param dt - Delta time in milliseconds.
   */
  update(dt) {
    const dx = this.targetX - this.x;
    const dy = this.targetY - this.y;
    if (Math.abs(dx) < EPSILON && Math.abs(dy) < EPSILON)
      return;
    const d2 = Math.sqrt(__pow(dx, 2) + __pow(dy, 2));
    const maxSpeed = MAX_SPEED / (1e3 / dt);
    let ax = maxSpeed * (dx / d2) - this.vx;
    let ay = maxSpeed * (dy / d2) - this.vy;
    const a2 = Math.sqrt(__pow(ax, 2) + __pow(ay, 2));
    const maxA = maxSpeed * ACCELERATION_TIME * dt;
    if (a2 > maxA) {
      ax *= maxA / a2;
      ay *= maxA / a2;
    }
    this.vx += ax;
    this.vy += ay;
    const v2 = Math.sqrt(__pow(this.vx, 2) + __pow(this.vy, 2));
    const maxV = 0.5 * (Math.sqrt(__pow(maxA, 2) + 8 * maxA * d2) - maxA);
    if (v2 > maxV) {
      this.vx *= maxV / v2;
      this.vy *= maxV / v2;
    }
    this.x += this.vx;
    this.y += this.vy;
  }
}
class ModelSettings {
  /**
   * @param json - The settings JSON object.
   * @param json.url - The `url` field must be defined to specify the settings file's URL.
   */
  constructor(json) {
    __publicField(this, "json");
    __publicField(this, "name");
    __publicField(this, "url");
    __publicField(this, "pose");
    __publicField(this, "physics");
    this.json = json;
    const url2 = json.url;
    if (typeof url2 !== "string") {
      throw new TypeError("The `url` field in settings JSON must be defined as a string.");
    }
    this.url = url2;
    this.name = folderName(this.url);
  }
  /**
   * Resolves a relative path using the {@link url}. This is used to resolve the resource files
   * defined in the settings.
   * @param path - Relative path.
   * @return Resolved path.
   */
  resolveURL(path2) {
    return url.resolve(this.url, path2);
  }
  /**
   * Replaces the resource files by running each file through the `replacer`.
   * @param replacer - Invoked with two arguments: `(file, path)`, where `file` is the file definition,
   * and `path` is its property path in the ModelSettings instance. A string must be returned to be the replacement.
   *
   * ```js
   * modelSettings.replaceFiles((file, path) => {
   *     // file = "foo.moc", path = "moc"
   *     // file = "foo.png", path = "textures[0]"
   *     // file = "foo.mtn", path = "motions.idle[0].file"
   *     // file = "foo.motion3.json", path = "motions.idle[0].File"
   *
   *     return "bar/" + file;
   * });
   * ```
   */
  replaceFiles(replacer) {
    this.moc = replacer(this.moc, "moc");
    if (this.pose !== void 0) {
      this.pose = replacer(this.pose, "pose");
    }
    if (this.physics !== void 0) {
      this.physics = replacer(this.physics, "physics");
    }
    for (let i2 = 0; i2 < this.textures.length; i2++) {
      this.textures[i2] = replacer(this.textures[i2], `textures[${i2}]`);
    }
  }
  /**
   * Retrieves all resource files defined in the settings.
   * @return A flat array of the paths of all resource files.
   *
   * ```js
   * modelSettings.getDefinedFiles();
   * // returns: ["foo.moc", "foo.png", ...]
   * ```
   */
  getDefinedFiles() {
    const files = [];
    this.replaceFiles((file) => {
      files.push(file);
      return file;
    });
    return files;
  }
  /**
   * Validates that the files defined in the settings exist in given files. Each file will be
   * resolved by {@link resolveURL} before comparison.
   * @param files - A flat array of file paths.
   * @return All the files which are defined in the settings and also exist in given files,
   * *including the optional files*.
   * @throws Error if any *essential* file is defined in settings but not included in given files.
   */
  validateFiles(files) {
    const assertFileExists = (expectedFile, shouldThrow) => {
      const actualPath = this.resolveURL(expectedFile);
      if (!files.includes(actualPath)) {
        if (shouldThrow) {
          throw new Error(
            `File "${expectedFile}" is defined in settings, but doesn't exist in given files`
          );
        }
        return false;
      }
      return true;
    };
    const essentialFiles = [this.moc, ...this.textures];
    essentialFiles.forEach((texture) => assertFileExists(texture, true));
    const definedFiles = this.getDefinedFiles();
    return definedFiles.filter((file) => assertFileExists(file, false));
  }
}
var MotionPriority = /* @__PURE__ */ ((MotionPriority2) => {
  MotionPriority2[MotionPriority2["NONE"] = 0] = "NONE";
  MotionPriority2[MotionPriority2["IDLE"] = 1] = "IDLE";
  MotionPriority2[MotionPriority2["NORMAL"] = 2] = "NORMAL";
  MotionPriority2[MotionPriority2["FORCE"] = 3] = "FORCE";
  return MotionPriority2;
})(MotionPriority || {});
class MotionState {
  constructor() {
    __publicField(this, "tag");
    __publicField(this, "debug", false);
    __publicField(this, "currentPriority", 0);
    __publicField(this, "reservePriority", 0);
    __publicField(this, "currentGroup");
    __publicField(this, "currentIndex");
    __publicField(this, "reservedGroup");
    __publicField(this, "reservedIndex");
    __publicField(this, "reservedIdleGroup");
    __publicField(this, "reservedIdleIndex");
  }
  /**
   * Reserves the playback for a motion.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @param priority - The priority to be applied.
   * @return True if the reserving has succeeded.
   */
  reserve(group2, index, priority) {
    if (priority <= 0) {
      logger.log(this.tag, `Cannot start a motion with MotionPriority.NONE.`);
      return false;
    }
    if (group2 === this.currentGroup && index === this.currentIndex) {
      logger.log(this.tag, `Motion is already playing.`, this.dump(group2, index));
      return false;
    }
    if (group2 === this.reservedGroup && index === this.reservedIndex || group2 === this.reservedIdleGroup && index === this.reservedIdleIndex) {
      logger.log(this.tag, `Motion is already reserved.`, this.dump(group2, index));
      return false;
    }
    if (priority === 1) {
      if (this.currentPriority !== 0) {
        logger.log(
          this.tag,
          `Cannot start idle motion because another motion is playing.`,
          this.dump(group2, index)
        );
        return false;
      }
      if (this.reservedIdleGroup !== void 0) {
        logger.log(
          this.tag,
          `Cannot start idle motion because another idle motion has reserved.`,
          this.dump(group2, index)
        );
        return false;
      }
      this.setReservedIdle(group2, index);
    } else {
      if (priority < 3) {
        if (priority <= this.currentPriority) {
          logger.log(
            this.tag,
            "Cannot start motion because another motion is playing as an equivalent or higher priority.",
            this.dump(group2, index)
          );
          return false;
        }
        if (priority <= this.reservePriority) {
          logger.log(
            this.tag,
            "Cannot start motion because another motion has reserved as an equivalent or higher priority.",
            this.dump(group2, index)
          );
          return false;
        }
      }
      this.setReserved(group2, index, priority);
    }
    return true;
  }
  /**
   * Requests the playback for a motion.
   * @param motion - The Motion, can be undefined.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @param priority - The priority to be applied.
   * @return True if the request has been approved, i.e. the motion is allowed to play.
   */
  start(motion, group2, index, priority) {
    if (priority === 1) {
      this.setReservedIdle(void 0, void 0);
      if (this.currentPriority !== 0) {
        logger.log(
          this.tag,
          "Cannot start idle motion because another motion is playing.",
          this.dump(group2, index)
        );
        return false;
      }
    } else {
      if (group2 !== this.reservedGroup || index !== this.reservedIndex) {
        logger.log(
          this.tag,
          "Cannot start motion because another motion has taken the place.",
          this.dump(group2, index)
        );
        return false;
      }
      this.setReserved(
        void 0,
        void 0,
        0
        /* NONE */
      );
    }
    if (!motion) {
      return false;
    }
    this.setCurrent(group2, index, priority);
    return true;
  }
  /**
   * Notifies the motion playback has finished.
   */
  complete() {
    this.setCurrent(
      void 0,
      void 0,
      0
      /* NONE */
    );
  }
  /**
   * Sets the current motion.
   */
  setCurrent(group2, index, priority) {
    this.currentPriority = priority;
    this.currentGroup = group2;
    this.currentIndex = index;
  }
  /**
   * Sets the reserved motion.
   */
  setReserved(group2, index, priority) {
    this.reservePriority = priority;
    this.reservedGroup = group2;
    this.reservedIndex = index;
  }
  /**
   * Sets the reserved idle motion.
   */
  setReservedIdle(group2, index) {
    this.reservedIdleGroup = group2;
    this.reservedIdleIndex = index;
  }
  /**
   * Checks if a Motion is currently playing or has reserved.
   * @return True if active.
   */
  isActive(group2, index) {
    return group2 === this.currentGroup && index === this.currentIndex || group2 === this.reservedGroup && index === this.reservedIndex || group2 === this.reservedIdleGroup && index === this.reservedIdleIndex;
  }
  /**
   * Resets the state.
   */
  reset() {
    this.setCurrent(
      void 0,
      void 0,
      0
      /* NONE */
    );
    this.setReserved(
      void 0,
      void 0,
      0
      /* NONE */
    );
    this.setReservedIdle(void 0, void 0);
  }
  /**
   * Checks if an idle motion should be requests to play.
   */
  shouldRequestIdleMotion() {
    return this.currentGroup === void 0 && this.reservedIdleGroup === void 0;
  }
  /**
   * Checks if the model's expression should be overridden by the motion.
   */
  shouldOverrideExpression() {
    return false;
  }
  /**
   * Dumps the state for debugging.
   */
  dump(requestedGroup, requestedIndex) {
    if (this.debug) {
      const keys = [
        "currentPriority",
        "reservePriority",
        "currentGroup",
        "currentIndex",
        "reservedGroup",
        "reservedIndex",
        "reservedIdleGroup",
        "reservedIdleIndex"
      ];
      return `
<Requested> group = "${requestedGroup}", index = ${requestedIndex}
` + keys.map((key) => "[" + key + "] " + this[key]).join("\n");
    }
    return "";
  }
}
const TAG$2 = "SoundManager";
const VOLUME = 0.5;
class SoundManager {
  /**
   * Global volume that applies to all the sounds.
   */
  static get volume() {
    return this._volume;
  }
  static set volume(value) {
    this._volume = (value > 1 ? 1 : value < 0 ? 0 : value) || 0;
    this.audios.forEach((audio) => audio.volume = this._volume);
  }
  // TODO: return an ID?
  /**
   * Creates an audio element and adds it to the {@link audios}.
   * @param file - URL of the sound file.
   * @param onFinish - Callback invoked when the playback has finished.
   * @param onError - Callback invoked when error occurs.
   * @param crossOrigin - Cross origin setting.
   * @return Created audio element.
   */
  static add(file, onFinish, onError, crossOrigin) {
    const audio = new Audio(file);
    audio.volume = this._volume;
    audio.preload = "auto";
    audio.crossOrigin = crossOrigin;
    audio.addEventListener("ended", () => {
      this.dispose(audio);
      onFinish == null ? void 0 : onFinish();
    });
    audio.addEventListener("error", (e2) => {
      this.dispose(audio);
      logger.warn(TAG$2, `Error occurred on "${file}"`, e2.error);
      onError == null ? void 0 : onError(e2.error);
    });
    this.audios.push(audio);
    return audio;
  }
  /**
   * Plays the sound.
   * @param audio - An audio element.
   * @return Promise that resolves when the audio is ready to play, rejects when error occurs.
   */
  static play(audio) {
    return new Promise((resolve2, reject2) => {
      var _a2;
      (_a2 = audio.play()) == null ? void 0 : _a2.catch((e2) => {
        audio.dispatchEvent(new ErrorEvent("error", { error: e2 }));
        reject2(e2);
      });
      if (audio.readyState === audio.HAVE_ENOUGH_DATA) {
        resolve2();
      } else {
        audio.addEventListener("canplaythrough", resolve2);
      }
    });
  }
  static addContext(audio) {
    const context2 = new AudioContext();
    this.contexts.push(context2);
    return context2;
  }
  static addAnalyzer(audio, context2) {
    const source = context2.createMediaElementSource(audio);
    const analyser = context2.createAnalyser();
    analyser.fftSize = 256;
    analyser.minDecibels = -90;
    analyser.maxDecibels = -10;
    analyser.smoothingTimeConstant = 0.85;
    source.connect(analyser);
    analyser.connect(context2.destination);
    this.analysers.push(analyser);
    return analyser;
  }
  /**
   * Get volume for lip sync
   * @param analyser - An analyzer element.
   * @return Returns value to feed into lip sync
   */
  static analyze(analyser) {
    if (analyser != void 0) {
      const pcmData = new Float32Array(analyser.fftSize);
      let sumSquares = 0;
      analyser.getFloatTimeDomainData(pcmData);
      for (const amplitude of pcmData) {
        sumSquares += amplitude * amplitude;
      }
      return parseFloat(Math.sqrt(sumSquares / pcmData.length * 20).toFixed(1));
    } else {
      return parseFloat(Math.random().toFixed(1));
    }
  }
  /**
   * Disposes an audio element and removes it from {@link audios}.
   * @param audio - An audio element.
   */
  static dispose(audio) {
    audio.pause();
    audio.removeAttribute("src");
    remove$1(this.audios, audio);
  }
  /**
   * Destroys all managed audios.
   */
  static destroy() {
    for (let i2 = this.contexts.length - 1; i2 >= 0; i2--) {
      this.contexts[i2].close();
    }
    for (let i2 = this.audios.length - 1; i2 >= 0; i2--) {
      this.dispose(this.audios[i2]);
    }
  }
}
__publicField(SoundManager, "audios", []);
__publicField(SoundManager, "analysers", []);
__publicField(SoundManager, "contexts", []);
__publicField(SoundManager, "_volume", VOLUME);
var MotionPreloadStrategy = /* @__PURE__ */ ((MotionPreloadStrategy2) => {
  MotionPreloadStrategy2["ALL"] = "ALL";
  MotionPreloadStrategy2["IDLE"] = "IDLE";
  MotionPreloadStrategy2["NONE"] = "NONE";
  return MotionPreloadStrategy2;
})(MotionPreloadStrategy || {});
class MotionManager extends EventEmitter {
  constructor(settings2, options) {
    super();
    __publicField(this, "tag");
    __publicField(this, "settings");
    __publicField(this, "motionGroups", {});
    __publicField(this, "state", new MotionState());
    __publicField(this, "currentAudio");
    __publicField(this, "currentAnalyzer");
    __publicField(this, "currentContext");
    __publicField(this, "playing", false);
    __publicField(this, "destroyed", false);
    this.settings = settings2;
    this.tag = `MotionManager(${settings2.name})`;
    this.state.tag = this.tag;
  }
  /**
   * Should be called in the constructor of derived class.
   */
  init(options) {
    if (options == null ? void 0 : options.idleMotionGroup) {
      this.groups.idle = options.idleMotionGroup;
    }
    this.setupMotions(options);
    this.stopAllMotions();
  }
  /**
   * Sets up motions from the definitions, and preloads them according to the preload strategy.
   */
  setupMotions(options) {
    for (const group2 of Object.keys(this.definitions)) {
      this.motionGroups[group2] = [];
    }
    let groups;
    switch (options == null ? void 0 : options.motionPreload) {
      case "NONE":
        return;
      case "ALL":
        groups = Object.keys(this.definitions);
        break;
      case "IDLE":
      default:
        groups = [this.groups.idle];
        break;
    }
    for (const group2 of groups) {
      if (this.definitions[group2]) {
        for (let i2 = 0; i2 < this.definitions[group2].length; i2++) {
          this.loadMotion(group2, i2).then();
        }
      }
    }
  }
  /**
   * Loads a Motion in a motion group. Errors in this method will not be thrown,
   * but be emitted with a "motionLoadError" event.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
   * @emits {@link MotionManagerEvents.motionLoaded}
   * @emits {@link MotionManagerEvents.motionLoadError}
   */
  loadMotion(group2, index) {
    return __async(this, null, function* () {
      var _a2;
      if (!((_a2 = this.definitions[group2]) == null ? void 0 : _a2[index])) {
        logger.warn(this.tag, `Undefined motion at "${group2}"[${index}]`);
        return void 0;
      }
      if (this.motionGroups[group2][index] === null) {
        logger.warn(
          this.tag,
          `Cannot start motion at "${group2}"[${index}] because it's already failed in loading.`
        );
        return void 0;
      }
      if (this.motionGroups[group2][index]) {
        return this.motionGroups[group2][index];
      }
      const motion = yield this._loadMotion(group2, index);
      if (this.destroyed) {
        return;
      }
      this.motionGroups[group2][index] = motion != null ? motion : null;
      return motion;
    });
  }
  /**
   * Loads the Motion. Will be implemented by Live2DFactory in order to avoid circular dependency.
   * @ignore
   */
  _loadMotion(group2, index) {
    throw new Error("Not implemented.");
  }
  /**
   * Only play sound with lip sync
   * @param sound - The audio url to file or base64 content
   * ### OPTIONAL: {name: value, ...}
   * @param volume - Volume of the sound (0-1)
   * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
   * @param resetExpression - Reset expression before and after playing sound (default: true)
   * @param crossOrigin - Cross origin setting.
   * @returns Promise that resolves with true if the sound is playing, false if it's not
   */
  speak(_0) {
    return __async(this, arguments, function* (sound, {
      volume = VOLUME,
      expression,
      resetExpression = true,
      crossOrigin,
      onFinish,
      onError
    } = {}) {
      let audio;
      let analyzer;
      let context2;
      if (this.currentAudio) {
        if (!this.currentAudio.ended) {
          return false;
        }
      }
      let soundURL;
      const isBase64Content = sound && sound.startsWith("data:");
      console.log(onFinish);
      if (sound && !isBase64Content) {
        const A2 = document.createElement("a");
        A2.href = sound;
        sound = A2.href;
        soundURL = sound;
      } else {
        soundURL = "data:audio/";
      }
      const file = sound;
      if (file) {
        try {
          audio = SoundManager.add(
            file,
            (that = this) => {
              console.log("Audio finished playing");
              onFinish == null ? void 0 : onFinish();
              resetExpression && expression && that.expressionManager && that.expressionManager.resetExpression();
              that.currentAudio = void 0;
            },
            // reset expression when audio is done
            (e2, that = this) => {
              console.log("Error during audio playback:", e2);
              onError == null ? void 0 : onError(e2);
              resetExpression && expression && that.expressionManager && that.expressionManager.resetExpression();
              that.currentAudio = void 0;
            },
            // on error
            crossOrigin
          );
          this.currentAudio = audio;
          SoundManager.volume = volume;
          context2 = SoundManager.addContext(this.currentAudio);
          this.currentContext = context2;
          analyzer = SoundManager.addAnalyzer(this.currentAudio, this.currentContext);
          this.currentAnalyzer = analyzer;
        } catch (e2) {
          logger.warn(this.tag, "Failed to create audio", soundURL, e2);
          return false;
        }
      }
      if (audio) {
        let playSuccess = true;
        const readyToPlay = SoundManager.play(audio).catch((e2) => {
          logger.warn(this.tag, "Failed to play audio", audio.src, e2);
          playSuccess = false;
        });
        {
          yield readyToPlay;
          if (!playSuccess) {
            return false;
          }
        }
      }
      if (this.state.shouldOverrideExpression()) {
        this.expressionManager && this.expressionManager.resetExpression();
      }
      if (expression && this.expressionManager) {
        this.expressionManager.setExpression(expression);
      }
      this.playing = true;
      return true;
    });
  }
  /**
   * Starts a motion as given priority.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @param priority - The priority to be applied. default: 2 (NORMAL)
   * ### OPTIONAL: {name: value, ...}
   * @param sound - The audio url to file or base64 content
   * @param volume - Volume of the sound (0-1)
   * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
   * @param resetExpression - Reset expression before and after playing sound (default: true)
   * @param crossOrigin - Cross origin setting.
   * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
   */
  startMotion(_0, _1) {
    return __async(this, arguments, function* (group2, index, priority = MotionPriority.NORMAL, {
      sound = void 0,
      volume = VOLUME,
      expression = void 0,
      resetExpression = true,
      crossOrigin,
      onFinish,
      onError
    } = {}) {
      var _a2;
      if (!this.state.reserve(group2, index, priority)) {
        return false;
      }
      if (this.currentAudio) {
        if (!this.currentAudio.ended && priority != MotionPriority.FORCE) {
          return false;
        }
      }
      const definition = (_a2 = this.definitions[group2]) == null ? void 0 : _a2[index];
      if (!definition) {
        return false;
      }
      if (this.currentAudio) {
        SoundManager.dispose(this.currentAudio);
      }
      let audio;
      let analyzer;
      let context2;
      let soundURL;
      const isBase64Content = sound && sound.startsWith("data:");
      if (sound && !isBase64Content) {
        const A2 = document.createElement("a");
        A2.href = sound;
        sound = A2.href;
        soundURL = sound;
      } else {
        soundURL = this.getSoundFile(definition);
        if (soundURL) {
          soundURL = this.settings.resolveURL(soundURL);
        }
      }
      const file = soundURL;
      if (file) {
        try {
          audio = SoundManager.add(
            file,
            (that = this) => {
              console.log("Audio finished playing");
              onFinish == null ? void 0 : onFinish();
              console.log(onFinish);
              resetExpression && expression && that.expressionManager && that.expressionManager.resetExpression();
              that.currentAudio = void 0;
            },
            // reset expression when audio is done
            (e2, that = this) => {
              console.log("Error during audio playback:", e2);
              onError == null ? void 0 : onError(e2);
              resetExpression && expression && that.expressionManager && that.expressionManager.resetExpression();
              that.currentAudio = void 0;
            },
            // on error
            crossOrigin
          );
          this.currentAudio = audio;
          SoundManager.volume = volume;
          context2 = SoundManager.addContext(this.currentAudio);
          this.currentContext = context2;
          analyzer = SoundManager.addAnalyzer(this.currentAudio, this.currentContext);
          this.currentAnalyzer = analyzer;
        } catch (e2) {
          logger.warn(this.tag, "Failed to create audio", soundURL, e2);
        }
      }
      const motion = yield this.loadMotion(group2, index);
      if (audio) {
        const readyToPlay = SoundManager.play(audio).catch(
          (e2) => logger.warn(this.tag, "Failed to play audio", audio.src, e2)
        );
        {
          yield readyToPlay;
        }
      }
      if (!this.state.start(motion, group2, index, priority)) {
        if (audio) {
          SoundManager.dispose(audio);
          this.currentAudio = void 0;
        }
        return false;
      }
      if (this.state.shouldOverrideExpression()) {
        this.expressionManager && this.expressionManager.resetExpression();
      }
      logger.log(this.tag, "Start motion:", this.getMotionName(definition));
      this.emit("motionStart", group2, index, audio);
      if (expression && this.expressionManager && this.state.shouldOverrideExpression()) {
        this.expressionManager.setExpression(expression);
      }
      this.playing = true;
      this._startMotion(motion);
      return true;
    });
  }
  /**
   * Starts a random Motion as given priority.
   * @param group - The motion group.
   * @param priority - The priority to be applied. (default: 1 `IDLE`)
   * ### OPTIONAL: {name: value, ...}
   * @param sound - The wav url file or base64 content+
   * @param volume - Volume of the sound (0-1) (default: 1)
   * @param expression - In case you want to mix up a expression while playing sound (name/index)
   * @param resetExpression - Reset expression before and after playing sound (default: true)
   * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
   */
  startRandomMotion(_0, _1) {
    return __async(this, arguments, function* (group2, priority, {
      sound,
      volume = VOLUME,
      expression,
      resetExpression = true,
      crossOrigin,
      onFinish,
      onError
    } = {}) {
      const groupDefs = this.definitions[group2];
      if (groupDefs == null ? void 0 : groupDefs.length) {
        const availableIndices = [];
        for (let i2 = 0; i2 < groupDefs.length; i2++) {
          if (this.motionGroups[group2][i2] !== null && !this.state.isActive(group2, i2)) {
            availableIndices.push(i2);
          }
        }
        if (availableIndices.length) {
          const index = availableIndices[Math.floor(Math.random() * availableIndices.length)];
          return this.startMotion(group2, index, priority, {
            sound,
            volume,
            expression,
            resetExpression,
            crossOrigin,
            onFinish,
            onError
          });
        }
      }
      return false;
    });
  }
  /**
   * Stop current audio playback and lipsync
   */
  stopSpeaking() {
    if (this.currentAudio) {
      SoundManager.dispose(this.currentAudio);
      this.currentAudio = void 0;
    }
  }
  /**
   * Stops all playing motions as well as the sound.
   */
  stopAllMotions() {
    this._stopAllMotions();
    this.state.reset();
    this.stopSpeaking();
  }
  /**
   * Updates parameters of the core model.
   * @param model - The core model.
   * @param now - Current time in milliseconds.
   * @return True if the parameters have been actually updated.
   */
  update(model, now) {
    var _a2;
    if (this.isFinished()) {
      if (this.playing) {
        this.playing = false;
        this.emit("motionFinish");
      }
      if (this.state.shouldOverrideExpression()) {
        (_a2 = this.expressionManager) == null ? void 0 : _a2.restoreExpression();
      }
      this.state.complete();
      if (this.state.shouldRequestIdleMotion()) {
        this.startRandomMotion(this.groups.idle, MotionPriority.IDLE);
      }
    }
    return this.updateParameters(model, now);
  }
  /**
   * Move the mouth
   *
   */
  mouthSync() {
    if (this.currentAnalyzer) {
      return SoundManager.analyze(this.currentAnalyzer);
    } else {
      return 0;
    }
  }
  /**
   * Destroys the instance.
   * @emits {@link MotionManagerEvents.destroy}
   */
  destroy() {
    var _a2;
    this.destroyed = true;
    this.emit("destroy");
    this.stopAllMotions();
    (_a2 = this.expressionManager) == null ? void 0 : _a2.destroy();
    const self2 = this;
    self2.definitions = void 0;
    self2.motionGroups = void 0;
  }
}
const tempBounds = { x: 0, y: 0, width: 0, height: 0 };
class InternalModel extends EventEmitter {
  constructor() {
    super(...arguments);
    __publicField(this, "focusController", new FocusController());
    __publicField(this, "pose");
    __publicField(this, "physics");
    __publicField(this, "originalWidth", 0);
    __publicField(this, "originalHeight", 0);
    __publicField(this, "width", 0);
    __publicField(this, "height", 0);
    __publicField(this, "localTransform", new Matrix());
    __publicField(this, "drawingMatrix", new Matrix());
    __publicField(this, "hitAreas", {});
    __publicField(this, "textureFlipY", false);
    __publicField(this, "viewport", [0, 0, 0, 0]);
    __publicField(this, "destroyed", false);
  }
  /**
   * Should be called in the constructor of derived class.
   */
  init() {
    this.setupLayout();
    this.setupHitAreas();
  }
  /**
   * Sets up the model's size and local transform by the model's layout.
   */
  setupLayout() {
    const self2 = this;
    const size2 = this.getSize();
    self2.originalWidth = size2[0];
    self2.originalHeight = size2[1];
    const layout = Object.assign(
      {
        width: LOGICAL_WIDTH,
        height: LOGICAL_HEIGHT
      },
      this.getLayout()
    );
    this.localTransform.scale(layout.width / LOGICAL_WIDTH, layout.height / LOGICAL_HEIGHT);
    self2.width = this.originalWidth * this.localTransform.a;
    self2.height = this.originalHeight * this.localTransform.d;
    const offsetX = layout.x !== void 0 && layout.x - layout.width / 2 || layout.centerX !== void 0 && layout.centerX || layout.left !== void 0 && layout.left - layout.width / 2 || layout.right !== void 0 && layout.right + layout.width / 2 || 0;
    const offsetY = layout.y !== void 0 && layout.y - layout.height / 2 || layout.centerY !== void 0 && layout.centerY || layout.top !== void 0 && layout.top - layout.height / 2 || layout.bottom !== void 0 && layout.bottom + layout.height / 2 || 0;
    this.localTransform.translate(this.width * offsetX, -this.height * offsetY);
  }
  /**
   * Sets up the hit areas by their definitions in settings.
   */
  setupHitAreas() {
    const definitions = this.getHitAreaDefs().filter((hitArea) => hitArea.index >= 0);
    for (const def of definitions) {
      this.hitAreas[def.name] = def;
    }
  }
  /**
   * Hit-test on the model.
   * @param x - Position in model canvas.
   * @param y - Position in model canvas.
   * @return The names of the *hit* hit areas. Can be empty if none is hit.
   */
  hitTest(x2, y2) {
    return Object.keys(this.hitAreas).filter((hitAreaName) => this.isHit(hitAreaName, x2, y2));
  }
  /**
   * Hit-test for a single hit area.
   * @param hitAreaName - The hit area's name.
   * @param x - Position in model canvas.
   * @param y - Position in model canvas.
   * @return True if hit.
   */
  isHit(hitAreaName, x2, y2) {
    if (!this.hitAreas[hitAreaName]) {
      return false;
    }
    const drawIndex = this.hitAreas[hitAreaName].index;
    const bounds = this.getDrawableBounds(drawIndex, tempBounds);
    return bounds.x <= x2 && x2 <= bounds.x + bounds.width && bounds.y <= y2 && y2 <= bounds.y + bounds.height;
  }
  /**
   * Gets a drawable's bounds.
   * @param index - Index of the drawable.
   * @param bounds - Object to store the output values.
   * @return The bounds in model canvas space.
   */
  getDrawableBounds(index, bounds) {
    const vertices = this.getDrawableVertices(index);
    let left = vertices[0];
    let right = vertices[0];
    let top = vertices[1];
    let bottom = vertices[1];
    for (let i2 = 0; i2 < vertices.length; i2 += 2) {
      const vx2 = vertices[i2];
      const vy2 = vertices[i2 + 1];
      left = Math.min(vx2, left);
      right = Math.max(vx2, right);
      top = Math.min(vy2, top);
      bottom = Math.max(vy2, bottom);
    }
    bounds != null ? bounds : bounds = {};
    bounds.x = left;
    bounds.y = top;
    bounds.width = right - left;
    bounds.height = bottom - top;
    return bounds;
  }
  /**
   * Updates the model's transform.
   * @param transform - The world transform.
   */
  updateTransform(transform2) {
    this.drawingMatrix.copyFrom(transform2).append(this.localTransform);
  }
  /**
   * Updates the model's parameters.
   * @param dt - Elapsed time in milliseconds from last frame.
   * @param now - Current time in milliseconds.
   */
  update(dt, now) {
    this.focusController.update(dt);
  }
  /**
   * Destroys the model and all related resources.
   * @emits {@link InternalModelEvents.destroy | destroy}
   */
  destroy() {
    this.destroyed = true;
    this.emit("destroy");
    this.motionManager.destroy();
    this.motionManager = void 0;
  }
}
const TAG$1 = "XHRLoader";
class NetworkError extends Error {
  constructor(message, url2, status, aborted = false) {
    super(message);
    this.url = url2;
    this.status = status;
    this.aborted = aborted;
  }
}
const _XHRLoader = class _XHRLoader2 {
  /**
   * Creates a managed XHR.
   * @param target - If provided, the XHR will be canceled when receiving an "destroy" event from the target.
   * @param url - The URL.
   * @param type - The XHR response type.
   * @param onload - Load listener.
   * @param onerror - Error handler.
   */
  static createXHR(target, url2, type2, onload, onerror) {
    const xhr = new XMLHttpRequest();
    _XHRLoader2.allXhrSet.add(xhr);
    if (target) {
      let xhrSet = _XHRLoader2.xhrMap.get(target);
      if (!xhrSet) {
        xhrSet = /* @__PURE__ */ new Set([xhr]);
        _XHRLoader2.xhrMap.set(target, xhrSet);
      } else {
        xhrSet.add(xhr);
      }
      if (!target.listeners("destroy").includes(_XHRLoader2.cancelXHRs)) {
        target.once("destroy", _XHRLoader2.cancelXHRs);
      }
    }
    xhr.open("GET", url2);
    xhr.responseType = type2;
    xhr.onload = () => {
      if ((xhr.status === 200 || xhr.status === 0) && xhr.response) {
        onload(xhr.response);
      } else {
        xhr.onerror();
      }
    };
    xhr.onerror = () => {
      logger.warn(
        TAG$1,
        `Failed to load resource as ${xhr.responseType} (Status ${xhr.status}): ${url2}`
      );
      onerror(new NetworkError("Network error.", url2, xhr.status));
    };
    xhr.onabort = () => onerror(new NetworkError("Aborted.", url2, xhr.status, true));
    xhr.onloadend = () => {
      var _a2;
      _XHRLoader2.allXhrSet.delete(xhr);
      if (target) {
        (_a2 = _XHRLoader2.xhrMap.get(target)) == null ? void 0 : _a2.delete(xhr);
      }
    };
    return xhr;
  }
  /**
   * Cancels all XHRs related to this target.
   */
  static cancelXHRs() {
    var _a2;
    (_a2 = _XHRLoader2.xhrMap.get(this)) == null ? void 0 : _a2.forEach((xhr) => {
      xhr.abort();
      _XHRLoader2.allXhrSet.delete(xhr);
    });
    _XHRLoader2.xhrMap.delete(this);
  }
  /**
   * Release all XHRs.
   */
  static release() {
    _XHRLoader2.allXhrSet.forEach((xhr) => xhr.abort());
    _XHRLoader2.allXhrSet.clear();
    _XHRLoader2.xhrMap = /* @__PURE__ */ new WeakMap();
  }
};
__publicField(_XHRLoader, "xhrMap", /* @__PURE__ */ new WeakMap());
__publicField(_XHRLoader, "allXhrSet", /* @__PURE__ */ new Set());
__publicField(_XHRLoader, "loader", (context2, next2) => {
  return new Promise((resolve2, reject2) => {
    const xhr = _XHRLoader.createXHR(
      context2.target,
      context2.settings ? context2.settings.resolveURL(context2.url) : context2.url,
      context2.type,
      (data) => {
        context2.result = data;
        resolve2();
      },
      reject2
    );
    xhr.send();
  });
});
let XHRLoader = _XHRLoader;
function runMiddlewares(middleware2, context2) {
  let index = -1;
  return dispatch(0);
  function dispatch(i2, err) {
    if (err)
      return Promise.reject(err);
    if (i2 <= index)
      return Promise.reject(new Error("next() called multiple times"));
    index = i2;
    const fn = middleware2[i2];
    if (!fn)
      return Promise.resolve();
    try {
      return Promise.resolve(fn(context2, dispatch.bind(null, i2 + 1)));
    } catch (err2) {
      return Promise.reject(err2);
    }
  }
}
class Live2DLoader {
  /**
   * Loads a resource.
   * @return Promise that resolves with the loaded data in a format that's consistent with the specified `type`.
   */
  static load(context2) {
    return runMiddlewares(this.middlewares, context2).then(() => context2.result);
  }
}
__publicField(Live2DLoader, "middlewares", [XHRLoader.loader]);
function createTexture(url2, options = {}) {
  var _a2;
  const textureOptions = { resourceOptions: { crossorigin: options.crossOrigin } };
  if (Texture.fromURL) {
    return Texture.fromURL(url2, textureOptions).catch((e2) => {
      if (e2 instanceof Error) {
        throw e2;
      }
      const err = new Error("Texture loading error");
      err.event = e2;
      throw err;
    });
  }
  textureOptions.resourceOptions.autoLoad = false;
  const texture = Texture.from(url2, textureOptions);
  if (texture.baseTexture.valid) {
    return Promise.resolve(texture);
  }
  const resource = texture.baseTexture.resource;
  (_a2 = resource._live2d_load) != null ? _a2 : resource._live2d_load = new Promise((resolve2, reject2) => {
    const errorHandler = (event) => {
      resource.source.removeEventListener("error", errorHandler);
      const err = new Error("Texture loading error");
      err.event = event;
      reject2(err);
    };
    resource.source.addEventListener("error", errorHandler);
    resource.load().then(() => resolve2(texture)).catch(errorHandler);
  });
  return resource._live2d_load;
}
function noop$3() {
}
const TAG = "Live2DFactory";
const urlToJSON = (context2, next2) => __async(void 0, null, function* () {
  if (typeof context2.source === "string") {
    const data = yield Live2DLoader.load({
      url: context2.source,
      type: "json",
      target: context2.live2dModel
    });
    data.url = context2.source;
    context2.source = data;
    context2.live2dModel.emit("settingsJSONLoaded", data);
  }
  return next2();
});
const jsonToSettings = (context2, next2) => __async(void 0, null, function* () {
  if (context2.source instanceof ModelSettings) {
    context2.settings = context2.source;
    return next2();
  } else if (typeof context2.source === "object") {
    const runtime = Live2DFactory.findRuntime(context2.source);
    if (runtime) {
      const settings2 = runtime.createModelSettings(context2.source);
      context2.settings = settings2;
      context2.live2dModel.emit("settingsLoaded", settings2);
      return next2();
    }
  }
  throw new TypeError("Unknown settings format.");
});
const waitUntilReady = (context2, next2) => {
  if (context2.settings) {
    const runtime = Live2DFactory.findRuntime(context2.settings);
    if (runtime) {
      return runtime.ready().then(next2);
    }
  }
  return next2();
};
const setupOptionals = (context2, next2) => __async(void 0, null, function* () {
  yield next2();
  const internalModel = context2.internalModel;
  if (internalModel) {
    const settings2 = context2.settings;
    const runtime = Live2DFactory.findRuntime(settings2);
    if (runtime) {
      const tasks = [];
      if (settings2.pose) {
        tasks.push(
          Live2DLoader.load({
            settings: settings2,
            url: settings2.pose,
            type: "json",
            target: internalModel
          }).then((data) => {
            internalModel.pose = runtime.createPose(internalModel.coreModel, data);
            context2.live2dModel.emit("poseLoaded", internalModel.pose);
          }).catch((e2) => {
            context2.live2dModel.emit("poseLoadError", e2);
            logger.warn(TAG, "Failed to load pose.", e2);
          })
        );
      }
      if (settings2.physics) {
        tasks.push(
          Live2DLoader.load({
            settings: settings2,
            url: settings2.physics,
            type: "json",
            target: internalModel
          }).then((data) => {
            internalModel.physics = runtime.createPhysics(
              internalModel.coreModel,
              data
            );
            context2.live2dModel.emit("physicsLoaded", internalModel.physics);
          }).catch((e2) => {
            context2.live2dModel.emit("physicsLoadError", e2);
            logger.warn(TAG, "Failed to load physics.", e2);
          })
        );
      }
      if (tasks.length) {
        yield Promise.all(tasks);
      }
    }
  }
});
const setupEssentials = (context2, next2) => __async(void 0, null, function* () {
  if (context2.settings) {
    const live2DModel = context2.live2dModel;
    const loadingTextures = Promise.all(
      context2.settings.textures.map((tex) => {
        const url2 = context2.settings.resolveURL(tex);
        return createTexture(url2, { crossOrigin: context2.options.crossOrigin });
      })
    );
    loadingTextures.catch(noop$3);
    yield next2();
    if (context2.internalModel) {
      live2DModel.internalModel = context2.internalModel;
      live2DModel.emit("modelLoaded", context2.internalModel);
    } else {
      throw new TypeError("Missing internal model.");
    }
    live2DModel.textures = yield loadingTextures;
    live2DModel.emit("textureLoaded", live2DModel.textures);
  } else {
    throw new TypeError("Missing settings.");
  }
});
const createInternalModel = (context2, next2) => __async(void 0, null, function* () {
  const settings2 = context2.settings;
  if (settings2 instanceof ModelSettings) {
    const runtime = Live2DFactory.findRuntime(settings2);
    if (!runtime) {
      throw new TypeError("Unknown model settings.");
    }
    const modelData = yield Live2DLoader.load({
      settings: settings2,
      url: settings2.moc,
      type: "arraybuffer",
      target: context2.live2dModel
    });
    if (!runtime.isValidMoc(modelData)) {
      throw new Error("Invalid moc data");
    }
    const coreModel = runtime.createCoreModel(modelData);
    context2.internalModel = runtime.createInternalModel(coreModel, settings2, context2.options);
    return next2();
  }
  throw new TypeError("Missing settings.");
});
const _ZipLoader = class _ZipLoader2 {
  static unzip(reader, settings2) {
    return __async(this, null, function* () {
      const filePaths = yield _ZipLoader2.getFilePaths(reader);
      const requiredFilePaths = [];
      for (const definedFile of settings2.getDefinedFiles()) {
        const actualPath = decodeURI(url.resolve(settings2.url, definedFile));
        if (filePaths.includes(actualPath)) {
          requiredFilePaths.push(actualPath);
        }
      }
      const files = yield _ZipLoader2.getFiles(reader, requiredFilePaths);
      for (let i2 = 0; i2 < files.length; i2++) {
        const path2 = requiredFilePaths[i2];
        const file = files[i2];
        Object.defineProperty(file, "webkitRelativePath", {
          value: path2
        });
      }
      return files;
    });
  }
  static createSettings(reader) {
    return __async(this, null, function* () {
      const filePaths = yield _ZipLoader2.getFilePaths(reader);
      const settingsFilePath = filePaths.find(
        (path2) => path2.endsWith("model.json") || path2.endsWith("model3.json")
      );
      if (!settingsFilePath) {
        throw new Error("Settings file not found");
      }
      const settingsText = yield _ZipLoader2.readText(reader, settingsFilePath);
      if (!settingsText) {
        throw new Error("Empty settings file: " + settingsFilePath);
      }
      const settingsJSON = JSON.parse(settingsText);
      settingsJSON.url = settingsFilePath;
      const runtime = _ZipLoader2.live2dFactory.findRuntime(settingsJSON);
      if (!runtime) {
        throw new Error("Unknown settings JSON");
      }
      return runtime.createModelSettings(settingsJSON);
    });
  }
  static zipReader(data, url2) {
    return __async(this, null, function* () {
      throw new Error("Not implemented");
    });
  }
  static getFilePaths(reader) {
    return __async(this, null, function* () {
      throw new Error("Not implemented");
    });
  }
  static getFiles(reader, paths) {
    return __async(this, null, function* () {
      throw new Error("Not implemented");
    });
  }
  static readText(reader, path2) {
    return __async(this, null, function* () {
      throw new Error("Not implemented");
    });
  }
  static releaseReader(reader) {
  }
};
__publicField(_ZipLoader, "live2dFactory");
__publicField(_ZipLoader, "ZIP_PROTOCOL", "zip://");
__publicField(_ZipLoader, "uid", 0);
__publicField(_ZipLoader, "factory", (context2, next2) => __async(_ZipLoader, null, function* () {
  const source = context2.source;
  let sourceURL;
  let zipBlob;
  let settings2;
  if (typeof source === "string" && (source.endsWith(".zip") || source.startsWith(_ZipLoader.ZIP_PROTOCOL))) {
    if (source.startsWith(_ZipLoader.ZIP_PROTOCOL)) {
      sourceURL = source.slice(_ZipLoader.ZIP_PROTOCOL.length);
    } else {
      sourceURL = source;
    }
    zipBlob = yield Live2DLoader.load({
      url: sourceURL,
      type: "blob",
      target: context2.live2dModel
    });
  } else if (Array.isArray(source) && source.length === 1 && source[0] instanceof File && source[0].name.endsWith(".zip")) {
    zipBlob = source[0];
    sourceURL = URL.createObjectURL(zipBlob);
    settings2 = source.settings;
  }
  if (zipBlob) {
    if (!zipBlob.size) {
      throw new Error("Empty zip file");
    }
    const reader = yield _ZipLoader.zipReader(zipBlob, sourceURL);
    if (!settings2) {
      settings2 = yield _ZipLoader.createSettings(reader);
    }
    settings2._objectURL = _ZipLoader.ZIP_PROTOCOL + _ZipLoader.uid + "/" + settings2.url;
    const files = yield _ZipLoader.unzip(reader, settings2);
    files.settings = settings2;
    context2.source = files;
    if (sourceURL.startsWith("blob:")) {
      context2.live2dModel.once("modelLoaded", (internalModel) => {
        internalModel.once("destroy", function() {
          URL.revokeObjectURL(sourceURL);
        });
      });
    }
    _ZipLoader.releaseReader(reader);
  }
  return next2();
}));
let ZipLoader = _ZipLoader;
const _FileLoader = class _FileLoader2 {
  /**
   * Resolves the path of a resource file to the object URL.
   * @param settingsURL - Object URL of the settings file.
   * @param filePath - Resource file path.
   * @return Resolved object URL.
   */
  static resolveURL(settingsURL, filePath) {
    var _a2;
    const resolved = (_a2 = _FileLoader2.filesMap[settingsURL]) == null ? void 0 : _a2[filePath];
    if (resolved === void 0) {
      throw new Error("Cannot find this file from uploaded files: " + filePath);
    }
    return resolved;
  }
  /**
   * Consumes the files by storing their object URLs. Files not defined in the settings will be ignored.
   */
  static upload(files, settings2) {
    return __async(this, null, function* () {
      const fileMap = {};
      for (const definedFile of settings2.getDefinedFiles()) {
        const actualPath = decodeURI(url.resolve(settings2.url, definedFile));
        const actualFile = files.find((file) => file.webkitRelativePath === actualPath);
        if (actualFile) {
          fileMap[definedFile] = URL.createObjectURL(actualFile);
        }
      }
      _FileLoader2.filesMap[settings2._objectURL] = fileMap;
    });
  }
  /**
   * Creates a ModelSettings by given files.
   * @return Promise that resolves with the created ModelSettings.
   */
  static createSettings(files) {
    return __async(this, null, function* () {
      const settingsFile = files.find(
        (file) => file.name.endsWith("model.json") || file.name.endsWith("model3.json")
      );
      if (!settingsFile) {
        throw new TypeError("Settings file not found");
      }
      const settingsText = yield _FileLoader2.readText(settingsFile);
      const settingsJSON = JSON.parse(settingsText);
      settingsJSON.url = settingsFile.webkitRelativePath;
      const runtime = Live2DFactory.findRuntime(settingsJSON);
      if (!runtime) {
        throw new Error("Unknown settings JSON");
      }
      const settings2 = runtime.createModelSettings(settingsJSON);
      settings2._objectURL = URL.createObjectURL(settingsFile);
      return settings2;
    });
  }
  /**
   * Reads a file as text in UTF-8.
   */
  static readText(file) {
    return __async(this, null, function* () {
      return new Promise((resolve2, reject2) => {
        const reader = new FileReader();
        reader.onload = () => resolve2(reader.result);
        reader.onerror = reject2;
        reader.readAsText(file, "utf8");
      });
    });
  }
};
__publicField(_FileLoader, "live2dFactory");
__publicField(_FileLoader, "filesMap", {});
__publicField(_FileLoader, "factory", (context2, next2) => __async(_FileLoader, null, function* () {
  if (Array.isArray(context2.source) && context2.source[0] instanceof File) {
    const files = context2.source;
    let settings2 = files.settings;
    if (!settings2) {
      settings2 = yield _FileLoader.createSettings(files);
    } else if (!settings2._objectURL) {
      throw new Error('"_objectURL" must be specified in ModelSettings');
    }
    settings2.validateFiles(files.map((file) => encodeURI(file.webkitRelativePath)));
    yield _FileLoader.upload(files, settings2);
    settings2.resolveURL = function(url2) {
      return _FileLoader.resolveURL(this._objectURL, url2);
    };
    context2.source = settings2;
    context2.live2dModel.once("modelLoaded", (internalModel) => {
      internalModel.once("destroy", function() {
        const objectURL = this.settings._objectURL;
        URL.revokeObjectURL(objectURL);
        if (_FileLoader.filesMap[objectURL]) {
          for (const resourceObjectURL of Object.values(
            _FileLoader.filesMap[objectURL]
          )) {
            URL.revokeObjectURL(resourceObjectURL);
          }
        }
        delete _FileLoader.filesMap[objectURL];
      });
    });
  }
  return next2();
}));
let FileLoader = _FileLoader;
const _Live2DFactory = class _Live2DFactory2 {
  /**
   * Registers a Live2DRuntime.
   */
  static registerRuntime(runtime) {
    _Live2DFactory2.runtimes.push(runtime);
    _Live2DFactory2.runtimes.sort((a2, b2) => b2.version - a2.version);
  }
  /**
   * Finds a runtime that matches given source.
   * @param source - Either a settings JSON object or a ModelSettings instance.
   * @return The Live2DRuntime, or undefined if not found.
   */
  static findRuntime(source) {
    for (const runtime of _Live2DFactory2.runtimes) {
      if (runtime.test(source)) {
        return runtime;
      }
    }
  }
  /**
   * Sets up a Live2DModel, populating it with all defined resources.
   * @param live2dModel - The Live2DModel instance.
   * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
   * @param options - Options for the process.
   * @return Promise that resolves when all resources have been loaded, rejects when error occurs.
   */
  static setupLive2DModel(live2dModel, source, options) {
    return __async(this, null, function* () {
      const textureLoaded = new Promise((resolve2) => live2dModel.once("textureLoaded", resolve2));
      const modelLoaded = new Promise((resolve2) => live2dModel.once("modelLoaded", resolve2));
      const readyEventEmitted = Promise.all([textureLoaded, modelLoaded]).then(
        () => live2dModel.emit("ready")
      );
      yield runMiddlewares(_Live2DFactory2.live2DModelMiddlewares, {
        live2dModel,
        source,
        options: options || {}
      });
      yield readyEventEmitted;
      live2dModel.emit("load");
    });
  }
  /**
   * Loads a Motion and registers the task to {@link motionTasksMap}. The task will be automatically
   * canceled when its owner - the MotionManager instance - has been destroyed.
   * @param motionManager - MotionManager that owns this Motion.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
   */
  static loadMotion(motionManager, group2, index) {
    var _a2, _b;
    const handleError = (e2) => motionManager.emit("motionLoadError", group2, index, e2);
    try {
      const definition = (_a2 = motionManager.definitions[group2]) == null ? void 0 : _a2[index];
      if (!definition) {
        return Promise.resolve(void 0);
      }
      if (!motionManager.listeners("destroy").includes(_Live2DFactory2.releaseTasks)) {
        motionManager.once("destroy", _Live2DFactory2.releaseTasks);
      }
      let tasks = _Live2DFactory2.motionTasksMap.get(motionManager);
      if (!tasks) {
        tasks = {};
        _Live2DFactory2.motionTasksMap.set(motionManager, tasks);
      }
      let taskGroup = tasks[group2];
      if (!taskGroup) {
        taskGroup = [];
        tasks[group2] = taskGroup;
      }
      const path2 = motionManager.getMotionFile(definition);
      (_b = taskGroup[index]) != null ? _b : taskGroup[index] = Live2DLoader.load({
        url: path2,
        settings: motionManager.settings,
        type: motionManager.motionDataType,
        target: motionManager
      }).then((data) => {
        var _a22;
        const taskGroup2 = (_a22 = _Live2DFactory2.motionTasksMap.get(motionManager)) == null ? void 0 : _a22[group2];
        if (taskGroup2) {
          delete taskGroup2[index];
        }
        const motion = motionManager.createMotion(data, group2, definition);
        motionManager.emit("motionLoaded", group2, index, motion);
        return motion;
      }).catch((e2) => {
        logger.warn(motionManager.tag, `Failed to load motion: ${path2}
`, e2);
        handleError(e2);
      });
      return taskGroup[index];
    } catch (e2) {
      logger.warn(motionManager.tag, `Failed to load motion at "${group2}"[${index}]
`, e2);
      handleError(e2);
    }
    return Promise.resolve(void 0);
  }
  /**
   * Loads an Expression and registers the task to {@link expressionTasksMap}. The task will be automatically
   * canceled when its owner - the ExpressionManager instance - has been destroyed.
   * @param expressionManager - ExpressionManager that owns this Expression.
   * @param index - Index of the Expression.
   * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
   */
  static loadExpression(expressionManager, index) {
    var _a2;
    const handleError = (e2) => expressionManager.emit("expressionLoadError", index, e2);
    try {
      const definition = expressionManager.definitions[index];
      if (!definition) {
        return Promise.resolve(void 0);
      }
      if (!expressionManager.listeners("destroy").includes(_Live2DFactory2.releaseTasks)) {
        expressionManager.once("destroy", _Live2DFactory2.releaseTasks);
      }
      let tasks = _Live2DFactory2.expressionTasksMap.get(expressionManager);
      if (!tasks) {
        tasks = [];
        _Live2DFactory2.expressionTasksMap.set(expressionManager, tasks);
      }
      const path2 = expressionManager.getExpressionFile(definition);
      (_a2 = tasks[index]) != null ? _a2 : tasks[index] = Live2DLoader.load({
        url: path2,
        settings: expressionManager.settings,
        type: "json",
        target: expressionManager
      }).then((data) => {
        const tasks2 = _Live2DFactory2.expressionTasksMap.get(expressionManager);
        if (tasks2) {
          delete tasks2[index];
        }
        const expression = expressionManager.createExpression(data, definition);
        expressionManager.emit("expressionLoaded", index, expression);
        return expression;
      }).catch((e2) => {
        logger.warn(expressionManager.tag, `Failed to load expression: ${path2}
`, e2);
        handleError(e2);
      });
      return tasks[index];
    } catch (e2) {
      logger.warn(expressionManager.tag, `Failed to load expression at [${index}]
`, e2);
      handleError(e2);
    }
    return Promise.resolve(void 0);
  }
  static releaseTasks() {
    if (this instanceof MotionManager) {
      _Live2DFactory2.motionTasksMap.delete(this);
    } else {
      _Live2DFactory2.expressionTasksMap.delete(this);
    }
  }
};
__publicField(_Live2DFactory, "runtimes", []);
__publicField(_Live2DFactory, "urlToJSON", urlToJSON);
__publicField(_Live2DFactory, "jsonToSettings", jsonToSettings);
__publicField(_Live2DFactory, "waitUntilReady", waitUntilReady);
__publicField(_Live2DFactory, "setupOptionals", setupOptionals);
__publicField(_Live2DFactory, "setupEssentials", setupEssentials);
__publicField(_Live2DFactory, "createInternalModel", createInternalModel);
__publicField(_Live2DFactory, "live2DModelMiddlewares", [
  ZipLoader.factory,
  FileLoader.factory,
  urlToJSON,
  jsonToSettings,
  waitUntilReady,
  setupOptionals,
  setupEssentials,
  createInternalModel
]);
__publicField(_Live2DFactory, "motionTasksMap", /* @__PURE__ */ new WeakMap());
__publicField(_Live2DFactory, "expressionTasksMap", /* @__PURE__ */ new WeakMap());
let Live2DFactory = _Live2DFactory;
MotionManager.prototype["_loadMotion"] = function(group2, index) {
  return Live2DFactory.loadMotion(this, group2, index);
};
ExpressionManager.prototype["_loadExpression"] = function(index) {
  return Live2DFactory.loadExpression(this, index);
};
FileLoader["live2dFactory"] = Live2DFactory;
ZipLoader["live2dFactory"] = Live2DFactory;
const _Automator = class _Automator2 {
  constructor(model, {
    autoUpdate: autoUpdate2 = true,
    autoHitTest = true,
    autoFocus = true,
    autoInteract,
    ticker
  } = {}) {
    __publicField(this, "model");
    __publicField(this, "destroyed", false);
    __publicField(this, "_ticker");
    __publicField(this, "_autoUpdate", false);
    __publicField(this, "_autoHitTest", false);
    __publicField(this, "_autoFocus", false);
    if (!ticker) {
      if (_Automator2.defaultTicker) {
        ticker = _Automator2.defaultTicker;
      } else if (typeof PIXI !== "undefined") {
        ticker = PIXI.Ticker.shared;
      }
    }
    if (autoInteract !== void 0) {
      autoHitTest = autoInteract;
      autoFocus = autoInteract;
      logger.warn(
        model.tag,
        "options.autoInteract is deprecated since v0.5.0, use autoHitTest and autoFocus instead."
      );
    }
    this.model = model;
    this.ticker = ticker;
    this.autoUpdate = autoUpdate2;
    this.autoHitTest = autoHitTest;
    this.autoFocus = autoFocus;
    if (autoHitTest || autoFocus) {
      this.model.eventMode = "static";
    }
  }
  get ticker() {
    return this._ticker;
  }
  set ticker(ticker) {
    var _a2;
    if (this._ticker) {
      this._ticker.remove(onTickerUpdate, this);
    }
    this._ticker = ticker;
    if (this._autoUpdate) {
      (_a2 = this._ticker) == null ? void 0 : _a2.add(onTickerUpdate, this);
    }
  }
  /**
   * @see {@link AutomatorOptions.autoUpdate}
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(autoUpdate2) {
    var _a2;
    if (this.destroyed) {
      return;
    }
    if (autoUpdate2) {
      if (this._ticker) {
        this._ticker.add(onTickerUpdate, this);
        this._autoUpdate = true;
      } else {
        logger.warn(
          this.model.tag,
          "No Ticker to be used for automatic updates. Either set option.ticker when creating Live2DModel, or expose PIXI to global scope (window.PIXI = PIXI)."
        );
      }
    } else {
      (_a2 = this._ticker) == null ? void 0 : _a2.remove(onTickerUpdate, this);
      this._autoUpdate = false;
    }
  }
  /**
   * @see {@link AutomatorOptions.autoHitTest}
   */
  get autoHitTest() {
    return this._autoHitTest;
  }
  set autoHitTest(autoHitTest) {
    if (autoHitTest !== this.autoHitTest) {
      if (autoHitTest) {
        this.model.on("pointertap", onTap, this);
      } else {
        this.model.off("pointertap", onTap, this);
      }
      this._autoHitTest = autoHitTest;
    }
  }
  /**
   * @see {@link AutomatorOptions.autoFocus}
   */
  get autoFocus() {
    return this._autoFocus;
  }
  set autoFocus(autoFocus) {
    if (autoFocus !== this.autoFocus) {
      if (autoFocus) {
        this.model.on("globalpointermove", onPointerMove, this);
      } else {
        this.model.off("globalpointermove", onPointerMove, this);
      }
      this._autoFocus = autoFocus;
    }
  }
  /**
   * @see {@link AutomatorOptions.autoInteract}
   */
  get autoInteract() {
    return this._autoHitTest && this._autoFocus;
  }
  set autoInteract(autoInteract) {
    this.autoHitTest = autoInteract;
    this.autoFocus = autoInteract;
  }
  onTickerUpdate() {
    const deltaMS = this.ticker.deltaMS;
    this.model.update(deltaMS);
  }
  onTap(event) {
    this.model.tap(event.global.x, event.global.y);
  }
  onPointerMove(event) {
    this.model.focus(event.global.x, event.global.y);
  }
  destroy() {
    this.autoFocus = false;
    this.autoHitTest = false;
    this.autoUpdate = false;
    this.ticker = void 0;
    this.destroyed = true;
  }
};
__publicField(_Automator, "defaultTicker");
let Automator = _Automator;
function onTickerUpdate() {
  this.onTickerUpdate();
}
function onTap(event) {
  this.onTap(event);
}
function onPointerMove(event) {
  this.onPointerMove(event);
}
class Live2DTransform extends Transform {
}
const tempPoint = new Point();
const tempMatrix$1 = new Matrix();
class Live2DModel extends Container {
  constructor(options) {
    super();
    __publicField(this, "tag", "Live2DModel(uninitialized)");
    __publicField(this, "internalModel");
    __publicField(this, "textures", []);
    __publicField(this, "transform", new Live2DTransform());
    __publicField(this, "anchor", new ObservablePoint(this.onAnchorChange, this, 0, 0));
    __publicField(this, "glContextID", -1);
    __publicField(this, "elapsedTime", 0);
    __publicField(this, "deltaTime", 0);
    __publicField(this, "automator");
    this.automator = new Automator(this, options);
    this.once("modelLoaded", () => this.init(options));
  }
  /**
   * Creates a Live2DModel from given source.
   * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
   * @param options - Options for the creation.
   * @return Promise that resolves with the Live2DModel.
   */
  static from(source, options) {
    const model = new this(options);
    return Live2DFactory.setupLive2DModel(model, source, options).then(() => model);
  }
  /**
   * Synchronous version of `Live2DModel.from()`. This method immediately returns a Live2DModel instance,
   * whose resources have not been loaded. Therefore this model can't be manipulated or rendered
   * until the "load" event has been emitted.
   *
   * ```js
   * // no `await` here as it's not a Promise
   * const model = Live2DModel.fromSync('shizuku.model.json');
   *
   * // these will cause errors!
   * // app.stage.addChild(model);
   * // model.motion('tap_body');
   *
   * model.once('load', () => {
   *     // now it's safe
   *     app.stage.addChild(model);
   *     model.motion('tap_body');
   * });
   * ```
   */
  static fromSync(source, options) {
    const model = new this(options);
    Live2DFactory.setupLive2DModel(model, source, options).then(options == null ? void 0 : options.onLoad).catch(options == null ? void 0 : options.onError);
    return model;
  }
  /**
   * Registers the class of `PIXI.Ticker` for auto updating.
   * @deprecated Use {@link Live2DModelOptions.ticker} instead.
   */
  static registerTicker(tickerClass) {
    Automator["defaultTicker"] = tickerClass.shared;
  }
  // TODO: rename
  /**
   * A handler of the "modelLoaded" event, invoked when the internal model has been loaded.
   */
  init(options) {
    this.tag = `Live2DModel(${this.internalModel.settings.name})`;
  }
  /**
   * A callback that observes {@link anchor}, invoked when the anchor's values have been changed.
   */
  onAnchorChange() {
    this.pivot.set(
      this.anchor.x * this.internalModel.width,
      this.anchor.y * this.internalModel.height
    );
  }
  /**
   * Shorthand to start a motion.
   * @param group - The motion group.
   * @param index - Index in the motion group.
   * @param priority - The priority to be applied. (0: No priority, 1: IDLE, 2:NORMAL, 3:FORCE) (default: 2)
   * ### OPTIONAL: `{name: value, ...}`
   * @param sound - The audio url to file or base64 content
   * @param volume - Volume of the sound (0-1) (default: 0.5)
   * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
   * @param resetExpression - Reset the expression to default after the motion is finished (default: true)
   * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
   */
  motion(group2, index, priority, {
    sound = void 0,
    volume = VOLUME,
    expression = void 0,
    resetExpression = true,
    crossOrigin,
    onFinish,
    onError
  } = {}) {
    return index === void 0 ? this.internalModel.motionManager.startRandomMotion(group2, priority, {
      sound,
      volume,
      expression,
      resetExpression,
      crossOrigin,
      onFinish,
      onError
    }) : this.internalModel.motionManager.startMotion(group2, index, priority, {
      sound,
      volume,
      expression,
      resetExpression,
      crossOrigin,
      onFinish,
      onError
    });
  }
  /**
   * Stops all playing motions as well as the sound.
   */
  stopMotions() {
    return this.internalModel.motionManager.stopAllMotions();
  }
  /**
   * Shorthand to start speaking a sound with an expression.
   * @param sound - The audio url to file or base64 content
   * ### OPTIONAL: {name: value, ...}
   * @param volume - Volume of the sound (0-1)
   * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
   * @param resetExpression - Reset the expression to default after the motion is finished (default: true)
   * @returns Promise that resolves with true if the sound is playing, false if it's not
   */
  speak(sound, {
    volume = VOLUME,
    expression,
    resetExpression = true,
    crossOrigin,
    onFinish,
    onError
  } = {}) {
    return this.internalModel.motionManager.speak(sound, {
      volume,
      expression,
      resetExpression,
      crossOrigin,
      onFinish,
      onError
    });
  }
  /**
   * Stop current audio playback and lipsync
   */
  stopSpeaking() {
    return this.internalModel.motionManager.stopSpeaking();
  }
  /**
   * Shorthand to set an expression.
   * @param id - Either the index, or the name of the expression. If not presented, a random expression will be set.
   * @return Promise that resolves with true if succeeded, with false otherwise.
   */
  expression(id2) {
    if (this.internalModel.motionManager.expressionManager) {
      return id2 === void 0 ? this.internalModel.motionManager.expressionManager.setRandomExpression() : this.internalModel.motionManager.expressionManager.setExpression(id2);
    }
    return Promise.resolve(false);
  }
  /**
   * Updates the focus position. This will not cause the model to immediately look at the position,
   * instead the movement will be interpolated.
   * @param x - Position in world space.
   * @param y - Position in world space.
   * @param instant - Should the focus position be instantly applied.
   */
  focus(x2, y2, instant = false) {
    tempPoint.x = x2;
    tempPoint.y = y2;
    this.toModelPosition(tempPoint, tempPoint, true);
    const tx = tempPoint.x / this.internalModel.originalWidth * 2 - 1;
    const ty = tempPoint.y / this.internalModel.originalHeight * 2 - 1;
    const radian = Math.atan2(ty, tx);
    this.internalModel.focusController.focus(Math.cos(radian), -Math.sin(radian), instant);
  }
  /**
   * Tap on the model. This will perform a hit-testing, and emit a "hit" event
   * if at least one of the hit areas is hit.
   * @param x - Position in world space.
   * @param y - Position in world space.
   * @emits {@link Live2DModelEvents.hit}
   */
  tap(x2, y2) {
    const hitAreaNames = this.hitTest(x2, y2);
    if (hitAreaNames.length) {
      logger.log(this.tag, `Hit`, hitAreaNames);
      this.emit("hit", hitAreaNames);
    }
  }
  /**
   * Hit-test on the model.
   * @param x - Position in world space.
   * @param y - Position in world space.
   * @return The names of the *hit* hit areas. Can be empty if none is hit.
   */
  hitTest(x2, y2) {
    tempPoint.x = x2;
    tempPoint.y = y2;
    this.toModelPosition(tempPoint, tempPoint);
    return this.internalModel.hitTest(tempPoint.x, tempPoint.y);
  }
  /**
   * Calculates the position in the canvas of original, unscaled Live2D model.
   * @param position - A Point in world space.
   * @param result - A Point to store the new value. Defaults to a new Point.
   * @param skipUpdate - True to skip the update transform.
   * @return The Point in model canvas space.
   */
  toModelPosition(position2, result = position2.clone(), skipUpdate) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    this.transform.worldTransform.applyInverse(position2, result);
    this.internalModel.localTransform.applyInverse(result, result);
    return result;
  }
  /**
   * A method required by `PIXI.InteractionManager` to perform hit-testing.
   * @param point - A Point in world space.
   * @return True if the point is inside this model.
   */
  containsPoint(point) {
    return this.getBounds(true).contains(point.x, point.y);
  }
  /** @override */
  _calculateBounds() {
    this._bounds.addFrame(
      this.transform,
      0,
      0,
      this.internalModel.width,
      this.internalModel.height
    );
  }
  /**
   * Updates the model. Note this method just updates the timer,
   * and the actual update will be done right before rendering the model.
   * @param dt - The elapsed time in milliseconds since last frame.
   */
  update(dt) {
    this.deltaTime += dt;
    this.elapsedTime += dt;
  }
  _render(renderer) {
    renderer.batch.reset();
    renderer.geometry.reset();
    renderer.shader.reset();
    renderer.state.reset();
    let shouldUpdateTexture = false;
    if (this.glContextID !== renderer.CONTEXT_UID) {
      this.glContextID = renderer.CONTEXT_UID;
      this.internalModel.updateWebGLContext(renderer.gl, this.glContextID);
      shouldUpdateTexture = true;
    }
    for (let i2 = 0; i2 < this.textures.length; i2++) {
      const texture = this.textures[i2];
      if (!texture.valid) {
        continue;
      }
      if (shouldUpdateTexture || !texture.baseTexture._glTextures[this.glContextID]) {
        renderer.gl.pixelStorei(
          WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL,
          this.internalModel.textureFlipY
        );
        renderer.texture.bind(texture.baseTexture, 0);
      }
      this.internalModel.bindTexture(
        i2,
        texture.baseTexture._glTextures[this.glContextID].texture
      );
      texture.baseTexture.touched = renderer.textureGC.count;
    }
    const viewport = renderer.framebuffer.viewport;
    this.internalModel.viewport = [viewport.x, viewport.y, viewport.width, viewport.height];
    if (this.deltaTime) {
      this.internalModel.update(this.deltaTime, this.elapsedTime);
      this.deltaTime = 0;
    }
    const internalTransform = tempMatrix$1.copyFrom(renderer.globalUniforms.uniforms.projectionMatrix).append(this.worldTransform);
    this.internalModel.updateTransform(internalTransform);
    this.internalModel.draw(renderer.gl);
    renderer.state.reset();
    renderer.texture.reset();
  }
  /**
   * Destroys the model and all related resources. This takes the same options and also
   * behaves the same as `PIXI.Container#destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    this.emit("destroy");
    if (options == null ? void 0 : options.texture) {
      this.textures.forEach((texture) => texture.destroy(options.baseTexture));
    }
    this.automator.destroy();
    this.internalModel.destroy();
    super.destroy(options);
  }
}
if (!window.Live2D) {
  throw new Error(
    "Could not find Cubism 2 runtime. This plugin requires live2d.min.js to be loaded."
  );
}
const originalUpdateParam = Live2DMotion.prototype.updateParam;
Live2DMotion.prototype.updateParam = function(model, entry) {
  originalUpdateParam.call(this, model, entry);
  if (entry.isFinished() && this.onFinishHandler) {
    this.onFinishHandler(this);
    delete this.onFinishHandler;
  }
};
class Live2DExpression extends AMotion {
  constructor(json) {
    super();
    __publicField(this, "params", []);
    this.setFadeIn(json.fade_in > 0 ? json.fade_in : config$1.expressionFadingDuration);
    this.setFadeOut(json.fade_out > 0 ? json.fade_out : config$1.expressionFadingDuration);
    if (Array.isArray(json.params)) {
      json.params.forEach((param) => {
        const calc2 = param.calc || "add";
        if (calc2 === "add") {
          const defaultValue2 = param.def || 0;
          param.val -= defaultValue2;
        } else if (calc2 === "mult") {
          const defaultValue2 = param.def || 1;
          param.val /= defaultValue2;
        }
        this.params.push({
          calc: calc2,
          val: param.val,
          id: param.id
        });
      });
    }
  }
  /** @override */
  updateParamExe(model, time, weight, motionQueueEnt) {
    this.params.forEach((param) => {
      model.setParamFloat(param.id, param.val * weight);
    });
  }
}
class Cubism2ExpressionManager extends ExpressionManager {
  constructor(settings2, options) {
    var _a2;
    super(settings2, options);
    __publicField(this, "queueManager", new MotionQueueManager());
    __publicField(this, "definitions");
    this.definitions = (_a2 = this.settings.expressions) != null ? _a2 : [];
    this.init();
  }
  isFinished() {
    return this.queueManager.isFinished();
  }
  getExpressionIndex(name2) {
    return this.definitions.findIndex((def) => def.name === name2);
  }
  getExpressionFile(definition) {
    return definition.file;
  }
  createExpression(data, definition) {
    return new Live2DExpression(data);
  }
  _setExpression(motion) {
    return this.queueManager.startMotion(motion);
  }
  stopAllExpressions() {
    this.queueManager.stopAllMotions();
  }
  updateParameters(model, dt) {
    return this.queueManager.updateParam(model);
  }
}
class Cubism2MotionManager extends MotionManager {
  constructor(settings2, options) {
    super(settings2, options);
    __publicField(this, "definitions");
    __publicField(this, "groups", { idle: "idle" });
    __publicField(this, "motionDataType", "arraybuffer");
    __publicField(this, "queueManager", new MotionQueueManager());
    __publicField(this, "lipSyncIds");
    __publicField(this, "expressionManager");
    this.definitions = this.settings.motions;
    this.init(options);
    this.lipSyncIds = ["PARAM_MOUTH_OPEN_Y"];
  }
  init(options) {
    super.init(options);
    if (this.settings.expressions) {
      this.expressionManager = new Cubism2ExpressionManager(this.settings, options);
    }
  }
  isFinished() {
    return this.queueManager.isFinished();
  }
  createMotion(data, group2, definition) {
    const motion = Live2DMotion.loadMotion(data);
    const defaultFadingDuration = group2 === this.groups.idle ? config$1.idleMotionFadingDuration : config$1.motionFadingDuration;
    motion.setFadeIn(definition.fade_in > 0 ? definition.fade_in : defaultFadingDuration);
    motion.setFadeOut(definition.fade_out > 0 ? definition.fade_out : defaultFadingDuration);
    return motion;
  }
  getMotionFile(definition) {
    return definition.file;
  }
  getMotionName(definition) {
    return definition.file;
  }
  getSoundFile(definition) {
    return definition.sound;
  }
  _startMotion(motion, onFinish) {
    motion.onFinishHandler = onFinish;
    this.queueManager.stopAllMotions();
    return this.queueManager.startMotion(motion);
  }
  _stopAllMotions() {
    this.queueManager.stopAllMotions();
  }
  updateParameters(model, now) {
    return this.queueManager.updateParam(model);
  }
  destroy() {
    super.destroy();
    this.queueManager = void 0;
  }
}
class Live2DEyeBlink {
  constructor(coreModel) {
    __publicField(this, "leftParam");
    __publicField(this, "rightParam");
    __publicField(this, "blinkInterval", 4e3);
    __publicField(this, "closingDuration", 100);
    __publicField(this, "closedDuration", 50);
    __publicField(this, "openingDuration", 150);
    __publicField(this, "eyeState", 0);
    __publicField(this, "eyeParamValue", 1);
    __publicField(this, "closedTimer", 0);
    __publicField(this, "nextBlinkTimeLeft", this.blinkInterval);
    this.coreModel = coreModel;
    this.leftParam = coreModel.getParamIndex("PARAM_EYE_L_OPEN");
    this.rightParam = coreModel.getParamIndex("PARAM_EYE_R_OPEN");
  }
  setEyeParams(value) {
    this.eyeParamValue = clamp(value, 0, 1);
    this.coreModel.setParamFloat(this.leftParam, this.eyeParamValue);
    this.coreModel.setParamFloat(this.rightParam, this.eyeParamValue);
  }
  update(dt) {
    switch (this.eyeState) {
      case 0:
        this.nextBlinkTimeLeft -= dt;
        if (this.nextBlinkTimeLeft < 0) {
          this.eyeState = 1;
          this.nextBlinkTimeLeft = this.blinkInterval + this.closingDuration + this.closedDuration + this.openingDuration + rand(0, 2e3);
        }
        break;
      case 1:
        this.setEyeParams(this.eyeParamValue + dt / this.closingDuration);
        if (this.eyeParamValue <= 0) {
          this.eyeState = 2;
          this.closedTimer = 0;
        }
        break;
      case 2:
        this.closedTimer += dt;
        if (this.closedTimer >= this.closedDuration) {
          this.eyeState = 3;
        }
        break;
      case 3:
        this.setEyeParams(this.eyeParamValue + dt / this.openingDuration);
        if (this.eyeParamValue >= 1) {
          this.eyeState = 0;
        }
    }
  }
}
const tempMatrixArray = new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]);
class Cubism2InternalModel extends InternalModel {
  constructor(coreModel, settings2, options) {
    super();
    __publicField(this, "settings");
    __publicField(this, "coreModel");
    __publicField(this, "motionManager");
    __publicField(this, "eyeBlink");
    __publicField(this, "eyeballXParamIndex");
    __publicField(this, "eyeballYParamIndex");
    __publicField(this, "angleXParamIndex");
    __publicField(this, "angleYParamIndex");
    __publicField(this, "angleZParamIndex");
    __publicField(this, "bodyAngleXParamIndex");
    __publicField(this, "breathParamIndex");
    __publicField(this, "textureFlipY", true);
    __publicField(this, "lipSync", true);
    __publicField(this, "drawDataCount", 0);
    __publicField(this, "disableCulling", false);
    __publicField(this, "hasDrawn", false);
    this.coreModel = coreModel;
    this.settings = settings2;
    this.motionManager = new Cubism2MotionManager(settings2, options);
    this.eyeBlink = new Live2DEyeBlink(coreModel);
    this.eyeballXParamIndex = coreModel.getParamIndex("PARAM_EYE_BALL_X");
    this.eyeballYParamIndex = coreModel.getParamIndex("PARAM_EYE_BALL_Y");
    this.angleXParamIndex = coreModel.getParamIndex("PARAM_ANGLE_X");
    this.angleYParamIndex = coreModel.getParamIndex("PARAM_ANGLE_Y");
    this.angleZParamIndex = coreModel.getParamIndex("PARAM_ANGLE_Z");
    this.bodyAngleXParamIndex = coreModel.getParamIndex("PARAM_BODY_ANGLE_X");
    this.breathParamIndex = coreModel.getParamIndex("PARAM_BREATH");
    this.init();
  }
  init() {
    super.init();
    if (this.settings.initParams) {
      this.settings.initParams.forEach(
        ({ id: id2, value }) => this.coreModel.setParamFloat(id2, value)
      );
    }
    if (this.settings.initOpacities) {
      this.settings.initOpacities.forEach(
        ({ id: id2, value }) => this.coreModel.setPartsOpacity(id2, value)
      );
    }
    this.coreModel.saveParam();
    const arr = this.coreModel.getModelContext()._$aS;
    if (arr == null ? void 0 : arr.length) {
      this.drawDataCount = arr.length;
    }
    let culling = this.coreModel.drawParamWebGL.culling;
    Object.defineProperty(this.coreModel.drawParamWebGL, "culling", {
      set: (v2) => culling = v2,
      // always return false when disabled
      get: () => this.disableCulling ? false : culling
    });
    const clipManager = this.coreModel.getModelContext().clipManager;
    const originalSetupClip = clipManager.setupClip;
    clipManager.setupClip = (modelContext, drawParam) => {
      originalSetupClip.call(clipManager, modelContext, drawParam);
      drawParam.gl.viewport(...this.viewport);
    };
  }
  getSize() {
    return [this.coreModel.getCanvasWidth(), this.coreModel.getCanvasHeight()];
  }
  getLayout() {
    const layout = {};
    if (this.settings.layout) {
      for (const [key, value] of Object.entries(this.settings.layout)) {
        let commonKey = key;
        if (key === "center_x") {
          commonKey = "centerX";
        } else if (key === "center_y") {
          commonKey = "centerY";
        }
        layout[commonKey] = value;
      }
    }
    return layout;
  }
  updateWebGLContext(gl2, glContextID) {
    const drawParamWebGL = this.coreModel.drawParamWebGL;
    drawParamWebGL.firstDraw = true;
    drawParamWebGL.setGL(gl2);
    drawParamWebGL.glno = glContextID;
    for (const [key, value] of Object.entries(drawParamWebGL)) {
      if (value instanceof WebGLBuffer) {
        drawParamWebGL[key] = null;
      }
    }
    const clipManager = this.coreModel.getModelContext().clipManager;
    clipManager.curFrameNo = glContextID;
    const framebuffer = gl2.getParameter(gl2.FRAMEBUFFER_BINDING);
    clipManager.getMaskRenderTexture();
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer);
  }
  bindTexture(index, texture) {
    this.coreModel.setTexture(index, texture);
  }
  getHitAreaDefs() {
    var _a2;
    return ((_a2 = this.settings.hitAreas) == null ? void 0 : _a2.map((hitArea) => ({
      id: hitArea.id,
      name: hitArea.name,
      index: this.coreModel.getDrawDataIndex(hitArea.id)
    }))) || [];
  }
  getDrawableIDs() {
    const modelContext = this.coreModel.getModelContext();
    const ids = [];
    for (let i2 = 0; i2 < this.drawDataCount; i2++) {
      const drawData = modelContext.getDrawData(i2);
      if (drawData) {
        ids.push(drawData.getDrawDataID().id);
      }
    }
    return ids;
  }
  getDrawableIndex(id2) {
    return this.coreModel.getDrawDataIndex(id2);
  }
  getDrawableVertices(drawIndex) {
    if (typeof drawIndex === "string") {
      drawIndex = this.coreModel.getDrawDataIndex(drawIndex);
      if (drawIndex === -1)
        throw new TypeError("Unable to find drawable ID: " + drawIndex);
    }
    return this.coreModel.getTransformedPoints(drawIndex).slice();
  }
  hitTest(x2, y2) {
    if (!this.hasDrawn) {
      logger.warn(
        "Trying to hit-test a Cubism 2 model that has not been rendered yet. The result will always be empty since the draw data is not ready."
      );
    }
    return super.hitTest(x2, y2);
  }
  update(dt, now) {
    var _a2, _b, _c, _d;
    super.update(dt, now);
    const model = this.coreModel;
    this.emit("beforeMotionUpdate");
    const motionUpdated = this.motionManager.update(this.coreModel, now);
    this.emit("afterMotionUpdate");
    model.saveParam();
    (_a2 = this.motionManager.expressionManager) == null ? void 0 : _a2.update(model, now);
    if (!motionUpdated) {
      (_b = this.eyeBlink) == null ? void 0 : _b.update(dt);
    }
    this.updateFocus();
    this.updateNaturalMovements(dt, now);
    if (this.lipSync && this.motionManager.currentAudio) {
      let value = this.motionManager.mouthSync();
      let min_ = 0;
      const max_ = 1;
      const bias_weight = 1.2;
      const bias_power = 0.7;
      if (value > 0) {
        min_ = 0.4;
      }
      value = Math.pow(value, bias_power);
      value = clamp(value * bias_weight, min_, max_);
      for (let i2 = 0; i2 < this.motionManager.lipSyncIds.length; ++i2) {
        this.coreModel.setParamFloat(
          this.coreModel.getParamIndex(this.motionManager.lipSyncIds[i2]),
          value
        );
      }
    }
    (_c = this.physics) == null ? void 0 : _c.update(now);
    (_d = this.pose) == null ? void 0 : _d.update(dt);
    this.emit("beforeModelUpdate");
    model.update();
    model.loadParam();
  }
  updateFocus() {
    this.coreModel.addToParamFloat(this.eyeballXParamIndex, this.focusController.x);
    this.coreModel.addToParamFloat(this.eyeballYParamIndex, this.focusController.y);
    this.coreModel.addToParamFloat(this.angleXParamIndex, this.focusController.x * 30);
    this.coreModel.addToParamFloat(this.angleYParamIndex, this.focusController.y * 30);
    this.coreModel.addToParamFloat(
      this.angleZParamIndex,
      this.focusController.x * this.focusController.y * -30
    );
    this.coreModel.addToParamFloat(this.bodyAngleXParamIndex, this.focusController.x * 10);
  }
  updateNaturalMovements(dt, now) {
    const t2 = now / 1e3 * 2 * Math.PI;
    this.coreModel.addToParamFloat(this.angleXParamIndex, 15 * Math.sin(t2 / 6.5345) * 0.5);
    this.coreModel.addToParamFloat(this.angleYParamIndex, 8 * Math.sin(t2 / 3.5345) * 0.5);
    this.coreModel.addToParamFloat(this.angleZParamIndex, 10 * Math.sin(t2 / 5.5345) * 0.5);
    this.coreModel.addToParamFloat(this.bodyAngleXParamIndex, 4 * Math.sin(t2 / 15.5345) * 0.5);
    this.coreModel.setParamFloat(this.breathParamIndex, 0.5 + 0.5 * Math.sin(t2 / 3.2345));
  }
  draw(gl2) {
    const disableCulling = this.disableCulling;
    if (gl2.getParameter(gl2.FRAMEBUFFER_BINDING)) {
      this.disableCulling = true;
    }
    const matrix = this.drawingMatrix;
    tempMatrixArray[0] = matrix.a;
    tempMatrixArray[1] = matrix.b;
    tempMatrixArray[4] = matrix.c;
    tempMatrixArray[5] = matrix.d;
    tempMatrixArray[12] = matrix.tx;
    tempMatrixArray[13] = matrix.ty;
    this.coreModel.setMatrix(tempMatrixArray);
    this.coreModel.draw();
    this.hasDrawn = true;
    this.disableCulling = disableCulling;
  }
  destroy() {
    super.destroy();
    this.coreModel = void 0;
  }
}
class Cubism2ModelSettings extends ModelSettings {
  constructor(json) {
    super(json);
    __publicField(this, "moc");
    __publicField(this, "textures");
    __publicField(this, "layout");
    __publicField(this, "hitAreas");
    __publicField(this, "initParams");
    __publicField(this, "initOpacities");
    __publicField(this, "expressions");
    __publicField(this, "motions", {});
    if (!Cubism2ModelSettings.isValidJSON(json)) {
      throw new TypeError("Invalid JSON.");
    }
    this.moc = json.model;
    copyArray("string", json, this, "textures", "textures");
    this.copy(json);
  }
  /**
   * Checks if a JSON object is valid model settings.
   * @param json
   */
  static isValidJSON(json) {
    var _a2;
    return !!json && typeof json.model === "string" && ((_a2 = json.textures) == null ? void 0 : _a2.length) > 0 && // textures must be an array of strings
    json.textures.every((item) => typeof item === "string");
  }
  /**
   * Validates and copies *optional* properties from raw JSON.
   */
  copy(json) {
    copyProperty("string", json, this, "name", "name");
    copyProperty("string", json, this, "pose", "pose");
    copyProperty("string", json, this, "physics", "physics");
    copyProperty("object", json, this, "layout", "layout");
    copyProperty("object", json, this, "motions", "motions");
    copyArray("object", json, this, "hit_areas", "hitAreas");
    copyArray("object", json, this, "expressions", "expressions");
    copyArray("object", json, this, "init_params", "initParams");
    copyArray("object", json, this, "init_opacities", "initOpacities");
  }
  replaceFiles(replace2) {
    super.replaceFiles(replace2);
    for (const [group2, motions] of Object.entries(this.motions)) {
      for (let i2 = 0; i2 < motions.length; i2++) {
        motions[i2].file = replace2(motions[i2].file, `motions.${group2}[${i2}].file`);
        if (motions[i2].sound !== void 0) {
          motions[i2].sound = replace2(motions[i2].sound, `motions.${group2}[${i2}].sound`);
        }
      }
    }
    if (this.expressions) {
      for (let i2 = 0; i2 < this.expressions.length; i2++) {
        this.expressions[i2].file = replace2(
          this.expressions[i2].file,
          `expressions[${i2}].file`
        );
      }
    }
  }
}
const SRC_TYPE_MAP = {
  x: PhysicsHair.Src.SRC_TO_X,
  y: PhysicsHair.Src.SRC_TO_Y,
  angle: PhysicsHair.Src.SRC_TO_G_ANGLE
};
const TARGET_TYPE_MAP = {
  x: PhysicsHair.Src.SRC_TO_X,
  y: PhysicsHair.Src.SRC_TO_Y,
  angle: PhysicsHair.Src.SRC_TO_G_ANGLE
};
class Live2DPhysics {
  constructor(coreModel, json) {
    __publicField(this, "physicsHairs", []);
    this.coreModel = coreModel;
    if (json.physics_hair) {
      this.physicsHairs = json.physics_hair.map((definition) => {
        const physicsHair = new PhysicsHair();
        physicsHair.setup(
          definition.setup.length,
          definition.setup.regist,
          definition.setup.mass
        );
        definition.src.forEach(({ id: id2, ptype, scale, weight }) => {
          const type2 = SRC_TYPE_MAP[ptype];
          if (type2) {
            physicsHair.addSrcParam(type2, id2, scale, weight);
          }
        });
        definition.targets.forEach(({ id: id2, ptype, scale, weight }) => {
          const type2 = TARGET_TYPE_MAP[ptype];
          if (type2) {
            physicsHair.addTargetParam(type2, id2, scale, weight);
          }
        });
        return physicsHair;
      });
    }
  }
  update(elapsed) {
    this.physicsHairs.forEach((physicsHair) => physicsHair.update(this.coreModel, elapsed));
  }
}
class Live2DPartsParam {
  constructor(id2) {
    __publicField(this, "paramIndex", -1);
    __publicField(this, "partsIndex", -1);
    __publicField(this, "link", []);
    this.id = id2;
  }
  initIndex(model) {
    this.paramIndex = model.getParamIndex("VISIBLE:" + this.id);
    this.partsIndex = model.getPartsDataIndex(PartsDataID.getID(this.id));
    model.setParamFloat(this.paramIndex, 1);
  }
}
class Live2DPose {
  constructor(coreModel, json) {
    __publicField(this, "opacityAnimDuration", 500);
    __publicField(this, "partsGroups", []);
    this.coreModel = coreModel;
    if (json.parts_visible) {
      this.partsGroups = json.parts_visible.map(
        ({ group: group2 }) => group2.map(({ id: id2, link }) => {
          const parts2 = new Live2DPartsParam(id2);
          if (link) {
            parts2.link = link.map((l2) => new Live2DPartsParam(l2));
          }
          return parts2;
        })
      );
      this.init();
    }
  }
  init() {
    this.partsGroups.forEach((group2) => {
      group2.forEach((parts2) => {
        parts2.initIndex(this.coreModel);
        if (parts2.paramIndex >= 0) {
          const visible = this.coreModel.getParamFloat(parts2.paramIndex) !== 0;
          this.coreModel.setPartsOpacity(parts2.partsIndex, visible ? 1 : 0);
          this.coreModel.setParamFloat(parts2.paramIndex, visible ? 1 : 0);
          if (parts2.link.length > 0) {
            parts2.link.forEach((p2) => p2.initIndex(this.coreModel));
          }
        }
      });
    });
  }
  normalizePartsOpacityGroup(partsGroup, dt) {
    const model = this.coreModel;
    const phi = 0.5;
    const maxBackOpacity = 0.15;
    let visibleOpacity = 1;
    let visibleIndex = partsGroup.findIndex(
      ({ paramIndex, partsIndex }) => partsIndex >= 0 && model.getParamFloat(paramIndex) !== 0
    );
    if (visibleIndex >= 0) {
      const originalOpacity = model.getPartsOpacity(partsGroup[visibleIndex].partsIndex);
      visibleOpacity = clamp(originalOpacity + dt / this.opacityAnimDuration, 0, 1);
    } else {
      visibleIndex = 0;
      visibleOpacity = 1;
    }
    partsGroup.forEach(({ partsIndex }, index) => {
      if (partsIndex >= 0) {
        if (visibleIndex == index) {
          model.setPartsOpacity(partsIndex, visibleOpacity);
        } else {
          let opacity = model.getPartsOpacity(partsIndex);
          let a1;
          if (visibleOpacity < phi) {
            a1 = visibleOpacity * (phi - 1) / phi + 1;
          } else {
            a1 = (1 - visibleOpacity) * phi / (1 - phi);
          }
          const backOp = (1 - a1) * (1 - visibleOpacity);
          if (backOp > maxBackOpacity) {
            a1 = 1 - maxBackOpacity / (1 - visibleOpacity);
          }
          if (opacity > a1) {
            opacity = a1;
          }
          model.setPartsOpacity(partsIndex, opacity);
        }
      }
    });
  }
  copyOpacity(partsGroup) {
    const model = this.coreModel;
    partsGroup.forEach(({ partsIndex, link }) => {
      if (partsIndex >= 0 && link) {
        const opacity = model.getPartsOpacity(partsIndex);
        link.forEach(({ partsIndex: partsIndex2 }) => {
          if (partsIndex2 >= 0) {
            model.setPartsOpacity(partsIndex2, opacity);
          }
        });
      }
    });
  }
  update(dt) {
    this.partsGroups.forEach((partGroup) => {
      this.normalizePartsOpacityGroup(partGroup, dt);
      this.copyOpacity(partGroup);
    });
  }
}
Live2DFactory.registerRuntime({
  version: 2,
  test(source) {
    return source instanceof Cubism2ModelSettings || Cubism2ModelSettings.isValidJSON(source);
  },
  ready() {
    return Promise.resolve();
  },
  isValidMoc(modelData) {
    if (modelData.byteLength < 3) {
      return false;
    }
    const view = new Int8Array(modelData, 0, 3);
    return String.fromCharCode(...view) === "moc";
  },
  createModelSettings(json) {
    return new Cubism2ModelSettings(json);
  },
  createCoreModel(data) {
    const model = Live2DModelWebGL.loadModel(data);
    const error = Live2D.getError();
    if (error)
      throw error;
    return model;
  },
  createInternalModel(coreModel, settings2, options) {
    return new Cubism2InternalModel(coreModel, settings2, options);
  },
  createPose(coreModel, data) {
    return new Live2DPose(coreModel, data);
  },
  createPhysics(coreModel, data) {
    return new Live2DPhysics(coreModel, data);
  }
});
if (!window.Live2DCubismCore) {
  throw new Error(
    "Could not find Cubism 4 runtime. This plugin requires live2dcubismcore.js to be loaded."
  );
}
class CubismVector2 {
  /**
   * コンストラクタ
   */
  constructor(x2, y2) {
    this.x = x2 || 0;
    this.y = y2 || 0;
  }
  /**
   * ベクトルの加算
   *
   * @param vector2 加算するベクトル値
   * @return 加算結果 ベクトル値
   */
  add(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x + vector2.x;
    ret.y = this.y + vector2.y;
    return ret;
  }
  /**
   * ベクトルの減算
   *
   * @param vector2 減算するベクトル値
   * @return 減算結果 ベクトル値
   */
  substract(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x - vector2.x;
    ret.y = this.y - vector2.y;
    return ret;
  }
  /**
   * ベクトルの乗算
   *
   * @param vector2 乗算するベクトル値
   * @return 乗算結果 ベクトル値
   */
  multiply(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x * vector2.x;
    ret.y = this.y * vector2.y;
    return ret;
  }
  /**
   * ベクトルの乗算(スカラー)
   *
   * @param scalar 乗算するスカラー値
   * @return 乗算結果 ベクトル値
   */
  multiplyByScaler(scalar) {
    return this.multiply(new CubismVector2(scalar, scalar));
  }
  /**
   * ベクトルの除算
   *
   * @param vector2 除算するベクトル値
   * @return 除算結果 ベクトル値
   */
  division(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x / vector2.x;
    ret.y = this.y / vector2.y;
    return ret;
  }
  /**
   * ベクトルの除算(スカラー)
   *
   * @param scalar 除算するスカラー値
   * @return 除算結果 ベクトル値
   */
  divisionByScalar(scalar) {
    return this.division(new CubismVector2(scalar, scalar));
  }
  /**
   * ベクトルの長さを取得する
   *
   * @return ベクトルの長さ
   */
  getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * ベクトルの距離の取得
   *
   * @param a 点
   * @return ベクトルの距離
   */
  getDistanceWith(a2) {
    return Math.sqrt(
      (this.x - a2.x) * (this.x - a2.x) + (this.y - a2.y) * (this.y - a2.y)
    );
  }
  /**
   * ドット積の計算
   *
   * @param a 値
   * @return 結果
   */
  dot(a2) {
    return this.x * a2.x + this.y * a2.y;
  }
  /**
   * 正規化の適用
   */
  normalize() {
    const length2 = Math.pow(this.x * this.x + this.y * this.y, 0.5);
    this.x = this.x / length2;
    this.y = this.y / length2;
  }
  /**
   * 等しさの確認（等しいか？）
   *
   * 値が等しいか？
   *
   * @param rhs 確認する値
   * @return true 値は等しい
   * @return false 値は等しくない
   */
  isEqual(rhs) {
    return this.x == rhs.x && this.y == rhs.y;
  }
  /**
   * 等しさの確認（等しくないか？）
   *
   * 値が等しくないか？
   *
   * @param rhs 確認する値
   * @return true 値は等しくない
   * @return false 値は等しい
   */
  isNotEqual(rhs) {
    return !this.isEqual(rhs);
  }
}
const _CubismMath = class _CubismMath2 {
  /**
   * 第一引数の値を最小値と最大値の範囲に収めた値を返す
   *
   * @param value 収められる値
   * @param min   範囲の最小値
   * @param max   範囲の最大値
   * @return 最小値と最大値の範囲に収めた値
   */
  static range(value, min2, max2) {
    if (value < min2) {
      value = min2;
    } else if (value > max2) {
      value = max2;
    }
    return value;
  }
  /**
   * サイン関数の値を求める
   *
   * @param x 角度値（ラジアン）
   * @return サイン関数sin(x)の値
   */
  static sin(x2) {
    return Math.sin(x2);
  }
  /**
   * コサイン関数の値を求める
   *
   * @param x 角度値(ラジアン)
   * @return コサイン関数cos(x)の値
   */
  static cos(x2) {
    return Math.cos(x2);
  }
  /**
   * 値の絶対値を求める
   *
   * @param x 絶対値を求める値
   * @return 値の絶対値
   */
  static abs(x2) {
    return Math.abs(x2);
  }
  /**
   * 平方根(ルート)を求める
   * @param x -> 平方根を求める値
   * @return 値の平方根
   */
  static sqrt(x2) {
    return Math.sqrt(x2);
  }
  /**
   * 立方根を求める
   * @param x -> 立方根を求める値
   * @return 値の立方根
   */
  static cbrt(x2) {
    if (x2 === 0) {
      return x2;
    }
    let cx2 = x2;
    const isNegativeNumber = cx2 < 0;
    if (isNegativeNumber) {
      cx2 = -cx2;
    }
    let ret;
    if (cx2 === Infinity) {
      ret = Infinity;
    } else {
      ret = Math.exp(Math.log(cx2) / 3);
      ret = (cx2 / (ret * ret) + 2 * ret) / 3;
    }
    return isNegativeNumber ? -ret : ret;
  }
  /**
   * イージング処理されたサインを求める
   * フェードイン・アウト時のイージングに利用できる
   *
   * @param value イージングを行う値
   * @return イージング処理されたサイン値
   */
  static getEasingSine(value) {
    if (value < 0) {
      return 0;
    } else if (value > 1) {
      return 1;
    }
    return 0.5 - 0.5 * this.cos(value * Math.PI);
  }
  /**
   * 大きい方の値を返す
   *
   * @param left 左辺の値
   * @param right 右辺の値
   * @return 大きい方の値
   */
  static max(left, right) {
    return left > right ? left : right;
  }
  /**
   * 小さい方の値を返す
   *
   * @param left  左辺の値
   * @param right 右辺の値
   * @return 小さい方の値
   */
  static min(left, right) {
    return left > right ? right : left;
  }
  /**
   * 角度値をラジアン値に変換する
   *
   * @param degrees   角度値
   * @return 角度値から変換したラジアン値
   */
  static degreesToRadian(degrees) {
    return degrees / 180 * Math.PI;
  }
  /**
   * ラジアン値を角度値に変換する
   *
   * @param radian    ラジアン値
   * @return ラジアン値から変換した角度値
   */
  static radianToDegrees(radian) {
    return radian * 180 / Math.PI;
  }
  /**
   * ２つのベクトルからラジアン値を求める
   *
   * @param from  始点ベクトル
   * @param to    終点ベクトル
   * @return ラジアン値から求めた方向ベクトル
   */
  static directionToRadian(from2, to) {
    const q1 = Math.atan2(to.y, to.x);
    const q2 = Math.atan2(from2.y, from2.x);
    let ret = q1 - q2;
    while (ret < -Math.PI) {
      ret += Math.PI * 2;
    }
    while (ret > Math.PI) {
      ret -= Math.PI * 2;
    }
    return ret;
  }
  /**
   * ２つのベクトルから角度値を求める
   *
   * @param from  始点ベクトル
   * @param to    終点ベクトル
   * @return 角度値から求めた方向ベクトル
   */
  static directionToDegrees(from2, to) {
    const radian = this.directionToRadian(from2, to);
    let degree = this.radianToDegrees(radian);
    if (to.x - from2.x > 0) {
      degree = -degree;
    }
    return degree;
  }
  /**
   * ラジアン値を方向ベクトルに変換する。
   *
   * @param totalAngle    ラジアン値
   * @return ラジアン値から変換した方向ベクトル
   */
  static radianToDirection(totalAngle) {
    const ret = new CubismVector2();
    ret.x = this.sin(totalAngle);
    ret.y = this.cos(totalAngle);
    return ret;
  }
  /**
   * 三次方程式の三次項の係数が0になったときに補欠的に二次方程式の解をもとめる。
   * a * x^2 + b * x + c = 0
   *
   * @param   a -> 二次項の係数値
   * @param   b -> 一次項の係数値
   * @param   c -> 定数項の値
   * @return  二次方程式の解
   */
  static quadraticEquation(a2, b2, c2) {
    if (this.abs(a2) < _CubismMath2.Epsilon) {
      if (this.abs(b2) < _CubismMath2.Epsilon) {
        return -c2;
      }
      return -c2 / b2;
    }
    return -(b2 + this.sqrt(b2 * b2 - 4 * a2 * c2)) / (2 * a2);
  }
  /**
   * カルダノの公式によってベジェのt値に該当する３次方程式の解を求める。
   * 重解になったときには0.0～1.0の値になる解を返す。
   *
   * a * x^3 + b * x^2 + c * x + d = 0
   *
   * @param   a -> 三次項の係数値
   * @param   b -> 二次項の係数値
   * @param   c -> 一次項の係数値
   * @param   d -> 定数項の値
   * @return  0.0～1.0の間にある解
   */
  static cardanoAlgorithmForBezier(a2, b2, c2, d2) {
    if (this.sqrt(a2) < _CubismMath2.Epsilon) {
      return this.range(this.quadraticEquation(b2, c2, d2), 0, 1);
    }
    const ba = b2 / a2;
    const ca2 = c2 / a2;
    const da2 = d2 / a2;
    const p2 = (3 * ca2 - ba * ba) / 3;
    const p3 = p2 / 3;
    const q2 = (2 * ba * ba * ba - 9 * ba * ca2 + 27 * da2) / 27;
    const q22 = q2 / 2;
    const discriminant = q22 * q22 + p3 * p3 * p3;
    const center = 0.5;
    const threshold = center + 0.01;
    if (discriminant < 0) {
      const mp3 = -p2 / 3;
      const mp33 = mp3 * mp3 * mp3;
      const r2 = this.sqrt(mp33);
      const t2 = -q2 / (2 * r2);
      const cosphi = this.range(t2, -1, 1);
      const phi = Math.acos(cosphi);
      const crtr = this.cbrt(r2);
      const t1 = 2 * crtr;
      const root12 = t1 * this.cos(phi / 3) - ba / 3;
      if (this.abs(root12 - center) < threshold) {
        return this.range(root12, 0, 1);
      }
      const root2 = t1 * this.cos((phi + 2 * Math.PI) / 3) - ba / 3;
      if (this.abs(root2 - center) < threshold) {
        return this.range(root2, 0, 1);
      }
      const root3 = t1 * this.cos((phi + 4 * Math.PI) / 3) - ba / 3;
      return this.range(root3, 0, 1);
    }
    if (discriminant == 0) {
      let u12;
      if (q22 < 0) {
        u12 = this.cbrt(-q22);
      } else {
        u12 = -this.cbrt(q22);
      }
      const root12 = 2 * u12 - ba / 3;
      if (this.abs(root12 - center) < threshold) {
        return this.range(root12, 0, 1);
      }
      const root2 = -u12 - ba / 3;
      return this.range(root2, 0, 1);
    }
    const sd2 = this.sqrt(discriminant);
    const u1 = this.cbrt(sd2 - q22);
    const v1 = this.cbrt(sd2 + q22);
    const root1 = u1 - v1 - ba / 3;
    return this.range(root1, 0, 1);
  }
  /**
   * コンストラクタ
   */
  constructor() {
  }
};
_CubismMath.Epsilon = 1e-5;
let CubismMath = _CubismMath;
class CubismMatrix44 {
  /**
   * コンストラクタ
   */
  constructor() {
    this._tr = new Float32Array(16);
    this.loadIdentity();
  }
  /**
   * 受け取った２つの行列の乗算を行う。
   *
   * @param a 行列a
   * @param b 行列b
   * @return 乗算結果の行列
   */
  static multiply(a2, b2, dst) {
    const c2 = new Float32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    const n2 = 4;
    for (let i2 = 0; i2 < n2; ++i2) {
      for (let j2 = 0; j2 < n2; ++j2) {
        for (let k2 = 0; k2 < n2; ++k2) {
          c2[j2 + i2 * 4] += a2[k2 + i2 * 4] * b2[j2 + k2 * 4];
        }
      }
    }
    for (let i2 = 0; i2 < 16; ++i2) {
      dst[i2] = c2[i2];
    }
  }
  /**
   * 単位行列に初期化する
   */
  loadIdentity() {
    const c2 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    this.setMatrix(c2);
  }
  /**
   * 行列を設定
   *
   * @param tr 16個の浮動小数点数で表される4x4の行列
   */
  setMatrix(tr) {
    for (let i2 = 0; i2 < 16; ++i2) {
      this._tr[i2] = tr[i2];
    }
  }
  /**
   * 行列を浮動小数点数の配列で取得
   *
   * @return 16個の浮動小数点数で表される4x4の行列
   */
  getArray() {
    return this._tr;
  }
  /**
   * X軸の拡大率を取得
   * @return X軸の拡大率
   */
  getScaleX() {
    return this._tr[0];
  }
  /**
   * Y軸の拡大率を取得する
   *
   * @return Y軸の拡大率
   */
  getScaleY() {
    return this._tr[5];
  }
  /**
   * X軸の移動量を取得
   * @return X軸の移動量
   */
  getTranslateX() {
    return this._tr[12];
  }
  /**
   * Y軸の移動量を取得
   * @return Y軸の移動量
   */
  getTranslateY() {
    return this._tr[13];
  }
  /**
   * X軸の値を現在の行列で計算
   *
   * @param src X軸の値
   * @return 現在の行列で計算されたX軸の値
   */
  transformX(src) {
    return this._tr[0] * src + this._tr[12];
  }
  /**
   * Y軸の値を現在の行列で計算
   *
   * @param src Y軸の値
   * @return 現在の行列で計算されたY軸の値
   */
  transformY(src) {
    return this._tr[5] * src + this._tr[13];
  }
  /**
   * X軸の値を現在の行列で逆計算
   */
  invertTransformX(src) {
    return (src - this._tr[12]) / this._tr[0];
  }
  /**
   * Y軸の値を現在の行列で逆計算
   */
  invertTransformY(src) {
    return (src - this._tr[13]) / this._tr[5];
  }
  /**
   * 現在の行列の位置を起点にして移動
   *
   * 現在の行列の位置を起点にして相対的に移動する。
   *
   * @param x X軸の移動量
   * @param y Y軸の移動量
   */
  translateRelative(x2, y2) {
    const tr1 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      x2,
      y2,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 現在の行列の位置を移動
   *
   * 現在の行列の位置を指定した位置へ移動する
   *
   * @param x X軸の移動量
   * @param y y軸の移動量
   */
  translate(x2, y2) {
    this._tr[12] = x2;
    this._tr[13] = y2;
  }
  /**
   * 現在の行列のX軸の位置を指定した位置へ移動する
   *
   * @param x X軸の移動量
   */
  translateX(x2) {
    this._tr[12] = x2;
  }
  /**
   * 現在の行列のY軸の位置を指定した位置へ移動する
   *
   * @param y Y軸の移動量
   */
  translateY(y2) {
    this._tr[13] = y2;
  }
  /**
   * 現在の行列の拡大率を相対的に設定する
   *
   * @param x X軸の拡大率
   * @param y Y軸の拡大率
   */
  scaleRelative(x2, y2) {
    const tr1 = new Float32Array([
      x2,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 現在の行列の拡大率を指定した倍率に設定する
   *
   * @param x X軸の拡大率
   * @param y Y軸の拡大率
   */
  scale(x2, y2) {
    this._tr[0] = x2;
    this._tr[5] = y2;
  }
  /**
   * 現在の行列に行列を乗算
   *
   * @param m 行列
   */
  multiplyByMatrix(m2) {
    CubismMatrix44.multiply(m2.getArray(), this._tr, this._tr);
  }
  /**
   * オブジェクトのコピーを生成する
   */
  clone() {
    const cloneMatrix = new CubismMatrix44();
    for (let i2 = 0; i2 < this._tr.length; i2++) {
      cloneMatrix._tr[i2] = this._tr[i2];
    }
    return cloneMatrix;
  }
  // 4x4行列データ
}
class CubismRenderer {
  /**
   * レンダラの初期化処理を実行する
   * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
   * @param model モデルのインスタンス
   */
  initialize(model) {
    this._model = model;
  }
  /**
   * モデルを描画する
   */
  drawModel() {
    if (this.getModel() == null)
      return;
    this.saveProfile();
    this.doDrawModel();
    this.restoreProfile();
  }
  /**
   * Model-View-Projection 行列をセットする
   * 配列は複製されるので、元の配列は外で破棄して良い
   * @param matrix44 Model-View-Projection 行列
   */
  setMvpMatrix(matrix44) {
    this._mvpMatrix4x4.setMatrix(matrix44.getArray());
  }
  /**
   * Model-View-Projection 行列を取得する
   * @return Model-View-Projection 行列
   */
  getMvpMatrix() {
    return this._mvpMatrix4x4;
  }
  /**
   * モデルの色をセットする
   * 各色0.0~1.0の間で指定する（1.0が標準の状態）
   * @param red 赤チャンネルの値
   * @param green 緑チャンネルの値
   * @param blue 青チャンネルの値
   * @param alpha αチャンネルの値
   */
  setModelColor(red, green, blue, alpha) {
    if (red < 0) {
      red = 0;
    } else if (red > 1) {
      red = 1;
    }
    if (green < 0) {
      green = 0;
    } else if (green > 1) {
      green = 1;
    }
    if (blue < 0) {
      blue = 0;
    } else if (blue > 1) {
      blue = 1;
    }
    if (alpha < 0) {
      alpha = 0;
    } else if (alpha > 1) {
      alpha = 1;
    }
    this._modelColor.R = red;
    this._modelColor.G = green;
    this._modelColor.B = blue;
    this._modelColor.A = alpha;
  }
  /**
   * モデルの色を取得する
   * 各色0.0~1.0の間で指定する(1.0が標準の状態)
   *
   * @return RGBAのカラー情報
   */
  getModelColor() {
    return Object.assign({}, this._modelColor);
  }
  /**
   * 乗算済みαの有効・無効をセットする
   * 有効にするならtrue、無効にするならfalseをセットする
   */
  setIsPremultipliedAlpha(enable) {
    this._isPremultipliedAlpha = enable;
  }
  /**
   * 乗算済みαの有効・無効を取得する
   * @return true 乗算済みのα有効
   * @return false 乗算済みのα無効
   */
  isPremultipliedAlpha() {
    return this._isPremultipliedAlpha;
  }
  /**
   * カリング（片面描画）の有効・無効をセットする。
   * 有効にするならtrue、無効にするならfalseをセットする
   */
  setIsCulling(culling) {
    this._isCulling = culling;
  }
  /**
   * カリング（片面描画）の有効・無効を取得する。
   * @return true カリング有効
   * @return false カリング無効
   */
  isCulling() {
    return this._isCulling;
  }
  /**
   * テクスチャの異方性フィルタリングのパラメータをセットする
   * パラメータ値の影響度はレンダラの実装に依存する
   * @param n パラメータの値
   */
  setAnisotropy(n2) {
    this._anisotropy = n2;
  }
  /**
   * テクスチャの異方性フィルタリングのパラメータをセットする
   * @return 異方性フィルタリングのパラメータ
   */
  getAnisotropy() {
    return this._anisotropy;
  }
  /**
   * レンダリングするモデルを取得する
   * @return レンダリングするモデル
   */
  getModel() {
    return this._model;
  }
  /**
   * マスク描画の方式を変更する。
   * falseの場合、マスクを1枚のテクスチャに分割してレンダリングする（デフォルト）
   * 高速だが、マスク個数の上限が36に限定され、質も荒くなる
   * trueの場合、パーツ描画の前にその都度必要なマスクを描き直す
   * レンダリング品質は高いが描画処理負荷は増す
   * @param high 高精細マスクに切り替えるか？
   */
  useHighPrecisionMask(high) {
    this._useHighPrecisionMask = high;
  }
  /**
   * マスクの描画方式を取得する
   * @return true 高精細方式
   * @return false デフォルト
   */
  isUsingHighPrecisionMask() {
    return this._useHighPrecisionMask;
  }
  /**
   * コンストラクタ
   */
  constructor() {
    this._isCulling = false;
    this._isPremultipliedAlpha = false;
    this._anisotropy = 0;
    this._modelColor = new CubismTextureColor();
    this._useHighPrecisionMask = false;
    this._mvpMatrix4x4 = new CubismMatrix44();
    this._mvpMatrix4x4.loadIdentity();
  }
  // falseの場合、マスクを纏めて描画する trueの場合、マスクはパーツ描画ごとに書き直す
}
var CubismBlendMode = /* @__PURE__ */ ((CubismBlendMode2) => {
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal";
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive";
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative";
  return CubismBlendMode2;
})(CubismBlendMode || {});
class CubismTextureColor {
  /**
   * コンストラクタ
   */
  constructor(r2 = 1, g2 = 1, b2 = 1, a2 = 1) {
    this.R = r2;
    this.G = g2;
    this.B = b2;
    this.A = a2;
  }
  // αチャンネル
}
let s_isStarted = false;
let s_isInitialized = false;
let s_option = void 0;
const Constant = {
  vertexOffset: 0,
  // メッシュ頂点のオフセット値
  vertexStep: 2
  // メッシュ頂点のステップ値
};
class CubismFramework {
  /**
   * Cubism FrameworkのAPIを使用可能にする。
   *  APIを実行する前に必ずこの関数を実行すること。
   *  一度準備が完了して以降は、再び実行しても内部処理がスキップされます。
   *
   * @param    option      Optionクラスのインスタンス
   *
   * @return   準備処理が完了したらtrueが返ります。
   */
  static startUp(option) {
    if (s_isStarted) {
      CubismLogInfo("CubismFramework.startUp() is already done.");
      return s_isStarted;
    }
    if (Live2DCubismCore._isStarted) {
      s_isStarted = true;
      return true;
    }
    Live2DCubismCore._isStarted = true;
    s_option = option;
    if (s_option) {
      Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);
    }
    s_isStarted = true;
    if (s_isStarted) {
      const version = Live2DCubismCore.Version.csmGetVersion();
      const major = (version & 4278190080) >> 24;
      const minor = (version & 16711680) >> 16;
      const patch = version & 65535;
      const versionNumber = version;
      CubismLogInfo(
        `Live2D Cubism Core version: {0}.{1}.{2} ({3})`,
        ("00" + major).slice(-2),
        ("00" + minor).slice(-2),
        ("0000" + patch).slice(-4),
        versionNumber
      );
    }
    CubismLogInfo("CubismFramework.startUp() is complete.");
    return s_isStarted;
  }
  /**
   * StartUp()で初期化したCubismFrameworkの各パラメータをクリアします。
   * Dispose()したCubismFrameworkを再利用する際に利用してください。
   */
  static cleanUp() {
    s_isStarted = false;
    s_isInitialized = false;
    s_option = void 0;
  }
  /**
   * Cubism Framework内のリソースを初期化してモデルを表示可能な状態にします。<br>
   *     再度Initialize()するには先にDispose()を実行する必要があります。
   *
   * @param memorySize 初期化時メモリ量 [byte(s)]
   *    複数モデル表示時などにモデルが更新されない際に使用してください。
   *    指定する際は必ず1024*1024*16 byte(16MB)以上の値を指定してください。
   *    それ以外はすべて1024*1024*16 byteに丸めます。
   */
  static initialize(memorySize = 0) {
    if (!s_isStarted) {
      CubismLogWarning("CubismFramework is not started.");
      return;
    }
    if (s_isInitialized) {
      CubismLogWarning(
        "CubismFramework.initialize() skipped, already initialized."
      );
      return;
    }
    Live2DCubismCore.Memory.initializeAmountOfMemory(memorySize);
    s_isInitialized = true;
    CubismLogInfo("CubismFramework.initialize() is complete.");
  }
  /**
   * Cubism Framework内の全てのリソースを解放します。
   *      ただし、外部で確保されたリソースについては解放しません。
   *      外部で適切に破棄する必要があります。
   */
  static dispose() {
    if (!s_isStarted) {
      CubismLogWarning("CubismFramework is not started.");
      return;
    }
    if (!s_isInitialized) {
      CubismLogWarning("CubismFramework.dispose() skipped, not initialized.");
      return;
    }
    CubismRenderer.staticRelease();
    s_isInitialized = false;
    CubismLogInfo("CubismFramework.dispose() is complete.");
  }
  /**
   * Cubism FrameworkのAPIを使用する準備が完了したかどうか
   * @return APIを使用する準備が完了していればtrueが返ります。
   */
  static isStarted() {
    return s_isStarted;
  }
  /**
   * Cubism Frameworkのリソース初期化がすでに行われているかどうか
   * @return リソース確保が完了していればtrueが返ります
   */
  static isInitialized() {
    return s_isInitialized;
  }
  /**
   * Core APIにバインドしたログ関数を実行する
   *
   * @praram message ログメッセージ
   */
  static coreLogFunction(message) {
    if (!Live2DCubismCore.Logging.csmGetLogFunction()) {
      return;
    }
    Live2DCubismCore.Logging.csmGetLogFunction()(message);
  }
  /**
   * 現在のログ出力レベル設定の値を返す。
   *
   * @return  現在のログ出力レベル設定の値
   */
  static getLoggingLevel() {
    if (s_option != null) {
      return s_option.loggingLevel;
    }
    return 5;
  }
  /**
   * 静的クラスとして使用する
   * インスタンス化させない
   */
  constructor() {
  }
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["LogLevel_Verbose"] = 0] = "LogLevel_Verbose";
  LogLevel2[LogLevel2["LogLevel_Debug"] = 1] = "LogLevel_Debug";
  LogLevel2[LogLevel2["LogLevel_Info"] = 2] = "LogLevel_Info";
  LogLevel2[LogLevel2["LogLevel_Warning"] = 3] = "LogLevel_Warning";
  LogLevel2[LogLevel2["LogLevel_Error"] = 4] = "LogLevel_Error";
  LogLevel2[LogLevel2["LogLevel_Off"] = 5] = "LogLevel_Off";
  return LogLevel2;
})(LogLevel || {});
const CSM_ASSERT = typeof process !== "undefined" && true ? () => {
} : (expr) => console.assert(expr);
function CubismLogDebug(fmt, ...args) {
  CubismDebug.print(LogLevel.LogLevel_Debug, "[CSM][D]" + fmt + "\n", args);
}
function CubismLogInfo(fmt, ...args) {
  CubismDebug.print(LogLevel.LogLevel_Info, "[CSM][I]" + fmt + "\n", args);
}
function CubismLogWarning(fmt, ...args) {
  CubismDebug.print(LogLevel.LogLevel_Warning, "[CSM][W]" + fmt + "\n", args);
}
function CubismLogError(fmt, ...args) {
  CubismDebug.print(LogLevel.LogLevel_Error, "[CSM][E]" + fmt + "\n", args);
}
class CubismDebug {
  /**
   * ログを出力する。第一引数にログレベルを設定する。
   * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。
   *
   * @param logLevel ログレベルの設定
   * @param format 書式付き文字列
   * @param args 可変長引数
   */
  static print(logLevel, format2, args) {
    if (logLevel < CubismFramework.getLoggingLevel()) {
      return;
    }
    const logPrint = CubismFramework.coreLogFunction;
    if (!logPrint)
      return;
    const buffer = format2.replace(/{(\d+)}/g, (m2, k2) => {
      return args[k2];
    });
    logPrint(buffer);
  }
  /**
   * データから指定した長さだけダンプ出力する。
   * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。
   *
   * @param logLevel ログレベルの設定
   * @param data ダンプするデータ
   * @param length ダンプする長さ
   */
  static dumpBytes(logLevel, data, length2) {
    for (let i2 = 0; i2 < length2; i2++) {
      if (i2 % 16 == 0 && i2 > 0)
        this.print(logLevel, "\n");
      else if (i2 % 8 == 0 && i2 > 0)
        this.print(logLevel, "  ");
      this.print(logLevel, "{0} ", [data[i2] & 255]);
    }
    this.print(logLevel, "\n");
  }
  /**
   * private コンストラクタ
   */
  constructor() {
  }
}
class ACubismMotion {
  /**
   * コンストラクタ
   */
  constructor() {
    this._fadeInSeconds = -1;
    this._fadeOutSeconds = -1;
    this._weight = 1;
    this._offsetSeconds = 0;
    this._firedEventValues = [];
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._weight = 0;
  }
  /**
   * モデルのパラメータ
   * @param model 対象のモデル
   * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
   * @param userTimeSeconds デルタ時間の積算値[秒]
   */
  updateParameters(model, motionQueueEntry, userTimeSeconds) {
    if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {
      return;
    }
    if (!motionQueueEntry.isStarted()) {
      motionQueueEntry.setIsStarted(true);
      motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds);
      motionQueueEntry.setFadeInStartTime(userTimeSeconds);
      const duration = this.getDuration();
      if (motionQueueEntry.getEndTime() < 0) {
        motionQueueEntry.setEndTime(
          duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration
        );
      }
    }
    let fadeWeight = this._weight;
    const fadeIn = this._fadeInSeconds == 0 ? 1 : CubismMath.getEasingSine(
      (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds
    );
    const fadeOut = this._fadeOutSeconds == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
      (motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds
    );
    fadeWeight = fadeWeight * fadeIn * fadeOut;
    motionQueueEntry.setState(userTimeSeconds, fadeWeight);
    CSM_ASSERT(0 <= fadeWeight && fadeWeight <= 1);
    this.doUpdateParameters(
      model,
      userTimeSeconds,
      fadeWeight,
      motionQueueEntry
    );
    if (motionQueueEntry.getEndTime() > 0 && motionQueueEntry.getEndTime() < userTimeSeconds) {
      motionQueueEntry.setIsFinished(true);
    }
  }
  /**
   * フェードインの時間を設定する
   * @param fadeInSeconds フェードインにかかる時間[秒]
   */
  setFadeInTime(fadeInSeconds) {
    this._fadeInSeconds = fadeInSeconds;
  }
  /**
   * フェードアウトの時間を設定する
   * @param fadeOutSeconds フェードアウトにかかる時間[秒]
   */
  setFadeOutTime(fadeOutSeconds) {
    this._fadeOutSeconds = fadeOutSeconds;
  }
  /**
   * フェードアウトにかかる時間の取得
   * @return フェードアウトにかかる時間[秒]
   */
  getFadeOutTime() {
    return this._fadeOutSeconds;
  }
  /**
   * フェードインにかかる時間の取得
   * @return フェードインにかかる時間[秒]
   */
  getFadeInTime() {
    return this._fadeInSeconds;
  }
  /**
   * モーション適用の重みの設定
   * @param weight 重み（0.0 - 1.0）
   */
  setWeight(weight) {
    this._weight = weight;
  }
  /**
   * モーション適用の重みの取得
   * @return 重み（0.0 - 1.0）
   */
  getWeight() {
    return this._weight;
  }
  /**
   * モーションの長さの取得
   * @return モーションの長さ[秒]
   *
   * @note ループの時は「-1」。
   *       ループでない場合は、オーバーライドする。
   *       正の値の時は取得される時間で終了する。
   *       「-1」の時は外部から停止命令がない限り終わらない処理となる。
   */
  getDuration() {
    return -1;
  }
  /**
   * モーションのループ1回分の長さの取得
   * @return モーションのループ一回分の長さ[秒]
   *
   * @note ループしない場合は、getDuration()と同じ値を返す
   *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す
   */
  getLoopDuration() {
    return -1;
  }
  /**
   * モーション再生の開始時刻の設定
   * @param offsetSeconds モーション再生の開始時刻[秒]
   */
  setOffsetTime(offsetSeconds) {
    this._offsetSeconds = offsetSeconds;
  }
  /**
   * モデルのパラメータ更新
   *
   * イベント発火のチェック。
   * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
   *
   * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]
   * @param motionTimeSeconds 今回の再生時間[秒]
   */
  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
    return this._firedEventValues;
  }
  /**
   * モーション再生終了コールバックの登録
   *
   * モーション再生終了コールバックを登録する。
   * isFinishedフラグを設定するタイミングで呼び出される。
   * 以下の状態の際には呼び出されない:
   *   1. 再生中のモーションが「ループ」として設定されているとき
   *   2. コールバックが登録されていない時
   *
   * @param onFinishedMotionHandler モーション再生終了コールバック関数
   */
  setFinishedMotionHandler(onFinishedMotionHandler) {
    this._onFinishedMotion = onFinishedMotionHandler;
  }
  /**
   * モーション再生終了コールバックの取得
   *
   * モーション再生終了コールバックを取得する。
   *
   * @return 登録されているモーション再生終了コールバック関数
   */
  getFinishedMotionHandler() {
    return this._onFinishedMotion;
  }
  /**
   * 透明度のカーブが存在するかどうかを確認する
   *
   * @returns true  -> キーが存在する
   *          false -> キーが存在しない
   */
  isExistModelOpacity() {
    return false;
  }
  /**
   * 透明度のカーブのインデックスを返す
   *
   * @returns success:透明度のカーブのインデックス
   */
  getModelOpacityIndex() {
    return -1;
  }
  /**
   * 透明度のIdを返す
   *
   * @param index モーションカーブのインデックス
   * @returns success:透明度のId
   */
  getModelOpacityId(index) {
    return void 0;
  }
  /**
   * 指定時間の透明度の値を返す
   *
   * @returns success:モーションの現在時間におけるOpacityの値
   *
   * @note  更新後の値を取るにはUpdateParameters() の後に呼び出す。
   */
  getModelOpacityValue() {
    return 1;
  }
}
const DefaultFadeTime = 1;
class CubismExpressionMotion extends ACubismMotion {
  /**
   * インスタンスを作成する。
   * @param json expファイルが読み込まれているバッファ
   * @param size バッファのサイズ
   * @return 作成されたインスタンス
   */
  static create(json) {
    const expression = new CubismExpressionMotion();
    expression.parse(json);
    return expression;
  }
  /**
   * モデルのパラメータの更新の実行
   * @param model 対象のモデル
   * @param userTimeSeconds デルタ時間の積算値[秒]
   * @param weight モーションの重み
   * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
   */
  doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {
    for (let i2 = 0; i2 < this._parameters.length; ++i2) {
      const parameter = this._parameters[i2];
      switch (parameter.blendType) {
        case 0: {
          model.addParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
        case 1: {
          model.multiplyParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
        case 2: {
          model.setParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
      }
    }
  }
  parse(json) {
    this.setFadeInTime(
      json.FadeInTime != void 0 ? json.FadeInTime : DefaultFadeTime
    );
    this.setFadeOutTime(
      json.FadeOutTime != void 0 ? json.FadeOutTime : DefaultFadeTime
    );
    const parameterCount = (json.Parameters || []).length;
    for (let i2 = 0; i2 < parameterCount; ++i2) {
      const param = json.Parameters[i2];
      const parameterId = param.Id;
      const value = param.Value;
      let blendType;
      if (!param.Blend || param.Blend === "Add") {
        blendType = 0;
      } else if (param.Blend === "Multiply") {
        blendType = 1;
      } else if (param.Blend === "Overwrite") {
        blendType = 2;
      } else {
        blendType = 0;
      }
      const item = {
        parameterId,
        blendType,
        value
      };
      this._parameters.push(item);
    }
  }
  /**
   * コンストラクタ
   */
  constructor() {
    super();
    this._parameters = [];
  }
  // 表情のパラメータ情報リスト
}
class CubismMotionQueueEntry {
  /**
   * コンストラクタ
   */
  constructor() {
    this._autoDelete = false;
    this._available = true;
    this._finished = false;
    this._started = false;
    this._startTimeSeconds = -1;
    this._fadeInStartTimeSeconds = 0;
    this._endTimeSeconds = -1;
    this._stateTimeSeconds = 0;
    this._stateWeight = 0;
    this._lastEventCheckSeconds = 0;
    this._motionQueueEntryHandle = this;
    this._fadeOutSeconds = 0;
    this._isTriggeredFadeOut = false;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    if (this._autoDelete && this._motion) {
      this._motion.release();
    }
  }
  /**
   * フェードアウト時間と開始判定の設定
   * @param fadeOutSeconds フェードアウトにかかる時間[秒]
   */
  setFadeOut(fadeOutSeconds) {
    this._fadeOutSeconds = fadeOutSeconds;
    this._isTriggeredFadeOut = true;
  }
  /**
   * フェードアウトの開始
   * @param fadeOutSeconds フェードアウトにかかる時間[秒]
   * @param userTimeSeconds デルタ時間の積算値[秒]
   */
  startFadeOut(fadeOutSeconds, userTimeSeconds) {
    const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;
    this._isTriggeredFadeOut = true;
    if (this._endTimeSeconds < 0 || newEndTimeSeconds < this._endTimeSeconds) {
      this._endTimeSeconds = newEndTimeSeconds;
    }
  }
  /**
   * モーションの終了の確認
   *
   * @return true モーションが終了した
   * @return false 終了していない
   */
  isFinished() {
    return this._finished;
  }
  /**
   * モーションの開始の確認
   * @return true モーションが開始した
   * @return false 開始していない
   */
  isStarted() {
    return this._started;
  }
  /**
   * モーションの開始時刻の取得
   * @return モーションの開始時刻[秒]
   */
  getStartTime() {
    return this._startTimeSeconds;
  }
  /**
   * フェードインの開始時刻の取得
   * @return フェードインの開始時刻[秒]
   */
  getFadeInStartTime() {
    return this._fadeInStartTimeSeconds;
  }
  /**
   * フェードインの終了時刻の取得
   * @return フェードインの終了時刻の取得
   */
  getEndTime() {
    return this._endTimeSeconds;
  }
  /**
   * モーションの開始時刻の設定
   * @param startTime モーションの開始時刻
   */
  setStartTime(startTime) {
    this._startTimeSeconds = startTime;
  }
  /**
   * フェードインの開始時刻の設定
   * @param startTime フェードインの開始時刻[秒]
   */
  setFadeInStartTime(startTime) {
    this._fadeInStartTimeSeconds = startTime;
  }
  /**
   * フェードインの終了時刻の設定
   * @param endTime フェードインの終了時刻[秒]
   */
  setEndTime(endTime) {
    this._endTimeSeconds = endTime;
  }
  /**
   * モーションの終了の設定
   * @param f trueならモーションの終了
   */
  setIsFinished(f2) {
    this._finished = f2;
  }
  /**
   * モーション開始の設定
   * @param f trueならモーションの開始
   */
  setIsStarted(f2) {
    this._started = f2;
  }
  /**
   * モーションの有効性の確認
   * @return true モーションは有効
   * @return false モーションは無効
   */
  isAvailable() {
    return this._available;
  }
  /**
   * モーションの有効性の設定
   * @param v trueならモーションは有効
   */
  setIsAvailable(v2) {
    this._available = v2;
  }
  /**
   * モーションの状態の設定
   * @param timeSeconds 現在時刻[秒]
   * @param weight モーション尾重み
   */
  setState(timeSeconds, weight) {
    this._stateTimeSeconds = timeSeconds;
    this._stateWeight = weight;
  }
  /**
   * モーションの現在時刻の取得
   * @return モーションの現在時刻[秒]
   */
  getStateTime() {
    return this._stateTimeSeconds;
  }
  /**
   * モーションの重みの取得
   * @return モーションの重み
   */
  getStateWeight() {
    return this._stateWeight;
  }
  /**
   * 最後にイベントの発火をチェックした時間を取得
   *
   * @return 最後にイベントの発火をチェックした時間[秒]
   */
  getLastCheckEventSeconds() {
    return this._lastEventCheckSeconds;
  }
  /**
   * 最後にイベントをチェックした時間を設定
   * @param checkSeconds 最後にイベントをチェックした時間[秒]
   */
  setLastCheckEventSeconds(checkSeconds) {
    this._lastEventCheckSeconds = checkSeconds;
  }
  /**
   * フェードアウト開始判定の取得
   * @return フェードアウト開始するかどうか
   */
  isTriggeredFadeOut() {
    return this._isTriggeredFadeOut;
  }
  /**
   * フェードアウト時間の取得
   * @return フェードアウト時間[秒]
   */
  getFadeOutSeconds() {
    return this._fadeOutSeconds;
  }
  // インスタンスごとに一意の値を持つ識別番号
}
class CubismMotionQueueManager {
  /**
   * コンストラクタ
   */
  constructor() {
    this._userTimeSeconds = 0;
    this._eventCustomData = null;
    this._motions = [];
  }
  /**
   * デストラクタ
   */
  release() {
    for (let i2 = 0; i2 < this._motions.length; ++i2) {
      if (this._motions[i2]) {
        this._motions[i2].release();
      }
    }
    this._motions = void 0;
  }
  /**
   * 指定したモーションの開始
   *
   * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。
   *
   * @param   motion          開始するモーション
   * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true
   * @param   userTimeSeconds デルタ時間の積算値[秒]
   * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
   */
  startMotion(motion, autoDelete, userTimeSeconds) {
    if (motion == null) {
      return InvalidMotionQueueEntryHandleValue;
    }
    let motionQueueEntry;
    for (let i2 = 0; i2 < this._motions.length; ++i2) {
      motionQueueEntry = this._motions[i2];
      if (motionQueueEntry == null) {
        continue;
      }
      motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime());
    }
    motionQueueEntry = new CubismMotionQueueEntry();
    motionQueueEntry._autoDelete = autoDelete;
    motionQueueEntry._motion = motion;
    this._motions.push(motionQueueEntry);
    return motionQueueEntry._motionQueueEntryHandle;
  }
  /**
   * 全てのモーションの終了の確認
   * @return true 全て終了している
   * @return false 終了していない
   */
  isFinished() {
    let i2 = 0;
    while (i2 < this._motions.length) {
      const motionQueueEntry = this._motions[i2];
      if (motionQueueEntry == null) {
        this._motions.splice(i2, 1);
        continue;
      }
      const motion = motionQueueEntry._motion;
      if (motion == null) {
        motionQueueEntry.release();
        this._motions.splice(i2, 1);
        continue;
      }
      if (!motionQueueEntry.isFinished()) {
        return false;
      }
      i2++;
    }
    return true;
  }
  /**
   * 指定したモーションの終了の確認
   * @param motionQueueEntryNumber モーションの識別番号
   * @return true 全て終了している
   * @return false 終了していない
   */
  isFinishedByHandle(motionQueueEntryNumber) {
    for (let i2 = 0; i2 < this._motions.length; i2++) {
      const motionQueueEntry = this._motions[i2];
      if (motionQueueEntry == null) {
        continue;
      }
      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {
        return false;
      }
    }
    return true;
  }
  /**
   * 全てのモーションを停止する
   */
  stopAllMotions() {
    for (let i2 = 0; i2 < this._motions.length; i2++) {
      const motionQueueEntry = this._motions[i2];
      if (motionQueueEntry != null) {
        motionQueueEntry.release();
      }
    }
    this._motions = [];
  }
  /**
     * 指定したCubismMotionQueueEntryの取得
  
     * @param   motionQueueEntryNumber  モーションの識別番号
     * @return  指定したCubismMotionQueueEntry
     * @return  null   見つからなかった
     */
  getCubismMotionQueueEntry(motionQueueEntryNumber) {
    return this._motions.find(
      (entry) => entry != null && entry._motionQueueEntryHandle == motionQueueEntryNumber
    );
  }
  /**
   * イベントを受け取るCallbackの登録
   *
   * @param callback コールバック関数
   * @param customData コールバックに返されるデータ
   */
  setEventCallback(callback, customData = null) {
    this._eventCallBack = callback;
    this._eventCustomData = customData;
  }
  /**
   * モーションを更新して、モデルにパラメータ値を反映する。
   *
   * @param   model   対象のモデル
   * @param   userTimeSeconds   デルタ時間の積算値[秒]
   * @return  true    モデルへパラメータ値の反映あり
   * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)
   */
  doUpdateMotion(model, userTimeSeconds) {
    let updated = false;
    let i2 = 0;
    while (i2 < this._motions.length) {
      const motionQueueEntry = this._motions[i2];
      if (motionQueueEntry == null) {
        this._motions.splice(i2, 1);
        continue;
      }
      const motion = motionQueueEntry._motion;
      if (motion == null) {
        motionQueueEntry.release();
        this._motions.splice(i2, 1);
        continue;
      }
      motion.updateParameters(model, motionQueueEntry, userTimeSeconds);
      updated = true;
      const firedList = motion.getFiredEvent(
        motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(),
        userTimeSeconds - motionQueueEntry.getStartTime()
      );
      for (let i22 = 0; i22 < firedList.length; ++i22) {
        this._eventCallBack(this, firedList[i22], this._eventCustomData);
      }
      motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);
      if (motionQueueEntry.isFinished()) {
        motionQueueEntry.release();
        this._motions.splice(i2, 1);
      } else {
        if (motionQueueEntry.isTriggeredFadeOut()) {
          motionQueueEntry.startFadeOut(
            motionQueueEntry.getFadeOutSeconds(),
            userTimeSeconds
          );
        }
        i2++;
      }
    }
    return updated;
  }
  // コールバックに戻されるデータ
}
const InvalidMotionQueueEntryHandleValue = -1;
class Cubism4ExpressionManager extends ExpressionManager {
  constructor(settings2, options) {
    var _a2;
    super(settings2, options);
    __publicField(this, "queueManager", new CubismMotionQueueManager());
    __publicField(this, "definitions");
    this.definitions = (_a2 = settings2.expressions) != null ? _a2 : [];
    this.init();
  }
  isFinished() {
    return this.queueManager.isFinished();
  }
  getExpressionIndex(name2) {
    return this.definitions.findIndex((def) => def.Name === name2);
  }
  getExpressionFile(definition) {
    return definition.File;
  }
  createExpression(data, definition) {
    return CubismExpressionMotion.create(data);
  }
  _setExpression(motion) {
    return this.queueManager.startMotion(motion, false, performance.now());
  }
  stopAllExpressions() {
    this.queueManager.stopAllMotions();
  }
  updateParameters(model, now) {
    return this.queueManager.doUpdateMotion(model, now);
  }
}
var CubismMotionCurveTarget = /* @__PURE__ */ ((CubismMotionCurveTarget2) => {
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model";
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter";
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity";
  return CubismMotionCurveTarget2;
})(CubismMotionCurveTarget || {});
var CubismMotionSegmentType = /* @__PURE__ */ ((CubismMotionSegmentType2) => {
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped";
  return CubismMotionSegmentType2;
})(CubismMotionSegmentType || {});
class CubismMotionPoint {
  constructor(time = 0, value = 0) {
    this.time = time;
    this.value = value;
  }
  // 値
}
class CubismMotionSegment {
  /**
   * @brief コンストラクタ
   *
   * コンストラクタ。
   */
  constructor() {
    this.basePointIndex = 0;
    this.segmentType = 0;
  }
  // セグメントの種類
}
class CubismMotionCurve {
  constructor() {
    this.id = "";
    this.type = 0;
    this.segmentCount = 0;
    this.baseSegmentIndex = 0;
    this.fadeInTime = 0;
    this.fadeOutTime = 0;
  }
  // フェードアウトにかかる時間[秒]
}
class CubismMotionEvent {
  constructor() {
    this.fireTime = 0;
    this.value = "";
  }
}
class CubismMotionData {
  constructor() {
    this.duration = 0;
    this.loop = false;
    this.curveCount = 0;
    this.eventCount = 0;
    this.fps = 0;
    this.curves = [];
    this.segments = [];
    this.points = [];
    this.events = [];
  }
  // イベントのリスト
}
class CubismMotionJson {
  /**
   * コンストラクタ
   * @param json motion3.jsonが読み込まれているバッファ
   */
  constructor(json) {
    this._json = json;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._json = void 0;
  }
  /**
   * モーションの長さを取得する
   * @return モーションの長さ[秒]
   */
  getMotionDuration() {
    return this._json.Meta.Duration;
  }
  /**
   * モーションのループ情報の取得
   * @return true ループする
   * @return false ループしない
   */
  isMotionLoop() {
    return this._json.Meta.Loop || false;
  }
  getEvaluationOptionFlag(flagType) {
    if (0 == flagType) {
      return !!this._json.Meta.AreBeziersRestricted;
    }
    return false;
  }
  /**
   * モーションカーブの個数の取得
   * @return モーションカーブの個数
   */
  getMotionCurveCount() {
    return this._json.Meta.CurveCount;
  }
  /**
   * モーションのフレームレートの取得
   * @return フレームレート[FPS]
   */
  getMotionFps() {
    return this._json.Meta.Fps;
  }
  /**
   * モーションのセグメントの総合計の取得
   * @return モーションのセグメントの取得
   */
  getMotionTotalSegmentCount() {
    return this._json.Meta.TotalSegmentCount;
  }
  /**
   * モーションのカーブの制御店の総合計の取得
   * @return モーションのカーブの制御点の総合計
   */
  getMotionTotalPointCount() {
    return this._json.Meta.TotalPointCount;
  }
  /**
   * モーションのフェードイン時間の取得
   * @return フェードイン時間[秒]
   */
  getMotionFadeInTime() {
    return this._json.Meta.FadeInTime;
  }
  /**
   * モーションのフェードアウト時間の取得
   * @return フェードアウト時間[秒]
   */
  getMotionFadeOutTime() {
    return this._json.Meta.FadeOutTime;
  }
  /**
   * モーションのカーブの種類の取得
   * @param curveIndex カーブのインデックス
   * @return カーブの種類
   */
  getMotionCurveTarget(curveIndex) {
    return this._json.Curves[curveIndex].Target;
  }
  /**
   * モーションのカーブのIDの取得
   * @param curveIndex カーブのインデックス
   * @return カーブのID
   */
  getMotionCurveId(curveIndex) {
    return this._json.Curves[curveIndex].Id;
  }
  /**
   * モーションのカーブのフェードイン時間の取得
   * @param curveIndex カーブのインデックス
   * @return フェードイン時間[秒]
   */
  getMotionCurveFadeInTime(curveIndex) {
    return this._json.Curves[curveIndex].FadeInTime;
  }
  /**
   * モーションのカーブのフェードアウト時間の取得
   * @param curveIndex カーブのインデックス
   * @return フェードアウト時間[秒]
   */
  getMotionCurveFadeOutTime(curveIndex) {
    return this._json.Curves[curveIndex].FadeOutTime;
  }
  /**
   * モーションのカーブのセグメントの個数を取得する
   * @param curveIndex カーブのインデックス
   * @return モーションのカーブのセグメントの個数
   */
  getMotionCurveSegmentCount(curveIndex) {
    return this._json.Curves[curveIndex].Segments.length;
  }
  /**
   * モーションのカーブのセグメントの値の取得
   * @param curveIndex カーブのインデックス
   * @param segmentIndex セグメントのインデックス
   * @return セグメントの値
   */
  getMotionCurveSegment(curveIndex, segmentIndex) {
    return this._json.Curves[curveIndex].Segments[segmentIndex];
  }
  /**
   * イベントの個数の取得
   * @return イベントの個数
   */
  getEventCount() {
    return this._json.Meta.UserDataCount || 0;
  }
  /**
   *  イベントの総文字数の取得
   * @return イベントの総文字数
   */
  getTotalEventValueSize() {
    return this._json.Meta.TotalUserDataSize;
  }
  /**
   * イベントの時間の取得
   * @param userDataIndex イベントのインデックス
   * @return イベントの時間[秒]
   */
  getEventTime(userDataIndex) {
    return this._json.UserData[userDataIndex].Time;
  }
  /**
   * イベントの取得
   * @param userDataIndex イベントのインデックス
   * @return イベントの文字列
   */
  getEventValue(userDataIndex) {
    return this._json.UserData[userDataIndex].Value;
  }
  // motion3.jsonのデータ
}
var EvaluationOptionFlag = /* @__PURE__ */ ((EvaluationOptionFlag2) => {
  EvaluationOptionFlag2[EvaluationOptionFlag2["EvaluationOptionFlag_AreBeziersRistricted"] = 0] = "EvaluationOptionFlag_AreBeziersRistricted";
  return EvaluationOptionFlag2;
})(EvaluationOptionFlag || {});
const EffectNameEyeBlink = "EyeBlink";
const EffectNameLipSync = "LipSync";
const TargetNameModel = "Model";
const TargetNameParameter = "Parameter";
const TargetNamePartOpacity = "PartOpacity";
const IdNameOpacity = "Opacity";
const UseOldBeziersCurveMotion = false;
function lerpPoints(a2, b2, t2) {
  const result = new CubismMotionPoint();
  result.time = a2.time + (b2.time - a2.time) * t2;
  result.value = a2.value + (b2.value - a2.value) * t2;
  return result;
}
function linearEvaluate(points, time) {
  let t2 = (time - points[0].time) / (points[1].time - points[0].time);
  if (t2 < 0) {
    t2 = 0;
  }
  return points[0].value + (points[1].value - points[0].value) * t2;
}
function bezierEvaluate(points, time) {
  let t2 = (time - points[0].time) / (points[3].time - points[0].time);
  if (t2 < 0) {
    t2 = 0;
  }
  const p01 = lerpPoints(points[0], points[1], t2);
  const p12 = lerpPoints(points[1], points[2], t2);
  const p23 = lerpPoints(points[2], points[3], t2);
  const p012 = lerpPoints(p01, p12, t2);
  const p123 = lerpPoints(p12, p23, t2);
  return lerpPoints(p012, p123, t2).value;
}
function bezierEvaluateCardanoInterpretation(points, time) {
  const x2 = time;
  const x1 = points[0].time;
  const x22 = points[3].time;
  const cx1 = points[1].time;
  const cx2 = points[2].time;
  const a2 = x22 - 3 * cx2 + 3 * cx1 - x1;
  const b2 = 3 * cx2 - 6 * cx1 + 3 * x1;
  const c2 = 3 * cx1 - 3 * x1;
  const d2 = x1 - x2;
  const t2 = CubismMath.cardanoAlgorithmForBezier(a2, b2, c2, d2);
  const p01 = lerpPoints(points[0], points[1], t2);
  const p12 = lerpPoints(points[1], points[2], t2);
  const p23 = lerpPoints(points[2], points[3], t2);
  const p012 = lerpPoints(p01, p12, t2);
  const p123 = lerpPoints(p12, p23, t2);
  return lerpPoints(p012, p123, t2).value;
}
function steppedEvaluate(points, time) {
  return points[0].value;
}
function inverseSteppedEvaluate(points, time) {
  return points[1].value;
}
function evaluateCurve(motionData, index, time) {
  const curve = motionData.curves[index];
  let target = -1;
  const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;
  let pointPosition = 0;
  for (let i2 = curve.baseSegmentIndex; i2 < totalSegmentCount; ++i2) {
    pointPosition = motionData.segments[i2].basePointIndex + (motionData.segments[i2].segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);
    if (motionData.points[pointPosition].time > time) {
      target = i2;
      break;
    }
  }
  if (target == -1) {
    return motionData.points[pointPosition].value;
  }
  const segment = motionData.segments[target];
  return segment.evaluate(
    motionData.points.slice(segment.basePointIndex),
    time
  );
}
class CubismMotion extends ACubismMotion {
  /**
   * コンストラクタ
   */
  constructor() {
    super();
    this._eyeBlinkParameterIds = [];
    this._lipSyncParameterIds = [];
    this._sourceFrameRate = 30;
    this._loopDurationSeconds = -1;
    this._isLoop = false;
    this._isLoopFadeIn = true;
    this._lastWeight = 0;
    this._modelOpacity = 1;
  }
  /**
   * インスタンスを作成する
   *
   * @param json motion3.jsonが読み込まれているバッファ
   * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
   * @return 作成されたインスタンス
   */
  static create(json, onFinishedMotionHandler) {
    const ret = new CubismMotion();
    ret.parse(json);
    ret._sourceFrameRate = ret._motionData.fps;
    ret._loopDurationSeconds = ret._motionData.duration;
    ret._onFinishedMotion = onFinishedMotionHandler;
    return ret;
  }
  /**
   * モデルのパラメータの更新の実行
   * @param model             対象のモデル
   * @param userTimeSeconds   現在の時刻[秒]
   * @param fadeWeight        モーションの重み
   * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション
   */
  doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {
    if (this._modelCurveIdEyeBlink == null) {
      this._modelCurveIdEyeBlink = EffectNameEyeBlink;
    }
    if (this._modelCurveIdLipSync == null) {
      this._modelCurveIdLipSync = EffectNameLipSync;
    }
    if (this._modelCurveIdOpacity == null) {
      this._modelCurveIdOpacity = IdNameOpacity;
    }
    let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();
    if (timeOffsetSeconds < 0) {
      timeOffsetSeconds = 0;
    }
    let lipSyncValue = Number.MAX_VALUE;
    let eyeBlinkValue = Number.MAX_VALUE;
    const MaxTargetSize = 64;
    let lipSyncFlags = 0;
    let eyeBlinkFlags = 0;
    if (this._eyeBlinkParameterIds.length > MaxTargetSize) {
      CubismLogDebug(
        "too many eye blink targets : {0}",
        this._eyeBlinkParameterIds.length
      );
    }
    if (this._lipSyncParameterIds.length > MaxTargetSize) {
      CubismLogDebug(
        "too many lip sync targets : {0}",
        this._lipSyncParameterIds.length
      );
    }
    const tmpFadeIn = this._fadeInSeconds <= 0 ? 1 : CubismMath.getEasingSine(
      (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds
    );
    const tmpFadeOut = this._fadeOutSeconds <= 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
      (motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds
    );
    let value;
    let c2, parameterIndex;
    let time = timeOffsetSeconds;
    if (this._isLoop) {
      while (time > this._motionData.duration) {
        time -= this._motionData.duration;
      }
    }
    const curves2 = this._motionData.curves;
    for (c2 = 0; c2 < this._motionData.curveCount && curves2[c2].type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c2) {
      value = evaluateCurve(this._motionData, c2, time);
      if (curves2[c2].id == this._modelCurveIdEyeBlink) {
        eyeBlinkValue = value;
      } else if (curves2[c2].id == this._modelCurveIdLipSync) {
        lipSyncValue = value;
      } else if (curves2[c2].id == this._modelCurveIdOpacity) {
        this._modelOpacity = value;
        model.setModelOapcity(this.getModelOpacityValue());
      }
    }
    for (; c2 < this._motionData.curveCount && curves2[c2].type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c2) {
      parameterIndex = model.getParameterIndex(curves2[c2].id);
      if (parameterIndex == -1) {
        continue;
      }
      const sourceValue = model.getParameterValueByIndex(parameterIndex);
      value = evaluateCurve(this._motionData, c2, time);
      if (eyeBlinkValue != Number.MAX_VALUE) {
        for (let i2 = 0; i2 < this._eyeBlinkParameterIds.length && i2 < MaxTargetSize; ++i2) {
          if (this._eyeBlinkParameterIds[i2] == curves2[c2].id) {
            value *= eyeBlinkValue;
            eyeBlinkFlags |= 1 << i2;
            break;
          }
        }
      }
      if (lipSyncValue != Number.MAX_VALUE) {
        for (let i2 = 0; i2 < this._lipSyncParameterIds.length && i2 < MaxTargetSize; ++i2) {
          if (this._lipSyncParameterIds[i2] == curves2[c2].id) {
            value += lipSyncValue;
            lipSyncFlags |= 1 << i2;
            break;
          }
        }
      }
      let v2;
      if (curves2[c2].fadeInTime < 0 && curves2[c2].fadeOutTime < 0) {
        v2 = sourceValue + (value - sourceValue) * fadeWeight;
      } else {
        let fin;
        let fout;
        if (curves2[c2].fadeInTime < 0) {
          fin = tmpFadeIn;
        } else {
          fin = curves2[c2].fadeInTime == 0 ? 1 : CubismMath.getEasingSine(
            (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves2[c2].fadeInTime
          );
        }
        if (curves2[c2].fadeOutTime < 0) {
          fout = tmpFadeOut;
        } else {
          fout = curves2[c2].fadeOutTime == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
            (motionQueueEntry.getEndTime() - userTimeSeconds) / curves2[c2].fadeOutTime
          );
        }
        const paramWeight = this._weight * fin * fout;
        v2 = sourceValue + (value - sourceValue) * paramWeight;
      }
      model.setParameterValueByIndex(parameterIndex, v2, 1);
    }
    {
      if (eyeBlinkValue != Number.MAX_VALUE) {
        for (let i2 = 0; i2 < this._eyeBlinkParameterIds.length && i2 < MaxTargetSize; ++i2) {
          const sourceValue = model.getParameterValueById(
            this._eyeBlinkParameterIds[i2]
          );
          if (eyeBlinkFlags >> i2 & 1) {
            continue;
          }
          const v2 = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;
          model.setParameterValueById(this._eyeBlinkParameterIds[i2], v2);
        }
      }
      if (lipSyncValue != Number.MAX_VALUE) {
        for (let i2 = 0; i2 < this._lipSyncParameterIds.length && i2 < MaxTargetSize; ++i2) {
          const sourceValue = model.getParameterValueById(
            this._lipSyncParameterIds[i2]
          );
          if (lipSyncFlags >> i2 & 1) {
            continue;
          }
          const v2 = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;
          model.setParameterValueById(this._lipSyncParameterIds[i2], v2);
        }
      }
    }
    for (; c2 < this._motionData.curveCount && curves2[c2].type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c2) {
      value = evaluateCurve(this._motionData, c2, time);
      if (CubismConfig.setOpacityFromMotion) {
        model.setPartOpacityById(curves2[c2].id, value);
      } else {
        parameterIndex = model.getParameterIndex(curves2[c2].id);
        if (parameterIndex == -1) {
          continue;
        }
        model.setParameterValueByIndex(parameterIndex, value);
      }
    }
    if (timeOffsetSeconds >= this._motionData.duration) {
      if (this._isLoop) {
        motionQueueEntry.setStartTime(userTimeSeconds);
        if (this._isLoopFadeIn) {
          motionQueueEntry.setFadeInStartTime(userTimeSeconds);
        }
      } else {
        if (this._onFinishedMotion) {
          this._onFinishedMotion(this);
        }
        motionQueueEntry.setIsFinished(true);
      }
    }
    this._lastWeight = fadeWeight;
  }
  /**
   * ループ情報の設定
   * @param loop ループ情報
   */
  setIsLoop(loop) {
    this._isLoop = loop;
  }
  /**
   * ループ情報の取得
   * @return true ループする
   * @return false ループしない
   */
  isLoop() {
    return this._isLoop;
  }
  /**
   * ループ時のフェードイン情報の設定
   * @param loopFadeIn  ループ時のフェードイン情報
   */
  setIsLoopFadeIn(loopFadeIn) {
    this._isLoopFadeIn = loopFadeIn;
  }
  /**
   * ループ時のフェードイン情報の取得
   *
   * @return  true    する
   * @return  false   しない
   */
  isLoopFadeIn() {
    return this._isLoopFadeIn;
  }
  /**
   * モーションの長さを取得する。
   *
   * @return  モーションの長さ[秒]
   */
  getDuration() {
    return this._isLoop ? -1 : this._loopDurationSeconds;
  }
  /**
   * モーションのループ時の長さを取得する。
   *
   * @return  モーションのループ時の長さ[秒]
   */
  getLoopDuration() {
    return this._loopDurationSeconds;
  }
  /**
   * パラメータに対するフェードインの時間を設定する。
   *
   * @param parameterId     パラメータID
   * @param value           フェードインにかかる時間[秒]
   */
  setParameterFadeInTime(parameterId, value) {
    const curves2 = this._motionData.curves;
    for (let i2 = 0; i2 < this._motionData.curveCount; ++i2) {
      if (parameterId == curves2[i2].id) {
        curves2[i2].fadeInTime = value;
        return;
      }
    }
  }
  /**
   * パラメータに対するフェードアウトの時間の設定
   * @param parameterId     パラメータID
   * @param value           フェードアウトにかかる時間[秒]
   */
  setParameterFadeOutTime(parameterId, value) {
    const curves2 = this._motionData.curves;
    for (let i2 = 0; i2 < this._motionData.curveCount; ++i2) {
      if (parameterId == curves2[i2].id) {
        curves2[i2].fadeOutTime = value;
        return;
      }
    }
  }
  /**
   * パラメータに対するフェードインの時間の取得
   * @param    parameterId     パラメータID
   * @return   フェードインにかかる時間[秒]
   */
  getParameterFadeInTime(parameterId) {
    const curves2 = this._motionData.curves;
    for (let i2 = 0; i2 < this._motionData.curveCount; ++i2) {
      if (parameterId == curves2[i2].id) {
        return curves2[i2].fadeInTime;
      }
    }
    return -1;
  }
  /**
   * パラメータに対するフェードアウトの時間を取得
   *
   * @param   parameterId     パラメータID
   * @return   フェードアウトにかかる時間[秒]
   */
  getParameterFadeOutTime(parameterId) {
    const curves2 = this._motionData.curves;
    for (let i2 = 0; i2 < this._motionData.curveCount; ++i2) {
      if (parameterId == curves2[i2].id) {
        return curves2[i2].fadeOutTime;
      }
    }
    return -1;
  }
  /**
   * 自動エフェクトがかかっているパラメータIDリストの設定
   * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト
   * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト
   */
  setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {
    this._eyeBlinkParameterIds = eyeBlinkParameterIds;
    this._lipSyncParameterIds = lipSyncParameterIds;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._motionData = void 0;
  }
  /**
   * motion3.jsonをパースする。
   *
   * @param motionJson  motion3.jsonが読み込まれているバッファ
   */
  parse(motionJson) {
    this._motionData = new CubismMotionData();
    const json = new CubismMotionJson(motionJson);
    this._motionData.duration = json.getMotionDuration();
    this._motionData.loop = json.isMotionLoop();
    this._motionData.curveCount = json.getMotionCurveCount();
    this._motionData.fps = json.getMotionFps();
    this._motionData.eventCount = json.getEventCount();
    const areBeziersRestructed = json.getEvaluationOptionFlag(
      EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted
    );
    const fadeInSeconds = json.getMotionFadeInTime();
    const fadeOutSeconds = json.getMotionFadeOutTime();
    if (fadeInSeconds !== void 0) {
      this._fadeInSeconds = fadeInSeconds < 0 ? 1 : fadeInSeconds;
    } else {
      this._fadeInSeconds = 1;
    }
    if (fadeOutSeconds !== void 0) {
      this._fadeOutSeconds = fadeOutSeconds < 0 ? 1 : fadeOutSeconds;
    } else {
      this._fadeOutSeconds = 1;
    }
    this._motionData.curves = Array.from({
      length: this._motionData.curveCount
    }).map(() => new CubismMotionCurve());
    this._motionData.segments = Array.from({
      length: json.getMotionTotalSegmentCount()
    }).map(() => new CubismMotionSegment());
    this._motionData.events = Array.from({
      length: this._motionData.eventCount
    }).map(() => new CubismMotionEvent());
    this._motionData.points = [];
    let totalPointCount = 0;
    let totalSegmentCount = 0;
    for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
      const curve = this._motionData.curves[curveCount];
      switch (json.getMotionCurveTarget(curveCount)) {
        case TargetNameModel:
          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
          break;
        case TargetNameParameter:
          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;
          break;
        case TargetNamePartOpacity:
          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;
          break;
        default:
          CubismLogWarning(
            'Warning : Unable to get segment type from Curve! The number of "CurveCount" may be incorrect!'
          );
      }
      curve.id = json.getMotionCurveId(curveCount);
      curve.baseSegmentIndex = totalSegmentCount;
      const fadeInTime = json.getMotionCurveFadeInTime(curveCount);
      const fadeOutTime = json.getMotionCurveFadeOutTime(curveCount);
      curve.fadeInTime = fadeInTime !== void 0 ? fadeInTime : -1;
      curve.fadeOutTime = fadeOutTime !== void 0 ? fadeOutTime : -1;
      for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount); ) {
        if (segmentPosition == 0) {
          this._motionData.segments[totalSegmentCount].basePointIndex = totalPointCount;
          this._motionData.points[totalPointCount] = new CubismMotionPoint(
            json.getMotionCurveSegment(curveCount, segmentPosition),
            json.getMotionCurveSegment(curveCount, segmentPosition + 1)
          );
          totalPointCount += 1;
          segmentPosition += 2;
        } else {
          this._motionData.segments[totalSegmentCount].basePointIndex = totalPointCount - 1;
        }
        const segment = json.getMotionCurveSegment(
          curveCount,
          segmentPosition
        );
        switch (segment) {
          case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {
            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;
            this._motionData.segments[totalSegmentCount].evaluate = linearEvaluate;
            this._motionData.points[totalPointCount] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 1),
              json.getMotionCurveSegment(curveCount, segmentPosition + 2)
            );
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {
            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;
            if (areBeziersRestructed || UseOldBeziersCurveMotion) {
              this._motionData.segments[totalSegmentCount].evaluate = bezierEvaluate;
            } else {
              this._motionData.segments[totalSegmentCount].evaluate = bezierEvaluateCardanoInterpretation;
            }
            this._motionData.points[totalPointCount] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 1),
              json.getMotionCurveSegment(curveCount, segmentPosition + 2)
            );
            this._motionData.points[totalPointCount + 1] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 3),
              json.getMotionCurveSegment(curveCount, segmentPosition + 4)
            );
            this._motionData.points[totalPointCount + 2] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 5),
              json.getMotionCurveSegment(curveCount, segmentPosition + 6)
            );
            totalPointCount += 3;
            segmentPosition += 7;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {
            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;
            this._motionData.segments[totalSegmentCount].evaluate = steppedEvaluate;
            this._motionData.points[totalPointCount] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 1),
              json.getMotionCurveSegment(curveCount, segmentPosition + 2)
            );
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {
            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;
            this._motionData.segments[totalSegmentCount].evaluate = inverseSteppedEvaluate;
            this._motionData.points[totalPointCount] = new CubismMotionPoint(
              json.getMotionCurveSegment(curveCount, segmentPosition + 1),
              json.getMotionCurveSegment(curveCount, segmentPosition + 2)
            );
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          default: {
            CSM_ASSERT(0);
            break;
          }
        }
        ++curve.segmentCount;
        ++totalSegmentCount;
      }
      this._motionData.curves.push(curve);
    }
    for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {
      this._motionData.events[userdatacount].fireTime = json.getEventTime(userdatacount);
      this._motionData.events[userdatacount].value = json.getEventValue(userdatacount);
    }
    json.release();
  }
  /**
   * モデルのパラメータ更新
   *
   * イベント発火のチェック。
   * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
   *
   * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]
   * @param motionTimeSeconds        今回の再生時間[秒]
   */
  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
    this._firedEventValues.length = 0;
    for (let u2 = 0; u2 < this._motionData.eventCount; ++u2) {
      if (this._motionData.events[u2].fireTime > beforeCheckTimeSeconds && this._motionData.events[u2].fireTime <= motionTimeSeconds) {
        this._firedEventValues.push(this._motionData.events[u2].value);
      }
    }
    return this._firedEventValues;
  }
  /**
   * 透明度のカーブが存在するかどうかを確認する
   *
   * @returns true  -> キーが存在する
   *          false -> キーが存在しない
   */
  isExistModelOpacity() {
    for (let i2 = 0; i2 < this._motionData.curveCount; i2++) {
      const curve = this._motionData.curves[i2];
      if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
        continue;
      }
      if (curve.id === IdNameOpacity) {
        return true;
      }
    }
    return false;
  }
  /**
   * 透明度のカーブのインデックスを返す
   *
   * @returns success:透明度のカーブのインデックス
   */
  getModelOpacityIndex() {
    if (this.isExistModelOpacity()) {
      for (let i2 = 0; i2 < this._motionData.curveCount; i2++) {
        const curve = this._motionData.curves[i2];
        if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          continue;
        }
        if (curve.id === IdNameOpacity) {
          return i2;
        }
      }
    }
    return -1;
  }
  /**
   * 透明度のIdを返す
   *
   * @param index モーションカーブのインデックス
   * @returns success:透明度のカーブのインデックス
   */
  getModelOpacityId(index) {
    if (index != -1) {
      const curve = this._motionData.curves[index];
      if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
        if (curve.id === IdNameOpacity) {
          return curve.id;
        }
      }
    }
    return void 0;
  }
  /**
   * 現在時間の透明度の値を返す
   *
   * @returns success:モーションの当該時間におけるOpacityの値
   */
  getModelOpacityValue() {
    return this._modelOpacity;
  }
  // モーションから取得した不透明度
}
class Cubism4MotionManager extends MotionManager {
  constructor(settings2, options) {
    var _a2;
    super(settings2, options);
    __publicField(this, "definitions");
    __publicField(this, "groups", { idle: "Idle" });
    __publicField(this, "motionDataType", "json");
    __publicField(this, "queueManager", new CubismMotionQueueManager());
    __publicField(this, "expressionManager");
    __publicField(this, "eyeBlinkIds");
    __publicField(this, "lipSyncIds", ["ParamMouthOpenY"]);
    this.definitions = (_a2 = settings2.motions) != null ? _a2 : {};
    this.eyeBlinkIds = settings2.getEyeBlinkParameters() || [];
    const lipSyncIds = settings2.getLipSyncParameters();
    if (lipSyncIds == null ? void 0 : lipSyncIds.length) {
      this.lipSyncIds = lipSyncIds;
    }
    this.init(options);
  }
  init(options) {
    super.init(options);
    if (this.settings.expressions) {
      this.expressionManager = new Cubism4ExpressionManager(this.settings, options);
    }
    this.queueManager.setEventCallback((caller, eventValue, customData) => {
      this.emit("motion:" + eventValue);
    });
  }
  isFinished() {
    return this.queueManager.isFinished();
  }
  _startMotion(motion, onFinish) {
    motion.setFinishedMotionHandler(onFinish);
    this.queueManager.stopAllMotions();
    return this.queueManager.startMotion(motion, false, performance.now());
  }
  _stopAllMotions() {
    this.queueManager.stopAllMotions();
  }
  createMotion(data, group2, definition) {
    const motion = CubismMotion.create(data);
    const json = new CubismMotionJson(data);
    const defaultFadingDuration = (group2 === this.groups.idle ? config$1.idleMotionFadingDuration : config$1.motionFadingDuration) / 1e3;
    if (json.getMotionFadeInTime() === void 0) {
      motion.setFadeInTime(
        definition.FadeInTime > 0 ? definition.FadeInTime : defaultFadingDuration
      );
    }
    if (json.getMotionFadeOutTime() === void 0) {
      motion.setFadeOutTime(
        definition.FadeOutTime > 0 ? definition.FadeOutTime : defaultFadingDuration
      );
    }
    motion.setEffectIds(this.eyeBlinkIds, this.lipSyncIds);
    return motion;
  }
  getMotionFile(definition) {
    return definition.File;
  }
  getMotionName(definition) {
    return definition.File;
  }
  getSoundFile(definition) {
    return definition.Sound;
  }
  updateParameters(model, now) {
    return this.queueManager.doUpdateMotion(model, now);
  }
  destroy() {
    super.destroy();
    this.queueManager.release();
    this.queueManager = void 0;
  }
}
const ParamAngleX = "ParamAngleX";
const ParamAngleY = "ParamAngleY";
const ParamAngleZ = "ParamAngleZ";
const ParamEyeBallX = "ParamEyeBallX";
const ParamEyeBallY = "ParamEyeBallY";
const ParamMouthForm = "ParamMouthForm";
const ParamBodyAngleX = "ParamBodyAngleX";
const ParamBreath = "ParamBreath";
class CubismBreath {
  /**
   * コンストラクタ
   */
  constructor() {
    this._breathParameters = [];
    this._currentTime = 0;
  }
  /**
   * インスタンスの作成
   */
  static create() {
    return new CubismBreath();
  }
  /**
   * 呼吸のパラメータの紐づけ
   * @param breathParameters 呼吸を紐づけたいパラメータのリスト
   */
  setParameters(breathParameters) {
    this._breathParameters = breathParameters;
  }
  /**
   * 呼吸に紐づいているパラメータの取得
   * @return 呼吸に紐づいているパラメータのリスト
   */
  getParameters() {
    return this._breathParameters;
  }
  /**
   * モデルのパラメータの更新
   * @param model 対象のモデル
   * @param deltaTimeSeconds デルタ時間[秒]
   */
  updateParameters(model, deltaTimeSeconds) {
    this._currentTime += deltaTimeSeconds;
    const t2 = this._currentTime * 2 * 3.14159;
    for (let i2 = 0; i2 < this._breathParameters.length; ++i2) {
      const data = this._breathParameters[i2];
      model.addParameterValueById(
        data.parameterId,
        data.offset + data.peak * Math.sin(t2 / data.cycle),
        data.weight
      );
    }
  }
  // 積算時間[秒]
}
class BreathParameterData {
  /**
   * コンストラクタ
   * @param parameterId   呼吸をひもづけるパラメータID
   * @param offset        呼吸を正弦波としたときの、波のオフセット
   * @param peak          呼吸を正弦波としたときの、波の高さ
   * @param cycle         呼吸を正弦波としたときの、波の周期
   * @param weight        パラメータへの重み
   */
  constructor(parameterId, offset2, peak, cycle, weight) {
    this.parameterId = parameterId == void 0 ? void 0 : parameterId;
    this.offset = offset2 == void 0 ? 0 : offset2;
    this.peak = peak == void 0 ? 0 : peak;
    this.cycle = cycle == void 0 ? 0 : cycle;
    this.weight = weight == void 0 ? 0 : weight;
  }
  // パラメータへの重み
}
const _CubismEyeBlink = class _CubismEyeBlink2 {
  /**
   * インスタンスを作成する
   * @param modelSetting モデルの設定情報
   * @return 作成されたインスタンス
   * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。
   */
  static create(modelSetting) {
    return new _CubismEyeBlink2(modelSetting);
  }
  /**
   * まばたきの間隔の設定
   * @param blinkingInterval まばたきの間隔の時間[秒]
   */
  setBlinkingInterval(blinkingInterval) {
    this._blinkingIntervalSeconds = blinkingInterval;
  }
  /**
   * まばたきのモーションの詳細設定
   * @param closing   まぶたを閉じる動作の所要時間[秒]
   * @param closed    まぶたを閉じている動作の所要時間[秒]
   * @param opening   まぶたを開く動作の所要時間[秒]
   */
  setBlinkingSetting(closing, closed, opening) {
    this._closingSeconds = closing;
    this._closedSeconds = closed;
    this._openingSeconds = opening;
  }
  /**
   * まばたきさせるパラメータIDのリストの設定
   * @param parameterIds パラメータのIDのリスト
   */
  setParameterIds(parameterIds) {
    this._parameterIds = parameterIds;
  }
  /**
   * まばたきさせるパラメータIDのリストの取得
   * @return パラメータIDのリスト
   */
  getParameterIds() {
    return this._parameterIds;
  }
  /**
   * モデルのパラメータの更新
   * @param model 対象のモデル
   * @param deltaTimeSeconds デルタ時間[秒]
   */
  updateParameters(model, deltaTimeSeconds) {
    this._userTimeSeconds += deltaTimeSeconds;
    let parameterValue;
    let t2 = 0;
    switch (this._blinkingState) {
      case 2:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds;
        if (t2 >= 1) {
          t2 = 1;
          this._blinkingState = 3;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 1 - t2;
        break;
      case 3:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds;
        if (t2 >= 1) {
          this._blinkingState = 4;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 0;
        break;
      case 4:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds;
        if (t2 >= 1) {
          t2 = 1;
          this._blinkingState = 1;
          this._nextBlinkingTime = this.determinNextBlinkingTiming();
        }
        parameterValue = t2;
        break;
      case 1:
        if (this._nextBlinkingTime < this._userTimeSeconds) {
          this._blinkingState = 2;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 1;
        break;
      case 0:
      default:
        this._blinkingState = 1;
        this._nextBlinkingTime = this.determinNextBlinkingTiming();
        parameterValue = 1;
        break;
    }
    if (!_CubismEyeBlink2.CloseIfZero) {
      parameterValue = -parameterValue;
    }
    for (let i2 = 0; i2 < this._parameterIds.length; ++i2) {
      model.setParameterValueById(this._parameterIds[i2], parameterValue);
    }
  }
  /**
   * コンストラクタ
   * @param modelSetting モデルの設定情報
   */
  constructor(modelSetting) {
    var _a2, _b;
    this._blinkingState = 0;
    this._nextBlinkingTime = 0;
    this._stateStartTimeSeconds = 0;
    this._blinkingIntervalSeconds = 4;
    this._closingSeconds = 0.1;
    this._closedSeconds = 0.05;
    this._openingSeconds = 0.15;
    this._userTimeSeconds = 0;
    this._parameterIds = [];
    if (modelSetting == null) {
      return;
    }
    this._parameterIds = (_b = (_a2 = modelSetting.getEyeBlinkParameters()) == null ? void 0 : _a2.slice()) != null ? _b : this._parameterIds;
  }
  /**
   * 次の瞬きのタイミングの決定
   *
   * @return 次のまばたきを行う時刻[秒]
   */
  determinNextBlinkingTiming() {
    const r2 = Math.random();
    return this._userTimeSeconds + r2 * (2 * this._blinkingIntervalSeconds - 1);
  }
};
_CubismEyeBlink.CloseIfZero = true;
let CubismEyeBlink = _CubismEyeBlink;
class csmRect {
  /**
   * コンストラクタ
   * @param x 左端X座標
   * @param y 上端Y座標
   * @param w 幅
   * @param h 高さ
   */
  constructor(x2 = 0, y2 = 0, w2 = 0, h2 = 0) {
    this.x = x2;
    this.y = y2;
    this.width = w2;
    this.height = h2;
  }
  /**
   * 矩形中央のX座標を取得する
   */
  getCenterX() {
    return this.x + 0.5 * this.width;
  }
  /**
   * 矩形中央のY座標を取得する
   */
  getCenterY() {
    return this.y + 0.5 * this.height;
  }
  /**
   * 右側のX座標を取得する
   */
  getRight() {
    return this.x + this.width;
  }
  /**
   * 下端のY座標を取得する
   */
  getBottom() {
    return this.y + this.height;
  }
  /**
   * 矩形に値をセットする
   * @param r 矩形のインスタンス
   */
  setRect(r2) {
    this.x = r2.x;
    this.y = r2.y;
    this.width = r2.width;
    this.height = r2.height;
  }
  /**
   * 矩形中央を軸にして縦横を拡縮する
   * @param w 幅方向に拡縮する量
   * @param h 高さ方向に拡縮する量
   */
  expand(w2, h2) {
    this.x -= w2;
    this.y -= h2;
    this.width += w2 * 2;
    this.height += h2 * 2;
  }
  // 高さ
}
const ColorChannelCount = 4;
const ClippingMaskMaxCountOnDefault = 36;
const ClippingMaskMaxCountOnMultiRenderTexture = 32;
const ShaderCount = 10;
let s_instance;
let s_viewport;
let s_fbo;
class CubismClippingManager_WebGL {
  /**
   * カラーチャンネル（RGBA）のフラグを取得する
   * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）
   */
  getChannelFlagAsColor(channelNo) {
    return this._channelColors[channelNo];
  }
  /**
   * テンポラリのレンダーテクスチャのアドレスを取得する
   * FrameBufferObjectが存在しない場合、新しく生成する
   *
   * @return レンダーテクスチャの配列
   */
  getMaskRenderTexture() {
    if (this._maskTexture && this._maskTexture.textures != null) {
      this._maskTexture.frameNo = this._currentFrameNo;
    } else {
      this._maskRenderTextures = [];
      this._maskColorBuffers = [];
      const size2 = this._clippingMaskBufferSize;
      for (let index = 0; index < this._renderTextureCount; index++) {
        this._maskColorBuffers.push(this.gl.createTexture());
        this.gl.bindTexture(this.gl.TEXTURE_2D, this._maskColorBuffers[index]);
        this.gl.texImage2D(
          this.gl.TEXTURE_2D,
          0,
          this.gl.RGBA,
          size2,
          size2,
          0,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          null
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_S,
          this.gl.CLAMP_TO_EDGE
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_T,
          this.gl.CLAMP_TO_EDGE
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MIN_FILTER,
          this.gl.LINEAR
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MAG_FILTER,
          this.gl.LINEAR
        );
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this._maskRenderTextures.push(this.gl.createFramebuffer());
        this.gl.bindFramebuffer(
          this.gl.FRAMEBUFFER,
          this._maskRenderTextures[index]
        );
        this.gl.framebufferTexture2D(
          this.gl.FRAMEBUFFER,
          this.gl.COLOR_ATTACHMENT0,
          this.gl.TEXTURE_2D,
          this._maskColorBuffers[index],
          0
        );
      }
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
      this._maskTexture = new CubismRenderTextureResource(
        this._currentFrameNo,
        this._maskRenderTextures
      );
    }
    return this._maskTexture.textures;
  }
  /**
   * WebGLレンダリングコンテキストを設定する
   * @param gl WebGLレンダリングコンテキスト
   */
  setGL(gl2) {
    this.gl = gl2;
  }
  /**
   * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する
   * @param model モデルのインスタンス
   * @param clippingContext クリッピングマスクのコンテキスト
   */
  calcClippedDrawTotalBounds(model, clippingContext) {
    let clippedDrawTotalMinX = Number.MAX_VALUE;
    let clippedDrawTotalMinY = Number.MAX_VALUE;
    let clippedDrawTotalMaxX = Number.MIN_VALUE;
    let clippedDrawTotalMaxY = Number.MIN_VALUE;
    const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;
    for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {
      const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];
      const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);
      const drawableVertexes = model.getDrawableVertices(drawableIndex);
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = -Number.MAX_VALUE;
      let maxY = -Number.MAX_VALUE;
      const loop = drawableVertexCount * Constant.vertexStep;
      for (let pi2 = Constant.vertexOffset; pi2 < loop; pi2 += Constant.vertexStep) {
        const x2 = drawableVertexes[pi2];
        const y2 = drawableVertexes[pi2 + 1];
        if (x2 < minX) {
          minX = x2;
        }
        if (x2 > maxX) {
          maxX = x2;
        }
        if (y2 < minY) {
          minY = y2;
        }
        if (y2 > maxY) {
          maxY = y2;
        }
      }
      if (minX == Number.MAX_VALUE) {
        continue;
      }
      if (minX < clippedDrawTotalMinX) {
        clippedDrawTotalMinX = minX;
      }
      if (minY < clippedDrawTotalMinY) {
        clippedDrawTotalMinY = minY;
      }
      if (maxX > clippedDrawTotalMaxX) {
        clippedDrawTotalMaxX = maxX;
      }
      if (maxY > clippedDrawTotalMaxY) {
        clippedDrawTotalMaxY = maxY;
      }
      if (clippedDrawTotalMinX == Number.MAX_VALUE) {
        clippingContext._allClippedDrawRect.x = 0;
        clippingContext._allClippedDrawRect.y = 0;
        clippingContext._allClippedDrawRect.width = 0;
        clippingContext._allClippedDrawRect.height = 0;
        clippingContext._isUsing = false;
      } else {
        clippingContext._isUsing = true;
        const w2 = clippedDrawTotalMaxX - clippedDrawTotalMinX;
        const h2 = clippedDrawTotalMaxY - clippedDrawTotalMinY;
        clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;
        clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;
        clippingContext._allClippedDrawRect.width = w2;
        clippingContext._allClippedDrawRect.height = h2;
      }
    }
  }
  /**
   * コンストラクタ
   */
  constructor() {
    this._currentMaskRenderTexture = null;
    this._currentFrameNo = 0;
    this._renderTextureCount = 0;
    this._clippingMaskBufferSize = 256;
    this._clippingContextListForMask = [];
    this._clippingContextListForDraw = [];
    this._channelColors = [];
    this._tmpBoundsOnModel = new csmRect();
    this._tmpMatrix = new CubismMatrix44();
    this._tmpMatrixForMask = new CubismMatrix44();
    this._tmpMatrixForDraw = new CubismMatrix44();
    let tmp = new CubismTextureColor();
    tmp.R = 1;
    tmp.G = 0;
    tmp.B = 0;
    tmp.A = 0;
    this._channelColors.push(tmp);
    tmp = new CubismTextureColor();
    tmp.R = 0;
    tmp.G = 1;
    tmp.B = 0;
    tmp.A = 0;
    this._channelColors.push(tmp);
    tmp = new CubismTextureColor();
    tmp.R = 0;
    tmp.G = 0;
    tmp.B = 1;
    tmp.A = 0;
    this._channelColors.push(tmp);
    tmp = new CubismTextureColor();
    tmp.R = 0;
    tmp.G = 0;
    tmp.B = 0;
    tmp.A = 1;
    this._channelColors.push(tmp);
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    var _a2;
    const self2 = this;
    for (let i2 = 0; i2 < this._clippingContextListForMask.length; i2++) {
      if (this._clippingContextListForMask[i2]) {
        (_a2 = this._clippingContextListForMask[i2]) == null ? void 0 : _a2.release();
      }
    }
    self2._clippingContextListForMask = void 0;
    self2._clippingContextListForDraw = void 0;
    if (this._maskTexture) {
      for (let i2 = 0; i2 < this._maskTexture.textures.length; i2++) {
        this.gl.deleteFramebuffer(this._maskTexture.textures[i2]);
      }
      this._maskTexture = void 0;
    }
    self2._channelColors = void 0;
    if (this._maskColorBuffers) {
      for (let index = 0; index < this._maskColorBuffers.length; index++) {
        this.gl.deleteTexture(this._maskColorBuffers[index]);
      }
    }
    this._maskColorBuffers = void 0;
    this._maskRenderTextures = void 0;
    this._clearedFrameBufferflags = void 0;
  }
  /**
   * マネージャの初期化処理
   * クリッピングマスクを使う描画オブジェクトの登録を行う
   * @param model モデルのインスタンス
   * @param drawableCount 描画オブジェクトの数
   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト
   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
   * @param renderTextureCount バッファの生成数
   */
  initialize(model, drawableCount, drawableMasks, drawableMaskCounts, renderTextureCount) {
    if (renderTextureCount % 1 != 0) {
      CubismLogWarning(
        "The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer."
      );
      renderTextureCount = ~~renderTextureCount;
    }
    if (renderTextureCount < 1) {
      CubismLogWarning(
        "The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1."
      );
    }
    this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;
    this._clearedFrameBufferflags = [];
    for (let i2 = 0; i2 < drawableCount; i2++) {
      if (drawableMaskCounts[i2] <= 0) {
        this._clippingContextListForDraw.push(null);
        continue;
      }
      let clippingContext = this.findSameClip(
        drawableMasks[i2],
        drawableMaskCounts[i2]
      );
      if (clippingContext == null) {
        clippingContext = new CubismClippingContext(
          this,
          drawableMasks[i2],
          drawableMaskCounts[i2]
        );
        this._clippingContextListForMask.push(clippingContext);
      }
      clippingContext.addClippedDrawable(i2);
      this._clippingContextListForDraw.push(clippingContext);
    }
  }
  /**
   * クリッピングコンテキストを作成する。モデル描画時に実行する。
   * @param model モデルのインスタンス
   * @param renderer レンダラのインスタンス
   */
  setupClippingContext(model, renderer) {
    this._currentFrameNo++;
    let usingClipCount = 0;
    for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {
      const cc2 = this._clippingContextListForMask[clipIndex];
      this.calcClippedDrawTotalBounds(model, cc2);
      if (cc2._isUsing) {
        usingClipCount++;
      }
    }
    if (usingClipCount > 0) {
      this.setupLayoutBounds(
        renderer.isUsingHighPrecisionMask() ? 0 : usingClipCount
      );
      if (!renderer.isUsingHighPrecisionMask()) {
        this.gl.viewport(
          0,
          0,
          this._clippingMaskBufferSize,
          this._clippingMaskBufferSize
        );
        this._currentMaskRenderTexture = this.getMaskRenderTexture()[0];
        renderer.preDraw();
        this.gl.bindFramebuffer(
          this.gl.FRAMEBUFFER,
          this._currentMaskRenderTexture
        );
      }
      if (!this._clearedFrameBufferflags) {
        this._clearedFrameBufferflags = [];
      }
      for (let index = 0; index < this._renderTextureCount; index++) {
        this._clearedFrameBufferflags[index] = false;
      }
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {
        const clipContext = this._clippingContextListForMask[clipIndex];
        const allClipedDrawRect = clipContext._allClippedDrawRect;
        const layoutBoundsOnTex01 = clipContext._layoutBounds;
        const MARGIN = 0.05;
        let scaleX = 0;
        let scaleY = 0;
        const clipContextRenderTexture = this.getMaskRenderTexture()[clipContext._bufferIndex];
        if (this._currentMaskRenderTexture != clipContextRenderTexture && !renderer.isUsingHighPrecisionMask()) {
          this._currentMaskRenderTexture = clipContextRenderTexture;
          renderer.preDraw();
          this.gl.bindFramebuffer(
            this.gl.FRAMEBUFFER,
            this._currentMaskRenderTexture
          );
        }
        if (renderer.isUsingHighPrecisionMask()) {
          const ppu = model.getPixelsPerUnit();
          const maskPixelSize = clipContext.getClippingManager()._clippingMaskBufferSize;
          const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;
          const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;
          this._tmpBoundsOnModel.setRect(allClipedDrawRect);
          if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {
            this._tmpBoundsOnModel.expand(
              allClipedDrawRect.width * MARGIN,
              0
            );
            scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          } else {
            scaleX = ppu / physicalMaskWidth;
          }
          if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {
            this._tmpBoundsOnModel.expand(
              0,
              allClipedDrawRect.height * MARGIN
            );
            scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
          } else {
            scaleY = ppu / physicalMaskHeight;
          }
        } else {
          this._tmpBoundsOnModel.setRect(allClipedDrawRect);
          this._tmpBoundsOnModel.expand(
            allClipedDrawRect.width * MARGIN,
            allClipedDrawRect.height * MARGIN
          );
          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
        }
        {
          this._tmpMatrix.loadIdentity();
          {
            this._tmpMatrix.translateRelative(-1, -1);
            this._tmpMatrix.scaleRelative(2, 2);
          }
          {
            this._tmpMatrix.translateRelative(
              layoutBoundsOnTex01.x,
              layoutBoundsOnTex01.y
            );
            this._tmpMatrix.scaleRelative(scaleX, scaleY);
            this._tmpMatrix.translateRelative(
              -this._tmpBoundsOnModel.x,
              -this._tmpBoundsOnModel.y
            );
          }
          this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
        }
        {
          this._tmpMatrix.loadIdentity();
          {
            this._tmpMatrix.translateRelative(
              layoutBoundsOnTex01.x,
              layoutBoundsOnTex01.y
            );
            this._tmpMatrix.scaleRelative(scaleX, scaleY);
            this._tmpMatrix.translateRelative(
              -this._tmpBoundsOnModel.x,
              -this._tmpBoundsOnModel.y
            );
          }
          this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
        }
        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
        if (!renderer.isUsingHighPrecisionMask()) {
          const clipDrawCount = clipContext._clippingIdCount;
          for (let i2 = 0; i2 < clipDrawCount; i2++) {
            const clipDrawIndex = clipContext._clippingIdList[i2];
            if (!model.getDrawableDynamicFlagVertexPositionsDidChange(
              clipDrawIndex
            )) {
              continue;
            }
            renderer.setIsCulling(
              model.getDrawableCulling(clipDrawIndex) != false
            );
            if (!this._clearedFrameBufferflags[clipContext._bufferIndex]) {
              this.gl.clearColor(1, 1, 1, 1);
              this.gl.clear(this.gl.COLOR_BUFFER_BIT);
              this._clearedFrameBufferflags[clipContext._bufferIndex] = true;
            }
            renderer.setClippingContextBufferForMask(clipContext);
            renderer.drawMesh(
              model.getDrawableTextureIndex(clipDrawIndex),
              model.getDrawableVertexIndexCount(clipDrawIndex),
              model.getDrawableVertexCount(clipDrawIndex),
              model.getDrawableVertexIndices(clipDrawIndex),
              model.getDrawableVertices(clipDrawIndex),
              model.getDrawableVertexUvs(clipDrawIndex),
              model.getMultiplyColor(clipDrawIndex),
              model.getScreenColor(clipDrawIndex),
              model.getDrawableOpacity(clipDrawIndex),
              CubismBlendMode.CubismBlendMode_Normal,
              // クリッピングは通常描画を強制
              false
              // マスク生成時はクリッピングの反転使用は全く関係がない
            );
          }
        }
      }
      if (!renderer.isUsingHighPrecisionMask()) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
        renderer.setClippingContextBufferForMask(null);
        this.gl.viewport(
          s_viewport[0],
          s_viewport[1],
          s_viewport[2],
          s_viewport[3]
        );
      }
    }
  }
  /**
   * 既にマスクを作っているかを確認
   * 作っている様であれば該当するクリッピングマスクのインスタンスを返す
   * 作っていなければNULLを返す
   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト
   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
   * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す
   */
  findSameClip(drawableMasks, drawableMaskCounts) {
    for (let i2 = 0; i2 < this._clippingContextListForMask.length; i2++) {
      const clippingContext = this._clippingContextListForMask[i2];
      const count = clippingContext._clippingIdCount;
      if (count != drawableMaskCounts) {
        continue;
      }
      let sameCount = 0;
      for (let j2 = 0; j2 < count; j2++) {
        const clipId = clippingContext._clippingIdList[j2];
        for (let k2 = 0; k2 < count; k2++) {
          if (drawableMasks[k2] == clipId) {
            sameCount++;
            break;
          }
        }
      }
      if (sameCount == count) {
        return clippingContext;
      }
    }
    return null;
  }
  /**
   * クリッピングコンテキストを配置するレイアウト
   * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする
   * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。
   *
   * @param usingClipCount 配置するクリッピングコンテキストの数
   */
  setupLayoutBounds(usingClipCount) {
    const useClippingMaskMaxCount = this._renderTextureCount <= 1 ? ClippingMaskMaxCountOnDefault : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;
    if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {
      if (usingClipCount > useClippingMaskMaxCount) {
        CubismLogError(
          "not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",
          usingClipCount - useClippingMaskMaxCount,
          this._renderTextureCount,
          usingClipCount
        );
      }
      for (let index = 0; index < this._clippingContextListForMask.length; index++) {
        const clipContext = this._clippingContextListForMask[index];
        clipContext._layoutChannelNo = 0;
        clipContext._layoutBounds.x = 0;
        clipContext._layoutBounds.y = 0;
        clipContext._layoutBounds.width = 1;
        clipContext._layoutBounds.height = 1;
        clipContext._bufferIndex = 0;
      }
      return;
    }
    const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;
    let countPerSheetDiv = usingClipCount / this._renderTextureCount;
    let countPerSheetMod = usingClipCount % this._renderTextureCount;
    countPerSheetDiv = ~~countPerSheetDiv;
    countPerSheetMod = ~~countPerSheetMod;
    let div2 = countPerSheetDiv / ColorChannelCount;
    let mod2 = countPerSheetDiv % ColorChannelCount;
    div2 = ~~div2;
    mod2 = ~~mod2;
    let curClipIndex = 0;
    for (let renderTextureNo = 0; renderTextureNo < this._renderTextureCount; renderTextureNo++) {
      for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {
        let layoutCount = div2 + (channelNo < mod2 ? 1 : 0);
        const checkChannelNo = mod2 + 1 >= ColorChannelCount ? 0 : mod2 + 1;
        if (layoutCount < layoutCountMaxValue && channelNo == checkChannelNo) {
          layoutCount += renderTextureNo < countPerSheetMod ? 1 : 0;
        }
        if (layoutCount == 0)
          ;
        else if (layoutCount == 1) {
          const clipContext = this._clippingContextListForMask[curClipIndex++];
          clipContext._layoutChannelNo = channelNo;
          clipContext._layoutBounds.x = 0;
          clipContext._layoutBounds.y = 0;
          clipContext._layoutBounds.width = 1;
          clipContext._layoutBounds.height = 1;
          clipContext._bufferIndex = renderTextureNo;
        } else if (layoutCount == 2) {
          for (let i2 = 0; i2 < layoutCount; i2++) {
            let xpos = i2 % 2;
            xpos = ~~xpos;
            const cc2 = this._clippingContextListForMask[curClipIndex++];
            cc2._layoutChannelNo = channelNo;
            cc2._layoutBounds.x = xpos * 0.5;
            cc2._layoutBounds.y = 0;
            cc2._layoutBounds.width = 0.5;
            cc2._layoutBounds.height = 1;
            cc2._bufferIndex = renderTextureNo;
          }
        } else if (layoutCount <= 4) {
          for (let i2 = 0; i2 < layoutCount; i2++) {
            let xpos = i2 % 2;
            let ypos = i2 / 2;
            xpos = ~~xpos;
            ypos = ~~ypos;
            const cc2 = this._clippingContextListForMask[curClipIndex++];
            cc2._layoutChannelNo = channelNo;
            cc2._layoutBounds.x = xpos * 0.5;
            cc2._layoutBounds.y = ypos * 0.5;
            cc2._layoutBounds.width = 0.5;
            cc2._layoutBounds.height = 0.5;
            cc2._bufferIndex = renderTextureNo;
          }
        } else if (layoutCount <= layoutCountMaxValue) {
          for (let i2 = 0; i2 < layoutCount; i2++) {
            let xpos = i2 % 3;
            let ypos = i2 / 3;
            xpos = ~~xpos;
            ypos = ~~ypos;
            const cc2 = this._clippingContextListForMask[curClipIndex++];
            cc2._layoutChannelNo = channelNo;
            cc2._layoutBounds.x = xpos / 3;
            cc2._layoutBounds.y = ypos / 3;
            cc2._layoutBounds.width = 1 / 3;
            cc2._layoutBounds.height = 1 / 3;
            cc2._bufferIndex = renderTextureNo;
          }
        } else if (CubismConfig.supportMoreMaskDivisions && layoutCount <= 16) {
          for (let i2 = 0; i2 < layoutCount; i2++) {
            let xpos = i2 % 4;
            let ypos = i2 / 4;
            xpos = ~~xpos;
            ypos = ~~ypos;
            const cc2 = this._clippingContextListForMask[curClipIndex++];
            cc2._layoutChannelNo = channelNo;
            cc2._layoutBounds.x = xpos / 4;
            cc2._layoutBounds.y = ypos / 4;
            cc2._layoutBounds.width = 1 / 4;
            cc2._layoutBounds.height = 1 / 4;
            cc2._bufferIndex = renderTextureNo;
          }
        } else {
          CubismLogError(
            "not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",
            usingClipCount - useClippingMaskMaxCount,
            this._renderTextureCount,
            usingClipCount
          );
          for (let index = 0; index < layoutCount; index++) {
            const cc2 = this._clippingContextListForMask[curClipIndex++];
            cc2._layoutChannelNo = 0;
            cc2._layoutBounds.x = 0;
            cc2._layoutBounds.y = 0;
            cc2._layoutBounds.width = 1;
            cc2._layoutBounds.height = 1;
            cc2._bufferIndex = 0;
          }
        }
      }
    }
  }
  /**
   * カラーバッファを取得する
   * @return カラーバッファ
   */
  getColorBuffer() {
    return this._maskColorBuffers;
  }
  /**
   * 画面描画に使用するクリッピングマスクのリストを取得する
   * @return 画面描画に使用するクリッピングマスクのリスト
   */
  getClippingContextListForDraw() {
    return this._clippingContextListForDraw;
  }
  /**
   * マスクの合計数をカウント
   * @returns
   */
  getClippingMaskCount() {
    return this._clippingContextListForMask.length;
  }
  /**
   * クリッピングマスクバッファのサイズを設定する
   * @param size クリッピングマスクバッファのサイズ
   */
  setClippingMaskBufferSize(size2) {
    this._clippingMaskBufferSize = size2;
  }
  /**
   * クリッピングマスクバッファのサイズを取得する
   * @return クリッピングマスクバッファのサイズ
   */
  getClippingMaskBufferSize() {
    return this._clippingMaskBufferSize;
  }
  /**
   * このバッファのレンダーテクスチャの枚数を取得する
   * @return このバッファのレンダーテクスチャの枚数
   */
  getRenderTextureCount() {
    return this._renderTextureCount;
  }
  // WebGLレンダリングコンテキスト
}
class CubismRenderTextureResource {
  /**
   * 引数付きコンストラクタ
   * @param frameNo レンダラーのフレーム番号
   * @param texture テクスチャのアドレス
   */
  constructor(frameNo, texture) {
    this.frameNo = frameNo;
    this.textures = texture;
  }
  // テクスチャのアドレス
}
class CubismClippingContext {
  /**
   * 引数付きコンストラクタ
   */
  constructor(manager, clippingDrawableIndices, clipCount) {
    this._isUsing = false;
    this._owner = manager;
    this._clippingIdList = clippingDrawableIndices;
    this._clippingIdCount = clipCount;
    this._allClippedDrawRect = new csmRect();
    this._layoutBounds = new csmRect();
    this._clippedDrawableIndexList = [];
    this._matrixForMask = new CubismMatrix44();
    this._matrixForDraw = new CubismMatrix44();
    this._bufferIndex = 0;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    const self2 = this;
    self2._layoutBounds = void 0;
    self2._allClippedDrawRect = void 0;
    self2._clippedDrawableIndexList = void 0;
  }
  /**
   * このマスクにクリップされる描画オブジェクトを追加する
   *
   * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス
   */
  addClippedDrawable(drawableIndex) {
    this._clippedDrawableIndexList.push(drawableIndex);
  }
  /**
   * このマスクを管理するマネージャのインスタンスを取得する
   * @return クリッピングマネージャのインスタンス
   */
  getClippingManager() {
    return this._owner;
  }
  setGl(gl2) {
    this._owner.setGL(gl2);
  }
  // このマスクを管理しているマネージャのインスタンス
}
class CubismRendererProfile_WebGL {
  setGlEnable(index, enabled) {
    if (enabled)
      this.gl.enable(index);
    else
      this.gl.disable(index);
  }
  setGlEnableVertexAttribArray(index, enabled) {
    if (enabled)
      this.gl.enableVertexAttribArray(index);
    else
      this.gl.disableVertexAttribArray(index);
  }
  save() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    this._lastArrayBufferBinding = this.gl.getParameter(
      this.gl.ARRAY_BUFFER_BINDING
    );
    this._lastArrayBufferBinding = this.gl.getParameter(
      this.gl.ELEMENT_ARRAY_BUFFER_BINDING
    );
    this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);
    this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);
    this.gl.activeTexture(this.gl.TEXTURE1);
    this._lastTexture1Binding2D = this.gl.getParameter(
      this.gl.TEXTURE_BINDING_2D
    );
    this.gl.activeTexture(this.gl.TEXTURE0);
    this._lastTexture0Binding2D = this.gl.getParameter(
      this.gl.TEXTURE_BINDING_2D
    );
    this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(
      0,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(
      1,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(
      2,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(
      3,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);
    this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);
    this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);
    this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);
    this._lastBlend = this.gl.isEnabled(this.gl.BLEND);
    this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);
    this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);
    this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);
    this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);
    this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);
    this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);
    this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
    this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);
  }
  restore() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    this.gl.useProgram(this._lastProgram);
    this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);
    this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);
    this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);
    this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);
    this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);
    this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);
    this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);
    this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);
    this.setGlEnable(this.gl.BLEND, this._lastBlend);
    this.gl.frontFace(this._lastFrontFace);
    this.gl.colorMask(
      this._lastColorMask[0],
      this._lastColorMask[1],
      this._lastColorMask[2],
      this._lastColorMask[3]
    );
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding);
    this.gl.bindBuffer(
      this.gl.ELEMENT_ARRAY_BUFFER,
      this._lastElementArrayBufferBinding
    );
    this.gl.activeTexture(this.gl.TEXTURE1);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);
    this.gl.activeTexture(this._lastActiveTexture);
    this.gl.blendFuncSeparate(
      this._lastBlending[0],
      this._lastBlending[1],
      this._lastBlending[2],
      this._lastBlending[3]
    );
  }
  setGl(gl2) {
    this.gl = gl2;
  }
  constructor() {
    this._lastVertexAttribArrayEnabled = new Array(4);
    this._lastColorMask = new Array(4);
    this._lastBlending = new Array(4);
    this._lastViewport = new Array(4);
  }
}
class CubismShader_WebGL {
  /**
   * インスタンスを取得する（シングルトン）
   * @return インスタンス
   */
  static getInstance() {
    if (s_instance == null) {
      s_instance = new CubismShader_WebGL();
      return s_instance;
    }
    return s_instance;
  }
  /**
   * インスタンスを開放する（シングルトン）
   */
  static deleteInstance() {
    if (s_instance) {
      s_instance.release();
      s_instance = void 0;
    }
  }
  /**
   * privateなコンストラクタ
   */
  constructor() {
    this._shaderSets = [];
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this.releaseShaderProgram();
  }
  /**
   * シェーダープログラムの一連のセットアップを実行する
   * @param renderer レンダラのインスタンス
   * @param textureId GPUのテクスチャID
   * @param vertexCount ポリゴンメッシュの頂点数
   * @param vertexArray ポリゴンメッシュの頂点配列
   * @param indexArray インデックスバッファの頂点配列
   * @param uvArray uv配列
   * @param opacity 不透明度
   * @param colorBlendMode カラーブレンディングのタイプ
   * @param baseColor ベースカラー
   * @param isPremultipliedAlpha 乗算済みアルファかどうか
   * @param matrix4x4 Model-View-Projection行列
   * @param invertedMask マスクを反転して使用するフラグ
   */
  setupShaderProgram(renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, multiplyColor, screenColor, isPremultipliedAlpha, matrix4x4, invertedMask) {
    if (!isPremultipliedAlpha) {
      CubismLogError("NoPremultipliedAlpha is not allowed");
    }
    if (this._shaderSets.length == 0) {
      this.generateShaders();
    }
    let SRC_COLOR;
    let DST_COLOR;
    let SRC_ALPHA;
    let DST_ALPHA;
    const clippingContextBufferForMask = renderer.getClippingContextBufferForMask();
    if (clippingContextBufferForMask != null) {
      const shaderSet = this._shaderSets[
        0
        /* ShaderNames_SetupMask */
      ];
      this.gl.useProgram(shaderSet.shaderProgram);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      if (bufferData.vertex == null) {
        bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        vertexArray,
        this.gl.DYNAMIC_DRAW
      );
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(
        shaderSet.attributePositionLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0
      );
      if (bufferData.uv == null) {
        bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(
        shaderSet.attributeTexCoordLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0
      );
      const channelNo = clippingContextBufferForMask._layoutChannelNo;
      const colorChannel = clippingContextBufferForMask.getClippingManager().getChannelFlagAsColor(channelNo);
      this.gl.uniform4f(
        shaderSet.uniformChannelFlagLocation,
        colorChannel.R,
        colorChannel.G,
        colorChannel.B,
        colorChannel.A
      );
      this.gl.uniformMatrix4fv(
        shaderSet.uniformClipMatrixLocation,
        false,
        clippingContextBufferForMask._matrixForMask.getArray()
      );
      const rect = clippingContextBufferForMask._layoutBounds;
      this.gl.uniform4f(
        shaderSet.uniformBaseColorLocation,
        rect.x * 2 - 1,
        rect.y * 2 - 1,
        rect.getRight() * 2 - 1,
        rect.getBottom() * 2 - 1
      );
      this.gl.uniform4f(
        shaderSet.uniformMultiplyColorLocation,
        multiplyColor.R,
        multiplyColor.G,
        multiplyColor.B,
        multiplyColor.A
      );
      this.gl.uniform4f(
        shaderSet.uniformScreenColorLocation,
        screenColor.R,
        screenColor.G,
        screenColor.B,
        screenColor.A
      );
      SRC_COLOR = this.gl.ZERO;
      DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;
      SRC_ALPHA = this.gl.ZERO;
      DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;
    } else {
      const clippingContextBufferForDraw = renderer.getClippingContextBufferForDraw();
      const masked = clippingContextBufferForDraw != null;
      const offset2 = masked ? invertedMask ? 2 : 1 : 0;
      let shaderSet;
      switch (colorBlendMode) {
        case CubismBlendMode.CubismBlendMode_Normal:
        default:
          shaderSet = this._shaderSets[1 + offset2];
          SRC_COLOR = this.gl.ONE;
          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;
          SRC_ALPHA = this.gl.ONE;
          DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;
          break;
        case CubismBlendMode.CubismBlendMode_Additive:
          shaderSet = this._shaderSets[4 + offset2];
          SRC_COLOR = this.gl.ONE;
          DST_COLOR = this.gl.ONE;
          SRC_ALPHA = this.gl.ZERO;
          DST_ALPHA = this.gl.ONE;
          break;
        case CubismBlendMode.CubismBlendMode_Multiplicative:
          shaderSet = this._shaderSets[7 + offset2];
          SRC_COLOR = this.gl.DST_COLOR;
          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;
          SRC_ALPHA = this.gl.ZERO;
          DST_ALPHA = this.gl.ONE;
          break;
      }
      this.gl.useProgram(shaderSet.shaderProgram);
      if (bufferData.vertex == null) {
        bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        vertexArray,
        this.gl.DYNAMIC_DRAW
      );
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(
        shaderSet.attributePositionLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0
      );
      if (bufferData.uv == null) {
        bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(
        shaderSet.attributeTexCoordLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0
      );
      if (clippingContextBufferForDraw != null) {
        this.gl.activeTexture(this.gl.TEXTURE1);
        const tex = clippingContextBufferForDraw.getClippingManager().getColorBuffer()[renderer.getClippingContextBufferForDraw()._bufferIndex];
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);
        this.gl.uniformMatrix4fv(
          shaderSet.uniformClipMatrixLocation,
          false,
          clippingContextBufferForDraw._matrixForDraw.getArray()
        );
        const channelNo = clippingContextBufferForDraw._layoutChannelNo;
        const colorChannel = clippingContextBufferForDraw.getClippingManager().getChannelFlagAsColor(channelNo);
        this.gl.uniform4f(
          shaderSet.uniformChannelFlagLocation,
          colorChannel.R,
          colorChannel.G,
          colorChannel.B,
          colorChannel.A
        );
      }
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      this.gl.uniformMatrix4fv(
        shaderSet.uniformMatrixLocation,
        false,
        matrix4x4.getArray()
      );
      this.gl.uniform4f(
        shaderSet.uniformBaseColorLocation,
        baseColor.R,
        baseColor.G,
        baseColor.B,
        baseColor.A
      );
      this.gl.uniform4f(
        shaderSet.uniformMultiplyColorLocation,
        multiplyColor.R,
        multiplyColor.G,
        multiplyColor.B,
        multiplyColor.A
      );
      this.gl.uniform4f(
        shaderSet.uniformScreenColorLocation,
        screenColor.R,
        screenColor.G,
        screenColor.B,
        screenColor.A
      );
    }
    if (bufferData.index == null) {
      bufferData.index = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);
    this.gl.bufferData(
      this.gl.ELEMENT_ARRAY_BUFFER,
      indexArray,
      this.gl.DYNAMIC_DRAW
    );
    this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);
  }
  /**
   * シェーダープログラムを解放する
   */
  releaseShaderProgram() {
    for (let i2 = 0; i2 < this._shaderSets.length; i2++) {
      this.gl.deleteProgram(this._shaderSets[i2].shaderProgram);
      this._shaderSets[i2].shaderProgram = 0;
    }
    this._shaderSets = [];
  }
  /**
   * シェーダープログラムを初期化する
   * @param vertShaderSrc 頂点シェーダのソース
   * @param fragShaderSrc フラグメントシェーダのソース
   */
  generateShaders() {
    for (let i2 = 0; i2 < ShaderCount; i2++) {
      this._shaderSets.push({});
    }
    this._shaderSets[0].shaderProgram = this.loadShaderProgram(
      vertexShaderSrcSetupMask,
      fragmentShaderSrcsetupMask
    );
    this._shaderSets[1].shaderProgram = this.loadShaderProgram(
      vertexShaderSrc,
      fragmentShaderSrcPremultipliedAlpha
    );
    this._shaderSets[2].shaderProgram = this.loadShaderProgram(
      vertexShaderSrcMasked,
      fragmentShaderSrcMaskPremultipliedAlpha
    );
    this._shaderSets[3].shaderProgram = this.loadShaderProgram(
      vertexShaderSrcMasked,
      fragmentShaderSrcMaskInvertedPremultipliedAlpha
    );
    this._shaderSets[4].shaderProgram = this._shaderSets[1].shaderProgram;
    this._shaderSets[5].shaderProgram = this._shaderSets[2].shaderProgram;
    this._shaderSets[6].shaderProgram = this._shaderSets[3].shaderProgram;
    this._shaderSets[7].shaderProgram = this._shaderSets[1].shaderProgram;
    this._shaderSets[8].shaderProgram = this._shaderSets[2].shaderProgram;
    this._shaderSets[9].shaderProgram = this._shaderSets[3].shaderProgram;
    this._shaderSets[0].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[0].shaderProgram,
      "a_position"
    );
    this._shaderSets[0].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[0].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[0].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[0].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[0].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[0].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[0].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[0].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[0].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[1].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[1].shaderProgram,
      "a_position"
    );
    this._shaderSets[1].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[1].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[1].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[1].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[1].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[1].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[1].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[1].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[1].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[1].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[1].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[1].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[2].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[2].shaderProgram,
      "a_position"
    );
    this._shaderSets[2].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[2].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[2].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[2].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[2].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[2].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[2].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[2].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[2].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[2].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[2].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[3].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[3].shaderProgram,
      "a_position"
    );
    this._shaderSets[3].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[3].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[3].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[3].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[3].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[3].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[3].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[3].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[3].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[3].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[3].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[4].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[4].shaderProgram,
      "a_position"
    );
    this._shaderSets[4].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[4].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[4].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[4].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[4].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[4].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[4].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[4].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[4].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[4].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[4].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[4].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[5].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[5].shaderProgram,
      "a_position"
    );
    this._shaderSets[5].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[5].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[5].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[5].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[5].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[5].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[5].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[5].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[5].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[5].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[5].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[6].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[6].shaderProgram,
      "a_position"
    );
    this._shaderSets[6].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[6].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[6].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[6].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[6].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[6].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[6].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[6].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[6].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[6].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[6].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[7].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[7].shaderProgram,
      "a_position"
    );
    this._shaderSets[7].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[7].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[7].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[7].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[7].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[7].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[7].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[7].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[7].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[7].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[7].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[7].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[8].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[8].shaderProgram,
      "a_position"
    );
    this._shaderSets[8].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[8].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[8].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[8].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[8].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[8].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[8].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[8].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[8].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[8].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[8].shaderProgram,
      "u_screenColor"
    );
    this._shaderSets[9].attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets[9].shaderProgram,
      "a_position"
    );
    this._shaderSets[9].attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets[9].shaderProgram,
      "a_texCoord"
    );
    this._shaderSets[9].samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "s_texture0"
    );
    this._shaderSets[9].samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "s_texture1"
    );
    this._shaderSets[9].uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_matrix"
    );
    this._shaderSets[9].uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets[9].uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets[9].uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_baseColor"
    );
    this._shaderSets[9].uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets[9].uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets[9].shaderProgram,
      "u_screenColor"
    );
  }
  /**
   * シェーダプログラムをロードしてアドレスを返す
   * @param vertexShaderSource    頂点シェーダのソース
   * @param fragmentShaderSource  フラグメントシェーダのソース
   * @return シェーダプログラムのアドレス
   */
  loadShaderProgram(vertexShaderSource, fragmentShaderSource) {
    const shaderProgram = this.gl.createProgram();
    const vertShader = this.compileShaderSource(
      this.gl.VERTEX_SHADER,
      vertexShaderSource
    );
    if (!vertShader) {
      CubismLogError("Vertex shader compile error!");
      return 0;
    }
    const fragShader = this.compileShaderSource(
      this.gl.FRAGMENT_SHADER,
      fragmentShaderSource
    );
    if (!fragShader) {
      CubismLogError("Vertex shader compile error!");
      return 0;
    }
    this.gl.attachShader(shaderProgram, vertShader);
    this.gl.attachShader(shaderProgram, fragShader);
    this.gl.linkProgram(shaderProgram);
    const linkStatus = this.gl.getProgramParameter(
      shaderProgram,
      this.gl.LINK_STATUS
    );
    if (!linkStatus) {
      CubismLogError("Failed to link program: {0}", shaderProgram);
      this.gl.deleteShader(vertShader);
      this.gl.deleteShader(fragShader);
      if (shaderProgram) {
        this.gl.deleteProgram(shaderProgram);
      }
      return 0;
    }
    this.gl.deleteShader(vertShader);
    this.gl.deleteShader(fragShader);
    return shaderProgram;
  }
  /**
   * シェーダープログラムをコンパイルする
   * @param shaderType シェーダタイプ(Vertex/Fragment)
   * @param shaderSource シェーダソースコード
   *
   * @return コンパイルされたシェーダープログラム
   */
  compileShaderSource(shaderType, shaderSource) {
    const source = shaderSource;
    const shader = this.gl.createShader(shaderType);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!shader) {
      const log3 = this.gl.getShaderInfoLog(shader);
      CubismLogError("Shader compile log: {0} ", log3);
    }
    const status = this.gl.getShaderParameter(
      shader,
      this.gl.COMPILE_STATUS
    );
    if (!status) {
      this.gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  setGl(gl2) {
    this.gl = gl2;
  }
  // webglコンテキスト
}
const vertexShaderSrcSetupMask = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const fragmentShaderSrcsetupMask = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}";
const vertexShaderSrc = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const vertexShaderSrcMasked = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const fragmentShaderSrcPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 color = texColor * u_baseColor;   gl_FragColor = vec4(color.rgb, color.a);}";
const fragmentShaderSrcMaskPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}";
const fragmentShaderSrcMaskInvertedPremultipliedAlpha = "precision mediump float;varying vec2      v_texCoord;varying vec4      v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4      u_channelFlag;uniform vec4      u_baseColor;uniform vec4      u_multiplyColor;uniform vec4      u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * (1.0 - maskVal);   gl_FragColor = col_formask;}";
class CubismRenderer_WebGL extends CubismRenderer {
  /**
   * レンダラの初期化処理を実行する
   * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
   *
   * @param model モデルのインスタンス
   * @param maskBufferCount バッファの生成数
   */
  initialize(model, maskBufferCount = 1) {
    if (model.isUsingMasking()) {
      this._clippingManager = new CubismClippingManager_WebGL();
      this._clippingManager.initialize(
        model,
        model.getDrawableCount(),
        model.getDrawableMasks(),
        model.getDrawableMaskCounts(),
        maskBufferCount
      );
    }
    for (let i2 = model.getDrawableCount() - 1; i2 >= 0; i2--) {
      this._sortedDrawableIndexList[i2] = 0;
    }
    super.initialize(model);
  }
  /**
   * WebGLテクスチャのバインド処理
   * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする
   * @param modelTextureNo セットするモデルテクスチャの番号
   * @param glTextureNo WebGLテクスチャの番号
   */
  bindTexture(modelTextureNo, glTexture) {
    this._textures[modelTextureNo] = glTexture;
  }
  /**
   * WebGLにバインドされたテクスチャのリストを取得する
   * @return テクスチャのリスト
   */
  getBindedTextures() {
    return this._textures;
  }
  /**
   * クリッピングマスクバッファのサイズを設定する
   * マスク用のFrameBufferを破棄、再作成する為処理コストは高い
   * @param size クリッピングマスクバッファのサイズ
   */
  setClippingMaskBufferSize(size2) {
    if (!this._model.isUsingMasking()) {
      return;
    }
    const renderTextureCount = this._clippingManager.getRenderTextureCount();
    this._clippingManager.release();
    this._clippingManager = new CubismClippingManager_WebGL();
    this._clippingManager.setClippingMaskBufferSize(size2);
    this._clippingManager.initialize(
      this.getModel(),
      this.getModel().getDrawableCount(),
      this.getModel().getDrawableMasks(),
      this.getModel().getDrawableMaskCounts(),
      renderTextureCount
      // インスタンス破棄前に保存したレンダーテクスチャの数
    );
  }
  /**
   * クリッピングマスクバッファのサイズを取得する
   * @return クリッピングマスクバッファのサイズ
   */
  getClippingMaskBufferSize() {
    return this._model.isUsingMasking() ? this._clippingManager.getClippingMaskBufferSize() : -1;
  }
  /**
   * レンダーテクスチャの枚数を取得する
   * @return レンダーテクスチャの枚数
   */
  getRenderTextureCount() {
    return this._model.isUsingMasking() ? this._clippingManager.getRenderTextureCount() : -1;
  }
  /**
   * コンストラクタ
   */
  constructor() {
    super();
    this._clippingContextBufferForMask = null;
    this._clippingContextBufferForDraw = null;
    this._rendererProfile = new CubismRendererProfile_WebGL();
    this.firstDraw = true;
    this._textures = {};
    this._sortedDrawableIndexList = [];
    this._bufferData = {
      vertex: null,
      uv: null,
      index: null
    };
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    var _a2, _b, _c;
    const self2 = this;
    this._clippingManager.release();
    self2._clippingManager = void 0;
    (_a2 = this.gl) == null ? void 0 : _a2.deleteBuffer(this._bufferData.vertex);
    this._bufferData.vertex = null;
    (_b = this.gl) == null ? void 0 : _b.deleteBuffer(this._bufferData.uv);
    this._bufferData.uv = null;
    (_c = this.gl) == null ? void 0 : _c.deleteBuffer(this._bufferData.index);
    this._bufferData.index = null;
    self2._bufferData = void 0;
    self2._textures = void 0;
  }
  /**
   * モデルを描画する実際の処理
   */
  doDrawModel() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    if (this._clippingManager != null) {
      this.preDraw();
      this._clippingManager.setupClippingContext(this.getModel(), this);
    }
    this.preDraw();
    const drawableCount = this.getModel().getDrawableCount();
    const renderOrder = this.getModel().getDrawableRenderOrders();
    for (let i2 = 0; i2 < drawableCount; ++i2) {
      const order = renderOrder[i2];
      this._sortedDrawableIndexList[order] = i2;
    }
    for (let i2 = 0; i2 < drawableCount; ++i2) {
      const drawableIndex = this._sortedDrawableIndexList[i2];
      if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {
        continue;
      }
      const clipContext = this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw()[drawableIndex] : null;
      if (clipContext != null && this.isUsingHighPrecisionMask()) {
        if (clipContext._isUsing) {
          this.gl.viewport(
            0,
            0,
            this._clippingManager.getClippingMaskBufferSize(),
            this._clippingManager.getClippingMaskBufferSize()
          );
          this.preDraw();
          this.gl.bindFramebuffer(
            this.gl.FRAMEBUFFER,
            clipContext.getClippingManager().getMaskRenderTexture()[clipContext._bufferIndex]
          );
          this.gl.clearColor(1, 1, 1, 1);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
        {
          const clipDrawCount = clipContext._clippingIdCount;
          for (let index = 0; index < clipDrawCount; index++) {
            const clipDrawIndex = clipContext._clippingIdList[index];
            if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(
              clipDrawIndex
            )) {
              continue;
            }
            this.setIsCulling(
              this._model.getDrawableCulling(clipDrawIndex) != false
            );
            this.setClippingContextBufferForMask(clipContext);
            this.drawMesh(
              this.getModel().getDrawableTextureIndex(clipDrawIndex),
              this.getModel().getDrawableVertexIndexCount(clipDrawIndex),
              this.getModel().getDrawableVertexCount(clipDrawIndex),
              this.getModel().getDrawableVertexIndices(clipDrawIndex),
              this.getModel().getDrawableVertices(clipDrawIndex),
              this.getModel().getDrawableVertexUvs(clipDrawIndex),
              this.getModel().getMultiplyColor(clipDrawIndex),
              this.getModel().getScreenColor(clipDrawIndex),
              this.getModel().getDrawableOpacity(clipDrawIndex),
              CubismBlendMode.CubismBlendMode_Normal,
              // クリッピングは通常描画を強制
              false
              // マスク生成時はクリッピングの反転使用は全く関係がない
            );
          }
        }
        {
          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
          this.setClippingContextBufferForMask(null);
          this.gl.viewport(
            s_viewport[0],
            s_viewport[1],
            s_viewport[2],
            s_viewport[3]
          );
          this.preDraw();
        }
      }
      this.setClippingContextBufferForDraw(clipContext);
      this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));
      this.drawMesh(
        this.getModel().getDrawableTextureIndex(drawableIndex),
        this.getModel().getDrawableVertexIndexCount(drawableIndex),
        this.getModel().getDrawableVertexCount(drawableIndex),
        this.getModel().getDrawableVertexIndices(drawableIndex),
        this.getModel().getDrawableVertices(drawableIndex),
        this.getModel().getDrawableVertexUvs(drawableIndex),
        this.getModel().getMultiplyColor(drawableIndex),
        this.getModel().getScreenColor(drawableIndex),
        this.getModel().getDrawableOpacity(drawableIndex),
        this.getModel().getDrawableBlendMode(drawableIndex),
        this.getModel().getDrawableInvertedMaskBit(drawableIndex)
      );
    }
  }
  /**
   * [オーバーライド]
   * 描画オブジェクト（アートメッシュ）を描画する。
   * ポリゴンメッシュとテクスチャ番号をセットで渡す。
   * @param textureNo 描画するテクスチャ番号
   * @param indexCount 描画オブジェクトのインデックス値
   * @param vertexCount ポリゴンメッシュの頂点数
   * @param indexArray ポリゴンメッシュのインデックス配列
   * @param vertexArray ポリゴンメッシュの頂点配列
   * @param uvArray uv配列
   * @param opacity 不透明度
   * @param colorBlendMode カラー合成タイプ
   * @param invertedMask マスク使用時のマスクの反転使用
   */
  drawMesh(textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, multiplyColor, screenColor, opacity, colorBlendMode, invertedMask) {
    if (this.isCulling()) {
      this.gl.enable(this.gl.CULL_FACE);
    } else {
      this.gl.disable(this.gl.CULL_FACE);
    }
    this.gl.frontFace(this.gl.CCW);
    const modelColorRGBA = this.getModelColor();
    if (this.getClippingContextBufferForMask() == null) {
      modelColorRGBA.A *= opacity;
      if (this.isPremultipliedAlpha()) {
        modelColorRGBA.R *= modelColorRGBA.A;
        modelColorRGBA.G *= modelColorRGBA.A;
        modelColorRGBA.B *= modelColorRGBA.A;
      }
    }
    let drawtexture = null;
    if (this._textures[textureNo] != null) {
      drawtexture = this._textures[textureNo];
    }
    CubismShader_WebGL.getInstance().setupShaderProgram(
      this,
      drawtexture,
      vertexCount,
      vertexArray,
      indexArray,
      uvArray,
      this._bufferData,
      opacity,
      colorBlendMode,
      modelColorRGBA,
      multiplyColor,
      screenColor,
      this.isPremultipliedAlpha(),
      this.getMvpMatrix(),
      invertedMask
    );
    this.gl.drawElements(
      this.gl.TRIANGLES,
      indexCount,
      this.gl.UNSIGNED_SHORT,
      0
    );
    this.gl.useProgram(null);
    this.setClippingContextBufferForDraw(null);
    this.setClippingContextBufferForMask(null);
  }
  saveProfile() {
    this._rendererProfile.save();
  }
  restoreProfile() {
    this._rendererProfile.restore();
  }
  /**
   * レンダラが保持する静的なリソースを解放する
   * WebGLの静的なシェーダープログラムを解放する
   */
  static doStaticRelease() {
    CubismShader_WebGL.deleteInstance();
  }
  /**
   * レンダーステートを設定する
   * @param fbo アプリケーション側で指定しているフレームバッファ
   * @param viewport ビューポート
   */
  setRenderState(fbo, viewport) {
    s_fbo = fbo;
    s_viewport = viewport;
  }
  /**
   * 描画開始時の追加処理
   * モデルを描画する前にクリッピングマスクに必要な処理を実装している
   */
  preDraw() {
    if (this.firstDraw) {
      this.firstDraw = false;
    }
    this.gl.disable(this.gl.SCISSOR_TEST);
    this.gl.disable(this.gl.STENCIL_TEST);
    this.gl.disable(this.gl.DEPTH_TEST);
    this.gl.frontFace(this.gl.CW);
    this.gl.enable(this.gl.BLEND);
    this.gl.colorMask(true, true, true, true);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
    if (this.getAnisotropy() > 0 && this._extension) {
      for (const tex of Object.entries(this._textures)) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameterf(
          this.gl.TEXTURE_2D,
          this._extension.TEXTURE_MAX_ANISOTROPY_EXT,
          this.getAnisotropy()
        );
      }
    }
  }
  /**
   * マスクテクスチャに描画するクリッピングコンテキストをセットする
   */
  setClippingContextBufferForMask(clip) {
    this._clippingContextBufferForMask = clip;
  }
  /**
   * マスクテクスチャに描画するクリッピングコンテキストを取得する
   * @return マスクテクスチャに描画するクリッピングコンテキスト
   */
  getClippingContextBufferForMask() {
    return this._clippingContextBufferForMask;
  }
  /**
   * 画面上に描画するクリッピングコンテキストをセットする
   */
  setClippingContextBufferForDraw(clip) {
    this._clippingContextBufferForDraw = clip;
  }
  /**
   * 画面上に描画するクリッピングコンテキストを取得する
   * @return 画面上に描画するクリッピングコンテキスト
   */
  getClippingContextBufferForDraw() {
    return this._clippingContextBufferForDraw;
  }
  /**
   * glの設定
   */
  startUp(gl2) {
    this.gl = gl2;
    if (this._clippingManager) {
      this._clippingManager.setGL(gl2);
    }
    CubismShader_WebGL.getInstance().setGl(gl2);
    this._rendererProfile.setGl(gl2);
    this._extension = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
  }
  // webglコンテキスト
}
CubismRenderer.staticRelease = () => {
  CubismRenderer_WebGL.doStaticRelease();
};
const tempMatrix = new CubismMatrix44();
class Cubism4InternalModel extends InternalModel {
  constructor(coreModel, settings2, options) {
    super();
    __publicField(this, "settings");
    __publicField(this, "coreModel");
    __publicField(this, "motionManager");
    __publicField(this, "lipSync", true);
    __publicField(this, "breath", CubismBreath.create());
    __publicField(this, "eyeBlink");
    __publicField(this, "userData");
    __publicField(this, "renderer", new CubismRenderer_WebGL());
    __publicField(this, "idParamAngleX", ParamAngleX);
    __publicField(this, "idParamAngleY", ParamAngleY);
    __publicField(this, "idParamAngleZ", ParamAngleZ);
    __publicField(this, "idParamEyeBallX", ParamEyeBallX);
    __publicField(this, "idParamEyeBallY", ParamEyeBallY);
    __publicField(this, "idParamBodyAngleX", ParamBodyAngleX);
    __publicField(this, "idParamBreath", ParamBreath);
    __publicField(this, "idParamMouthForm", ParamMouthForm);
    __publicField(this, "pixelsPerUnit", 1);
    __publicField(this, "centeringTransform", new Matrix());
    this.coreModel = coreModel;
    this.settings = settings2;
    this.motionManager = new Cubism4MotionManager(settings2, options);
    this.init();
  }
  init() {
    var _a2;
    super.init();
    if ((_a2 = this.settings.getEyeBlinkParameters()) == null ? void 0 : _a2.length) {
      this.eyeBlink = CubismEyeBlink.create(this.settings);
    }
    this.breath.setParameters([
      new BreathParameterData(this.idParamAngleX, 0, 15, 6.5345, 0.5),
      new BreathParameterData(this.idParamAngleY, 0, 8, 3.5345, 0.5),
      new BreathParameterData(this.idParamAngleZ, 0, 10, 5.5345, 0.5),
      new BreathParameterData(this.idParamBodyAngleX, 0, 4, 15.5345, 0.5),
      new BreathParameterData(this.idParamBreath, 0, 0.5, 3.2345, 0.5)
    ]);
    this.renderer.initialize(this.coreModel);
    this.renderer.setIsPremultipliedAlpha(true);
  }
  getSize() {
    return [
      this.coreModel.getModel().canvasinfo.CanvasWidth,
      this.coreModel.getModel().canvasinfo.CanvasHeight
    ];
  }
  getLayout() {
    const layout = {};
    if (this.settings.layout) {
      for (const [key, value] of Object.entries(this.settings.layout)) {
        const commonKey = key.charAt(0).toLowerCase() + key.slice(1);
        layout[commonKey] = value;
      }
    }
    return layout;
  }
  setupLayout() {
    super.setupLayout();
    this.pixelsPerUnit = this.coreModel.getModel().canvasinfo.PixelsPerUnit;
    this.centeringTransform.scale(this.pixelsPerUnit, this.pixelsPerUnit).translate(this.originalWidth / 2, this.originalHeight / 2);
  }
  updateWebGLContext(gl2, glContextID) {
    this.renderer.firstDraw = true;
    this.renderer._bufferData = {
      vertex: null,
      uv: null,
      index: null
    };
    this.renderer.startUp(gl2);
    this.renderer._clippingManager._currentFrameNo = glContextID;
    this.renderer._clippingManager._maskTexture = void 0;
    CubismShader_WebGL.getInstance()._shaderSets = [];
  }
  bindTexture(index, texture) {
    this.renderer.bindTexture(index, texture);
  }
  getHitAreaDefs() {
    var _a2, _b;
    return (_b = (_a2 = this.settings.hitAreas) == null ? void 0 : _a2.map((hitArea) => ({
      id: hitArea.Id,
      name: hitArea.Name,
      index: this.coreModel.getDrawableIndex(hitArea.Id)
    }))) != null ? _b : [];
  }
  getDrawableIDs() {
    return this.coreModel.getDrawableIds();
  }
  getDrawableIndex(id2) {
    return this.coreModel.getDrawableIndex(id2);
  }
  getDrawableVertices(drawIndex) {
    if (typeof drawIndex === "string") {
      drawIndex = this.coreModel.getDrawableIndex(drawIndex);
      if (drawIndex === -1)
        throw new TypeError("Unable to find drawable ID: " + drawIndex);
    }
    const arr = this.coreModel.getDrawableVertices(drawIndex).slice();
    for (let i2 = 0; i2 < arr.length; i2 += 2) {
      arr[i2] = arr[i2] * this.pixelsPerUnit + this.originalWidth / 2;
      arr[i2 + 1] = -arr[i2 + 1] * this.pixelsPerUnit + this.originalHeight / 2;
    }
    return arr;
  }
  updateTransform(transform2) {
    this.drawingMatrix.copyFrom(this.centeringTransform).prepend(this.localTransform).prepend(transform2);
  }
  update(dt, now) {
    var _a2, _b, _c, _d;
    super.update(dt, now);
    dt /= 1e3;
    now /= 1e3;
    const model = this.coreModel;
    this.emit("beforeMotionUpdate");
    const motionUpdated = this.motionManager.update(this.coreModel, now);
    this.emit("afterMotionUpdate");
    model.saveParameters();
    (_a2 = this.motionManager.expressionManager) == null ? void 0 : _a2.update(model, now);
    if (!motionUpdated) {
      (_b = this.eyeBlink) == null ? void 0 : _b.updateParameters(model, dt);
    }
    this.updateFocus();
    this.updateNaturalMovements(dt * 1e3, now * 1e3);
    if (this.lipSync && this.motionManager.currentAudio) {
      let value = this.motionManager.mouthSync();
      let min_ = 0;
      const max_ = 1;
      const weight = 1.2;
      if (value > 0) {
        min_ = 0.4;
      }
      value = clamp(value * weight, min_, max_);
      for (let i2 = 0; i2 < this.motionManager.lipSyncIds.length; ++i2) {
        model.addParameterValueById(this.motionManager.lipSyncIds[i2], value, 0.8);
      }
    }
    (_c = this.physics) == null ? void 0 : _c.evaluate(model, dt);
    (_d = this.pose) == null ? void 0 : _d.updateParameters(model, dt);
    this.emit("beforeModelUpdate");
    model.update();
    model.loadParameters();
  }
  updateFocus() {
    this.coreModel.addParameterValueById(this.idParamEyeBallX, this.focusController.x);
    this.coreModel.addParameterValueById(this.idParamEyeBallY, this.focusController.y);
    this.coreModel.addParameterValueById(this.idParamAngleX, this.focusController.x * 30);
    this.coreModel.addParameterValueById(this.idParamAngleY, this.focusController.y * 30);
    this.coreModel.addParameterValueById(
      this.idParamAngleZ,
      this.focusController.x * this.focusController.y * -30
    );
    this.coreModel.addParameterValueById(this.idParamBodyAngleX, this.focusController.x * 10);
  }
  updateFacialEmotion(mouthForm) {
    this.coreModel.addParameterValueById(this.idParamMouthForm, mouthForm);
  }
  updateNaturalMovements(dt, now) {
    var _a2;
    (_a2 = this.breath) == null ? void 0 : _a2.updateParameters(this.coreModel, dt / 1e3);
  }
  draw(gl2) {
    const matrix = this.drawingMatrix;
    const array = tempMatrix.getArray();
    array[0] = matrix.a;
    array[1] = matrix.b;
    array[4] = -matrix.c;
    array[5] = -matrix.d;
    array[12] = matrix.tx;
    array[13] = matrix.ty;
    this.renderer.setMvpMatrix(tempMatrix);
    this.renderer.setRenderState(gl2.getParameter(gl2.FRAMEBUFFER_BINDING), this.viewport);
    this.renderer.drawModel();
  }
  destroy() {
    super.destroy();
    this.renderer.release();
    this.coreModel.release();
    this.renderer = void 0;
    this.coreModel = void 0;
  }
}
class CubismModelSettingsJson {
  constructor(json) {
    this.groups = json.Groups;
    this.hitAreas = json.HitAreas;
    this.layout = json.Layout;
    this.moc = json.FileReferences.Moc;
    this.expressions = json.FileReferences.Expressions;
    this.motions = json.FileReferences.Motions;
    this.textures = json.FileReferences.Textures;
    this.physics = json.FileReferences.Physics;
    this.pose = json.FileReferences.Pose;
  }
  getEyeBlinkParameters() {
    var _a2, _b;
    return (_b = (_a2 = this.groups) == null ? void 0 : _a2.find((group2) => group2.Name === "EyeBlink")) == null ? void 0 : _b.Ids;
  }
  getLipSyncParameters() {
    var _a2, _b;
    return (_b = (_a2 = this.groups) == null ? void 0 : _a2.find((group2) => group2.Name === "LipSync")) == null ? void 0 : _b.Ids;
  }
}
class Cubism4ModelSettings extends ModelSettings {
  constructor(json) {
    super(json);
    __publicField(this, "moc");
    __publicField(this, "textures");
    if (!Cubism4ModelSettings.isValidJSON(json)) {
      throw new TypeError("Invalid JSON.");
    }
    Object.assign(this, new CubismModelSettingsJson(json));
  }
  static isValidJSON(json) {
    var _a2;
    return !!(json == null ? void 0 : json.FileReferences) && typeof json.FileReferences.Moc === "string" && ((_a2 = json.FileReferences.Textures) == null ? void 0 : _a2.length) > 0 && // textures must be an array of strings
    json.FileReferences.Textures.every((item) => typeof item === "string");
  }
  replaceFiles(replace2) {
    super.replaceFiles(replace2);
    if (this.motions) {
      for (const [group2, motions] of Object.entries(this.motions)) {
        for (let i2 = 0; i2 < motions.length; i2++) {
          motions[i2].File = replace2(motions[i2].File, `motions.${group2}[${i2}].File`);
          if (motions[i2].Sound !== void 0) {
            motions[i2].Sound = replace2(
              motions[i2].Sound,
              `motions.${group2}[${i2}].Sound`
            );
          }
        }
      }
    }
    if (this.expressions) {
      for (let i2 = 0; i2 < this.expressions.length; i2++) {
        this.expressions[i2].File = replace2(
          this.expressions[i2].File,
          `expressions[${i2}].File`
        );
      }
    }
  }
}
applyMixins(Cubism4ModelSettings, [CubismModelSettingsJson]);
let startupPromise;
let startupRetries = 20;
function cubism4Ready() {
  if (CubismFramework.isStarted()) {
    return Promise.resolve();
  }
  startupPromise != null ? startupPromise : startupPromise = new Promise((resolve2, reject2) => {
    function startUpWithRetry() {
      try {
        startUpCubism4();
        resolve2();
      } catch (e2) {
        startupRetries--;
        if (startupRetries < 0) {
          const err = new Error("Failed to start up Cubism 4 framework.");
          err.cause = e2;
          reject2(err);
          return;
        }
        setTimeout(startUpWithRetry, 10);
      }
    }
    startUpWithRetry();
  });
  return startupPromise;
}
function startUpCubism4(options) {
  options = Object.assign(
    {
      logFunction: console.log,
      loggingLevel: LogLevel.LogLevel_Verbose
    },
    options
  );
  CubismFramework.startUp(options);
  CubismFramework.initialize();
}
const Epsilon = 1e-3;
const DefaultFadeInSeconds = 0.5;
class CubismPose {
  /**
   * インスタンスの作成
   * @param pose3json pose3.jsonのデータ
   * @return 作成されたインスタンス
   */
  static create(pose3json) {
    const ret = new CubismPose();
    if (typeof pose3json.FadeInTime === "number") {
      ret._fadeTimeSeconds = pose3json.FadeInTime;
      if (ret._fadeTimeSeconds <= 0) {
        ret._fadeTimeSeconds = DefaultFadeInSeconds;
      }
    }
    const poseListInfo = pose3json.Groups;
    const poseCount = poseListInfo.length;
    for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {
      const idListInfo = poseListInfo[poseIndex];
      const idCount = idListInfo.length;
      let groupCount = 0;
      for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {
        const partInfo = idListInfo[groupIndex];
        const partData = new PartData();
        partData.partId = partInfo.Id;
        const linkListInfo = partInfo.Link;
        if (linkListInfo) {
          const linkCount = linkListInfo.length;
          for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {
            const linkPart = new PartData();
            linkPart.partId = linkListInfo[linkIndex];
            partData.link.push(linkPart);
          }
        }
        ret._partGroups.push(partData);
        ++groupCount;
      }
      ret._partGroupCounts.push(groupCount);
    }
    return ret;
  }
  /**
   * モデルのパラメータの更新
   * @param model 対象のモデル
   * @param deltaTimeSeconds デルタ時間[秒]
   */
  updateParameters(model, deltaTimeSeconds) {
    if (model != this._lastModel) {
      this.reset(model);
    }
    this._lastModel = model;
    if (deltaTimeSeconds < 0) {
      deltaTimeSeconds = 0;
    }
    let beginIndex = 0;
    for (let i2 = 0; i2 < this._partGroupCounts.length; i2++) {
      const partGroupCount = this._partGroupCounts[i2];
      this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);
      beginIndex += partGroupCount;
    }
    this.copyPartOpacities(model);
  }
  /**
   * 表示を初期化
   * @param model 対象のモデル
   * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する
   */
  reset(model) {
    let beginIndex = 0;
    for (let i2 = 0; i2 < this._partGroupCounts.length; ++i2) {
      const groupCount = this._partGroupCounts[i2];
      for (let j2 = beginIndex; j2 < beginIndex + groupCount; ++j2) {
        this._partGroups[j2].initialize(model);
        const partsIndex = this._partGroups[j2].partIndex;
        const paramIndex = this._partGroups[j2].parameterIndex;
        if (partsIndex < 0) {
          continue;
        }
        model.setPartOpacityByIndex(partsIndex, j2 == beginIndex ? 1 : 0);
        model.setParameterValueByIndex(paramIndex, j2 == beginIndex ? 1 : 0);
        for (let k2 = 0; k2 < this._partGroups[j2].link.length; ++k2) {
          this._partGroups[j2].link[k2].initialize(model);
        }
      }
      beginIndex += groupCount;
    }
  }
  /**
   * パーツの不透明度をコピー
   *
   * @param model 対象のモデル
   */
  copyPartOpacities(model) {
    for (let groupIndex = 0; groupIndex < this._partGroups.length; ++groupIndex) {
      const partData = this._partGroups[groupIndex];
      if (partData.link.length == 0) {
        continue;
      }
      const partIndex = this._partGroups[groupIndex].partIndex;
      const opacity = model.getPartOpacityByIndex(partIndex);
      for (let linkIndex = 0; linkIndex < partData.link.length; ++linkIndex) {
        const linkPart = partData.link[linkIndex];
        const linkPartIndex = linkPart.partIndex;
        if (linkPartIndex < 0) {
          continue;
        }
        model.setPartOpacityByIndex(linkPartIndex, opacity);
      }
    }
  }
  /**
   * パーツのフェード操作を行う。
   * @param model 対象のモデル
   * @param deltaTimeSeconds デルタ時間[秒]
   * @param beginIndex フェード操作を行うパーツグループの先頭インデックス
   * @param partGroupCount フェード操作を行うパーツグループの個数
   */
  doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {
    let visiblePartIndex = -1;
    let newOpacity = 1;
    const phi = 0.5;
    const backOpacityThreshold = 0.15;
    for (let i2 = beginIndex; i2 < beginIndex + partGroupCount; ++i2) {
      const partIndex = this._partGroups[i2].partIndex;
      const paramIndex = this._partGroups[i2].parameterIndex;
      if (model.getParameterValueByIndex(paramIndex) > Epsilon) {
        if (visiblePartIndex >= 0) {
          break;
        }
        visiblePartIndex = i2;
        newOpacity = model.getPartOpacityByIndex(partIndex);
        newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;
        if (newOpacity > 1) {
          newOpacity = 1;
        }
      }
    }
    if (visiblePartIndex < 0) {
      visiblePartIndex = 0;
      newOpacity = 1;
    }
    for (let i2 = beginIndex; i2 < beginIndex + partGroupCount; ++i2) {
      const partsIndex = this._partGroups[i2].partIndex;
      if (visiblePartIndex == i2) {
        model.setPartOpacityByIndex(partsIndex, newOpacity);
      } else {
        let opacity = model.getPartOpacityByIndex(partsIndex);
        let a1;
        if (newOpacity < phi) {
          a1 = newOpacity * (phi - 1) / phi + 1;
        } else {
          a1 = (1 - newOpacity) * phi / (1 - phi);
        }
        const backOpacity = (1 - a1) * (1 - newOpacity);
        if (backOpacity > backOpacityThreshold) {
          a1 = 1 - backOpacityThreshold / (1 - newOpacity);
        }
        if (opacity > a1) {
          opacity = a1;
        }
        model.setPartOpacityByIndex(partsIndex, opacity);
      }
    }
  }
  /**
   * コンストラクタ
   */
  constructor() {
    this._fadeTimeSeconds = DefaultFadeInSeconds;
    this._lastModel = void 0;
    this._partGroups = [];
    this._partGroupCounts = [];
  }
  // 前回操作したモデル
}
class PartData {
  /**
   * コンストラクタ
   */
  constructor(v2) {
    this.parameterIndex = 0;
    this.partIndex = 0;
    this.partId = "";
    this.link = [];
    if (v2 != void 0) {
      this.assignment(v2);
    }
  }
  /**
   * =演算子のオーバーロード
   */
  assignment(v2) {
    this.partId = v2.partId;
    this.link = v2.link.map((link) => link.clone());
    return this;
  }
  /**
   * 初期化
   * @param model 初期化に使用するモデル
   */
  initialize(model) {
    this.parameterIndex = model.getParameterIndex(this.partId);
    this.partIndex = model.getPartIndex(this.partId);
    model.setParameterValueByIndex(this.parameterIndex, 1);
  }
  /**
   * オブジェクトのコピーを生成する
   */
  clone() {
    const clonePartData = new PartData();
    clonePartData.partId = this.partId;
    clonePartData.parameterIndex = this.parameterIndex;
    clonePartData.partIndex = this.partIndex;
    clonePartData.link = this.link.map((link) => link.clone());
    return clonePartData;
  }
  // 連動するパラメータ
}
class DrawableColorData {
  constructor(isOverwritten = false, color = new CubismTextureColor()) {
    this.isOverwritten = isOverwritten;
    this.Color = color;
  }
}
class PartColorData {
  constructor(isOverwritten = false, color = new CubismTextureColor()) {
    this.isOverwritten = isOverwritten;
    this.Color = color;
  }
}
class DrawableCullingData {
  /**
   * コンストラクタ
   *
   * @param isOverwritten
   * @param isCulling
   */
  constructor(isOverwritten = false, isCulling = false) {
    this.isOverwritten = isOverwritten;
    this.isCulling = isCulling;
  }
}
class CubismModel {
  /**
   * モデルのパラメータの更新
   */
  update() {
    this._model.update();
    this._model.drawables.resetDynamicFlags();
  }
  /**
   * PixelsPerUnitを取得する
   * @returns PixelsPerUnit
   */
  getPixelsPerUnit() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * キャンバスの幅を取得する
   */
  getCanvasWidth() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * キャンバスの高さを取得する
   */
  getCanvasHeight() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * パラメータを保存する
   */
  saveParameters() {
    const parameterCount = this._model.parameters.count;
    const savedParameterCount = this._savedParameters.length;
    for (let i2 = 0; i2 < parameterCount; ++i2) {
      if (i2 < savedParameterCount) {
        this._savedParameters[i2] = this._parameterValues[i2];
      } else {
        this._savedParameters.push(this._parameterValues[i2]);
      }
    }
  }
  /**
   * 乗算色を取得する
   * @param index Drawablesのインデックス
   * @returns 指定したdrawableの乗算色(RGBA)
   */
  getMultiplyColor(index) {
    if (this.getOverwriteFlagForModelMultiplyColors() || this.getOverwriteFlagForDrawableMultiplyColors(index)) {
      return this._userMultiplyColors[index].Color;
    }
    const color = this.getDrawableMultiplyColor(index);
    return color;
  }
  /**
   * スクリーン色を取得する
   * @param index Drawablesのインデックス
   * @returns 指定したdrawableのスクリーン色(RGBA)
   */
  getScreenColor(index) {
    if (this.getOverwriteFlagForModelScreenColors() || this.getOverwriteFlagForDrawableScreenColors(index)) {
      return this._userScreenColors[index].Color;
    }
    const color = this.getDrawableScreenColor(index);
    return color;
  }
  /**
   * 乗算色をセットする
   * @param index Drawablesのインデックス
   * @param color 設定する乗算色(CubismTextureColor)
   */
  setMultiplyColorByTextureColor(index, color) {
    this.setMultiplyColorByRGBA(index, color.R, color.G, color.B, color.A);
  }
  /**
   * 乗算色をセットする
   * @param index Drawablesのインデックス
   * @param r 設定する乗算色のR値
   * @param g 設定する乗算色のG値
   * @param b 設定する乗算色のB値
   * @param a 設定する乗算色のA値
   */
  setMultiplyColorByRGBA(index, r2, g2, b2, a2 = 1) {
    this._userMultiplyColors[index].Color.R = r2;
    this._userMultiplyColors[index].Color.G = g2;
    this._userMultiplyColors[index].Color.B = b2;
    this._userMultiplyColors[index].Color.A = a2;
  }
  /**
   * スクリーン色をセットする
   * @param index Drawablesのインデックス
   * @param color 設定するスクリーン色(CubismTextureColor)
   */
  setScreenColorByTextureColor(index, color) {
    this.setScreenColorByRGBA(index, color.R, color.G, color.B, color.A);
  }
  /**
   * スクリーン色をセットする
   * @param index Drawablesのインデックス
   * @param r 設定するスクリーン色のR値
   * @param g 設定するスクリーン色のG値
   * @param b 設定するスクリーン色のB値
   * @param a 設定するスクリーン色のA値
   */
  setScreenColorByRGBA(index, r2, g2, b2, a2 = 1) {
    this._userScreenColors[index].Color.R = r2;
    this._userScreenColors[index].Color.G = g2;
    this._userScreenColors[index].Color.B = b2;
    this._userScreenColors[index].Color.A = a2;
  }
  /**
   * partの乗算色を取得する
   * @param partIndex partのインデックス
   * @returns 指定したpartの乗算色
   */
  getPartMultiplyColor(partIndex) {
    return this._userPartMultiplyColors[partIndex].Color;
  }
  /**
   * partのスクリーン色を取得する
   * @param partIndex partのインデックス
   * @returns 指定したpartのスクリーン色
   */
  getPartScreenColor(partIndex) {
    return this._userPartScreenColors[partIndex].Color;
  }
  /**
   * partのOverwriteColor setter関数
   * @param partIndex partのインデックス
   * @param r 設定する色のR値
   * @param g 設定する色のG値
   * @param b 設定する色のB値
   * @param a 設定する色のA値
   * @param partColors 設定するpartのカラーデータ配列
   * @param drawableColors partに関連するDrawableのカラーデータ配列
   */
  setPartColor(partIndex, r2, g2, b2, a2, partColors, drawableColors) {
    partColors[partIndex].Color.R = r2;
    partColors[partIndex].Color.G = g2;
    partColors[partIndex].Color.B = b2;
    partColors[partIndex].Color.A = a2;
    if (partColors[partIndex].isOverwritten) {
      for (let i2 = 0; i2 < this._partChildDrawables[partIndex].length; ++i2) {
        const drawableIndex = this._partChildDrawables[partIndex][i2];
        drawableColors[drawableIndex].Color.R = r2;
        drawableColors[drawableIndex].Color.G = g2;
        drawableColors[drawableIndex].Color.B = b2;
        drawableColors[drawableIndex].Color.A = a2;
      }
    }
  }
  /**
   * 乗算色をセットする
   * @param partIndex partのインデックス
   * @param color 設定する乗算色(CubismTextureColor)
   */
  setPartMultiplyColorByTextureColor(partIndex, color) {
    this.setPartMultiplyColorByRGBA(
      partIndex,
      color.R,
      color.G,
      color.B,
      color.A
    );
  }
  /**
   * 乗算色をセットする
   * @param partIndex partのインデックス
   * @param r 設定する乗算色のR値
   * @param g 設定する乗算色のG値
   * @param b 設定する乗算色のB値
   * @param a 設定する乗算色のA値
   */
  setPartMultiplyColorByRGBA(partIndex, r2, g2, b2, a2) {
    this.setPartColor(
      partIndex,
      r2,
      g2,
      b2,
      a2,
      this._userPartMultiplyColors,
      this._userMultiplyColors
    );
  }
  /**
   * スクリーン色をセットする
   * @param partIndex partのインデックス
   * @param color 設定するスクリーン色(CubismTextureColor)
   */
  setPartScreenColorByTextureColor(partIndex, color) {
    this.setPartScreenColorByRGBA(
      partIndex,
      color.R,
      color.G,
      color.B,
      color.A
    );
  }
  /**
   * スクリーン色をセットする
   * @param partIndex partのインデックス
   * @param r 設定するスクリーン色のR値
   * @param g 設定するスクリーン色のG値
   * @param b 設定するスクリーン色のB値
   * @param a 設定するスクリーン色のA値
   */
  setPartScreenColorByRGBA(partIndex, r2, g2, b2, a2) {
    this.setPartColor(
      partIndex,
      r2,
      g2,
      b2,
      a2,
      this._userPartScreenColors,
      this._userScreenColors
    );
  }
  /**
   * SDKから指定したモデルの乗算色を上書きするか
   * @returns true -> SDKからの情報を優先する
   *          false -> モデルに設定されている色情報を使用
   */
  getOverwriteFlagForModelMultiplyColors() {
    return this._isOverwrittenModelMultiplyColors;
  }
  /**
   * SDKから指定したモデルのスクリーン色を上書きするか
   * @returns true -> SDKからの情報を優先する
   *          false -> モデルに設定されている色情報を使用
   */
  getOverwriteFlagForModelScreenColors() {
    return this._isOverwrittenModelScreenColors;
  }
  /**
   * SDKから指定したモデルの乗算色を上書きするかセットする
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteFlagForModelMultiplyColors(value) {
    this._isOverwrittenModelMultiplyColors = value;
  }
  /**
   * SDKから指定したモデルのスクリーン色を上書きするかセットする
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteFlagForModelScreenColors(value) {
    this._isOverwrittenModelScreenColors = value;
  }
  /**
   * SDKから指定したDrawableIndexの乗算色を上書きするか
   * @returns true -> SDKからの情報を優先する
   *          false -> モデルに設定されている色情報を使用
   */
  getOverwriteFlagForDrawableMultiplyColors(drawableindex) {
    return this._userMultiplyColors[drawableindex].isOverwritten;
  }
  /**
   * SDKから指定したDrawableIndexのスクリーン色を上書きするか
   * @returns true -> SDKからの情報を優先する
   *          false -> モデルに設定されている色情報を使用
   */
  getOverwriteFlagForDrawableScreenColors(drawableindex) {
    return this._userScreenColors[drawableindex].isOverwritten;
  }
  /**
   * SDKから指定したDrawableIndexの乗算色を上書きするかセットする
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteFlagForDrawableMultiplyColors(drawableindex, value) {
    this._userMultiplyColors[drawableindex].isOverwritten = value;
  }
  /**
   * SDKから指定したDrawableIndexのスクリーン色を上書きするかセットする
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteFlagForDrawableScreenColors(drawableindex, value) {
    this._userScreenColors[drawableindex].isOverwritten = value;
  }
  /**
   * SDKからpartの乗算色を上書きするか
   * @param partIndex partのインデックス
   * @returns true    ->  SDKからの情報を優先する
   *          false   ->  モデルに設定されている色情報を使用
   */
  getOverwriteColorForPartMultiplyColors(partIndex) {
    return this._userPartMultiplyColors[partIndex].isOverwritten;
  }
  /**
   * SDKからpartのスクリーン色を上書きするか
   * @param partIndex partのインデックス
   * @returns true    ->  SDKからの情報を優先する
   *          false   ->  モデルに設定されている色情報を使用
   */
  getOverwriteColorForPartScreenColors(partIndex) {
    return this._userPartScreenColors[partIndex].isOverwritten;
  }
  /**
   * partのOverwriteFlag setter関数
   * @param partIndex partのインデックス
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   * @param partColors 設定するpartのカラーデータ配列
   * @param drawableColors partに関連するDrawableのカラーデータ配列
   */
  setOverwriteColorForPartColors(partIndex, value, partColors, drawableColors) {
    partColors[partIndex].isOverwritten = value;
    for (let i2 = 0; i2 < this._partChildDrawables[partIndex].length; ++i2) {
      const drawableIndex = this._partChildDrawables[partIndex][i2];
      drawableColors[drawableIndex].isOverwritten = value;
      if (value) {
        drawableColors[drawableIndex].Color.R = partColors[partIndex].Color.R;
        drawableColors[drawableIndex].Color.G = partColors[partIndex].Color.G;
        drawableColors[drawableIndex].Color.B = partColors[partIndex].Color.B;
        drawableColors[drawableIndex].Color.A = partColors[partIndex].Color.A;
      }
    }
  }
  /**
   * SDKからpartのスクリーン色を上書きするかをセットする
   * @param partIndex partのインデックス
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteColorForPartMultiplyColors(partIndex, value) {
    this._userPartMultiplyColors[partIndex].isOverwritten = value;
    this.setOverwriteColorForPartColors(
      partIndex,
      value,
      this._userPartMultiplyColors,
      this._userMultiplyColors
    );
  }
  /**
   * SDKからpartのスクリーン色を上書きするかをセットする
   * @param partIndex partのインデックス
   * @param value true -> SDKからの情報を優先する
   *              false -> モデルに設定されている色情報を使用
   */
  setOverwriteColorForPartScreenColors(partIndex, value) {
    this._userPartScreenColors[partIndex].isOverwritten = value;
    this.setOverwriteColorForPartColors(
      partIndex,
      value,
      this._userPartScreenColors,
      this._userScreenColors
    );
  }
  /**
   * Drawableのカリング情報を取得する。
   *
   * @param   drawableIndex   Drawableのインデックス
   * @return  Drawableのカリング情報
   */
  getDrawableCulling(drawableIndex) {
    if (this.getOverwriteFlagForModelCullings() || this.getOverwriteFlagForDrawableCullings(drawableIndex)) {
      return this._userCullings[drawableIndex].isCulling;
    }
    const constantFlags = this._model.drawables.constantFlags;
    return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(
      constantFlags[drawableIndex]
    );
  }
  /**
   * Drawableのカリング情報を設定する。
   *
   * @param drawableIndex Drawableのインデックス
   * @param isCulling カリング情報
   */
  setDrawableCulling(drawableIndex, isCulling) {
    this._userCullings[drawableIndex].isCulling = isCulling;
  }
  /**
   * SDKからモデル全体のカリング設定を上書きするか。
   *
   * @retval  true    ->  SDK上のカリング設定を使用
   * @retval  false   ->  モデルのカリング設定を使用
   */
  getOverwriteFlagForModelCullings() {
    return this._isOverwrittenCullings;
  }
  /**
   * SDKからモデル全体のカリング設定を上書きするかを設定する。
   *
   * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
   */
  setOverwriteFlagForModelCullings(isOverwrittenCullings) {
    this._isOverwrittenCullings = isOverwrittenCullings;
  }
  /**
   *
   * @param drawableIndex Drawableのインデックス
   * @retval  true    ->  SDK上のカリング設定を使用
   * @retval  false   ->  モデルのカリング設定を使用
   */
  getOverwriteFlagForDrawableCullings(drawableIndex) {
    return this._userCullings[drawableIndex].isOverwritten;
  }
  /**
   *
   * @param drawableIndex Drawableのインデックス
   * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
   */
  setOverwriteFlagForDrawableCullings(drawableIndex, isOverwrittenCullings) {
    this._userCullings[drawableIndex].isOverwritten = isOverwrittenCullings;
  }
  /**
   * モデルの不透明度を取得する
   *
   * @returns 不透明度の値
   */
  getModelOapcity() {
    return this._modelOpacity;
  }
  /**
   * モデルの不透明度を設定する
   *
   * @param value 不透明度の値
   */
  setModelOapcity(value) {
    this._modelOpacity = value;
  }
  /**
   * モデルを取得
   */
  getModel() {
    return this._model;
  }
  /**
   * パーツのインデックスを取得
   * @param partId パーツのID
   * @return パーツのインデックス
   */
  getPartIndex(partId) {
    let partIndex;
    const partCount = this._model.parts.count;
    for (partIndex = 0; partIndex < partCount; ++partIndex) {
      if (partId == this._partIds[partIndex]) {
        return partIndex;
      }
    }
    if (partId in this._notExistPartId) {
      return this._notExistPartId[partId];
    }
    partIndex = partCount + this._notExistPartId.length;
    this._notExistPartId[partId] = partIndex;
    this._notExistPartOpacities[partIndex] = 0;
    return partIndex;
  }
  /**
   * パーツのIDを取得する。
   *
   * @param partIndex 取得するパーツのインデックス
   * @return パーツのID
   */
  getPartId(partIndex) {
    return this._model.parts.ids[partIndex];
  }
  /**
   * パーツの個数の取得
   * @return パーツの個数
   */
  getPartCount() {
    return this._model.parts.count;
  }
  /**
   * パーツの不透明度の設定(Index)
   * @param partIndex パーツのインデックス
   * @param opacity 不透明度
   */
  setPartOpacityByIndex(partIndex, opacity) {
    if (partIndex in this._notExistPartOpacities) {
      this._notExistPartOpacities[partIndex] = opacity;
      return;
    }
    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
    this._partOpacities[partIndex] = opacity;
  }
  /**
   * パーツの不透明度の設定(Id)
   * @param partId パーツのID
   * @param opacity パーツの不透明度
   */
  setPartOpacityById(partId, opacity) {
    const index = this.getPartIndex(partId);
    if (index < 0) {
      return;
    }
    this.setPartOpacityByIndex(index, opacity);
  }
  /**
   * パーツの不透明度の取得(index)
   * @param partIndex パーツのインデックス
   * @return パーツの不透明度
   */
  getPartOpacityByIndex(partIndex) {
    if (partIndex in this._notExistPartOpacities) {
      return this._notExistPartOpacities[partIndex];
    }
    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
    return this._partOpacities[partIndex];
  }
  /**
   * パーツの不透明度の取得(id)
   * @param partId パーツのＩｄ
   * @return パーツの不透明度
   */
  getPartOpacityById(partId) {
    const index = this.getPartIndex(partId);
    if (index < 0) {
      return 0;
    }
    return this.getPartOpacityByIndex(index);
  }
  /**
   * パラメータのインデックスの取得
   * @param パラメータID
   * @return パラメータのインデックス
   */
  getParameterIndex(parameterId) {
    let parameterIndex;
    const idCount = this._model.parameters.count;
    for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {
      if (parameterId != this._parameterIds[parameterIndex]) {
        continue;
      }
      return parameterIndex;
    }
    if (parameterId in this._notExistParameterId) {
      return this._notExistParameterId[parameterId];
    }
    parameterIndex = this._model.parameters.count + Object.keys(this._notExistParameterId).length;
    this._notExistParameterId[parameterId] = parameterIndex;
    this._notExistParameterValues[parameterIndex] = 0;
    return parameterIndex;
  }
  /**
   * パラメータの個数の取得
   * @return パラメータの個数
   */
  getParameterCount() {
    return this._model.parameters.count;
  }
  /**
   * パラメータの種類の取得
   * @param parameterIndex パラメータのインデックス
   * @return csmParameterType_Normal -> 通常のパラメータ
   *          csmParameterType_BlendShape -> ブレンドシェイプパラメータ
   */
  getParameterType(parameterIndex) {
    return this._model.parameters.types[parameterIndex];
  }
  /**
   * パラメータの最大値の取得
   * @param parameterIndex パラメータのインデックス
   * @return パラメータの最大値
   */
  getParameterMaximumValue(parameterIndex) {
    return this._model.parameters.maximumValues[parameterIndex];
  }
  /**
   * パラメータの最小値の取得
   * @param parameterIndex パラメータのインデックス
   * @return パラメータの最小値
   */
  getParameterMinimumValue(parameterIndex) {
    return this._model.parameters.minimumValues[parameterIndex];
  }
  /**
   * パラメータのデフォルト値の取得
   * @param parameterIndex パラメータのインデックス
   * @return パラメータのデフォルト値
   */
  getParameterDefaultValue(parameterIndex) {
    return this._model.parameters.defaultValues[parameterIndex];
  }
  /**
   * パラメータの値の取得
   * @param parameterIndex    パラメータのインデックス
   * @return パラメータの値
   */
  getParameterValueByIndex(parameterIndex) {
    if (parameterIndex in this._notExistParameterValues) {
      return this._notExistParameterValues[parameterIndex];
    }
    CSM_ASSERT(
      0 <= parameterIndex && parameterIndex < this.getParameterCount()
    );
    return this._parameterValues[parameterIndex];
  }
  /**
   * パラメータの値の取得
   * @param parameterId    パラメータのID
   * @return パラメータの値
   */
  getParameterValueById(parameterId) {
    const parameterIndex = this.getParameterIndex(parameterId);
    return this.getParameterValueByIndex(parameterIndex);
  }
  /**
   * パラメータの値の設定
   * @param parameterIndex パラメータのインデックス
   * @param value パラメータの値
   * @param weight 重み
   */
  setParameterValueByIndex(parameterIndex, value, weight = 1) {
    if (parameterIndex in this._notExistParameterValues) {
      this._notExistParameterValues[parameterIndex] = weight == 1 ? value : this._notExistParameterValues[parameterIndex] * (1 - weight) + value * weight;
      return;
    }
    CSM_ASSERT(
      0 <= parameterIndex && parameterIndex < this.getParameterCount()
    );
    if (this._model.parameters.maximumValues[parameterIndex] < value) {
      value = this._model.parameters.maximumValues[parameterIndex];
    }
    if (this._model.parameters.minimumValues[parameterIndex] > value) {
      value = this._model.parameters.minimumValues[parameterIndex];
    }
    this._parameterValues[parameterIndex] = weight == 1 ? value : this._parameterValues[parameterIndex] = this._parameterValues[parameterIndex] * (1 - weight) + value * weight;
  }
  /**
   * パラメータの値の設定
   * @param parameterId パラメータのID
   * @param value パラメータの値
   * @param weight 重み
   */
  setParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.setParameterValueByIndex(index, value, weight);
  }
  /**
   * パラメータの値の加算(index)
   * @param parameterIndex パラメータインデックス
   * @param value 加算する値
   * @param weight 重み
   */
  addParameterValueByIndex(parameterIndex, value, weight = 1) {
    this.setParameterValueByIndex(
      parameterIndex,
      this.getParameterValueByIndex(parameterIndex) + value * weight
    );
  }
  /**
   * パラメータの値の加算(id)
   * @param parameterId パラメータＩＤ
   * @param value 加算する値
   * @param weight 重み
   */
  addParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.addParameterValueByIndex(index, value, weight);
  }
  /**
   * パラメータの値の乗算
   * @param parameterId パラメータのID
   * @param value 乗算する値
   * @param weight 重み
   */
  multiplyParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.multiplyParameterValueByIndex(index, value, weight);
  }
  /**
   * パラメータの値の乗算
   * @param parameterIndex パラメータのインデックス
   * @param value 乗算する値
   * @param weight 重み
   */
  multiplyParameterValueByIndex(parameterIndex, value, weight = 1) {
    this.setParameterValueByIndex(
      parameterIndex,
      this.getParameterValueByIndex(parameterIndex) * (1 + (value - 1) * weight)
    );
  }
  getDrawableIds() {
    return this._drawableIds.slice();
  }
  /**
   * Drawableのインデックスの取得
   * @param drawableId DrawableのID
   * @return Drawableのインデックス
   */
  getDrawableIndex(drawableId) {
    const drawableCount = this._model.drawables.count;
    for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {
      if (this._drawableIds[drawableIndex] == drawableId) {
        return drawableIndex;
      }
    }
    return -1;
  }
  /**
   * Drawableの個数の取得
   * @return drawableの個数
   */
  getDrawableCount() {
    return this._model.drawables.count;
  }
  /**
   * DrawableのIDを取得する
   * @param drawableIndex Drawableのインデックス
   * @return drawableのID
   */
  getDrawableId(drawableIndex) {
    return this._model.drawables.ids[drawableIndex];
  }
  /**
   * Drawableの描画順リストの取得
   * @return Drawableの描画順リスト
   */
  getDrawableRenderOrders() {
    return this._model.drawables.renderOrders;
  }
  /**
   * @deprecated
   * 関数名が誤っていたため、代替となる getDrawableTextureIndex を追加し、この関数は非推奨となりました。
   *
   * Drawableのテクスチャインデックスリストの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableのテクスチャインデックスリスト
   */
  getDrawableTextureIndices(drawableIndex) {
    return this.getDrawableTextureIndex(drawableIndex);
  }
  /**
   * Drawableのテクスチャインデックスの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableのテクスチャインデックス
   */
  getDrawableTextureIndex(drawableIndex) {
    const textureIndices = this._model.drawables.textureIndices;
    return textureIndices[drawableIndex];
  }
  /**
   * DrawableのVertexPositionsの変化情報の取得
   *
   * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。
   *
   * @param   drawableIndex   Drawableのインデックス
   * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した
   * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない
   */
  getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawableの頂点インデックスの個数の取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの頂点インデックスの個数
   */
  getDrawableVertexIndexCount(drawableIndex) {
    return this._model.drawables.indexCounts[drawableIndex];
  }
  /**
   * Drawableの頂点の個数の取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの頂点の個数
   */
  getDrawableVertexCount(drawableIndex) {
    return this._model.drawables.vertexCounts[drawableIndex];
  }
  /**
   * Drawableの頂点リストの取得
   * @param drawableIndex drawableのインデックス
   * @return drawableの頂点リスト
   */
  getDrawableVertices(drawableIndex) {
    return this.getDrawableVertexPositions(drawableIndex);
  }
  /**
   * Drawableの頂点インデックスリストの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの頂点インデックスリスト
   */
  getDrawableVertexIndices(drawableIndex) {
    return this._model.drawables.indices[drawableIndex];
  }
  /**
   * Drawableの頂点リストの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの頂点リスト
   */
  getDrawableVertexPositions(drawableIndex) {
    return this._model.drawables.vertexPositions[drawableIndex];
  }
  /**
   * Drawableの頂点のUVリストの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの頂点UVリスト
   */
  getDrawableVertexUvs(drawableIndex) {
    return this._model.drawables.vertexUvs[drawableIndex];
  }
  /**
   * Drawableの不透明度の取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの不透明度
   */
  getDrawableOpacity(drawableIndex) {
    return this._model.drawables.opacities[drawableIndex];
  }
  /**
   * Drawableの乗算色の取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの乗算色(RGBA)
   * スクリーン色はRGBAで取得されるが、Aは必ず0
   */
  getDrawableMultiplyColor(drawableIndex) {
    const multiplyColors = this._model.drawables.multiplyColors;
    const index = drawableIndex * 4;
    const multiplyColor = new CubismTextureColor();
    multiplyColor.R = multiplyColors[index];
    multiplyColor.G = multiplyColors[index + 1];
    multiplyColor.B = multiplyColors[index + 2];
    multiplyColor.A = multiplyColors[index + 3];
    return multiplyColor;
  }
  /**
   * Drawableのスクリーン色の取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableのスクリーン色(RGBA)
   * スクリーン色はRGBAで取得されるが、Aは必ず0
   */
  getDrawableScreenColor(drawableIndex) {
    const screenColors = this._model.drawables.screenColors;
    const index = drawableIndex * 4;
    const screenColor = new CubismTextureColor();
    screenColor.R = screenColors[index];
    screenColor.G = screenColors[index + 1];
    screenColor.B = screenColors[index + 2];
    screenColor.A = screenColors[index + 3];
    return screenColor;
  }
  /**
   * Drawableの親パーツのインデックスの取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableの親パーツのインデックス
   */
  getDrawableParentPartIndex(drawableIndex) {
    return this._model.drawables.parentPartIndices[drawableIndex];
  }
  /**
   * Drawableのブレンドモードを取得
   * @param drawableIndex Drawableのインデックス
   * @return drawableのブレンドモード
   */
  getDrawableBlendMode(drawableIndex) {
    const constantFlags = this._model.drawables.constantFlags;
    return Live2DCubismCore.Utils.hasBlendAdditiveBit(
      constantFlags[drawableIndex]
    ) ? CubismBlendMode.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(
      constantFlags[drawableIndex]
    ) ? CubismBlendMode.CubismBlendMode_Multiplicative : CubismBlendMode.CubismBlendMode_Normal;
  }
  /**
   * Drawableのマスクの反転使用の取得
   *
   * Drawableのマスク使用時の反転設定を取得する。
   * マスクを使用しない場合は無視される。
   *
   * @param drawableIndex Drawableのインデックス
   * @return Drawableの反転設定
   */
  getDrawableInvertedMaskBit(drawableIndex) {
    const constantFlags = this._model.drawables.constantFlags;
    return Live2DCubismCore.Utils.hasIsInvertedMaskBit(
      constantFlags[drawableIndex]
    );
  }
  /**
   * Drawableのクリッピングマスクリストの取得
   * @return Drawableのクリッピングマスクリスト
   */
  getDrawableMasks() {
    return this._model.drawables.masks;
  }
  /**
   * Drawableのクリッピングマスクの個数リストの取得
   * @return Drawableのクリッピングマスクの個数リスト
   */
  getDrawableMaskCounts() {
    return this._model.drawables.maskCounts;
  }
  /**
   * クリッピングマスクの使用状態
   *
   * @return true クリッピングマスクを使用している
   * @return false クリッピングマスクを使用していない
   */
  isUsingMasking() {
    for (let d2 = 0; d2 < this._model.drawables.count; ++d2) {
      if (this._model.drawables.maskCounts[d2] <= 0) {
        continue;
      }
      return true;
    }
    return false;
  }
  /**
   * Drawableの表示情報を取得する
   *
   * @param drawableIndex Drawableのインデックス
   * @return true Drawableが表示
   * @return false Drawableが非表示
   */
  getDrawableDynamicFlagIsVisible(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);
  }
  /**
   * DrawableのDrawOrderの変化情報の取得
   *
   * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。
   * drawOrderはartMesh上で指定する0から1000の情報
   * @param drawableIndex drawableのインデックス
   * @return true drawableの不透明度が直近のCubismModel.update関数で変化した
   * @return false drawableの不透明度が直近のCubismModel.update関数で変化している
   */
  getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawableの不透明度の変化情報の取得
   *
   * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。
   *
   * @param drawableIndex drawableのインデックス
   * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した
   * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない
   */
  getDrawableDynamicFlagOpacityDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasOpacityDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawableの描画順序の変化情報の取得
   *
   * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。
   *
   * @param drawableIndex Drawableのインデックス
   * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した
   * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない
   */
  getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawableの乗算色・スクリーン色の変化情報の取得
   *
   * 直近のCubismModel.update関数でDrawableの乗算色・スクリーン色が変化したかを取得する。
   *
   * @param drawableIndex Drawableのインデックス
   * @return true Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化した
   * @return false Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化してない
   */
  getDrawableDynamicFlagBlendColorDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * 保存されたパラメータの読み込み
   */
  loadParameters() {
    let parameterCount = this._model.parameters.count;
    const savedParameterCount = this._savedParameters.length;
    if (parameterCount > savedParameterCount) {
      parameterCount = savedParameterCount;
    }
    for (let i2 = 0; i2 < parameterCount; ++i2) {
      this._parameterValues[i2] = this._savedParameters[i2];
    }
  }
  /**
   * 初期化する
   */
  initialize() {
    this._parameterValues = this._model.parameters.values;
    this._partOpacities = this._model.parts.opacities;
    this._parameterMaximumValues = this._model.parameters.maximumValues;
    this._parameterMinimumValues = this._model.parameters.minimumValues;
    {
      const parameterIds = this._model.parameters.ids;
      const parameterCount = this._model.parameters.count;
      for (let i2 = 0; i2 < parameterCount; ++i2) {
        this._parameterIds.push(parameterIds[i2]);
      }
    }
    const partCount = this._model.parts.count;
    {
      const partIds = this._model.parts.ids;
      for (let i2 = 0; i2 < partCount; ++i2) {
        this._partIds.push(partIds[i2]);
      }
    }
    {
      const drawableIds = this._model.drawables.ids;
      const drawableCount = this._model.drawables.count;
      const userCulling = new DrawableCullingData(
        false,
        false
      );
      {
        for (let i2 = 0; i2 < partCount; ++i2) {
          const multiplyColor = new CubismTextureColor(
            1,
            1,
            1,
            1
          );
          const screenColor = new CubismTextureColor(
            0,
            0,
            0,
            1
          );
          const userMultiplyColor = new PartColorData(
            false,
            multiplyColor
          );
          const userScreenColor = new PartColorData(
            false,
            screenColor
          );
          this._userPartMultiplyColors.push(userMultiplyColor);
          this._userPartScreenColors.push(userScreenColor);
          this._partChildDrawables.push([]);
        }
      }
      {
        for (let i2 = 0; i2 < drawableCount; ++i2) {
          const multiplyColor = new CubismTextureColor(
            1,
            1,
            1,
            1
          );
          const screenColor = new CubismTextureColor(
            0,
            0,
            0,
            1
          );
          const userMultiplyColor = new DrawableColorData(
            false,
            multiplyColor
          );
          const userScreenColor = new DrawableColorData(
            false,
            screenColor
          );
          this._drawableIds.push(drawableIds[i2]);
          this._userMultiplyColors.push(userMultiplyColor);
          this._userScreenColors.push(userScreenColor);
          this._userCullings.push(userCulling);
          const parentIndex = this.getDrawableParentPartIndex(i2);
          if (parentIndex >= 0) {
            this._partChildDrawables[parentIndex].push(i2);
          }
        }
      }
    }
  }
  /**
   * コンストラクタ
   * @param model モデル
   */
  constructor(model) {
    this._model = model;
    this._savedParameters = [];
    this._parameterIds = [];
    this._drawableIds = [];
    this._partIds = [];
    this._isOverwrittenModelMultiplyColors = false;
    this._isOverwrittenModelScreenColors = false;
    this._isOverwrittenCullings = false;
    this._modelOpacity = 1;
    this._userMultiplyColors = [];
    this._userScreenColors = [];
    this._userCullings = [];
    this._userPartMultiplyColors = [];
    this._userPartScreenColors = [];
    this._partChildDrawables = [];
    this._notExistPartId = {};
    this._notExistParameterId = {};
    this._notExistParameterValues = {};
    this._notExistPartOpacities = {};
    this.initialize();
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._model.release();
    this._model = void 0;
  }
  // カリング設定の配列
}
class CubismMoc {
  /**
   * Mocデータの作成
   */
  static create(mocBytes, shouldCheckMocConsistency) {
    if (shouldCheckMocConsistency) {
      const consistency = this.hasMocConsistency(mocBytes);
      if (!consistency) {
        throw new Error(`Inconsistent MOC3.`);
      }
    }
    const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);
    if (moc) {
      const cubismMoc = new CubismMoc(moc);
      cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(
        moc,
        mocBytes
      );
      return cubismMoc;
    }
    throw new Error("Failed to CubismMoc.create().");
  }
  /**
   * モデルを作成する
   *
   * @return Mocデータから作成されたモデル
   */
  createModel() {
    let cubismModel;
    const model = Live2DCubismCore.Model.fromMoc(
      this._moc
    );
    if (model) {
      cubismModel = new CubismModel(model);
      ++this._modelCount;
      return cubismModel;
    }
    throw new Error("Unknown error");
  }
  /**
   * モデルを削除する
   */
  deleteModel(model) {
    if (model != null) {
      --this._modelCount;
    }
  }
  /**
   * コンストラクタ
   */
  constructor(moc) {
    this._moc = moc;
    this._modelCount = 0;
    this._mocVersion = 0;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._moc._release();
    this._moc = void 0;
  }
  /**
   * 最新の.moc3 Versionを取得
   */
  getLatestMocVersion() {
    return Live2DCubismCore.Version.csmGetLatestMocVersion();
  }
  /**
   * 読み込んだモデルの.moc3 Versionを取得
   */
  getMocVersion() {
    return this._mocVersion;
  }
  /**
   * .moc3 の整合性を検証する
   */
  static hasMocConsistency(mocBytes) {
    const isConsistent = Live2DCubismCore.Moc.prototype.hasMocConsistency(mocBytes);
    return isConsistent === 1 ? true : false;
  }
  // 読み込んだモデルの.moc3 Version
}
var CubismPhysicsTargetType = /* @__PURE__ */ ((CubismPhysicsTargetType2) => {
  CubismPhysicsTargetType2[CubismPhysicsTargetType2["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter";
  return CubismPhysicsTargetType2;
})(CubismPhysicsTargetType || {});
var CubismPhysicsSource = /* @__PURE__ */ ((CubismPhysicsSource2) => {
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X";
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y";
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle";
  return CubismPhysicsSource2;
})(CubismPhysicsSource || {});
class CubismPhysicsParticle {
  constructor() {
    this.initialPosition = new CubismVector2(0, 0);
    this.position = new CubismVector2(0, 0);
    this.lastPosition = new CubismVector2(0, 0);
    this.lastGravity = new CubismVector2(0, 0);
    this.force = new CubismVector2(0, 0);
    this.velocity = new CubismVector2(0, 0);
  }
  // 現在の速度
}
class CubismPhysicsSubRig {
  constructor() {
    this.normalizationPosition = {};
    this.normalizationAngle = {};
  }
  // 正規化された角度
}
class CubismPhysicsInput {
  constructor() {
    this.source = {};
  }
  // 正規化されたパラメータ値の取得関数
}
class CubismPhysicsOutput {
  constructor() {
    this.destination = {};
    this.translationScale = new CubismVector2(0, 0);
  }
  // 物理演算のスケール値の取得関数
}
class CubismPhysicsRig {
  constructor() {
    this.settings = [];
    this.inputs = [];
    this.outputs = [];
    this.particles = [];
    this.gravity = new CubismVector2(0, 0);
    this.wind = new CubismVector2(0, 0);
    this.fps = 0;
  }
  //物理演算動作FPS
}
class CubismPhysicsJson {
  /**
   * コンストラクタ
   * @param json physics3.jsonが読み込まれているバッファ
   */
  constructor(json) {
    this._json = json;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._json = void 0;
  }
  /**
   * 重力の取得
   * @return 重力
   */
  getGravity() {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.Meta.EffectiveForces.Gravity.X;
    ret.y = this._json.Meta.EffectiveForces.Gravity.Y;
    return ret;
  }
  /**
   * 風の取得
   * @return 風
   */
  getWind() {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.Meta.EffectiveForces.Wind.X;
    ret.y = this._json.Meta.EffectiveForces.Wind.Y;
    return ret;
  }
  /**
   * 物理演算設定FPSの取得
   * @return 物理演算設定FPS
   */
  getFps() {
    return this._json.Meta.Fps || 0;
  }
  /**
   * 物理店の管理の個数の取得
   * @return 物理店の管理の個数
   */
  getSubRigCount() {
    return this._json.Meta.PhysicsSettingCount;
  }
  /**
   * 入力の総合計の取得
   * @return 入力の総合計
   */
  getTotalInputCount() {
    return this._json.Meta.TotalInputCount;
  }
  /**
   * 出力の総合計の取得
   * @return 出力の総合計
   */
  getTotalOutputCount() {
    return this._json.Meta.TotalOutputCount;
  }
  /**
   * 物理点の個数の取得
   * @return 物理点の個数
   */
  getVertexCount() {
    return this._json.Meta.VertexCount;
  }
  /**
   * 正規化された位置の最小値の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 正規化された位置の最小値
   */
  getNormalizationPositionMinimumValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Minimum;
  }
  /**
   * 正規化された位置の最大値の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 正規化された位置の最大値
   */
  getNormalizationPositionMaximumValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Maximum;
  }
  /**
   * 正規化された位置のデフォルト値の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 正規化された位置のデフォルト値
   */
  getNormalizationPositionDefaultValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Default;
  }
  /**
   * 正規化された角度の最小値の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 正規化された角度の最小値
   */
  getNormalizationAngleMinimumValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Minimum;
  }
  /**
   * 正規化された角度の最大値の取得
   * @param physicsSettingIndex
   * @return 正規化された角度の最大値
   */
  getNormalizationAngleMaximumValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Maximum;
  }
  /**
   * 正規化された角度のデフォルト値の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 正規化された角度のデフォルト値
   */
  getNormalizationAngleDefaultValue(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Default;
  }
  /**
   * 入力の個数の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 入力の個数
   */
  getInputCount(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Input.length;
  }
  /**
   * 入力の重みの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param inputIndex 入力のインデックス
   * @return 入力の重み
   */
  getInputWeight(physicsSettingIndex, inputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Weight;
  }
  /**
   * 入力の反転の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param inputIndex 入力のインデックス
   * @return 入力の反転
   */
  getInputReflect(physicsSettingIndex, inputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Reflect;
  }
  /**
   * 入力の種類の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param inputIndex 入力のインデックス
   * @return 入力の種類
   */
  getInputType(physicsSettingIndex, inputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Type;
  }
  /**
   * 入力元のIDの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param inputIndex 入力のインデックス
   * @return 入力元のID
   */
  getInputSourceId(physicsSettingIndex, inputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Source.Id;
  }
  /**
   * 出力の個数の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @return 出力の個数
   */
  getOutputCount(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output.length;
  }
  /**
   * 出力の物理点のインデックスの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力の物理点のインデックス
   */
  getOutputVertexIndex(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].VertexIndex;
  }
  /**
   * 出力の角度のスケールを取得する
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力の角度のスケール
   */
  getOutputAngleScale(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Scale;
  }
  /**
   * 出力の重みの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力の重み
   */
  getOutputWeight(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Weight;
  }
  /**
   * 出力先のIDの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力先のID
   */
  getOutputDestinationId(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Destination.Id;
  }
  /**
   * 出力の種類の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力の種類
   */
  getOutputType(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Type;
  }
  /**
   * 出力の反転の取得
   * @param physicsSettingIndex 物理演算のインデックス
   * @param outputIndex 出力のインデックス
   * @return 出力の反転
   */
  getOutputReflect(physicsSettingIndex, outputIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Reflect;
  }
  /**
   * 物理点の個数の取得
   * @param physicsSettingIndex 物理演算男設定のインデックス
   * @return 物理点の個数
   */
  getParticleCount(physicsSettingIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Vertices.length;
  }
  /**
   * 物理点の動きやすさの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param vertexIndex 物理点のインデックス
   * @return 物理点の動きやすさ
   */
  getParticleMobility(physicsSettingIndex, vertexIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Mobility;
  }
  /**
   * 物理点の遅れの取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param vertexIndex 物理点のインデックス
   * @return 物理点の遅れ
   */
  getParticleDelay(physicsSettingIndex, vertexIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Delay;
  }
  /**
   * 物理点の加速度の取得
   * @param physicsSettingIndex 物理演算の設定
   * @param vertexIndex 物理点のインデックス
   * @return 物理点の加速度
   */
  getParticleAcceleration(physicsSettingIndex, vertexIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Acceleration;
  }
  /**
   * 物理点の距離の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param vertexIndex 物理点のインデックス
   * @return 物理点の距離
   */
  getParticleRadius(physicsSettingIndex, vertexIndex) {
    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Radius;
  }
  /**
   * 物理点の位置の取得
   * @param physicsSettingIndex 物理演算の設定のインデックス
   * @param vertexIndex 物理点のインデックス
   * @return 物理点の位置
   */
  getParticlePosition(physicsSettingIndex, vertexIndex) {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.X;
    ret.y = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.Y;
    return ret;
  }
  // physics3.jsonデータ
}
const PhysicsTypeTagX = "X";
const PhysicsTypeTagY = "Y";
const PhysicsTypeTagAngle = "Angle";
const AirResistance = 5;
const MaximumWeight = 100;
const MovementThreshold = 1e-3;
const MaxDeltaTime = 5;
class CubismPhysics {
  /**
   * インスタンスの作成
   * @param json    physics3.jsonが読み込まれているバッファ
   * @return 作成されたインスタンス
   */
  static create(json) {
    const ret = new CubismPhysics();
    ret.parse(json);
    ret._physicsRig.gravity.y = 0;
    return ret;
  }
  /**
   * インスタンスを破棄する
   * @param physics 破棄するインスタンス
   */
  static delete(physics) {
    if (physics != null) {
      physics.release();
    }
  }
  /**
   * physics3.jsonをパースする。
   * @param physicsJson physics3.jsonが読み込まれているバッファ
   */
  parse(physicsJson) {
    this._physicsRig = new CubismPhysicsRig();
    const json = new CubismPhysicsJson(physicsJson);
    this._physicsRig.gravity = json.getGravity();
    this._physicsRig.wind = json.getWind();
    this._physicsRig.subRigCount = json.getSubRigCount();
    this._physicsRig.fps = json.getFps();
    this._currentRigOutputs = [];
    this._previousRigOutputs = [];
    let inputIndex = 0, outputIndex = 0, particleIndex = 0;
    for (let i2 = 0; i2 < this._physicsRig.subRigCount; ++i2) {
      const setting = new CubismPhysicsSubRig();
      setting.normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i2);
      setting.normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i2);
      setting.normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i2);
      setting.normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i2);
      setting.normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i2);
      setting.normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i2);
      setting.inputCount = json.getInputCount(i2);
      setting.baseInputIndex = inputIndex;
      inputIndex += setting.inputCount;
      for (let j2 = 0; j2 < setting.inputCount; ++j2) {
        const input = new CubismPhysicsInput();
        input.sourceParameterIndex = -1;
        input.weight = json.getInputWeight(i2, j2);
        input.reflect = json.getInputReflect(i2, j2);
        switch (json.getInputType(i2, j2)) {
          case PhysicsTypeTagX:
            input.type = CubismPhysicsSource.CubismPhysicsSource_X;
            input.getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;
            break;
          case PhysicsTypeTagY:
            input.type = CubismPhysicsSource.CubismPhysicsSource_Y;
            input.getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;
            break;
          case PhysicsTypeTagAngle:
            input.type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            input.getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;
            break;
        }
        input.source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
        input.source.id = json.getInputSourceId(i2, j2);
        this._physicsRig.inputs.push(input);
      }
      setting.outputCount = json.getOutputCount(i2);
      setting.baseOutputIndex = outputIndex;
      const currentRigOutput = new PhysicsOutput();
      const previousRigOutput = new PhysicsOutput();
      for (let j2 = 0; j2 < setting.outputCount; ++j2) {
        currentRigOutput.outputs[j2] = 0;
        previousRigOutput.outputs[j2] = 0;
        let output = this._physicsRig.outputs[outputIndex + j2];
        if (!output) {
          output = new CubismPhysicsOutput();
          this._physicsRig.outputs[outputIndex + j2] = output;
        }
        output.destinationParameterIndex = -1;
        output.vertexIndex = json.getOutputVertexIndex(i2, j2);
        output.angleScale = json.getOutputAngleScale(i2, j2);
        output.weight = json.getOutputWeight(i2, j2);
        output.destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
        output.destination.id = json.getOutputDestinationId(i2, j2);
        switch (json.getOutputType(i2, j2)) {
          case PhysicsTypeTagX:
            output.type = CubismPhysicsSource.CubismPhysicsSource_X;
            output.getValue = getOutputTranslationX;
            output.getScale = getOutputScaleTranslationX;
            break;
          case PhysicsTypeTagY:
            output.type = CubismPhysicsSource.CubismPhysicsSource_Y;
            output.getValue = getOutputTranslationY;
            output.getScale = getOutputScaleTranslationY;
            break;
          case PhysicsTypeTagAngle:
            output.type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            output.getValue = getOutputAngle;
            output.getScale = getOutputScaleAngle;
            break;
        }
        output.reflect = json.getOutputReflect(i2, j2);
      }
      this._currentRigOutputs.push(currentRigOutput);
      this._previousRigOutputs.push(previousRigOutput);
      outputIndex += setting.outputCount;
      setting.particleCount = json.getParticleCount(i2);
      setting.baseParticleIndex = particleIndex;
      particleIndex += setting.particleCount;
      for (let j2 = 0; j2 < setting.particleCount; ++j2) {
        const particle = new CubismPhysicsParticle();
        particle.mobility = json.getParticleMobility(i2, j2);
        particle.delay = json.getParticleDelay(i2, j2);
        particle.acceleration = json.getParticleAcceleration(i2, j2);
        particle.radius = json.getParticleRadius(i2, j2);
        particle.position = json.getParticlePosition(i2, j2);
        this._physicsRig.particles.push(particle);
      }
      this._physicsRig.settings.push(setting);
    }
    this.initialize();
    json.release();
  }
  /**
   * 現在のパラメータ値で物理演算が安定化する状態を演算する。
   * @param model 物理演算の結果を適用するモデル
   */
  stabilization(model) {
    var _a2, _b, _c, _d;
    let totalAngle;
    let weight;
    let radAngle;
    let outputValue;
    const totalTranslation = new CubismVector2();
    let currentSetting;
    let currentInputs;
    let currentOutputs;
    let currentParticles;
    let parameterValues;
    let parameterMaximumValues;
    let parameterMinimumValues;
    let parameterDefaultValues;
    parameterValues = model.getModel().parameters.values;
    parameterMaximumValues = model.getModel().parameters.maximumValues;
    parameterMinimumValues = model.getModel().parameters.minimumValues;
    parameterDefaultValues = model.getModel().parameters.defaultValues;
    if (((_b = (_a2 = this._parameterCaches) == null ? void 0 : _a2.length) != null ? _b : 0) < model.getParameterCount()) {
      this._parameterCaches = new Float32Array(model.getParameterCount());
    }
    if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
      this._parameterInputCaches = new Float32Array(model.getParameterCount());
    }
    for (let j2 = 0; j2 < model.getParameterCount(); ++j2) {
      this._parameterCaches[j2] = parameterValues[j2];
      this._parameterInputCaches[j2] = parameterValues[j2];
    }
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      totalAngle = { angle: 0 };
      totalTranslation.x = 0;
      totalTranslation.y = 0;
      currentSetting = this._physicsRig.settings[settingIndex];
      currentInputs = this._physicsRig.inputs.slice(
        currentSetting.baseInputIndex
      );
      currentOutputs = this._physicsRig.outputs.slice(
        currentSetting.baseOutputIndex
      );
      currentParticles = this._physicsRig.particles.slice(
        currentSetting.baseParticleIndex
      );
      for (let i2 = 0; i2 < currentSetting.inputCount; ++i2) {
        weight = currentInputs[i2].weight / MaximumWeight;
        if (currentInputs[i2].sourceParameterIndex == -1) {
          currentInputs[i2].sourceParameterIndex = model.getParameterIndex(
            currentInputs[i2].source.id
          );
        }
        currentInputs[i2].getNormalizedParameterValue(
          totalTranslation,
          totalAngle,
          parameterValues[currentInputs[i2].sourceParameterIndex],
          parameterMinimumValues[currentInputs[i2].sourceParameterIndex],
          parameterMaximumValues[currentInputs[i2].sourceParameterIndex],
          parameterDefaultValues[currentInputs[i2].sourceParameterIndex],
          currentSetting.normalizationPosition,
          currentSetting.normalizationAngle,
          currentInputs[i2].reflect,
          weight
        );
        this._parameterCaches[currentInputs[i2].sourceParameterIndex] = parameterValues[currentInputs[i2].sourceParameterIndex];
      }
      radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
      totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
      totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
      updateParticlesForStabilization(
        currentParticles,
        currentSetting.particleCount,
        totalTranslation,
        totalAngle.angle,
        this._options.wind,
        MovementThreshold * currentSetting.normalizationPosition.maximum
      );
      for (let i2 = 0; i2 < currentSetting.outputCount; ++i2) {
        const particleIndex = currentOutputs[i2].vertexIndex;
        if (currentOutputs[i2].destinationParameterIndex == -1) {
          currentOutputs[i2].destinationParameterIndex = model.getParameterIndex(
            currentOutputs[i2].destination.id
          );
        }
        if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
          continue;
        }
        let translation = new CubismVector2();
        translation = currentParticles[particleIndex].position.substract(
          currentParticles[particleIndex - 1].position
        );
        outputValue = currentOutputs[i2].getValue(
          translation,
          currentParticles,
          particleIndex,
          currentOutputs[i2].reflect,
          this._options.gravity
        );
        this._currentRigOutputs[settingIndex].outputs[i2] = outputValue;
        this._previousRigOutputs[settingIndex].outputs[i2] = outputValue;
        const destinationParameterIndex = currentOutputs[i2].destinationParameterIndex;
        const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
          JSON.stringify(
            parameterValues.subarray(destinationParameterIndex)
          )
        ) : parameterValues.slice(destinationParameterIndex);
        updateOutputParameterValue(
          outParameterCaches,
          parameterMinimumValues[destinationParameterIndex],
          parameterMaximumValues[destinationParameterIndex],
          outputValue,
          currentOutputs[i2]
        );
        for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < this._parameterCaches.length; offset2++, outParamIndex++) {
          parameterValues[offset2] = this._parameterCaches[offset2] = outParameterCaches[outParamIndex];
        }
      }
    }
  }
  /**
   * 物理演算の評価
   *
   * Pendulum interpolation weights
   *
   * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。
   * The result of the pendulum calculation is saved and
   * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.
   *
   * 図で示すと[1]と[2]で補間されます。
   * The figure shows the interpolation between [1] and [2].
   *
   * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。
   * The weight of the interpolation are determined by the current time seen between
   * the latest pendulum calculation timing and the next timing.
   *
   * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。
   * Figure shows the weight of position (3) as seen between [2] and [4].
   *
   * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。
   * As an interpretation, the pendulum calculation and weights are misaligned.
   *
   * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。
   * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.
   *
   * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。
   * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.
   *
   * ------------ time -------------->
   *
   *                 |+++++|------| <- weight
   * ==[1]====#=====[2]---(3)----(4)
   *          ^ output contents
   *
   * 1:_previousRigOutputs
   * 2:_currentRigOutputs
   * 3:_currentRemainTime (now rendering)
   * 4:next particles timing
   * @param model 物理演算の結果を適用するモデル
   * @param deltaTimeSeconds デルタ時間[秒]
   */
  evaluate(model, deltaTimeSeconds) {
    var _a2, _b, _c, _d;
    let totalAngle;
    let weight;
    let radAngle;
    let outputValue;
    const totalTranslation = new CubismVector2();
    let currentSetting;
    let currentInputs;
    let currentOutputs;
    let currentParticles;
    if (0 >= deltaTimeSeconds) {
      return;
    }
    let parameterValues;
    let parameterMaximumValues;
    let parameterMinimumValues;
    let parameterDefaultValues;
    let physicsDeltaTime;
    this._currentRemainTime += deltaTimeSeconds;
    if (this._currentRemainTime > MaxDeltaTime) {
      this._currentRemainTime = 0;
    }
    parameterValues = model.getModel().parameters.values;
    parameterMaximumValues = model.getModel().parameters.maximumValues;
    parameterMinimumValues = model.getModel().parameters.minimumValues;
    parameterDefaultValues = model.getModel().parameters.defaultValues;
    if (((_b = (_a2 = this._parameterCaches) == null ? void 0 : _a2.length) != null ? _b : 0) < model.getParameterCount()) {
      this._parameterCaches = new Float32Array(model.getParameterCount());
    }
    if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
      this._parameterInputCaches = new Float32Array(model.getParameterCount());
      for (let j2 = 0; j2 < model.getParameterCount(); ++j2) {
        this._parameterInputCaches[j2] = parameterValues[j2];
      }
    }
    if (this._physicsRig.fps > 0) {
      physicsDeltaTime = 1 / this._physicsRig.fps;
    } else {
      physicsDeltaTime = deltaTimeSeconds;
    }
    while (this._currentRemainTime >= physicsDeltaTime) {
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings[settingIndex];
        currentOutputs = this._physicsRig.outputs.slice(
          currentSetting.baseOutputIndex
        );
        for (let i2 = 0; i2 < currentSetting.outputCount; ++i2) {
          this._previousRigOutputs[settingIndex].outputs[i2] = this._currentRigOutputs[settingIndex].outputs[i2];
        }
      }
      const inputWeight = physicsDeltaTime / this._currentRemainTime;
      for (let j2 = 0; j2 < model.getParameterCount(); ++j2) {
        this._parameterCaches[j2] = this._parameterInputCaches[j2] * (1 - inputWeight) + parameterValues[j2] * inputWeight;
        this._parameterInputCaches[j2] = this._parameterCaches[j2];
      }
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        totalAngle = { angle: 0 };
        totalTranslation.x = 0;
        totalTranslation.y = 0;
        currentSetting = this._physicsRig.settings[settingIndex];
        currentInputs = this._physicsRig.inputs.slice(
          currentSetting.baseInputIndex
        );
        currentOutputs = this._physicsRig.outputs.slice(
          currentSetting.baseOutputIndex
        );
        currentParticles = this._physicsRig.particles.slice(
          currentSetting.baseParticleIndex
        );
        for (let i2 = 0; i2 < currentSetting.inputCount; ++i2) {
          weight = currentInputs[i2].weight / MaximumWeight;
          if (currentInputs[i2].sourceParameterIndex == -1) {
            currentInputs[i2].sourceParameterIndex = model.getParameterIndex(
              currentInputs[i2].source.id
            );
          }
          currentInputs[i2].getNormalizedParameterValue(
            totalTranslation,
            totalAngle,
            this._parameterCaches[currentInputs[i2].sourceParameterIndex],
            parameterMinimumValues[currentInputs[i2].sourceParameterIndex],
            parameterMaximumValues[currentInputs[i2].sourceParameterIndex],
            parameterDefaultValues[currentInputs[i2].sourceParameterIndex],
            currentSetting.normalizationPosition,
            currentSetting.normalizationAngle,
            currentInputs[i2].reflect,
            weight
          );
        }
        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
        updateParticles(
          currentParticles,
          currentSetting.particleCount,
          totalTranslation,
          totalAngle.angle,
          this._options.wind,
          MovementThreshold * currentSetting.normalizationPosition.maximum,
          physicsDeltaTime,
          AirResistance
        );
        for (let i2 = 0; i2 < currentSetting.outputCount; ++i2) {
          const particleIndex = currentOutputs[i2].vertexIndex;
          if (currentOutputs[i2].destinationParameterIndex == -1) {
            currentOutputs[i2].destinationParameterIndex = model.getParameterIndex(currentOutputs[i2].destination.id);
          }
          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
            continue;
          }
          const translation = new CubismVector2();
          translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;
          translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;
          outputValue = currentOutputs[i2].getValue(
            translation,
            currentParticles,
            particleIndex,
            currentOutputs[i2].reflect,
            this._options.gravity
          );
          this._currentRigOutputs[settingIndex].outputs[i2] = outputValue;
          const destinationParameterIndex = currentOutputs[i2].destinationParameterIndex;
          const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
            JSON.stringify(
              this._parameterCaches.subarray(destinationParameterIndex)
            )
          ) : this._parameterCaches.slice(destinationParameterIndex);
          updateOutputParameterValue(
            outParameterCaches,
            parameterMinimumValues[destinationParameterIndex],
            parameterMaximumValues[destinationParameterIndex],
            outputValue,
            currentOutputs[i2]
          );
          for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < this._parameterCaches.length; offset2++, outParamIndex++) {
            this._parameterCaches[offset2] = outParameterCaches[outParamIndex];
          }
        }
      }
      this._currentRemainTime -= physicsDeltaTime;
    }
    const alpha = this._currentRemainTime / physicsDeltaTime;
    this.interpolate(model, alpha);
  }
  /**
   * 物理演算結果の適用
   * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。
   * @param model 物理演算の結果を適用するモデル
   * @param weight 最新結果の重み
   */
  interpolate(model, weight) {
    let currentOutputs;
    let currentSetting;
    let parameterValues;
    let parameterMaximumValues;
    let parameterMinimumValues;
    parameterValues = model.getModel().parameters.values;
    parameterMaximumValues = model.getModel().parameters.maximumValues;
    parameterMinimumValues = model.getModel().parameters.minimumValues;
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      currentSetting = this._physicsRig.settings[settingIndex];
      currentOutputs = this._physicsRig.outputs.slice(
        currentSetting.baseOutputIndex
      );
      for (let i2 = 0; i2 < currentSetting.outputCount; ++i2) {
        if (currentOutputs[i2].destinationParameterIndex == -1) {
          continue;
        }
        const destinationParameterIndex = currentOutputs[i2].destinationParameterIndex;
        const outParameterValues = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
          JSON.stringify(
            parameterValues.subarray(destinationParameterIndex)
          )
        ) : parameterValues.slice(destinationParameterIndex);
        updateOutputParameterValue(
          outParameterValues,
          parameterMinimumValues[destinationParameterIndex],
          parameterMaximumValues[destinationParameterIndex],
          this._previousRigOutputs[settingIndex].outputs[i2] * (1 - weight) + this._currentRigOutputs[settingIndex].outputs[i2] * weight,
          currentOutputs[i2]
        );
        for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < parameterValues.length; offset2++, outParamIndex++) {
          parameterValues[offset2] = outParameterValues[outParamIndex];
        }
      }
    }
  }
  /**
   * オプションの設定
   * @param options オプション
   */
  setOptions(options) {
    this._options = options;
  }
  /**
   * オプションの取得
   * @return オプション
   */
  getOption() {
    return this._options;
  }
  /**
   * コンストラクタ
   */
  constructor() {
    this._options = new Options();
    this._options.gravity.y = -1;
    this._options.gravity.x = 0;
    this._options.wind.x = 0;
    this._options.wind.y = 0;
    this._currentRigOutputs = [];
    this._previousRigOutputs = [];
    this._currentRemainTime = 0;
  }
  /**
   * デストラクタ相当の処理
   */
  release() {
    this._physicsRig = void 0;
  }
  /**
   * 初期化する
   */
  initialize() {
    let strand;
    let currentSetting;
    let radius;
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      currentSetting = this._physicsRig.settings[settingIndex];
      strand = this._physicsRig.particles.slice(
        currentSetting.baseParticleIndex
      );
      strand[0].initialPosition = new CubismVector2(0, 0);
      strand[0].lastPosition = new CubismVector2(
        strand[0].initialPosition.x,
        strand[0].initialPosition.y
      );
      strand[0].lastGravity = new CubismVector2(0, -1);
      strand[0].lastGravity.y *= -1;
      strand[0].velocity = new CubismVector2(0, 0);
      strand[0].force = new CubismVector2(0, 0);
      for (let i2 = 1; i2 < currentSetting.particleCount; ++i2) {
        radius = new CubismVector2(0, 0);
        radius.y = strand[i2].radius;
        strand[i2].initialPosition = new CubismVector2(
          strand[i2 - 1].initialPosition.x + radius.x,
          strand[i2 - 1].initialPosition.y + radius.y
        );
        strand[i2].position = new CubismVector2(
          strand[i2].initialPosition.x,
          strand[i2].initialPosition.y
        );
        strand[i2].lastPosition = new CubismVector2(
          strand[i2].initialPosition.x,
          strand[i2].initialPosition.y
        );
        strand[i2].lastGravity = new CubismVector2(0, -1);
        strand[i2].lastGravity.y *= -1;
        strand[i2].velocity = new CubismVector2(0, 0);
        strand[i2].force = new CubismVector2(0, 0);
      }
    }
  }
  ///< UpdateParticlesが動くときの入力をキャッシュ
}
class Options {
  constructor() {
    this.gravity = new CubismVector2(0, 0);
    this.wind = new CubismVector2(0, 0);
  }
  // 風の方向
}
class PhysicsOutput {
  constructor() {
    this.outputs = [];
  }
  // 物理演算出力結果
}
function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
  targetTranslation.x += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationPosition.minimum,
    normalizationPosition.maximum,
    normalizationPosition.defalut,
    isInverted
  ) * weight;
}
function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
  targetTranslation.y += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationPosition.minimum,
    normalizationPosition.maximum,
    normalizationPosition.defalut,
    isInverted
  ) * weight;
}
function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {
  targetAngle.angle += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationAngle.minimum,
    normalizationAngle.maximum,
    normalizationAngle.defalut,
    isInverted
  ) * weight;
}
function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue = translation.x;
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue = translation.y;
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue;
  if (particleIndex >= 2) {
    parentGravity = particles[particleIndex - 1].position.substract(
      particles[particleIndex - 2].position
    );
  } else {
    parentGravity = parentGravity.multiplyByScaler(-1);
  }
  outputValue = CubismMath.directionToRadian(parentGravity, translation);
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getRangeValue(min2, max2) {
  return Math.abs(Math.max(min2, max2) - Math.min(min2, max2));
}
function getDefaultValue(min2, max2) {
  const minValue = Math.min(min2, max2);
  return minValue + getRangeValue(min2, max2) / 2;
}
function getOutputScaleTranslationX(translationScale, angleScale) {
  return translationScale.x;
}
function getOutputScaleTranslationY(translationScale, angleScale) {
  return translationScale.y;
}
function getOutputScaleAngle(translationScale, angleScale) {
  return angleScale;
}
function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {
  let totalRadian;
  let delay2;
  let radian;
  let currentGravity;
  let direction = new CubismVector2(0, 0);
  let velocity = new CubismVector2(0, 0);
  let force = new CubismVector2(0, 0);
  let newDirection = new CubismVector2(0, 0);
  strand[0].position = new CubismVector2(
    totalTranslation.x,
    totalTranslation.y
  );
  totalRadian = CubismMath.degreesToRadian(totalAngle);
  currentGravity = CubismMath.radianToDirection(totalRadian);
  currentGravity.normalize();
  for (let i2 = 1; i2 < strandCount; ++i2) {
    strand[i2].force = currentGravity.multiplyByScaler(strand[i2].acceleration).add(windDirection);
    strand[i2].lastPosition = new CubismVector2(
      strand[i2].position.x,
      strand[i2].position.y
    );
    delay2 = strand[i2].delay * deltaTimeSeconds * 30;
    direction = strand[i2].position.substract(strand[i2 - 1].position);
    radian = CubismMath.directionToRadian(strand[i2].lastGravity, currentGravity) / airResistance;
    direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);
    direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);
    strand[i2].position = strand[i2 - 1].position.add(direction);
    velocity = strand[i2].velocity.multiplyByScaler(delay2);
    force = strand[i2].force.multiplyByScaler(delay2).multiplyByScaler(delay2);
    strand[i2].position = strand[i2].position.add(velocity).add(force);
    newDirection = strand[i2].position.substract(strand[i2 - 1].position);
    newDirection.normalize();
    strand[i2].position = strand[i2 - 1].position.add(
      newDirection.multiplyByScaler(strand[i2].radius)
    );
    if (CubismMath.abs(strand[i2].position.x) < thresholdValue) {
      strand[i2].position.x = 0;
    }
    if (delay2 != 0) {
      strand[i2].velocity = strand[i2].position.substract(strand[i2].lastPosition);
      strand[i2].velocity = strand[i2].velocity.divisionByScalar(delay2);
      strand[i2].velocity = strand[i2].velocity.multiplyByScaler(
        strand[i2].mobility
      );
    }
    strand[i2].force = new CubismVector2(0, 0);
    strand[i2].lastGravity = new CubismVector2(
      currentGravity.x,
      currentGravity.y
    );
  }
}
function updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {
  let totalRadian;
  let currentGravity;
  let force = new CubismVector2(0, 0);
  strand[0].position = new CubismVector2(
    totalTranslation.x,
    totalTranslation.y
  );
  totalRadian = CubismMath.degreesToRadian(totalAngle);
  currentGravity = CubismMath.radianToDirection(totalRadian);
  currentGravity.normalize();
  for (let i2 = 1; i2 < strandCount; ++i2) {
    strand[i2].force = currentGravity.multiplyByScaler(strand[i2].acceleration).add(windDirection);
    strand[i2].lastPosition = new CubismVector2(
      strand[i2].position.x,
      strand[i2].position.y
    );
    strand[i2].velocity = new CubismVector2(0, 0);
    force = strand[i2].force;
    force.normalize();
    force = force.multiplyByScaler(strand[i2].radius);
    strand[i2].position = strand[i2 - 1].position.add(force);
    if (CubismMath.abs(strand[i2].position.x) < thresholdValue) {
      strand[i2].position.x = 0;
    }
    strand[i2].force = new CubismVector2(0, 0);
    strand[i2].lastGravity = new CubismVector2(
      currentGravity.x,
      currentGravity.y
    );
  }
}
function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {
  let outputScale;
  let value;
  let weight;
  outputScale = output.getScale(output.translationScale, output.angleScale);
  value = translation * outputScale;
  if (value < parameterValueMinimum) {
    if (value < output.valueBelowMinimum) {
      output.valueBelowMinimum = value;
    }
    value = parameterValueMinimum;
  } else if (value > parameterValueMaximum) {
    if (value > output.valueExceededMaximum) {
      output.valueExceededMaximum = value;
    }
    value = parameterValueMaximum;
  }
  weight = output.weight / MaximumWeight;
  if (weight >= 1) {
    parameterValue[0] = value;
  } else {
    value = parameterValue[0] * (1 - weight) + value * weight;
    parameterValue[0] = value;
  }
}
function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {
  let result = 0;
  const maxValue2 = CubismMath.max(parameterMaximum, parameterMinimum);
  if (maxValue2 < value) {
    value = maxValue2;
  }
  const minValue = CubismMath.min(parameterMaximum, parameterMinimum);
  if (minValue > value) {
    value = minValue;
  }
  const minNormValue = CubismMath.min(
    normalizedMinimum,
    normalizedMaximum
  );
  const maxNormValue = CubismMath.max(
    normalizedMinimum,
    normalizedMaximum
  );
  const middleNormValue = normalizedDefault;
  const middleValue = getDefaultValue(minValue, maxValue2);
  const paramValue = value - middleValue;
  switch (Math.sign(paramValue)) {
    case 1: {
      const nLength = maxNormValue - middleNormValue;
      const pLength = maxValue2 - middleValue;
      if (pLength != 0) {
        result = paramValue * (nLength / pLength);
        result += middleNormValue;
      }
      break;
    }
    case -1: {
      const nLength = minNormValue - middleNormValue;
      const pLength = minValue - middleValue;
      if (pLength != 0) {
        result = paramValue * (nLength / pLength);
        result += middleNormValue;
      }
      break;
    }
    case 0: {
      result = middleNormValue;
      break;
    }
  }
  return isInverted ? result : result * -1;
}
Live2DFactory.registerRuntime({
  version: 4,
  ready: cubism4Ready,
  test(source) {
    return source instanceof Cubism4ModelSettings || Cubism4ModelSettings.isValidJSON(source);
  },
  isValidMoc(modelData) {
    if (modelData.byteLength < 4) {
      return false;
    }
    const view = new Int8Array(modelData, 0, 4);
    return String.fromCharCode(...view) === "MOC3";
  },
  createModelSettings(json) {
    return new Cubism4ModelSettings(json);
  },
  createCoreModel(data, options) {
    const moc = CubismMoc.create(data, !!(options == null ? void 0 : options.checkMocConsistency));
    try {
      const model = moc.createModel();
      model.__moc = moc;
      return model;
    } catch (e2) {
      try {
        moc.release();
      } catch (e22) {
      }
      throw e2;
    }
  },
  createInternalModel(coreModel, settings2, options) {
    const model = new Cubism4InternalModel(coreModel, settings2, options);
    const coreModelWithMoc = coreModel;
    if (coreModelWithMoc.__moc) {
      model.__moc = coreModelWithMoc.__moc;
      delete coreModelWithMoc.__moc;
      model.once("destroy", releaseMoc);
    }
    return model;
  },
  createPhysics(coreModel, data) {
    return CubismPhysics.create(data);
  },
  createPose(coreModel, data) {
    return CubismPose.create(data);
  }
});
function releaseMoc() {
  var _a2;
  (_a2 = this.__moc) == null ? void 0 : _a2.release();
}
const DEFAULT_MODEL_STATE = {
  currentModel: null
};
const Live2DModelContext = reactExports.createContext(null);
const Live2DModelProvider = reactExports.memo(({ children }) => {
  const [currentModel, setCurrentModel] = reactExports.useState(
    DEFAULT_MODEL_STATE.currentModel
  );
  const updateModelState = reactExports.useCallback((updates) => {
    setCurrentModel((prev2) => {
      if (!prev2) return null;
      return Object.assign(prev2, updates);
    });
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      currentModel,
      setCurrentModel,
      updateModelState
    }),
    [currentModel, updateModelState]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DModelContext.Provider, { value: contextValue, children });
});
function useLive2DModel$1() {
  const context2 = reactExports.useContext(Live2DModelContext);
  if (!context2) {
    throw new Error("useLive2DModel must be used within a Live2DModelProvider");
  }
  return context2;
}
const SCALE_SPEED = 0.01;
const resetModelPosition = (model, width, height, initialXshift, initialYshift) => {
  if (!model) return;
  const initXshift = Number(initialXshift || 0);
  const initYshift = Number(initialYshift || 0);
  const targetX = (width - model.width) / 2 + initXshift;
  const targetY = (height - model.height) / 2 + initYshift;
  model.position.set(targetX, targetY);
};
const handleModelScale = (model, deltaY) => {
  const delta = deltaY > 0 ? -0.01 : SCALE_SPEED;
  const currentScale = model.scale.x;
  const newScale = currentScale + delta;
  const lerpFactor = 0.3;
  const smoothScale = currentScale + (newScale - currentScale) * lerpFactor;
  model.scale.set(smoothScale);
  return smoothScale;
};
const setModelSize = (model, kScale) => {
  if (!model || !kScale) return;
  const dpr = Number(window.devicePixelRatio || 1);
  model.scale.set(Number(kScale));
  if (model.filters) {
    model.filters.forEach((filter) => {
      if ("resolution" in filter) {
        Object.defineProperty(filter, "resolution", { value: dpr });
      }
    });
  }
};
const useLive2DResize = (containerRef, appRef, modelRef, modelInfo, isPet) => {
  const { updateModelScale } = useLive2DConfig();
  const scaleUpdateTimeout = reactExports.useRef(null);
  const lastScaleRef = reactExports.useRef(null);
  const handleWheel = reactExports.useCallback((e2) => {
    if (!modelRef.current || !modelInfo?.scrollToResize) return;
    e2.preventDefault();
    const smoothScale = handleModelScale(modelRef.current, e2.deltaY);
    const hasSignificantChange = !lastScaleRef.current || Math.abs(smoothScale - lastScaleRef.current) > 1e-4;
    if (hasSignificantChange) {
      if (scaleUpdateTimeout.current) {
        clearTimeout(scaleUpdateTimeout.current);
      }
      scaleUpdateTimeout.current = setTimeout(() => {
        updateModelScale(smoothScale);
        lastScaleRef.current = smoothScale;
      }, 500);
    }
  }, [modelRef, modelInfo?.scrollToResize, updateModelScale]);
  reactExports.useEffect(() => {
    const canvas = containerRef.current?.querySelector("canvas");
    if (canvas) {
      canvas.addEventListener("wheel", handleWheel, { passive: false });
      return () => canvas.removeEventListener("wheel", handleWheel);
    }
    return void 0;
  }, [handleWheel, containerRef]);
  reactExports.useEffect(() => {
    const observer = new ResizeObserver(() => {
      if (modelRef.current && appRef.current) {
        const { width, height } = isPet ? { width: window.innerWidth, height: window.innerHeight } : containerRef.current?.getBoundingClientRect() || {
          width: 0,
          height: 0
        };
        appRef.current.renderer.resize(width, height);
        appRef.current.renderer.clear();
        resetModelPosition(modelRef.current, width, height, modelInfo?.initialXshift, modelInfo?.initialYshift);
      }
    });
    if (containerRef.current) {
      observer.observe(containerRef.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [modelRef, containerRef, isPet, appRef]);
  reactExports.useEffect(() => () => {
    if (scaleUpdateTimeout.current) {
      clearTimeout(scaleUpdateTimeout.current);
    }
  }, []);
};
const useLive2DModel = ({
  isPet,
  modelInfo
}) => {
  const canvasRef = reactExports.useRef(null);
  const appRef = reactExports.useRef(null);
  const modelRef = reactExports.useRef(null);
  const containerRef = reactExports.useRef(null);
  const kScaleRef = reactExports.useRef(void 0);
  const { setCurrentModel } = useLive2DModel$1();
  const { setIsLoading } = useLive2DConfig();
  const loadingRef = reactExports.useRef(false);
  const { setAiState, aiState } = useAiState();
  const [isModelReady, setIsModelReady] = reactExports.useState(false);
  const { forceIgnoreMouse } = useForceIgnoreMouse();
  const cleanupModel = reactExports.useCallback(() => {
    if (modelRef.current) {
      modelRef.current.removeAllListeners();
      setCurrentModel(null);
      if (appRef.current) {
        appRef.current.stage.removeChild(modelRef.current);
        modelRef.current.destroy({
          children: true,
          texture: true,
          baseTexture: true
        });
        clearTextureCache();
        modelRef.current = null;
      }
    }
    setIsModelReady(false);
  }, [setCurrentModel]);
  const cleanupApp = reactExports.useCallback(() => {
    if (appRef.current) {
      if (modelRef.current) {
        cleanupModel();
      }
      appRef.current.stage.removeChildren();
      clearTextureCache();
      appRef.current.renderer.clear();
      appRef.current.destroy(true, {
        children: true,
        texture: true,
        baseTexture: true
      });
      destroyTextureCache();
      appRef.current = null;
    }
  }, [cleanupModel]);
  reactExports.useEffect(() => {
    if (!appRef.current && canvasRef.current) {
      const app = new Application({
        view: canvasRef.current,
        // cavas element to render on
        autoStart: true,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundAlpha: 0,
        // transparent background
        antialias: true,
        // antialiasing
        clearBeforeRender: true,
        // clear before render
        preserveDrawingBuffer: false,
        // don't preserve drawing buffer
        powerPreference: "high-performance",
        // high performance, use GPU if available
        resolution: window.devicePixelRatio || 1,
        autoDensity: true
        // auto adjust resolution to fit the screen
      });
      app.ticker.add(() => {
        if (app.renderer) {
          app.renderer.render(app.stage);
        }
      });
      appRef.current = app;
    }
    return () => {
      cleanupApp();
    };
  }, [cleanupApp]);
  const setupModel = reactExports.useCallback(
    async (model) => {
      if (!appRef.current || !modelInfo) return;
      if (modelRef.current) {
        modelRef.current.removeAllListeners();
        appRef.current.stage.removeChild(modelRef.current);
        modelRef.current.destroy({
          children: true,
          texture: true,
          baseTexture: true
        });
        clearTextureCache();
      }
      modelRef.current = model;
      setCurrentModel(model);
      appRef.current.stage.addChild(model);
      model.interactive = true;
      model.cursor = "pointer";
      setIsModelReady(true);
    },
    [setCurrentModel]
  );
  const setupModelSizeAndPosition = reactExports.useCallback(() => {
    if (!modelRef.current) return;
    setModelSize(modelRef.current, kScaleRef.current);
    const { width, height } = isPet ? { width: window.innerWidth, height: window.innerHeight } : containerRef.current?.getBoundingClientRect() || {
      width: 0,
      height: 0
    };
    resetModelPosition(modelRef.current, width, height, modelInfo?.initialXshift, modelInfo?.initialYshift);
  }, [modelInfo?.initialXshift, modelInfo?.initialYshift]);
  const loadModel = reactExports.useCallback(async () => {
    if (!modelInfo?.url || !appRef.current) return;
    if (loadingRef.current) return;
    console.log("Loading model:", modelInfo.url);
    try {
      loadingRef.current = true;
      setIsLoading(true);
      setAiState(AiStateEnum.LOADING);
      const model = await Live2DModel.from(modelInfo.url, {
        autoHitTest: true,
        autoFocus: modelInfo.pointerInteractive ?? false,
        autoUpdate: true,
        ticker: Ticker.shared,
        motionPreload: MotionPreloadStrategy.IDLE,
        idleMotionGroup: modelInfo.idleMotionGroupName
      });
      await setupModel(model);
    } catch (error) {
      console.error("Failed to load Live2D model:", error);
      toaster.create({
        title: `Failed to load Live2D model: ${error}`,
        type: "error",
        duration: 2e3
      });
    } finally {
      loadingRef.current = false;
      setIsLoading(false);
      setAiState(AiStateEnum.IDLE);
    }
  }, [
    modelInfo?.url,
    modelInfo?.pointerInteractive,
    setIsLoading,
    setupModel
  ]);
  const setupModelInteractions = reactExports.useCallback(
    (model) => {
      if (!model) return;
      model.removeAllListeners("pointerenter");
      model.removeAllListeners("pointerleave");
      model.removeAllListeners("rightdown");
      model.removeAllListeners("pointerdown");
      model.removeAllListeners("pointermove");
      model.removeAllListeners("pointerup");
      model.removeAllListeners("pointerupoutside");
      if (forceIgnoreMouse && isPet) {
        model.interactive = false;
        model.cursor = "default";
        return;
      }
      model.interactive = true;
      model.cursor = "pointer";
      let dragging = false;
      let pointerX = 0;
      let pointerY = 0;
      let isTap = false;
      const dragThreshold = 5;
      if (isPet) {
        model.on("pointerenter", () => {
          window.api?.updateComponentHover("live2d-model", true);
        });
        model.on("pointerleave", () => {
          if (!dragging) {
            window.api?.updateComponentHover("live2d-model", false);
          }
        });
        model.on("rightdown", (e2) => {
          e2.data.originalEvent.preventDefault();
          window.api.showContextMenu();
        });
      }
      model.on("pointerdown", (e2) => {
        if (e2.button === 0) {
          dragging = true;
          isTap = true;
          pointerX = e2.global.x - model.x;
          pointerY = e2.global.y - model.y;
        }
      });
      model.on("pointermove", (e2) => {
        if (dragging) {
          const newX = e2.global.x - pointerX;
          const newY = e2.global.y - pointerY;
          const dx = newX - model.x;
          const dy = newY - model.y;
          if (Math.hypot(dx, dy) > dragThreshold) {
            isTap = false;
          }
          model.position.x = newX;
          model.position.y = newY;
        }
      });
      model.on("pointerup", (e2) => {
        if (dragging) {
          dragging = false;
          if (isTap) {
            handleTapMotion(model, e2.global.x, e2.global.y);
          }
        }
      });
      model.on("pointerupoutside", () => {
        dragging = false;
      });
    },
    [isPet, forceIgnoreMouse]
  );
  const handleTapMotion = reactExports.useCallback(
    (model, x2, y2) => {
      if (!modelInfo?.tapMotions) return;
      console.log("handleTapMotion", modelInfo?.tapMotions);
      const localPos = model.toLocal(new Point(x2, y2));
      const hitAreas = model.hitTest(localPos.x, localPos.y);
      const foundMotion = hitAreas.find((area2) => {
        const motionGroup = modelInfo?.tapMotions?.[area2];
        if (motionGroup) {
          console.log(`Found motion group for area ${area2}:`, motionGroup);
          playRandomMotion(model, motionGroup);
          return true;
        }
        return false;
      });
      if (!foundMotion && Object.keys(modelInfo.tapMotions).length > 0) {
        const mergedMotions = getMergedMotionGroup(modelInfo.tapMotions);
        playRandomMotion(model, mergedMotions);
      }
    },
    [modelInfo?.tapMotions]
  );
  reactExports.useEffect(() => {
    if (aiState === AiStateEnum.IDLE) {
      console.log("defaultEmotion: ", modelInfo?.defaultEmotion);
      if (modelInfo?.defaultEmotion) {
        modelRef.current?.internalModel.motionManager.expressionManager?.setExpression(
          modelInfo.defaultEmotion
        );
      } else {
        modelRef.current?.internalModel.motionManager.expressionManager?.resetExpression();
      }
    }
  }, [modelRef.current, aiState, modelInfo?.defaultEmotion]);
  reactExports.useEffect(() => {
    if (modelInfo?.url) {
      loadModel();
    }
    return () => {
      cleanupModel();
    };
  }, [modelInfo?.url, modelInfo?.pointerInteractive, loadModel, cleanupModel]);
  reactExports.useEffect(() => {
    kScaleRef.current = modelInfo?.kScale;
  }, [modelInfo?.kScale]);
  reactExports.useEffect(() => {
    setupModelSizeAndPosition();
  }, [isModelReady, setupModelSizeAndPosition]);
  reactExports.useEffect(() => {
    if (modelRef.current && isModelReady) {
      setupModelInteractions(modelRef.current);
    }
  }, [isModelReady, setupModelInteractions, forceIgnoreMouse]);
  return {
    canvasRef,
    appRef,
    modelRef,
    containerRef
  };
};
const playRandomMotion = (model, motionGroup) => {
  if (!motionGroup || Object.keys(motionGroup).length === 0) return;
  const totalWeight = Object.values(motionGroup).reduce((sum, weight) => sum + weight, 0);
  let random = Math.random() * totalWeight;
  Object.entries(motionGroup).find(([motion, weight]) => {
    random -= weight;
    if (random <= 0) {
      const priority = audioTaskQueue.hasTask() ? MotionPriority.NORMAL : MotionPriority.FORCE;
      console.log(
        `Playing weighted motion: ${motion} (weight: ${weight}/${totalWeight}, priority: ${priority})`
      );
      model.motion(motion, void 0, priority);
      return true;
    }
    return false;
  });
};
const getMergedMotionGroup = (tapMotions) => {
  const mergedMotions = {};
  Object.values(tapMotions).flatMap((motionGroup) => Object.entries(motionGroup)).reduce((acc, [motion, weight]) => {
    if (!acc[motion]) {
      acc[motion] = { total: 0, count: 0 };
    }
    acc[motion].total += weight;
    acc[motion].count += 1;
    return acc;
  }, mergedMotions);
  return Object.entries(mergedMotions).reduce(
    (acc, [motion, { total, count }]) => ({
      ...acc,
      [motion]: total / count
    }),
    {}
  );
};
const DEFAULT_HISTORY = {
  messages: [],
  historyList: [],
  currentHistoryUid: null,
  fullResponse: ""
};
const ChatHistoryContext = reactExports.createContext(null);
function ChatHistoryProvider({ children }) {
  const [messages2, setMessages] = reactExports.useState(DEFAULT_HISTORY.messages);
  const [historyList, setHistoryList] = reactExports.useState(
    DEFAULT_HISTORY.historyList
  );
  const [currentHistoryUid, setCurrentHistoryUid] = reactExports.useState(
    DEFAULT_HISTORY.currentHistoryUid
  );
  const [fullResponse, setFullResponse] = reactExports.useState(DEFAULT_HISTORY.fullResponse);
  const [forceNewMessage, setForceNewMessage] = reactExports.useState(false);
  const appendHumanMessage = reactExports.useCallback((content) => {
    const newMessage = {
      id: Date.now().toString(),
      content,
      role: "human",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    setMessages((prevMessages) => [...prevMessages, newMessage]);
  }, []);
  const appendAIMessage = reactExports.useCallback((content, name2, avatar) => {
    setMessages((prevMessages) => {
      const lastMessage = prevMessages[prevMessages.length - 1];
      if (forceNewMessage || !lastMessage || lastMessage.role !== "ai") {
        setForceNewMessage(false);
        return [...prevMessages, {
          id: Date.now().toString(),
          content,
          role: "ai",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          name: name2,
          avatar
        }];
      }
      return [
        ...prevMessages.slice(0, -1),
        {
          ...lastMessage,
          content: lastMessage.content + content,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
    });
  }, [forceNewMessage, setForceNewMessage]);
  const updateHistoryList = reactExports.useCallback(
    (uid2, latestMessage) => {
      if (!uid2) {
        console.error("updateHistoryList: uid is null");
      }
      if (!currentHistoryUid) {
        console.error("updateHistoryList: currentHistoryUid is null");
      }
      setHistoryList((prevList) => prevList.map((history) => {
        if (history.uid === uid2) {
          return {
            ...history,
            latest_message: latestMessage ? {
              content: latestMessage.content,
              role: latestMessage.role,
              timestamp: latestMessage.timestamp
            } : null,
            timestamp: latestMessage?.timestamp || history.timestamp
          };
        }
        return history;
      }));
    },
    [currentHistoryUid]
  );
  const appendResponse = reactExports.useCallback((text) => {
    setFullResponse((prev2) => prev2 + (text || ""));
  }, []);
  const clearResponse = reactExports.useCallback(() => {
    setFullResponse(DEFAULT_HISTORY.fullResponse);
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      messages: messages2,
      historyList,
      currentHistoryUid,
      appendHumanMessage,
      appendAIMessage,
      setMessages,
      setHistoryList,
      setCurrentHistoryUid,
      updateHistoryList,
      fullResponse,
      setFullResponse,
      appendResponse,
      clearResponse,
      setForceNewMessage
    }),
    [
      messages2,
      historyList,
      currentHistoryUid,
      appendHumanMessage,
      appendAIMessage,
      updateHistoryList,
      fullResponse,
      appendResponse,
      clearResponse,
      setForceNewMessage
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryContext.Provider, { value: contextValue, children });
}
function useChatHistory() {
  const context2 = reactExports.useContext(ChatHistoryContext);
  if (!context2) {
    throw new Error("useChatHistory must be used within a ChatHistoryProvider");
  }
  return context2;
}
const useInterrupt = () => {
  const { aiState, setAiState } = useAiState();
  const { sendMessage } = useWebSocket();
  const { fullResponse, clearResponse } = useChatHistory();
  const { currentModel } = useLive2DModel$1();
  const { subtitleText, setSubtitleText } = useSubtitle();
  const interrupt = (sendSignal = true) => {
    if (aiState !== "thinking-speaking") return;
    console.log("Interrupting conversation chain");
    if (sendSignal) {
      sendMessage({
        type: "interrupt-signal",
        text: fullResponse
      });
    }
    setAiState("interrupted");
    audioTaskQueue.clearQueue();
    if (currentModel) {
      currentModel.stopSpeaking();
    } else {
      console.error("Live2D model is not initialized");
    }
    clearResponse();
    if (subtitleText === "Thinking...") {
      setSubtitleText("");
    }
    console.log("Interrupted!");
  };
  return { interrupt };
};
const useAudioTask = () => {
  const { aiState, backendSynthComplete, setBackendSynthComplete } = useAiState();
  const { setSubtitleText } = useSubtitle();
  const { appendResponse, appendAIMessage } = useChatHistory();
  const { currentModel } = useLive2DModel$1();
  const { sendMessage } = useWebSocket();
  const stateRef = reactExports.useRef({
    aiState,
    currentModel,
    setSubtitleText,
    appendResponse,
    appendAIMessage
  });
  stateRef.current = {
    aiState,
    currentModel,
    setSubtitleText,
    appendResponse,
    appendAIMessage
  };
  const handleAudioPlayback = (options) => new Promise((resolve2) => {
    const {
      aiState: currentAiState,
      currentModel: model,
      setSubtitleText: updateSubtitle,
      appendResponse: appendText,
      appendAIMessage: appendAI
    } = stateRef.current;
    if (currentAiState === "interrupted") {
      console.error("Audio playback blocked. State:", currentAiState);
      resolve2();
      return;
    }
    const { audioBase64, displayText, expressions, forwarded } = options;
    if (displayText) {
      appendText(displayText.text);
      appendAI(displayText.text, displayText.name, displayText.avatar);
      if (audioBase64) {
        updateSubtitle(displayText.text);
      }
      if (!forwarded) {
        sendMessage({
          type: "audio-play-start",
          display_text: displayText,
          forwarded: true
        });
      }
    }
    if (!model) {
      console.error("Model not initialized");
      resolve2();
      return;
    }
    try {
      if (expressions?.[0] !== void 0) {
        model.expression(expressions[0]);
      }
      let isFinished = false;
      if (audioBase64) {
        model.speak(`data:audio/wav;base64,${audioBase64}`, {
          onFinish: () => {
            console.log("Voiceline is over");
            isFinished = true;
            resolve2();
          },
          onError: (error) => {
            console.error("Audio playback error:", error);
            isFinished = true;
            resolve2();
          }
        });
      } else {
        resolve2();
      }
      const checkFinished = () => {
        if (!isFinished) {
          setTimeout(checkFinished, 100);
        }
      };
      checkFinished();
    } catch (error) {
      console.error("Speak function error:", error);
      toaster.create({
        title: `Speak function error: ${error}`,
        type: "error",
        duration: 2e3
      });
      resolve2();
    }
  });
  reactExports.useEffect(() => {
    let isMounted = true;
    const handleComplete = async () => {
      await audioTaskQueue.waitForCompletion();
      if (isMounted && backendSynthComplete) {
        sendMessage({ type: "frontend-playback-complete" });
        setBackendSynthComplete(false);
      }
    };
    handleComplete();
    return () => {
      isMounted = false;
    };
  }, [backendSynthComplete, sendMessage, setBackendSynthComplete]);
  const addAudioTask = async (options) => {
    const { aiState: currentState } = stateRef.current;
    if (currentState === "interrupted") {
      console.log("Skipping audio task due to interrupted state");
      return;
    }
    console.log(`Adding audio task ${options.displayText?.text} to queue`);
    audioTaskQueue.addTask(() => handleAudioPlayback(options));
  };
  return {
    addAudioTask,
    appendResponse
  };
};
const useLive2DDebug = () => {
  const { baseUrl, wsUrl } = useWebSocket();
  const debugInfo = {
    currentLocation: window.location.href,
    hostname: window.location.hostname,
    protocol: window.location.protocol,
    wsUrl,
    baseUrl,
    isItcometrueAcademy: window.location.hostname === "itcometrue.academy"
  };
  const testModelUrl = (modelPath) => {
    const fullUrl = modelPath.startsWith("http") ? modelPath : baseUrl + modelPath;
    console.log("Testing model URL:", {
      originalPath: modelPath,
      fullUrl,
      baseUrl
    });
    return fullUrl;
  };
  const testLive2DConnection = async () => {
    console.group("🔍 Live2D Connection Test");
    console.log("Debug Info:", debugInfo);
    const testPaths = [
      "/live2d-models/mao_pro/mao_pro.model3.json",
      "/live2d-models/mao_pro",
      "live2d-models/mao_pro/mao_pro.model3.json"
    ];
    for (const path2 of testPaths) {
      const fullUrl = testModelUrl(path2);
      try {
        const response = await fetch(fullUrl, { method: "HEAD" });
        console.log(`✅ ${path2} -> ${response.status}`, fullUrl);
      } catch (error) {
        console.log(`❌ ${path2} -> Error`, fullUrl, error);
      }
    }
    console.groupEnd();
  };
  return {
    debugInfo,
    testModelUrl,
    testLive2DConnection
  };
};
const Live2D$1 = reactExports.memo(({ isPet }) => {
  const { modelInfo, isLoading } = useLive2DConfig();
  const { forceIgnoreMouse } = useForceIgnoreMouse();
  const { debugInfo, testLive2DConnection } = useLive2DDebug();
  useIpcHandlers({ isPet });
  const { canvasRef, appRef, modelRef, containerRef } = useLive2DModel({
    isPet,
    modelInfo
  });
  useLive2DResize(containerRef, appRef, modelRef, modelInfo, isPet);
  useInterrupt();
  useAudioTask();
  reactExports.useEffect(() => {
    if (modelRef.current) {
      window.live2d = {
        expression: (name2) => modelRef.current?.expression(name2),
        setExpression: (name2) => {
          if (name2 !== void 0) {
            modelRef.current?.internalModel.motionManager.expressionManager?.setExpression(name2);
          }
        },
        setRandomExpression: () => modelRef.current?.internalModel.motionManager.expressionManager?.setRandomExpression(),
        getExpressions: () => modelRef.current?.internalModel.motionManager.expressionManager?.definitions.map((d2) => d2.name),
        // デバッグ用関数を追加
        debug: () => {
          console.log("Live2D Debug Info:", debugInfo);
          testLive2DConnection();
        }
      };
    }
    return () => {
      delete window.live2d;
    };
  }, [modelRef.current, debugInfo, testLive2DConnection]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: containerRef,
      style: {
        width: isPet ? "100vw" : "100%",
        height: isPet ? "100vh" : "100%",
        pointerEvents: isPet && forceIgnoreMouse ? "none" : "auto",
        overflow: "hidden",
        opacity: isLoading ? 0 : 1,
        transition: "opacity 0.3s ease-in-out"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "canvas",
        {
          id: "canvas",
          ref: canvasRef,
          style: {
            width: "100%",
            height: "100%",
            pointerEvents: isPet && forceIgnoreMouse ? "none" : "auto",
            display: "block"
          }
        }
      )
    }
  );
});
Live2D$1.displayName = "Live2D";
function Canvas() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Background, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...canvasStyles.canvas.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Live2D$1, { isPet: false }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WebSocketStatus, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Subtitle, {})
  ] }) });
}
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && /* @__PURE__ */ React.createContext(DefaultContext);
var _excluded$x = ["attr", "size", "title"];
function _objectWithoutProperties$x(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$x(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$x(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends$w() {
  _extends$w = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$w.apply(this, arguments);
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$g(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$f(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$f(t2) {
  var i2 = _toPrimitive$f(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$f(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function Tree2Element(tree) {
  return tree && tree.map((node2, i2) => /* @__PURE__ */ React.createElement(node2.tag, _objectSpread$2({
    key: i2
  }, node2.attr), Tree2Element(node2.child)));
}
function GenIcon(data) {
  return (props) => /* @__PURE__ */ React.createElement(IconBase, _extends$w({
    attr: _objectSpread$2({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = (conf) => {
    var {
      attr,
      size: size2,
      title
    } = props, svgProps = _objectWithoutProperties$x(props, _excluded$x);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return /* @__PURE__ */ React.createElement("svg", _extends$w({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: _objectSpread$2(_objectSpread$2({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /* @__PURE__ */ React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? /* @__PURE__ */ React.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}
function FiCamera(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" }, "child": [] }, { "tag": "circle", "attr": { "cx": "12", "cy": "13", "r": "4" }, "child": [] }] })(props);
}
function FiChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "6 9 12 15 18 9" }, "child": [] }] })(props);
}
function FiChevronLeft(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "15 18 9 12 15 6" }, "child": [] }] })(props);
}
function FiChevronsDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "7 13 12 18 17 13" }, "child": [] }, { "tag": "polyline", "attr": { "points": "7 6 12 11 17 6" }, "child": [] }] })(props);
}
function FiClock(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" }, "child": [] }, { "tag": "polyline", "attr": { "points": "12 6 12 12 16 14" }, "child": [] }] })(props);
}
function FiMaximize2(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "15 3 21 3 21 9" }, "child": [] }, { "tag": "polyline", "attr": { "points": "9 21 3 21 3 15" }, "child": [] }, { "tag": "line", "attr": { "x1": "21", "y1": "3", "x2": "14", "y2": "10" }, "child": [] }, { "tag": "line", "attr": { "x1": "3", "y1": "21", "x2": "10", "y2": "14" }, "child": [] }] })(props);
}
function FiMinimize2(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "4 14 10 14 10 20" }, "child": [] }, { "tag": "polyline", "attr": { "points": "20 10 14 10 14 4" }, "child": [] }, { "tag": "line", "attr": { "x1": "14", "y1": "10", "x2": "21", "y2": "3" }, "child": [] }, { "tag": "line", "attr": { "x1": "3", "y1": "21", "x2": "10", "y2": "14" }, "child": [] }] })(props);
}
function FiMinus(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "5", "y1": "12", "x2": "19", "y2": "12" }, "child": [] }] })(props);
}
function FiMonitor(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "x": "2", "y": "3", "width": "20", "height": "14", "rx": "2", "ry": "2" }, "child": [] }, { "tag": "line", "attr": { "x1": "8", "y1": "21", "x2": "16", "y2": "21" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "y1": "17", "x2": "12", "y2": "21" }, "child": [] }] })(props);
}
function FiPlus(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "12", "y1": "5", "x2": "12", "y2": "19" }, "child": [] }, { "tag": "line", "attr": { "x1": "5", "y1": "12", "x2": "19", "y2": "12" }, "child": [] }] })(props);
}
function FiSettings(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "3" }, "child": [] }, { "tag": "path", "attr": { "d": "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" }, "child": [] }] })(props);
}
function FiTrash2(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "3 6 5 6 21 6" }, "child": [] }, { "tag": "path", "attr": { "d": "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }, "child": [] }, { "tag": "line", "attr": { "x1": "10", "y1": "11", "x2": "10", "y2": "17" }, "child": [] }, { "tag": "line", "attr": { "x1": "14", "y1": "11", "x2": "14", "y2": "17" }, "child": [] }] })(props);
}
function FiUsers(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" }, "child": [] }, { "tag": "circle", "attr": { "cx": "9", "cy": "7", "r": "4" }, "child": [] }, { "tag": "path", "attr": { "d": "M23 21v-2a4 4 0 0 0-3-3.87" }, "child": [] }, { "tag": "path", "attr": { "d": "M16 3.13a4 4 0 0 1 0 7.75" }, "child": [] }] })(props);
}
function FiX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "18", "y1": "6", "x2": "6", "y2": "18" }, "child": [] }, { "tag": "line", "attr": { "x1": "6", "y1": "6", "x2": "18", "y2": "18" }, "child": [] }] })(props);
}
const isElectron$2 = window.api !== void 0;
const commonStyles = {
  scrollbar: {
    "&::-webkit-scrollbar": {
      width: "4px"
    },
    "&::-webkit-scrollbar-track": {
      bg: "whiteAlpha.100",
      borderRadius: "full"
    },
    "&::-webkit-scrollbar-thumb": {
      bg: "whiteAlpha.300",
      borderRadius: "full"
    }
  },
  panel: {
    border: "1px solid",
    borderColor: "whiteAlpha.200",
    borderRadius: "lg",
    bg: "blackAlpha.400"
  },
  title: {
    fontSize: "lg",
    fontWeight: "semibold",
    color: "white",
    mb: 4
  }
};
const sidebarStyles = {
  sidebar: {
    container: (isCollapsed) => ({
      position: "absolute",
      left: 0,
      top: 0,
      height: "100%",
      width: "440px",
      bg: "gray.900",
      transform: isCollapsed ? "translateX(calc(-100% + 24px))" : "translateX(0)",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      display: "flex",
      flexDirection: "column",
      gap: 4,
      overflow: isCollapsed ? "visible" : "hidden",
      pb: "4"
    }),
    toggleButton: {
      position: "absolute",
      right: 0,
      top: 0,
      width: "24px",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      color: "whiteAlpha.700",
      _hover: { color: "white" },
      bg: "transparent",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      zIndex: 1
    },
    content: {
      flex: 1,
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: 4,
      overflow: "hidden"
    },
    header: {
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: 1,
      p: 2
    }
  },
  chatHistoryPanel: {
    container: {
      flex: 1,
      overflow: "hidden",
      px: 4,
      display: "flex",
      flexDirection: "column"
    },
    title: commonStyles.title,
    messageList: {
      ...commonStyles.panel,
      p: 4,
      width: "97%",
      flex: 1,
      overflowY: "auto",
      css: {
        ...commonStyles.scrollbar,
        scrollPaddingBottom: "1rem"
      },
      display: "flex",
      flexDirection: "column",
      gap: 2
    }
  },
  systemLogPanel: {
    container: {
      width: "100%",
      overflow: "hidden",
      px: 4,
      minH: "200px",
      marginTop: "auto"
    },
    title: commonStyles.title,
    logList: {
      ...commonStyles.panel,
      p: 4,
      height: "200px",
      overflowY: "auto",
      fontFamily: "mono",
      css: commonStyles.scrollbar
    },
    entry: {
      p: 2,
      borderRadius: "md",
      _hover: {
        bg: "whiteAlpha.50"
      }
    }
  },
  chatBubble: {
    container: {
      display: "flex",
      position: "relative",
      _hover: {
        bg: "whiteAlpha.50"
      },
      py: 1,
      px: 2,
      borderRadius: "md"
    },
    message: {
      maxW: "90%",
      bg: "transparent",
      p: 2
    },
    text: {
      fontSize: "xs",
      color: "whiteAlpha.900"
    },
    dot: {
      position: "absolute",
      w: "2",
      h: "2",
      borderRadius: "full",
      bg: "white",
      top: "2"
    }
  },
  historyDrawer: {
    listContainer: {
      flex: 1,
      overflowY: "auto",
      px: 4,
      py: 2,
      css: commonStyles.scrollbar
    },
    historyItem: {
      mb: 4,
      p: 3,
      borderRadius: "md",
      bg: "whiteAlpha.50",
      cursor: "pointer",
      transition: "all 0.2s",
      _hover: {
        bg: "whiteAlpha.100"
      }
    },
    historyItemSelected: {
      bg: "whiteAlpha.200",
      borderLeft: "3px solid",
      borderColor: "blue.500"
    },
    historyHeader: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 2
    },
    timestamp: {
      fontSize: "sm",
      color: "whiteAlpha.700",
      fontFamily: "mono"
    },
    deleteButton: {
      variant: "ghost",
      colorScheme: "red",
      size: "sm",
      color: "red.300",
      opacity: 0.8,
      _hover: {
        opacity: 1,
        bg: "whiteAlpha.200"
      }
    },
    messagePreview: {
      fontSize: "sm",
      color: "whiteAlpha.900",
      noOfLines: 2,
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    drawer: {
      content: {
        background: "var(--chakra-colors-gray-900)",
        maxWidth: "440px",
        marginTop: isElectron$2 ? "30px" : "0",
        height: isElectron$2 ? "calc(100vh - 30px)" : "100vh"
      },
      title: {
        color: "white"
      },
      closeButton: {
        color: "white"
      },
      actionButton: {
        color: "white",
        borderColor: "white",
        variant: "outline"
      }
    }
  },
  cameraPanel: {
    container: {
      width: "97%",
      overflow: "hidden",
      px: 4,
      minH: "240px"
    },
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 4
    },
    title: commonStyles.title,
    videoContainer: {
      ...commonStyles.panel,
      width: "100%",
      height: "240px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      transition: "all 0.2s"
    },
    video: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      transform: "scaleX(-1)",
      borderRadius: "8px",
      display: "block"
    }
  },
  screenPanel: {
    container: {
      width: "97%",
      overflow: "hidden",
      px: 4,
      minH: "240px"
    },
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 4
    },
    title: commonStyles.title,
    screenContainer: {
      ...commonStyles.panel,
      width: "100%",
      height: "240px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      transition: "all 0.2s"
    },
    video: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "8px",
      display: "block"
    }
  },
  bottomTab: {
    container: {
      width: "97%",
      px: 4,
      position: "relative",
      zIndex: 0
    },
    tabs: {
      width: "100%",
      bg: "whiteAlpha.50",
      borderRadius: "lg",
      p: "1"
    },
    list: {
      borderBottom: "none",
      gap: "2"
    },
    trigger: {
      color: "whiteAlpha.700",
      display: "flex",
      alignItems: "center",
      gap: 2,
      px: 3,
      py: 2,
      borderRadius: "md",
      _hover: {
        color: "white",
        bg: "whiteAlpha.50"
      },
      _selected: {
        color: "white",
        bg: "whiteAlpha.200"
      }
    }
  },
  groupDrawer: {
    section: {
      mb: 6
    },
    sectionTitle: {
      fontSize: "lg",
      fontWeight: "semibold",
      color: "white",
      mb: 3
    },
    inviteBox: {
      display: "flex",
      gap: 2
    },
    input: {
      bg: "whiteAlpha.100",
      border: "none",
      color: "white",
      _placeholder: {
        color: "whiteAlpha.400"
      }
    },
    memberList: {
      display: "flex",
      flexDirection: "column",
      gap: 2
    },
    memberItem: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      p: 2,
      borderRadius: "md",
      bg: "whiteAlpha.100"
    },
    memberText: {
      color: "white",
      fontSize: "sm"
    },
    removeButton: {
      size: "sm",
      color: "red.300",
      bg: "transparent",
      _hover: {
        bg: "whiteAlpha.200"
      }
    },
    button: {
      color: "white",
      bg: "whiteAlpha.100",
      _hover: {
        bg: "whiteAlpha.200"
      }
    },
    clipboardButton: {
      color: "white",
      bg: "transparent",
      _hover: {
        bg: "whiteAlpha.200"
      },
      size: "sm"
    }
  }
};
const chatPanelStyles = css$2`
  .cs-message-list {
    background: var(--chakra-colors-gray-900) !important;
    padding: var(--chakra-space-4);
  }
  
  .cs-message {
    margin: 12px 0;
    padding-top: 20px !important;
  }

  .cs-message__content {
    background-color: var(--chakra-colors-gray-700) !important;
    border-radius: var(--chakra-radii-md);
    padding: 8px !important;
    color: var(--chakra-colors-white) !important;
    font-size: 0.95rem !important;
    line-height: 1.5 !important;
    margin-top: 4px !important;
  }

  .cs-message__text {
    padding: 8px 0 !important;
  }

  .cs-message--outgoing .cs-message__content {
    background-color: var(--chakra-colors-gray-600) !important;
  }

  .cs-chat-container {
    background: transparent !important;
    border: 1px solid var(--chakra-colors-whiteAlpha-200);
    border-radius: var(--chakra-radii-lg);
    padding: var(--chakra-space-2);
  }

  .cs-main-container {
    border: none !important;
    background: transparent !important;
    width: calc(100% - 24px) !important;
    margin-left: 0 !important;
  }

  .cs-message__sender {
    position: absolute !important;
    top: 0 !important;
    left: 36px !important;
    font-size: 0.875rem !important;
    font-weight: 600 !important;
    color: var(--chakra-colors-whiteAlpha-900) !important;
  }

  .cs-message__content-wrapper {
    max-width: 80%;
    margin: 0 8px;
  }

  .cs-avatar {
    background-color: var(--chakra-colors-blue-500) !important;
    color: white !important;
    width: 28px !important;
    height: 28px !important;
    font-size: 14px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 50% !important;
  }

  .cs-message--outgoing .cs-avatar {
    background-color: var(--chakra-colors-green-500) !important;
  }

  .cs-message__header {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
`;
function LuBell(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9" }, "child": [] }, { "tag": "path", "attr": { "d": "M10.3 21a1.94 1.94 0 0 0 3.4 0" }, "child": [] }] })(props);
}
function LuCheck(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M20 6 9 17l-5-5" }, "child": [] }] })(props);
}
function LuClipboard(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "width": "8", "height": "4", "x": "8", "y": "2", "rx": "1", "ry": "1" }, "child": [] }, { "tag": "path", "attr": { "d": "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }, "child": [] }] })(props);
}
function LuHand(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2" }, "child": [] }, { "tag": "path", "attr": { "d": "M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2" }, "child": [] }, { "tag": "path", "attr": { "d": "M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8" }, "child": [] }, { "tag": "path", "attr": { "d": "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" }, "child": [] }] })(props);
}
function LuLink(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }, "child": [] }, { "tag": "path", "attr": { "d": "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }, "child": [] }] })(props);
}
function LuMicOff(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "2", "x2": "22", "y1": "2", "y2": "22" }, "child": [] }, { "tag": "path", "attr": { "d": "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2" }, "child": [] }, { "tag": "path", "attr": { "d": "M5 10v2a7 7 0 0 0 12 5" }, "child": [] }, { "tag": "path", "attr": { "d": "M15 9.34V5a3 3 0 0 0-5.68-1.33" }, "child": [] }, { "tag": "path", "attr": { "d": "M9 9v3a3 3 0 0 0 5.12 2.12" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "x2": "12", "y1": "19", "y2": "22" }, "child": [] }] })(props);
}
function LuMic(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z" }, "child": [] }, { "tag": "path", "attr": { "d": "M19 10v2a7 7 0 0 1-14 0v-2" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "x2": "12", "y1": "19", "y2": "22" }, "child": [] }] })(props);
}
function LuSend(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" }, "child": [] }, { "tag": "path", "attr": { "d": "m21.854 2.147-10.94 10.939" }, "child": [] }] })(props);
}
function LuX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M18 6 6 18" }, "child": [] }, { "tag": "path", "attr": { "d": "m6 6 12 12" }, "child": [] }] })(props);
}
const CloseButton = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { variant: "ghost", "aria-label": "Close", ref: ref2, ...props, children: props.children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(LuX, {}) }));
const isElectron$1 = window.api !== void 0;
const settingStyles = {
  settingUI: {
    container: {
      width: "100%",
      height: "100%",
      p: 4,
      gap: 4,
      position: "relative",
      overflowY: "auto",
      css: {
        "&::-webkit-scrollbar": {
          width: "4px"
        },
        "&::-webkit-scrollbar-track": {
          bg: "whiteAlpha.100",
          borderRadius: "full"
        },
        "&::-webkit-scrollbar-thumb": {
          bg: "whiteAlpha.300",
          borderRadius: "full"
        }
      }
    },
    header: {
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: 1
    },
    title: {
      ml: 4,
      fontSize: "lg",
      fontWeight: "bold"
    },
    tabs: {
      root: {
        width: "100%",
        variant: "plain",
        colorPalette: "gray"
      },
      content: {},
      trigger: {
        color: "whiteAlpha.600",
        _selected: {
          color: "white"
        },
        _hover: {
          color: "white"
        }
      },
      list: {
        display: "flex",
        justifyContent: "flex-start",
        width: "100%",
        borderBottom: "1px solid",
        borderColor: "whiteAlpha.200",
        mb: 4,
        pl: 0
      }
    },
    footer: {
      width: "100%",
      display: "flex",
      justifyContent: "flex-end",
      gap: 2,
      mt: "auto",
      pt: 4,
      borderTop: "1px solid",
      borderColor: "whiteAlpha.200"
    },
    drawerContent: {
      bg: "gray.900",
      maxWidth: "440px",
      height: isElectron$1 ? "calc(100vh - 30px)" : "100vh",
      borderLeft: "1px solid",
      borderColor: "whiteAlpha.200"
    },
    drawerHeader: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "100%",
      position: "relative",
      px: 6,
      py: 4
    },
    drawerTitle: {
      color: "white",
      fontSize: "lg",
      fontWeight: "semibold"
    },
    closeButton: {
      position: "absolute",
      right: 1,
      top: 1,
      color: "white"
    }
  },
  general: {
    container: {
      align: "stretch",
      gap: 6,
      p: 4
    },
    field: {
      label: {
        color: "whiteAlpha.800"
      }
    },
    select: {
      root: {
        colorPalette: "gray",
        bg: "gray.800"
      },
      trigger: {
        bg: "gray.800"
      }
    },
    input: {
      bg: "gray.800"
    },
    buttonGroup: {
      gap: 4,
      width: "100%"
    },
    button: {
      width: "50%",
      variant: "outline",
      bg: "blue",
      color: "white",
      _hover: {
        bg: "whiteAlpha.300"
      }
    },
    fieldLabel: {
      fontSize: "14px",
      color: "gray.600"
    }
  },
  common: {
    field: {
      orientation: "horizontal"
    },
    fieldLabel: {
      fontSize: "sm",
      color: "whiteAlpha.800",
      whiteSpace: "nowrap"
    },
    switch: {
      size: "md",
      colorPalette: "blue",
      variant: "solid"
    },
    numberInput: {
      root: {
        pattern: "[0-9]*\\.?[0-9]*",
        inputMode: "decimal"
      },
      input: {
        bg: "whiteAlpha.100",
        borderColor: "whiteAlpha.200",
        _hover: {
          bg: "whiteAlpha.200"
        }
      }
    },
    container: {
      gap: 8,
      maxW: "sm",
      css: { "--field-label-width": "120px" }
    },
    input: {
      bg: "whiteAlpha.100",
      borderColor: "whiteAlpha.200",
      _hover: {
        bg: "whiteAlpha.200"
      }
    }
  },
  live2d: {
    container: {
      gap: 8,
      maxW: "sm",
      css: { "--field-label-width": "120px" }
    },
    emotionMap: {
      title: {
        fontWeight: "bold",
        mb: 4
      },
      entry: {
        mb: 2
      },
      button: {
        colorPalette: "blue",
        mt: 2
      },
      deleteButton: {
        colorPalette: "red"
      }
    }
  }
};
const useGeneralSettings = ({
  bgUrlContext,
  confName,
  setConfName,
  baseUrl,
  wsUrl,
  onWsUrlChange,
  onBaseUrlChange,
  onSave,
  onCancel
}) => {
  const { showSubtitle, setShowSubtitle } = useSubtitle();
  const { setUseCameraBackground } = bgUrlContext || {};
  const { startBackgroundCamera, stopBackgroundCamera } = useCamera();
  const { configFiles, getFilenameByName } = useConfig();
  const { switchCharacter } = useSwitchCharacter();
  const getCurrentBgKey = () => {
    if (!bgUrlContext?.backgroundUrl) return [];
    const currentBgUrl = bgUrlContext.backgroundUrl;
    const path2 = currentBgUrl.replace(baseUrl, "");
    return path2.startsWith("/bg/") ? [path2] : [];
  };
  const initialSettings = {
    language: ["en"],
    customBgUrl: !bgUrlContext?.backgroundUrl?.includes("/bg/") ? bgUrlContext?.backgroundUrl || "" : "",
    selectedBgUrl: getCurrentBgKey(),
    backgroundUrl: bgUrlContext?.backgroundUrl || "",
    selectedCharacterPreset: [],
    useCameraBackground: bgUrlContext?.useCameraBackground || false,
    wsUrl: wsUrl || defaultWsUrl,
    baseUrl: baseUrl || defaultBaseUrl,
    showSubtitle
  };
  const [settings2, setSettings] = reactExports.useState(initialSettings);
  const [originalSettings, setOriginalSettings] = reactExports.useState(initialSettings);
  const originalConfName = confName;
  reactExports.useEffect(() => {
    setShowSubtitle(settings2.showSubtitle);
    const newBgUrl = settings2.customBgUrl || settings2.selectedBgUrl[0];
    if (newBgUrl && bgUrlContext) {
      const fullUrl = newBgUrl.startsWith("http") ? newBgUrl : `${baseUrl}${newBgUrl}`;
      bgUrlContext.setBackgroundUrl(fullUrl);
    }
    onWsUrlChange(settings2.wsUrl);
    onBaseUrlChange(settings2.baseUrl);
  }, [settings2]);
  reactExports.useEffect(() => {
    if (confName) {
      const newSettings = {
        ...settings2,
        selectedCharacterPreset: [confName]
      };
      setSettings(newSettings);
      setOriginalSettings(newSettings);
    }
  }, [confName]);
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(() => {
      handleSave();
    });
    const cleanupCancel = onCancel(() => {
      handleCancel();
    });
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel]);
  const handleSettingChange = (key, value) => {
    setSettings((prev2) => ({ ...prev2, [key]: value }));
    if (key === "wsUrl") {
      onWsUrlChange(value);
    }
    if (key === "baseUrl") {
      onBaseUrlChange(value);
    }
  };
  const handleSave = () => {
    setOriginalSettings(settings2);
  };
  const handleCancel = () => {
    setSettings(originalSettings);
    setShowSubtitle(originalSettings.showSubtitle);
    if (bgUrlContext) {
      bgUrlContext.setBackgroundUrl(originalSettings.backgroundUrl);
      bgUrlContext.setUseCameraBackground(originalSettings.useCameraBackground);
    }
    onWsUrlChange(originalSettings.wsUrl);
    onBaseUrlChange(originalSettings.baseUrl);
    if (originalConfName) {
      setConfName(originalConfName);
    }
    if (originalSettings.useCameraBackground) {
      startBackgroundCamera();
    } else {
      stopBackgroundCamera();
    }
  };
  const handleCharacterPresetChange = (value) => {
    const selectedFilename = value[0];
    const selectedConfig = configFiles.find((config2) => config2.filename === selectedFilename);
    const currentFilename = confName ? getFilenameByName(confName) : "";
    handleSettingChange("selectedCharacterPreset", value);
    if (currentFilename === selectedFilename) {
      return;
    }
    if (selectedConfig) {
      switchCharacter(selectedFilename);
    }
  };
  const handleCameraToggle = async (checked) => {
    if (!setUseCameraBackground) return;
    if (checked) {
      try {
        await startBackgroundCamera();
        handleSettingChange("useCameraBackground", true);
        setUseCameraBackground(true);
      } catch (error) {
        console.error("Failed to start camera:", error);
        handleSettingChange("useCameraBackground", false);
        setUseCameraBackground(false);
      }
    } else {
      stopBackgroundCamera();
      handleSettingChange("useCameraBackground", false);
      setUseCameraBackground(false);
    }
  };
  return {
    settings: settings2,
    handleSettingChange,
    handleSave,
    handleCancel,
    handleCameraToggle,
    handleCharacterPresetChange,
    showSubtitle,
    setShowSubtitle
  };
};
const Field = reactExports.forwardRef(
  (props, ref2) => {
    const {
      label,
      children,
      helperText,
      errorText,
      optionalText,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(FieldRoot, { ref: ref2, ...rest, children: [
      label && /* @__PURE__ */ jsxRuntimeExports.jsxs(FieldLabel, { children: [
        label,
        /* @__PURE__ */ jsxRuntimeExports.jsx(FieldRequiredIndicator, { fallback: optionalText })
      ] }),
      children,
      helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { children: helperText }),
      errorText && /* @__PURE__ */ jsxRuntimeExports.jsx(FieldErrorText, { children: errorText })
    ] });
  }
);
const Switch = reactExports.forwardRef(
  (props, ref2) => {
    const {
      inputProps,
      children,
      rootRef,
      trackLabel,
      thumbLabel,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, { ref: rootRef, ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchHiddenInput, { ref: ref2, ...inputProps }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchControl, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, { children: thumbLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumbIndicator, { fallback: thumbLabel?.off, children: thumbLabel?.on }) }),
        trackLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchIndicator, { fallback: trackLabel.off, children: trackLabel.on })
      ] }),
      children != null && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchLabel, { children })
    ] });
  }
);
const SelectTrigger = reactExports.forwardRef((props, ref2) => {
  const { children, clearable, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectControl, { ...rest, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger$1, { ref: ref2, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectIndicatorGroup, { children: [
      clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectClearTrigger, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIndicator, {})
    ] })
  ] });
});
const SelectClearTrigger = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectClearTrigger$1, { asChild: true, ...props, ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  CloseButton,
  {
    size: "xs",
    variant: "plain",
    focusVisibleRing: "inside",
    focusRingWidth: "2px",
    pointerEvents: "auto"
  }
) }));
const SelectContent = reactExports.forwardRef((props, ref2) => {
  const { portalled = true, portalRef, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent$1, { ...rest, ref: ref2 }) }) });
});
const SelectItem = reactExports.forwardRef((props, ref2) => {
  const { item, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem$1, { item, ...rest, ref: ref2, children: [
    children,
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemIndicator, {})
  ] }, item.value);
});
const SelectValueText = reactExports.forwardRef((props, ref2) => {
  const { children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueText$1, { ...rest, ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContext, { children: (select) => {
    const items = select.selectedItems;
    if (items.length === 0) return props.placeholder;
    if (children) return children(items);
    if (items.length === 1) return select.collection.stringifyItem(items[0]);
    return `${items.length} selected`;
  } }) });
});
const SelectRoot = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  SelectRoot$1,
  {
    ...props,
    ref: ref2,
    positioning: { sameWidth: true, ...props.positioning },
    children: props.asChild ? props.children : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectHiddenSelect, {}),
      props.children
    ] })
  }
));
reactExports.forwardRef((props, ref2) => {
  const { children, label, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItemGroup, { ...rest, ref: ref2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemGroupLabel, { children: label }),
    children
  ] });
});
function SelectField({
  label,
  value,
  onChange,
  collection: collection2,
  placeholder
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.general.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...settingStyles.general.field.label, children: label }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SelectRoot,
        {
          ...settingStyles.general.select.root,
          collection: collection2,
          value,
          onValueChange: (e2) => onChange(e2.value),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { ...settingStyles.general.select.trigger, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueText, { placeholder }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: collection2.items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { item, children: item.label }, item.value)) })
          ]
        }
      )
    }
  );
}
function NumberField({
  label,
  value,
  onChange,
  min: min2,
  max: max2,
  step,
  allowMouseWheel
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.common.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...settingStyles.common.fieldLabel, children: label }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NumberInputRoot,
        {
          ...settingStyles.common.numberInput.root,
          value: value.toString(),
          onValueChange: (details) => onChange(details.value),
          min: min2,
          max: max2,
          step,
          allowMouseWheel,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputInput, { ...settingStyles.common.numberInput.input }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(NumberInputControl, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputIncrementTrigger, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputDecrementTrigger, {})
            ] })
          ]
        }
      )
    }
  );
}
function SwitchField({ label, checked, onChange }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.common.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...settingStyles.common.fieldLabel, children: label }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...settingStyles.common.switch,
          checked,
          onCheckedChange: (details) => onChange(details.checked)
        }
      )
    }
  );
}
function InputField({
  label,
  value,
  onChange,
  placeholder
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.general.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...settingStyles.general.field.label, children: label }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          ...settingStyles.general.input,
          placeholder,
          value,
          onChange: (e2) => onChange(e2.target.value)
        }
      )
    }
  );
}
const useCollections = () => {
  const { backgroundFiles } = useBgUrl() || {};
  const { configFiles } = useConfig();
  const languages = createListCollection({
    items: [
      { label: "English", value: "en" },
      { label: "中文", value: "zh" }
    ]
  });
  const backgrounds = createListCollection({
    items: backgroundFiles?.map((filename) => ({
      label: String(filename),
      value: `/bg/${filename}`
    })) || []
  });
  const characterPresets = createListCollection({
    items: configFiles.map((config2) => ({
      label: config2.name,
      value: config2.filename
    }))
  });
  return {
    languages,
    backgrounds,
    characterPresets
  };
};
function General({ onSave, onCancel }) {
  const bgUrlContext = useBgUrl();
  const { confName, setConfName } = useConfig();
  const {
    wsUrl,
    setWsUrl,
    baseUrl,
    setBaseUrl
  } = useWebSocket();
  const collections = useCollections();
  const {
    settings: settings2,
    handleSettingChange,
    handleCameraToggle,
    handleCharacterPresetChange,
    showSubtitle,
    setShowSubtitle
  } = useGeneralSettings({
    bgUrlContext,
    confName,
    setConfName,
    baseUrl,
    wsUrl,
    onWsUrlChange: setWsUrl,
    onBaseUrlChange: setBaseUrl,
    onSave,
    onCancel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectField,
      {
        label: "Language",
        value: settings2.language,
        onChange: (value) => handleSettingChange("language", value),
        collection: collections.languages,
        placeholder: "Select language"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Use Camera Background",
        checked: settings2.useCameraBackground,
        onChange: handleCameraToggle
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Show Subtitle",
        checked: showSubtitle,
        onChange: setShowSubtitle
      }
    ),
    !settings2.useCameraBackground && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectField,
        {
          label: "Background Image",
          value: settings2.selectedBgUrl,
          onChange: (value) => handleSettingChange("selectedBgUrl", value),
          collection: collections.backgrounds,
          placeholder: "Select from available backgrounds"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputField,
        {
          label: "Or enter a custom background URL",
          value: settings2.customBgUrl,
          onChange: (value) => handleSettingChange("customBgUrl", value),
          placeholder: "Enter image URL"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectField,
      {
        label: "Character Preset",
        value: settings2.selectedCharacterPreset,
        onChange: handleCharacterPresetChange,
        collection: collections.characterPresets,
        placeholder: confName || "Select character preset"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: "WebSocket URL",
        value: settings2.wsUrl,
        onChange: (value) => handleSettingChange("wsUrl", value),
        placeholder: "Enter WebSocket URL"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: "Base URL",
        value: settings2.baseUrl,
        onChange: (value) => handleSettingChange("baseUrl", value),
        placeholder: "Enter Base URL"
      }
    )
  ] });
}
const useLive2dSettings = () => {
  const Live2DConfigContext2 = useLive2DConfig();
  const initialModelInfo = {
    url: "",
    kScale: 0.5,
    initialXshift: 0,
    initialYshift: 0,
    emotionMap: {},
    scrollToResize: true
  };
  const [modelInfo, setModelInfoState] = reactExports.useState(
    Live2DConfigContext2?.modelInfo || initialModelInfo
  );
  const [originalModelInfo, setOriginalModelInfo] = reactExports.useState(
    Live2DConfigContext2?.modelInfo || initialModelInfo
  );
  reactExports.useEffect(() => {
    if (Live2DConfigContext2?.modelInfo) {
      if (JSON.stringify(Live2DConfigContext2.modelInfo) !== JSON.stringify(originalModelInfo)) {
        setOriginalModelInfo(Live2DConfigContext2.modelInfo);
        setModelInfoState(Live2DConfigContext2.modelInfo);
      }
    }
  }, [Live2DConfigContext2?.modelInfo]);
  reactExports.useEffect(() => {
    if (Live2DConfigContext2 && modelInfo) {
      Live2DConfigContext2.setModelInfo(modelInfo);
    }
  }, [modelInfo.pointerInteractive, modelInfo.scrollToResize]);
  const handleInputChange = (key, value) => {
    setModelInfoState((prev2) => ({ ...prev2, [key]: value }));
  };
  const handleSave = () => {
    if (Live2DConfigContext2 && modelInfo) {
      setOriginalModelInfo(modelInfo);
    }
  };
  const handleCancel = () => {
    setModelInfoState(originalModelInfo);
    if (Live2DConfigContext2 && originalModelInfo) {
      Live2DConfigContext2.setModelInfo(originalModelInfo);
    }
  };
  return {
    modelInfo,
    handleInputChange,
    handleSave,
    handleCancel
  };
};
function live2D({ onSave, onCancel }) {
  const {
    modelInfo,
    handleInputChange,
    handleSave,
    handleCancel
  } = useLive2dSettings();
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Pointer Interactive",
        checked: modelInfo.pointerInteractive ?? false,
        onChange: (checked) => handleInputChange("pointerInteractive", checked)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Enable Scroll to Resize",
        checked: modelInfo.scrollToResize ?? true,
        onChange: (checked) => handleInputChange("scrollToResize", checked)
      }
    )
  ] });
}
const useASRSettings = () => {
  const {
    settings: settings2,
    updateSettings,
    autoStopMic,
    setAutoStopMic,
    autoStartMicOn,
    setAutoStartMicOn,
    autoStartMicOnConvEnd,
    setAutoStartMicOnConvEnd
  } = useVAD();
  const localSettingsRef = reactExports.useRef(settings2);
  const originalSettingsRef = reactExports.useRef(settings2);
  const originalAutoStopMicRef = reactExports.useRef(autoStopMic);
  const originalAutoStartMicOnRef = reactExports.useRef(autoStartMicOn);
  const originalAutoStartMicOnConvEndRef = reactExports.useRef(autoStartMicOnConvEnd);
  const [localVoiceInterruption, setLocalVoiceInterruption] = reactExports.useState(autoStopMic);
  const [localAutoStartMic, setLocalAutoStartMic] = reactExports.useState(autoStartMicOn);
  const [localAutoStartMicOnConvEnd, setLocalAutoStartMicOnConvEnd] = reactExports.useState(autoStartMicOnConvEnd);
  const [, forceUpdate] = React.useReducer((x2) => x2 + 1, 0);
  reactExports.useEffect(() => {
    setLocalVoiceInterruption(autoStopMic);
    setLocalAutoStartMic(autoStartMicOn);
    setLocalAutoStartMicOnConvEnd(autoStartMicOnConvEnd);
  }, [autoStopMic, autoStartMicOn, autoStartMicOnConvEnd]);
  const handleInputChange = (key, value) => {
    if (value === "" || value === "-") {
      localSettingsRef.current = { ...localSettingsRef.current, [key]: value };
    } else {
      const parsed = Number(value);
      if (!isNaN(parsed)) {
        localSettingsRef.current = { ...localSettingsRef.current, [key]: parsed };
      }
    }
    forceUpdate();
  };
  const handleVoiceInterruptionChange = (value) => {
    setLocalVoiceInterruption(value);
    setAutoStopMic(value);
  };
  const handleAutoStartMicChange = (value) => {
    setLocalAutoStartMic(value);
    setAutoStartMicOn(value);
  };
  const handleAutoStartMicOnConvEndChange = (value) => {
    setLocalAutoStartMicOnConvEnd(value);
    setAutoStartMicOnConvEnd(value);
  };
  const handleSave = () => {
    updateSettings(localSettingsRef.current);
    originalSettingsRef.current = localSettingsRef.current;
    originalAutoStopMicRef.current = localVoiceInterruption;
    originalAutoStartMicOnRef.current = localAutoStartMic;
    originalAutoStartMicOnConvEndRef.current = localAutoStartMicOnConvEnd;
  };
  const handleCancel = () => {
    localSettingsRef.current = originalSettingsRef.current;
    setLocalVoiceInterruption(originalAutoStopMicRef.current);
    setLocalAutoStartMic(originalAutoStartMicOnRef.current);
    setAutoStopMic(originalAutoStopMicRef.current);
    setAutoStartMicOn(originalAutoStartMicOnRef.current);
    setLocalAutoStartMicOnConvEnd(originalAutoStartMicOnConvEndRef.current);
    setAutoStartMicOnConvEnd(originalAutoStartMicOnConvEndRef.current);
    forceUpdate();
  };
  return {
    localSettings: localSettingsRef.current,
    autoStopMic: localVoiceInterruption,
    autoStartMicOn: localAutoStartMic,
    autoStartMicOnConvEnd: localAutoStartMicOnConvEnd,
    setAutoStopMic: handleVoiceInterruptionChange,
    setAutoStartMicOn: handleAutoStartMicChange,
    setAutoStartMicOnConvEnd: handleAutoStartMicOnConvEndChange,
    handleInputChange,
    handleSave,
    handleCancel
  };
};
function ASR({ onSave, onCancel }) {
  const {
    localSettings,
    autoStopMic,
    autoStartMicOn,
    autoStartMicOnConvEnd,
    setAutoStopMic,
    setAutoStartMicOn,
    setAutoStartMicOnConvEnd,
    handleInputChange,
    handleSave,
    handleCancel
  } = useASRSettings();
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel, handleSave, handleCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Auto Stop Mic When AI Start Speaking",
        checked: autoStopMic,
        onChange: setAutoStopMic
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Auto Start Mic When Conversation End",
        checked: autoStartMicOnConvEnd,
        onChange: setAutoStartMicOnConvEnd
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Auto Start Mic When AI Interrupted",
        checked: autoStartMicOn,
        onChange: setAutoStartMicOn
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: "Speech Prob Threshold",
        value: localSettings.positiveSpeechThreshold,
        onChange: (value) => handleInputChange("positiveSpeechThreshold", value),
        min: 1,
        max: 100
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: "Negative Speech Threshold",
        value: localSettings.negativeSpeechThreshold,
        onChange: (value) => handleInputChange("negativeSpeechThreshold", value),
        min: 0,
        max: 100
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: "Redemption Frames",
        value: localSettings.redemptionFrames,
        onChange: (value) => handleInputChange("redemptionFrames", value),
        min: 1,
        max: 100
      }
    )
  ] });
}
function TTS() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: "TTS Settings Content" });
}
function useTriggerSpeak() {
  const { sendMessage } = useWebSocket();
  const { captureAllMedia } = useMediaCapture();
  const sendTriggerSignal = reactExports.useCallback(
    async (actualIdleTime) => {
      const images = await captureAllMedia();
      sendMessage({
        type: "ai-speak-signal",
        idle_time: actualIdleTime,
        images
      });
    },
    [sendMessage, captureAllMedia]
  );
  return {
    sendTriggerSignal
  };
}
const defaultSettings$1 = {
  allowProactiveSpeak: false,
  idleSecondsToSpeak: 5,
  allowButtonTrigger: false
};
const ProactiveSpeakContext = reactExports.createContext(null);
function ProactiveSpeakProvider({ children }) {
  const [settings2, setSettings] = useLocalStorage(
    "proactiveSpeakSettings",
    defaultSettings$1
  );
  const { aiState } = useAiState();
  const { sendTriggerSignal } = useTriggerSpeak();
  const idleTimerRef = reactExports.useRef(null);
  const idleStartTimeRef = reactExports.useRef(null);
  const clearIdleTimer = reactExports.useCallback(() => {
    if (idleTimerRef.current) {
      clearTimeout(idleTimerRef.current);
      idleTimerRef.current = null;
    }
    idleStartTimeRef.current = null;
  }, []);
  const startIdleTimer = reactExports.useCallback(() => {
    clearIdleTimer();
    if (!settings2.allowProactiveSpeak) return;
    idleStartTimeRef.current = Date.now();
    idleTimerRef.current = setTimeout(() => {
      const actualIdleTime = (Date.now() - idleStartTimeRef.current) / 1e3;
      sendTriggerSignal(actualIdleTime);
    }, settings2.idleSecondsToSpeak * 1e3);
  }, [settings2.allowProactiveSpeak, settings2.idleSecondsToSpeak, sendTriggerSignal, clearIdleTimer]);
  reactExports.useEffect(() => {
    if (aiState === AiStateEnum.IDLE) {
      startIdleTimer();
    } else {
      clearIdleTimer();
    }
  }, [aiState, startIdleTimer, clearIdleTimer]);
  reactExports.useEffect(() => () => {
    clearIdleTimer();
  }, [clearIdleTimer]);
  const updateSettings = reactExports.useCallback((newSettings) => {
    setSettings(newSettings);
  }, [setSettings]);
  const contextValue = reactExports.useMemo(() => ({
    settings: settings2,
    updateSettings
  }), [settings2, updateSettings]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProactiveSpeakContext.Provider, { value: contextValue, children });
}
function useProactiveSpeak() {
  const context2 = reactExports.useContext(ProactiveSpeakContext);
  if (!context2) {
    throw new Error("useProactiveSpeak must be used within a ProactiveSpeakProvider");
  }
  return context2;
}
function useAgentSettings({ onSave, onCancel } = {}) {
  const { settings: persistedSettings, updateSettings } = useProactiveSpeak();
  const [tempSettings, setTempSettings] = reactExports.useState({
    allowProactiveSpeak: persistedSettings.allowProactiveSpeak,
    idleSecondsToSpeak: persistedSettings.idleSecondsToSpeak,
    allowButtonTrigger: persistedSettings.allowButtonTrigger
  });
  const [originalSettings, setOriginalSettings] = reactExports.useState({
    ...persistedSettings
  });
  reactExports.useEffect(() => {
    if (persistedSettings) {
      setOriginalSettings(persistedSettings);
      setTempSettings(persistedSettings);
    }
  }, [persistedSettings]);
  const handleAllowProactiveSpeakChange = reactExports.useCallback((checked) => {
    setTempSettings((prev2) => ({
      ...prev2,
      allowProactiveSpeak: checked
    }));
  }, []);
  const handleIdleSecondsChange = reactExports.useCallback((value) => {
    setTempSettings((prev2) => ({
      ...prev2,
      idleSecondsToSpeak: value
    }));
  }, []);
  const handleAllowButtonTriggerChange = reactExports.useCallback((checked) => {
    setTempSettings((prev2) => ({
      ...prev2,
      allowButtonTrigger: checked
    }));
  }, []);
  const handleSave = reactExports.useCallback(() => {
    updateSettings(tempSettings);
    setOriginalSettings(tempSettings);
  }, [updateSettings, tempSettings]);
  const handleCancel = reactExports.useCallback(() => {
    setTempSettings(originalSettings);
    updateSettings(originalSettings);
  }, [originalSettings, updateSettings]);
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel, handleSave, handleCancel]);
  return {
    settings: tempSettings,
    handleAllowProactiveSpeakChange,
    handleIdleSecondsChange,
    handleAllowButtonTriggerChange
  };
}
function Agent({ onSave, onCancel }) {
  const {
    settings: settings2,
    handleAllowProactiveSpeakChange,
    handleIdleSecondsChange,
    handleAllowButtonTriggerChange
  } = useAgentSettings({ onSave, onCancel });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Allow AI to Speak Proactively",
        checked: settings2.allowProactiveSpeak,
        onChange: handleAllowProactiveSpeakChange
      }
    ),
    settings2.allowProactiveSpeak && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: "Idle seconds allow AI to speak",
        value: settings2.idleSecondsToSpeak,
        onChange: (value) => handleIdleSecondsChange(Number(value)),
        min: 0,
        step: 0.1,
        allowMouseWheel: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: "Prompt AI to Speak via Raise Hand Button",
        checked: settings2.allowButtonTrigger,
        onChange: handleAllowButtonTriggerChange
      }
    )
  ] });
}
function About() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: "About Settings Content" });
}
function SettingUI({ open, onClose }) {
  const [saveHandlers, setSaveHandlers] = reactExports.useState([]);
  const [cancelHandlers, setCancelHandlers] = reactExports.useState([]);
  const [activeTab, setActiveTab] = reactExports.useState("general");
  const handleSaveCallback = reactExports.useCallback((handler) => {
    setSaveHandlers((prev2) => [...prev2, handler]);
    return () => {
      setSaveHandlers((prev2) => prev2.filter((h2) => h2 !== handler));
    };
  }, []);
  const handleCancelCallback = reactExports.useCallback((handler) => {
    setCancelHandlers((prev2) => [...prev2, handler]);
    return () => {
      setCancelHandlers((prev2) => prev2.filter((h2) => h2 !== handler));
    };
  }, []);
  const handleSave = reactExports.useCallback(() => {
    saveHandlers.forEach((handler) => handler());
    onClose();
  }, [saveHandlers, onClose]);
  const handleCancel = reactExports.useCallback(() => {
    cancelHandlers.forEach((handler) => handler());
    onClose();
  }, [cancelHandlers, onClose]);
  const tabsContent = reactExports.useMemo(
    () => /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsContentGroup, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "general", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        General,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "live2d", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        live2D,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "asr", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ASR, { onSave: handleSaveCallback, onCancel: handleCancelCallback }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "tts", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TTS, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "agent", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Agent,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "about", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(About, {}) })
    ] }),
    [handleSaveCallback, handleCancelCallback]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot$1,
    {
      open,
      onOpenChange: (e2) => e2.open ? null : onClose(),
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent$1, { ...settingStyles.settingUI.drawerContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader$1, { ...settingStyles.settingUI.drawerHeader, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle$1, { ...settingStyles.settingUI.drawerTitle, children: "Settings" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...settingStyles.settingUI.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerCloseTrigger$1, { asChild: true, onClick: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: "sm", color: "white" }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            TabsRoot,
            {
              defaultValue: "general",
              value: activeTab,
              onValueChange: (details) => setActiveTab(details.value),
              ...settingStyles.settingUI.tabs.root,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { ...settingStyles.settingUI.tabs.list, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "general",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "General"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "live2d",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "Live2D"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "asr",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "ASR"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "tts",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "TTS"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "agent",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "Agent"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "about",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: "About"
                    }
                  )
                ] }),
                tabsContent
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerFooter$1, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { colorPalette: "red", onClick: handleCancel, children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { colorPalette: "blue", onClick: handleSave, children: "Save" })
          ] })
        ] })
      ]
    }
  );
}
const Avatar$1 = reactExports.forwardRef(
  (props, ref2) => {
    const {
      name: name2,
      src,
      srcSet,
      loading,
      icon: icon2,
      fallback: fallback2,
      children,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(AvatarRoot, { ref: ref2, ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { name: name2, icon: icon2, children: fallback2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImage, { src, srcSet, loading }),
      children
    ] });
  }
);
const AvatarFallback = reactExports.forwardRef(
  (props, ref2) => {
    const {
      name: name2,
      icon: icon2,
      children,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(AvatarFallback$1, { ref: ref2, ...rest, children: [
      children,
      name2 != null && children == null && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: getInitials(name2) }),
      name2 == null && children == null && /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarIcon, { asChild: !!icon2, children: icon2 })
    ] });
  }
);
function getInitials(name2) {
  const names = name2.trim().split(" ");
  const firstName = names[0] != null ? names[0] : "";
  const lastName = names.length > 1 ? names[names.length - 1] : "";
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
const AvatarGroup$1 = reactExports.forwardRef(
  (props, ref2) => {
    const {
      size: size2,
      variant,
      borderless,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarPropsProvider, { value: { size: size2, variant, borderless }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { gap: "0", spaceX: "-3", ref: ref2, ...rest }) });
  }
);
function ChatBubble({ message, isSelected, onClick }) {
  const isAI = message.role === "ai";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      onClick,
      cursor: "pointer",
      bg: isSelected ? "gray.100" : "transparent",
      _hover: { bg: "gray.50" },
      p: 2,
      borderRadius: "md",
      transition: "background-color 0.2s",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { gap: 3, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarGroup$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Avatar$1,
          {
            size: "sm",
            name: message.name || (isAI ? "AI" : "Me"),
            bg: isAI ? "blue.500" : "green.500",
            color: "white"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flex: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { fontSize: "sm", fontWeight: "bold", color: "gray.700", children: message.name || (isAI ? "AI" : "Me") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Text$1,
            {
              fontSize: "sm",
              color: "gray.600",
              truncate: true,
              children: message.content
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { fontSize: "xs", color: "gray.400", mt: 1, children: new Date(message.timestamp).toLocaleTimeString() })
        ] })
      ] })
    }
  );
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var prefix = "cs";
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (arg) {
          classes = appendClass(classes, parseValue2(arg));
        }
      }
      return classes;
    }
    function parseValue2(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames2.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes = "";
      for (var key in arg) {
        if (hasOwn2.call(arg, key) && arg[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var StatusEnum = ["available", "unavailable", "away", "dnd", "invisible", "eager"];
var SizeEnum = ["xs", "sm", "md", "lg", "fluid"];
function _typeof$h(o2) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$h(o2);
}
var _excluded$w = ["status", "size", "className", "name", "selected", "children"];
function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$v.apply(this, arguments);
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$e(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$e(t2) {
  var i2 = _toPrimitive$e(t2, "string");
  return "symbol" == _typeof$h(i2) ? i2 : String(i2);
}
function _toPrimitive$e(t2, r2) {
  if ("object" != _typeof$h(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$h(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$w(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$w(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$w(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Status = function Status2(_ref2) {
  var status = _ref2.status, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, className = _ref2.className, name2 = _ref2.name, selected = _ref2.selected, children = _ref2.children, rest = _objectWithoutProperties$w(_ref2, _excluded$w);
  var cName2 = "".concat(prefix, "-status");
  var bullet = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__bullet")
  });
  var named = name2 || children;
  return /* @__PURE__ */ React.createElement("div", _extends$v({}, rest, {
    "aria-selected": selected === true ? "" : null,
    className: classNames(cName2, "".concat(cName2, "--").concat(size2), "".concat(cName2, "--").concat(status), _defineProperty$f({}, "".concat(cName2, "--selected"), selected), _defineProperty$f({}, "".concat(cName2, "--named"), named), className)
  }), bullet, named && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__name")
  }, name2 ? name2 : children));
};
function _typeof$g(o2) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$g(o2);
}
var _excluded$v = ["name", "src", "size", "status", "className", "active", "children"];
function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$u.apply(this, arguments);
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(t2) {
  var i2 = _toPrimitive$d(t2, "string");
  return "symbol" == _typeof$g(i2) ? i2 : String(i2);
}
function _toPrimitive$d(t2, r2) {
  if ("object" != _typeof$g(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$g(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$v(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$v(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$v(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function AvatarInner(_ref2, ref2) {
  var _ref$name = _ref2.name, name2 = _ref$name === void 0 ? "" : _ref$name, _ref$src = _ref2.src, src = _ref$src === void 0 ? "" : _ref$src, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, status = _ref2.status, className = _ref2.className, _ref$active = _ref2.active, active2 = _ref$active === void 0 ? false : _ref$active, children = _ref2.children, rest = _objectWithoutProperties$v(_ref2, _excluded$v);
  var cName2 = "".concat(prefix, "-avatar");
  var sizeClass = typeof size2 !== "undefined" ? " ".concat(cName2, "--").concat(size2) : "";
  var avatarRef = reactExports.useRef();
  reactExports.useImperativeHandle(ref2, function() {
    return {
      focus: function focus() {
        return avatarRef.current.focus();
      }
    };
  });
  return /* @__PURE__ */ React.createElement("div", _extends$u({
    ref: avatarRef
  }, rest, {
    className: classNames("".concat(cName2).concat(sizeClass), _defineProperty$e({}, "".concat(cName2, "--active"), active2), className)
  }), children ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("img", {
    src,
    alt: name2
  }), typeof status === "string" && /* @__PURE__ */ React.createElement(Status, {
    status,
    size: size2
  }), " "));
}
var Avatar = /* @__PURE__ */ reactExports.forwardRef(AvatarInner);
Avatar.displayName = "Avatar";
Avatar.propTypes = {
  /** Primary content */
  children: PropTypes.node,
  /**
   * User name/nickname/full name for displaying initials and image alt description
   */
  name: PropTypes.string,
  /** Avatar image source */
  src: PropTypes.string,
  /** Size */
  size: PropTypes.oneOf(SizeEnum),
  /** Status. */
  status: PropTypes.oneOf(StatusEnum),
  /** Active */
  active: PropTypes.bool,
  /** Additional classes. */
  className: PropTypes.string
};
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$d(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$c(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$c(t2) {
  var i2 = _toPrimitive$c(t2, "string");
  return "symbol" == _typeof$f(i2) ? i2 : String(i2);
}
function _toPrimitive$c(t2, r2) {
  if ("object" != _typeof$f(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$f(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$f(o2) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$f(o2);
}
var noop$2 = function noop2() {
};
var isChildrenNil = function isChildrenNil2(children) {
  return children === null || children === void 0 || Array.isArray(children) && children.length === 0;
};
var getChildren = function getChildren2(children, types) {
  var ret = [];
  var strTypes = types.map(function(t2) {
    return t2.displayName || t2.name;
  });
  React.Children.toArray(children).forEach(function(item) {
    var idx = types.indexOf(item.type);
    if (idx !== -1) {
      ret[idx] = item;
    } else {
      var _item$props$as, _item$props, _item$props2;
      var is = (_item$props$as = item === null || item === void 0 ? void 0 : (_item$props = item.props) === null || _item$props === void 0 ? void 0 : _item$props.as) !== null && _item$props$as !== void 0 ? _item$props$as : item === null || item === void 0 ? void 0 : (_item$props2 = item.props) === null || _item$props2 === void 0 ? void 0 : _item$props2.is;
      var typeofIs = _typeof$f(is);
      if (typeofIs === "function") {
        var fIdx = types.indexOf(is);
        if (fIdx !== -1) {
          ret[fIdx] = /* @__PURE__ */ React.cloneElement(item, _objectSpread$1(_objectSpread$1({}, item.props), {}, {
            as: null
          }));
        }
      } else if (typeofIs === "object") {
        var typeName = is.name || is.displayName;
        var tIdx = strTypes.indexOf(typeName);
        if (tIdx !== -1) {
          ret[tIdx] = /* @__PURE__ */ React.cloneElement(item, _objectSpread$1(_objectSpread$1({}, item.props), {}, {
            as: null
          }));
        }
      } else if (typeofIs === "string") {
        var sIdx = strTypes.indexOf(is);
        if (sIdx !== -1) {
          ret[sIdx] = item;
        }
      }
    }
  });
  return ret;
};
var getComponentName = function getComponentName2(component) {
  if (typeof component === "string") {
    return component;
  }
  if ("type" in component) {
    var componentType = _typeof$f(component.type);
    if (componentType === "function" || componentType === "object") {
      if ("displayName" in component.type) {
        return component.type.displayName;
      }
      if ("name" in component.type) {
        return component.type.name;
      }
    } else if (componentType === "string") {
      return component.type;
    }
    return "undefined";
  }
  return "undefined";
};
var allowedChildren = function allowedChildren2(allowedTypes) {
  return function(props, propName, componentName) {
    var allowedTypesAsStrings = allowedTypes.map(function(t2) {
      return t2.name || t2.displayName;
    });
    var forbidden = React.Children.toArray(props[propName]).find(function(item) {
      if (typeof item === "string" && item.trim().length === 0) {
        return false;
      }
      if (allowedTypes.indexOf(item.type) === -1) {
        var _item$props3, _item$props4;
        var is = (item === null || item === void 0 ? void 0 : (_item$props3 = item.props) === null || _item$props3 === void 0 ? void 0 : _item$props3.as) || (item === null || item === void 0 ? void 0 : (_item$props4 = item.props) === null || _item$props4 === void 0 ? void 0 : _item$props4.is);
        var typeofIs = _typeof$f(is);
        if (typeofIs === "function") {
          return allowedTypes.indexOf(is) === -1;
        } else if (typeofIs === "object") {
          var typeName2 = is.name || is.displayName;
          return allowedTypesAsStrings.indexOf(typeName2) === -1;
        } else if (typeofIs === "string") {
          return allowedTypesAsStrings.indexOf(is) === -1;
        } else {
          return true;
        }
      }
      return void 0;
    });
    if (typeof forbidden !== "undefined") {
      var typeName = getComponentName(forbidden);
      var allowedNames = allowedTypes.map(function(t2) {
        return t2.name || t2.displayName;
      }).join(", ");
      var errMessage = '"'.concat(typeName, '" is not a valid child for ').concat(componentName, ". Allowed types: ").concat(allowedNames);
      return new Error(errMessage);
    }
  };
};
var _excluded$u = ["children", "size", "className", "max", "activeIndex", "hoverToFront"];
function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$t.apply(this, arguments);
}
function _objectWithoutProperties$u(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$u(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$u(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var AvatarGroup = function AvatarGroup2(_ref2) {
  var children = _ref2.children, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, className = _ref2.className, max2 = _ref2.max, activeIndex = _ref2.activeIndex, hoverToFront = _ref2.hoverToFront, rest = _objectWithoutProperties$u(_ref2, _excluded$u);
  var cName2 = "".concat(prefix, "-avatar-group");
  var avatars = typeof max2 === "number" && React.Children.count(children) > max2 ? React.Children.toArray(children).reverse().slice(0, max2) : React.Children.toArray(children).reverse();
  var reversedActiveIndex = typeof activeIndex === "number" ? avatars.length - activeIndex - 1 : void 0;
  return /* @__PURE__ */ React.createElement("div", _extends$t({}, rest, {
    className: classNames(cName2, "".concat(cName2, "--").concat(size2), className)
  }), avatars.map(function(a2, i2) {
    var newProps = typeof reversedActiveIndex === "number" ? {
      active: reversedActiveIndex === i2
    } : {};
    if (hoverToFront === true) {
      newProps.className = classNames("".concat(prefix, "-avatar--active-on-hover"), a2.props.className);
    }
    return /* @__PURE__ */ React.cloneElement(a2, newProps);
  }));
};
AvatarGroup.displayName = "AvatarGroup";
var _excluded$t = ["children", "className", "icon", "border", "labelPosition"];
function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$s.apply(this, arguments);
}
function _objectWithoutProperties$t(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$t(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$t(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Button = function Button22(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$icon = _ref2.icon, icon2 = _ref$icon === void 0 ? void 0 : _ref$icon, _ref$border = _ref2.border, border = _ref$border === void 0 ? false : _ref$border, _ref$labelPosition = _ref2.labelPosition, labelPosition = _ref$labelPosition === void 0 ? void 0 : _ref$labelPosition, rest = _objectWithoutProperties$t(_ref2, _excluded$t);
  var cName2 = "".concat(prefix, "-button");
  var lPos = typeof labelPosition !== "undefined" ? labelPosition : "right";
  var labelPositionClassName = React.Children.count(children) > 0 ? "".concat(cName2, "--").concat(lPos) : "";
  var borderClassName = border === true ? "".concat(cName2, "--border") : "";
  return /* @__PURE__ */ React.createElement("button", _extends$s({}, rest, {
    className: classNames(cName2, labelPositionClassName, borderClassName, className)
  }), lPos === "left" && children, icon2, lPos === "right" && children);
};
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
function _typeof$e(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  _defineProperties$4(Constructor.prototype, protoProps);
  return Constructor;
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$c(target, key, source[key]);
    });
  }
  return target;
}
function _slicedToArray$7(arr, i2) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i2);
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit$7(arr, i2) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
var noop = function noop22() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e2) {
}
var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var DEFAULT_FAMILY_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
(function() {
  try {
    return true;
  } catch (e2) {
    return false;
  }
})();
var DUOTONE_CLASSES = {
  GROUP: "group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  var attrs = [["data-family-prefix", "familyPrefix"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach(function(_ref2) {
    var _ref22 = _slicedToArray$7(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
var _config = _objectSpread({}, _default, initial);
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = _objectSpread({}, _config);
WINDOW.FontAwesomeConfig = config;
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function listener2() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
  loaded = 1;
  functions.map(function(fn) {
    return fn();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
var PENDING = "pending";
var SETTLED = "settled";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
var NOOP = function NOOP2() {
};
var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;
function asyncFlush() {
  for (var i2 = 0; i2 < asyncQueue.length; i2++) {
    asyncQueue[i2][0](asyncQueue[i2][1]);
  }
  asyncQueue = [];
  asyncTimer = false;
}
function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);
  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}
function invokeResolver(resolver, promise2) {
  function resolvePromise(value) {
    resolve(promise2, value);
  }
  function rejectPromise(reason) {
    reject(promise2, reason);
  }
  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e2) {
    rejectPromise(e2);
  }
}
function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise2 = subscriber.then;
  if (typeof callback === "function") {
    settled = FULFILLED;
    try {
      value = callback(value);
    } catch (e2) {
      reject(promise2, e2);
    }
  }
  if (!handleThenable(promise2, value)) {
    if (settled === FULFILLED) {
      resolve(promise2, value);
    }
    if (settled === REJECTED) {
      reject(promise2, value);
    }
  }
}
function handleThenable(promise2, value) {
  var resolved;
  try {
    if (promise2 === value) {
      throw new TypeError("A promises callback cannot return that same promise.");
    }
    if (value && (typeof value === "function" || _typeof$e(value) === "object")) {
      var then2 = value.then;
      if (typeof then2 === "function") {
        then2.call(value, function(val) {
          if (!resolved) {
            resolved = true;
            if (value === val) {
              fulfill(promise2, val);
            } else {
              resolve(promise2, val);
            }
          }
        }, function(reason) {
          if (!resolved) {
            resolved = true;
            reject(promise2, reason);
          }
        });
        return true;
      }
    }
  } catch (e2) {
    if (!resolved) {
      reject(promise2, e2);
    }
    return true;
  }
  return false;
}
function resolve(promise2, value) {
  if (promise2 === value || !handleThenable(promise2, value)) {
    fulfill(promise2, value);
  }
}
function fulfill(promise2, value) {
  if (promise2._state === PENDING) {
    promise2._state = SETTLED;
    promise2._data = value;
    asyncCall(publishFulfillment, promise2);
  }
}
function reject(promise2, reason) {
  if (promise2._state === PENDING) {
    promise2._state = SETTLED;
    promise2._data = reason;
    asyncCall(publishRejection, promise2);
  }
}
function publish(promise2) {
  promise2._then = promise2._then.forEach(invokeCallback);
}
function publishFulfillment(promise2) {
  promise2._state = FULFILLED;
  publish(promise2);
}
function publishRejection(promise2) {
  promise2._state = REJECTED;
  publish(promise2);
  if (!promise2._handled && isNode) {
    global.process.emit("unhandledRejection", promise2._data, promise2);
  }
}
function notifyRejectionHandled(promise2) {
  global.process.emit("rejectionHandled", promise2);
}
function P(resolver) {
  if (typeof resolver !== "function") {
    throw new TypeError("Promise resolver " + resolver + " is not a function");
  }
  if (this instanceof P === false) {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  this._then = [];
  invokeResolver(resolver, this);
}
P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: void 0,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };
    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;
      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }
    if (this._state === FULFILLED || this._state === REJECTED) {
      asyncCall(invokeCallback, subscriber);
    } else {
      this._then.push(subscriber);
    }
    return subscriber.then;
  },
  catch: function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};
P.all = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.all().");
  }
  return new P(function(resolve2, reject2) {
    var results = [];
    var remaining = 0;
    function resolver(index) {
      remaining++;
      return function(value) {
        results[index] = value;
        if (!--remaining) {
          resolve2(results);
        }
      };
    }
    for (var i2 = 0, promise2; i2 < promises.length; i2++) {
      promise2 = promises[i2];
      if (promise2 && typeof promise2.then === "function") {
        promise2.then(resolver(i2), reject2);
      } else {
        results[i2] = promise2;
      }
    }
    if (!remaining) {
      resolve2(results);
    }
  });
};
P.race = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.race().");
  }
  return new P(function(resolve2, reject2) {
    for (var i2 = 0, promise2; i2 < promises.length; i2++) {
      promise2 = promises[i2];
      if (promise2 && typeof promise2.then === "function") {
        promise2.then(resolve2, reject2);
      } else {
        resolve2(promise2);
      }
    }
  });
};
P.resolve = function(value) {
  if (value && _typeof$e(value) === "object" && value.constructor === P) {
    return value;
  }
  return new P(function(resolve2) {
    resolve2(value);
  });
};
P.reject = function(reason) {
  return new P(function(resolve2, reject2) {
    reject2(reason);
  });
};
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  var style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i2 = headChildren.length - 1; i2 > -1; i2--) {
    var child = headChildren[i2];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size2 = 12;
  var id2 = "";
  while (size2-- > 0) {
    id2 += idPool[Math.random() * 62 | 0];
  }
  return id2;
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName], ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref2) {
  var transform2 = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  var innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path2 = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path: path2
  };
}
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
function makeIconMasking(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform2 = _ref2.transform;
  var mainWidth = main.width, mainPath = main.icon;
  var maskWidth = mask.width, maskPath = mask.icon;
  var trans = transformForSvg({
    transform: transform2,
    containerWidth: maskWidth,
    iconWidth: mainWidth
  });
  var maskRect = {
    tag: "rect",
    attributes: _objectSpread({}, ALL_SPACE, {
      fill: "white"
    })
  };
  var maskInnerGroupChildrenMixin = mainPath.children ? {
    children: mainPath.children.map(fillBlack)
  } : {};
  var maskInnerGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.inner),
    children: [fillBlack(_objectSpread({
      tag: mainPath.tag,
      attributes: _objectSpread({}, mainPath.attributes, trans.path)
    }, maskInnerGroupChildrenMixin))]
  };
  var maskOuterGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.outer),
    children: [maskInnerGroup]
  };
  var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
  var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
  var maskTag = {
    tag: "mask",
    attributes: _objectSpread({}, ALL_SPACE, {
      id: maskId,
      maskUnits: "userSpaceOnUse",
      maskContentUnits: "userSpaceOnUse"
    }),
    children: [maskRect, maskOuterGroup]
  };
  var defs = {
    tag: "defs",
    children: [{
      tag: "clipPath",
      attributes: {
        id: clipId
      },
      children: deGroup(maskPath)
    }, maskTag]
  };
  children.push(defs, {
    tag: "rect",
    attributes: _objectSpread({
      fill: "currentColor",
      "clip-path": "url(#".concat(clipId, ")"),
      mask: "url(#".concat(maskId, ")")
    }, ALL_SPACE)
  });
  return {
    children,
    attributes
  };
}
function makeIconStandard(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, transform2 = _ref2.transform, styles2 = _ref2.styles;
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  if (transformIsMeaningful(transform2)) {
    var trans = transformForSvg({
      transform: transform2,
      containerWidth: main.width,
      iconWidth: main.width
    });
    children.push({
      tag: "g",
      attributes: _objectSpread({}, trans.outer),
      children: [{
        tag: "g",
        attributes: _objectSpread({}, trans.inner),
        children: [{
          tag: main.icon.tag,
          children: main.icon.children,
          attributes: _objectSpread({}, main.icon.attributes, trans.path)
        }]
      }]
    });
  } else {
    children.push(main.icon);
  }
  return {
    children,
    attributes
  };
}
function asIcon(_ref2) {
  var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform2 = _ref2.transform;
  if (transformIsMeaningful(transform2) && main.found && !mask.found) {
    var width = main.width, height = main.height;
    var offset2 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread({}, styles2, {
      "transform-origin": "".concat(offset2.x + transform2.x / 16, "em ").concat(offset2.y + transform2.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix2 = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
  var id2 = symbol === true ? "".concat(prefix2, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread({}, attributes, {
        id: id2
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix2 = params.prefix, iconName = params.iconName, transform2 = params.transform, symbol = params.symbol, title = params.title, maskId = params.maskId, titleId = params.titleId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
  var isUploadedIcon = prefix2 === "fak";
  var widthClass = isUploadedIcon ? "" : "fa-w-".concat(Math.ceil(width / height * 16));
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : "", widthClass].filter(function(c2) {
    return extra.classes.indexOf(c2) === -1;
  }).filter(function(c2) {
    return c2 !== "" || !!c2;
  }).concat(extra.classes).join(" ");
  var content = {
    children: [],
    attributes: _objectSpread({}, extra.attributes, {
      "data-prefix": prefix2,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) content.children.push({
    tag: "title",
    attributes: {
      id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
    },
    children: [title]
  });
  var args = _objectSpread({}, content, {
    prefix: prefix2,
    iconName,
    main,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: _objectSpread({}, uploadedIconWidthStyle, extra.styles)
  });
  var _ref22 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args), children = _ref22.children, attributes = _ref22.attributes;
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
var noop$1 = function noop3() {
};
config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length2 = keys.length, iterator = fn, i2, key, result;
  if (initialValue === void 0) {
    i2 = 1;
    result = subject[keys[0]];
  } else {
    i2 = 0;
    result = initialValue;
  }
  for (; i2 < length2; i2++) {
    key = keys[i2];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function defineIcons(prefix2, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = Object.keys(icons).reduce(function(acc, iconName) {
    var icon2 = icons[iconName];
    var expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix2, normalized);
  } else {
    namespace.styles[prefix2] = _objectSpread({}, namespace.styles[prefix2] || {}, normalized);
  }
  if (prefix2 === "fas") {
    defineIcons("fa", icons);
  }
}
var styles = namespace.styles, shims = namespace.shims;
var build = function build2() {
  var lookup = function lookup2(reducer) {
    return reduce(styles, function(o2, style, prefix2) {
      o2[prefix2] = reduce(style, reducer, {});
      return o2;
    }, {});
  };
  lookup(function(acc, icon2, iconName) {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    return acc;
  });
  lookup(function(acc, icon2, iconName) {
    var ligatures = icon2[2];
    acc[iconName] = iconName;
    ligatures.forEach(function(ligature) {
      acc[ligature] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles;
  reduce(shims, function(acc, shim) {
    var oldName = shim[0];
    var prefix2 = shim[1];
    var iconName = shim[2];
    if (prefix2 === "far" && !hasRegular) {
      prefix2 = "fas";
    }
    acc[oldName] = {
      prefix: prefix2,
      iconName
    };
    return acc;
  }, {});
};
build();
namespace.styles;
function iconFromMapping(mapping, prefix2, iconName) {
  if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
    return {
      prefix: prefix2,
      iconName,
      icon: mapping[prefix2][iconName]
    };
  }
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
var parseTransformString = function parseTransformString2(transformString) {
  var transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  if (!transformString) {
    return transform2;
  } else {
    return transformString.toLowerCase().split(" ").reduce(function(acc, n2) {
      var parts2 = n2.toLowerCase().split("-");
      var first2 = parts2[0];
      var rest = parts2.slice(1).join("-");
      if (first2 && rest === "h") {
        acc.flipX = true;
        return acc;
      }
      if (first2 && rest === "v") {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first2) {
        case "grow":
          acc.size = acc.size + rest;
          break;
        case "shrink":
          acc.size = acc.size - rest;
          break;
        case "left":
          acc.x = acc.x - rest;
          break;
        case "right":
          acc.x = acc.x + rest;
          break;
        case "up":
          acc.y = acc.y - rest;
          break;
        case "down":
          acc.y = acc.y + rest;
          break;
        case "rotate":
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform2);
  }
};
function MissingIcon(error) {
  this.name = "MissingIcon";
  this.message = error || "Icon unavailable";
  this.stack = new Error().stack;
}
MissingIcon.prototype = Object.create(Error.prototype);
MissingIcon.prototype.constructor = MissingIcon;
var FILL = {
  fill: "currentColor"
};
var ANIMATION_BASE = {
  attributeType: "XML",
  repeatCount: "indefinite",
  dur: "2s"
};
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
  })
});
var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: "opacity"
});
({
  tag: "circle",
  attributes: _objectSpread({}, FILL, {
    cx: "256",
    cy: "364",
    r: "28"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, ANIMATION_BASE, {
      attributeName: "r",
      values: "28;14;28;28;14;28;"
    })
  }, {
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;1;1;0;1;"
    })
  }]
});
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    opacity: "1",
    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;0;0;0;1;"
    })
  }]
});
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    opacity: "0",
    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "0;0;1;1;0;0;"
    })
  }]
});
namespace.styles;
function asFoundIcon(icon2) {
  var width = icon2[0];
  var height = icon2[1];
  var _icon$slice = icon2.slice(4), _icon$slice2 = _slicedToArray$7(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
namespace.styles;
var baseStyles = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';
function css() {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc2 = config.replacementClass;
  var s2 = baseStyles;
  if (fp !== dfp || rc2 !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dfp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc2));
  }
  return s2;
}
var Library = /* @__PURE__ */ function() {
  function Library2() {
    _classCallCheck$4(this, Library2);
    this.definitions = {};
  }
  _createClass$4(Library2, [{
    key: "add",
    value: function add2() {
      var _this = this;
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread({}, _this.definitions[key] || {}, additions[key]);
        defineIcons(key, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix2 = _normalized$key.prefix, iconName = _normalized$key.iconName, icon2 = _normalized$key.icon;
        if (!additions[prefix2]) additions[prefix2] = {};
        additions[prefix2][iconName] = icon2;
      });
      return additions;
    }
  }]);
  return Library2;
}();
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
function apiObject(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get2() {
      return val.abstract.map(function(a2) {
        return toHtml(a2);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get2() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function findIconDefinition(iconLookup) {
  var _iconLookup$prefix = iconLookup.prefix, prefix2 = _iconLookup$prefix === void 0 ? "fa" : _iconLookup$prefix, iconName = iconLookup.iconName;
  if (!iconName) return;
  return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
}
function resolveIcons(next2) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next2(iconDefinition, _objectSpread({}, params, {
      mask
    }));
  };
}
var library = new Library();
var _cssInserted = false;
var parse = {
  transform: function transform(transformString) {
    return parseTransformString(transformString);
  }
};
var icon = resolveIcons(function(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform2 = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$titleId = params.titleId, titleId = _params$titleId === void 0 ? null : _params$titleId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix2 = iconDefinition.prefix, iconName = iconDefinition.iconName, icon2 = iconDefinition.icon;
  return apiObject(_objectSpread({
    type: "icon"
  }, iconDefinition), function() {
    ensureCss();
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix2,
      iconName,
      transform: _objectSpread({}, meaninglessTransform, transform2),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
});
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$d(obj);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose$s(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$s(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$s(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray$7(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$7(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$7(o2, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function classList(props) {
  var _classes;
  var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse = props.inverse, border = props.border, listItem = props.listItem, flip2 = props.flip, size2 = props.size, rotation = props.rotation, pull = props.pull;
  var classes = (_classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip2 === true,
    "fa-flip-horizontal": flip2 === "horizontal" || flip2 === "both",
    "fa-flip-vertical": flip2 === "vertical" || flip2 === "both"
  }, _defineProperty$b(_classes, "fa-".concat(size2), typeof size2 !== "undefined" && size2 !== null), _defineProperty$b(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty$b(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty$b(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  }
  string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string.substr(0, 1).toLowerCase() + string.substr(1);
}
var _excluded$1$1 = ["style"];
function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}
function styleToObject(style) {
  return style.split(";").map(function(s2) {
    return s2.trim();
  }).filter(function(s2) {
    return s2;
  }).reduce(function(acc, pair) {
    var i2 = pair.indexOf(":");
    var prop = camelize(pair.slice(0, i2));
    var value = pair.slice(i2 + 1).trim();
    prop.startsWith("webkit") ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}
function convert(createElement, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof element === "string") {
    return element;
  }
  var children = (element.children || []).map(function(child) {
    return convert(createElement, child);
  });
  var mixins = Object.keys(element.attributes || {}).reduce(function(acc, key) {
    var val = element.attributes[key];
    switch (key) {
      case "class":
        acc.attrs["className"] = val;
        delete element.attributes["class"];
        break;
      case "style":
        acc.attrs["style"] = styleToObject(val);
        break;
      default:
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
    }
    return acc;
  }, {
    attrs: {}
  });
  var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties$s(extraProps, _excluded$1$1);
  mixins.attrs["style"] = _objectSpread2(_objectSpread2({}, mixins.attrs["style"]), existingStyle);
  return createElement.apply(void 0, [element.tag, _objectSpread2(_objectSpread2({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
}
var PRODUCTION = false;
try {
  PRODUCTION = true;
} catch (e2) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof$d(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse.icon) {
    return parse.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && _typeof$d(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty$b({}, key, value) : {};
}
var _excluded$s = ["forwardedRef"];
function FontAwesomeIcon(_ref2) {
  var forwardedRef = _ref2.forwardedRef, props = _objectWithoutProperties$s(_ref2, _excluded$s);
  var iconArgs = props.icon, maskArgs = props.mask, symbol = props.symbol, className = props.className, title = props.title, titleId = props.titleId, maskId = props.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey("classes", [].concat(_toConsumableArray(classList(props)), _toConsumableArray(className.split(" "))));
  var transform2 = objectWithKey("transform", typeof props.transform === "string" ? parse.transform(props.transform) : props.transform);
  var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
  var renderedIcon = icon(iconLookup, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes), transform2), mask), {}, {
    symbol,
    title,
    titleId,
    maskId
  }));
  if (!renderedIcon) {
    log("Could not find icon", iconLookup);
    return null;
  }
  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref: forwardedRef
  };
  Object.keys(props).forEach(function(key) {
    if (!FontAwesomeIcon.defaultProps.hasOwnProperty(key)) {
      extraProps[key] = props[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
}
FontAwesomeIcon.displayName = "FontAwesomeIcon";
FontAwesomeIcon.propTypes = {
  beat: PropTypes.bool,
  border: PropTypes.bool,
  beatFade: PropTypes.bool,
  bounce: PropTypes.bool,
  className: PropTypes.string,
  fade: PropTypes.bool,
  flash: PropTypes.bool,
  mask: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  maskId: PropTypes.string,
  fixedWidth: PropTypes.bool,
  inverse: PropTypes.bool,
  flip: PropTypes.oneOf([true, false, "horizontal", "vertical", "both"]),
  icon: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  listItem: PropTypes.bool,
  pull: PropTypes.oneOf(["right", "left"]),
  pulse: PropTypes.bool,
  rotation: PropTypes.oneOf([0, 90, 180, 270]),
  shake: PropTypes.bool,
  size: PropTypes.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: PropTypes.bool,
  spinPulse: PropTypes.bool,
  spinReverse: PropTypes.bool,
  symbol: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  title: PropTypes.string,
  titleId: PropTypes.string,
  transform: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  swapOpacity: PropTypes.bool
};
FontAwesomeIcon.defaultProps = {
  border: false,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: false
};
var convertCurry = convert.bind(null, React.createElement);
var faArrowUp = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-up";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f062";
  var svgPathData = "M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowUp = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowUp);
var faArrowRight = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-right";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f061";
  var svgPathData = "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowRight = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowRight);
var faArrowDown = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-down";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f063";
  var svgPathData = "M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowDown = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowDown);
var faArrowLeft = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-left";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f060";
  var svgPathData = "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowLeft = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowLeft);
var _excluded$r = ["className", "direction", "children"];
function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$r.apply(this, arguments);
}
function _objectWithoutProperties$r(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$r(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$r(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ArrowButton = function ArrowButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$direction = _ref2.direction, direction = _ref$direction === void 0 ? "right" : _ref$direction, children = _ref2.children, rest = _objectWithoutProperties$r(_ref2, _excluded$r);
  var cName2 = "".concat(prefix, "-button--arrow");
  var icon2 = function() {
    if (direction === "up") {
      return faArrowUp.faArrowUp;
    } else if (direction === "right") {
      return faArrowRight.faArrowRight;
    } else if (direction === "down") {
      return faArrowDown.faArrowDown;
    } else if (direction === "left") {
      return faArrowLeft.faArrowLeft;
    }
  }();
  return /* @__PURE__ */ React.createElement(Button, _extends$r({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: icon2
    })
  }), children);
};
var faEllipsisV = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "ellipsis-v";
  var width = 192;
  var height = 512;
  var ligatures = [];
  var unicode = "f142";
  var svgPathData = "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faEllipsisV = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faEllipsisV);
var faPaperPlane = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "paper-plane";
  var width = 512;
  var height = 512;
  var ligatures = [];
  var unicode = "f1d8";
  var svgPathData = "M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faPaperPlane = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faPaperPlane);
var _excluded$q = ["className", "children"];
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
function _objectWithoutProperties$q(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$q(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$q(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var SendButton = function SendButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref2.children, rest = _objectWithoutProperties$q(_ref2, _excluded$q);
  var cName2 = "".concat(prefix, "-button--send");
  return /* @__PURE__ */ React.createElement(Button, _extends$q({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: faPaperPlane.faPaperPlane
    })
  }), children);
};
var faPaperclip = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "paperclip";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f0c6";
  var svgPathData = "M43.246 466.142c-58.43-60.289-57.341-157.511 1.386-217.581L254.392 34c44.316-45.332 116.351-45.336 160.671 0 43.89 44.894 43.943 117.329 0 162.276L232.214 383.128c-29.855 30.537-78.633 30.111-107.982-.998-28.275-29.97-27.368-77.473 1.452-106.953l143.743-146.835c6.182-6.314 16.312-6.422 22.626-.241l22.861 22.379c6.315 6.182 6.422 16.312.241 22.626L171.427 319.927c-4.932 5.045-5.236 13.428-.648 18.292 4.372 4.634 11.245 4.711 15.688.165l182.849-186.851c19.613-20.062 19.613-52.725-.011-72.798-19.189-19.627-49.957-19.637-69.154 0L90.39 293.295c-34.763 35.56-35.299 93.12-1.191 128.313 34.01 35.093 88.985 35.137 123.058.286l172.06-175.999c6.177-6.319 16.307-6.433 22.626-.256l22.877 22.364c6.319 6.177 6.434 16.307.256 22.626l-172.06 175.998c-59.576 60.938-155.943 60.216-214.77-.485z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faPaperclip = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faPaperclip);
var _excluded$p = ["className", "children"];
function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
function _objectWithoutProperties$p(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$p(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$p(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var AttachmentButton = function AttachmentButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref2.children, rest = _objectWithoutProperties$p(_ref2, _excluded$p);
  var cName2 = "".concat(prefix, "-button--attachment");
  return /* @__PURE__ */ React.createElement(Button, _extends$p({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: faPaperclip.faPaperclip
    })
  }), children);
};
var _excluded$o = ["onClick", "children", "className"];
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
function _objectWithoutProperties$o(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$o(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$o(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderBack = function ConversationHeaderBack2(_ref2) {
  var _ref$onClick = _ref2.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$o(_ref2, _excluded$o);
  var cName2 = "".concat(prefix, "-conversation-header__back");
  return /* @__PURE__ */ React.createElement("div", _extends$o({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(ArrowButton, {
    direction: "left",
    onClick
  }));
};
ConversationHeaderBack.displayName = "ConversationHeader.Back";
var _excluded$n = ["children", "className"];
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
function _objectWithoutProperties$n(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$n(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$n(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderActions = function ConversationHeaderActions2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$n(_ref2, _excluded$n);
  var cName2 = "".concat(prefix, "-conversation-header__actions");
  return /* @__PURE__ */ React.createElement("section", _extends$n({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
ConversationHeaderActions.displayName = "ConversationHeader.Actions";
var _excluded$m = ["userName", "info", "children", "className"];
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _objectWithoutProperties$m(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$m(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$m(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderContent = function ConversationHeaderContent2(_ref2) {
  var _ref$userName = _ref2.userName, userName = _ref$userName === void 0 ? "" : _ref$userName, _ref$info = _ref2.info, info = _ref$info === void 0 ? "" : _ref$info, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$m(_ref2, _excluded$m);
  var cName2 = "".concat(prefix, "-conversation-header__content");
  return /* @__PURE__ */ React.createElement("div", _extends$m({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-conversation-header__user-name")
  }, userName), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-conversation-header__info")
  }, info)));
};
ConversationHeaderContent.displayName = "ConversationHeader.Content";
var _excluded$l = ["children", "className"];
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function _slicedToArray$6(arr, i2) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i2) || _unsupportedIterableToArray$6(arr, i2) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$6(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$6(o2, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$6(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$l(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$l(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$l(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeader = function ConversationHeader2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$l(_ref2, _excluded$l);
  var cName2 = "".concat(prefix, "-conversation-header");
  var _getChildren = getChildren(children, [ConversationHeaderBack, Avatar, AvatarGroup, ConversationHeaderContent, ConversationHeaderActions]), _getChildren2 = _slicedToArray$6(_getChildren, 5), back = _getChildren2[0], avatar = _getChildren2[1], avatarGroup = _getChildren2[2], content = _getChildren2[3], actions = _getChildren2[4];
  return /* @__PURE__ */ React.createElement("div", _extends$l({}, rest, {
    className: classNames(cName2, className)
  }), back, avatar && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), !avatar && avatarGroup && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatarGroup), content, actions);
};
ConversationHeader.displayName = "ConversationHeader";
ConversationHeader.Back = ConversationHeaderBack;
ConversationHeader.Actions = ConversationHeaderActions;
ConversationHeader.Content = ConversationHeaderContent;
/*!
 * perfect-scrollbar v1.5.0
 * Copyright 2020 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function get(element) {
  return getComputedStyle(element);
}
function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element, query2) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query2);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function(child) {
    return matches(child, selector);
  });
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function thumb(x2) {
      return "ps__thumb-" + x2;
    },
    rail: function rail(x2) {
      return "ps__rail-" + x2;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function active(x2) {
      return "ps--active-" + x2;
    },
    scrolling: function scrolling(x2) {
      return "ps--scrolling-" + x2;
    }
  }
};
var scrollingClassTimeout = {
  x: null,
  y: null
};
function addScrollingClass(i2, x2) {
  var classList2 = i2.element.classList;
  var className = cls.state.scrolling(x2);
  if (classList2.contains(className)) {
    clearTimeout(scrollingClassTimeout[x2]);
  } else {
    classList2.add(className);
  }
}
function removeScrollingClass(i2, x2) {
  scrollingClassTimeout[x2] = setTimeout(function() {
    return i2.isAlive && i2.element.classList.remove(cls.state.scrolling(x2));
  }, i2.settings.scrollingThreshold);
}
function setScrollingClassInstantly(i2, x2) {
  addScrollingClass(i2, x2);
  removeScrollingClass(i2, x2);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors = {
  isEmpty: {
    configurable: true
  }
};
EventElement.prototype.bind = function bind2(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  var evts = ["touchstart", "wheel", "touchmove"];
  if (evts.indexOf(eventName) !== -1) {
    this.element.addEventListener(eventName, handler, {
      passive: false
    });
  } else {
    this.element.addEventListener(eventName, handler, false);
  }
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name2 in this.handlers) {
    this.unbind(name2);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(function(key) {
    return this$1$1.handlers[key].length === 0;
  });
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee2 = this.eventElements.filter(function(ee3) {
    return ee3.element === element;
  })[0];
  if (!ee2) {
    ee2 = new EventElement(element);
    this.eventElements.push(ee2);
  }
  return ee2;
};
EventManager.prototype.bind = function bind3(element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  ee2.unbind(eventName, handler);
  if (ee2.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e2) {
    return e2.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  var onceHandler = function onceHandler2(evt) {
    ee2.unbind(eventName, onceHandler2);
    handler(evt);
  };
  ee2.bind(eventName, onceHandler);
};
function createEvent(name2) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name2);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name2, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i2, axis, diff, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll) {
  if (useScrollingClass === void 0) useScrollingClass = true;
  if (forceFireReachEvent === void 0) forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
  } else if (axis === "left") {
    fields = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i2, diff, fields, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll);
}
function processScrollDiff$1(i2, diff, ref2, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll) {
  var contentHeight = ref2[0];
  var containerHeight = ref2[1];
  var scrollTop = ref2[2];
  var y2 = ref2[3];
  var up = ref2[4];
  var down = ref2[5];
  if (useScrollingClass === void 0) useScrollingClass = true;
  if (forceFireReachEvent === void 0) forceFireReachEvent = false;
  var element = i2.element;
  i2.reach[y2] = null;
  var eventFlag = disableOnYReachWhenNoScroll === true ? i2[contentHeight] !== i2[containerHeight] : true;
  if (eventFlag && element[scrollTop] < 1) {
    i2.reach[y2] = "start";
  }
  if (eventFlag && element[scrollTop] > i2[contentHeight] - i2[containerHeight] - 1) {
    i2.reach[y2] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y2));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i2, y2);
    }
  }
  if (i2.reach[y2] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i2.reach[y2]));
  }
}
function toInt(x2) {
  return parseInt(x2, 10) || 0;
}
function isEditable(el2) {
  return matches(el2, "input,[contenteditable]") || matches(el2, "select,[contenteditable]") || matches(el2, "textarea,[contenteditable]") || matches(el2, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles2 = get(element);
  return toInt(styles2.width) + toInt(styles2.paddingLeft) + toInt(styles2.paddingRight) + toInt(styles2.borderLeftWidth) + toInt(styles2.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i2) {
  var element = i2.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i2.containerWidth = Math.round(rect.width);
  i2.containerHeight = Math.round(rect.height);
  i2.contentWidth = element.scrollWidth;
  i2.contentHeight = element.scrollHeight;
  if (!element.contains(i2.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(function(el2) {
      return remove(el2);
    });
    element.appendChild(i2.scrollbarXRail);
  }
  if (!element.contains(i2.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(function(el2) {
      return remove(el2);
    });
    element.appendChild(i2.scrollbarYRail);
  }
  if (!i2.settings.suppressScrollX && i2.containerWidth + i2.settings.scrollXMarginOffset < i2.contentWidth) {
    i2.scrollbarXActive = true;
    i2.railXWidth = i2.containerWidth - i2.railXMarginWidth;
    i2.railXRatio = i2.containerWidth / i2.railXWidth;
    i2.scrollbarXWidth = getThumbSize(i2, toInt(i2.railXWidth * i2.containerWidth / i2.contentWidth));
    i2.scrollbarXLeft = toInt((i2.negativeScrollAdjustment + element.scrollLeft) * (i2.railXWidth - i2.scrollbarXWidth) / (i2.contentWidth - i2.containerWidth));
  } else {
    i2.scrollbarXActive = false;
  }
  if (!i2.settings.suppressScrollY && i2.containerHeight + i2.settings.scrollYMarginOffset < i2.contentHeight) {
    i2.scrollbarYActive = true;
    i2.railYHeight = i2.containerHeight - i2.railYMarginHeight;
    i2.railYRatio = i2.containerHeight / i2.railYHeight;
    i2.scrollbarYHeight = getThumbSize(i2, toInt(i2.railYHeight * i2.containerHeight / i2.contentHeight));
    i2.scrollbarYTop = toInt(roundedScrollTop * (i2.railYHeight - i2.scrollbarYHeight) / (i2.contentHeight - i2.containerHeight));
  } else {
    i2.scrollbarYActive = false;
  }
  if (i2.scrollbarXLeft >= i2.railXWidth - i2.scrollbarXWidth) {
    i2.scrollbarXLeft = i2.railXWidth - i2.scrollbarXWidth;
  }
  if (i2.scrollbarYTop >= i2.railYHeight - i2.scrollbarYHeight) {
    i2.scrollbarYTop = i2.railYHeight - i2.scrollbarYHeight;
  }
  updateCss(element, i2);
  if (i2.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i2.scrollbarXWidth = 0;
    i2.scrollbarXLeft = 0;
    element.scrollLeft = i2.isRtl === true ? i2.contentWidth : 0;
  }
  if (i2.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i2.scrollbarYHeight = 0;
    i2.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i2, thumbSize) {
  if (i2.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i2.settings.minScrollbarLength);
  }
  if (i2.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i2.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i2) {
  var xRailOffset = {
    width: i2.railXWidth
  };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i2.isRtl) {
    xRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth - i2.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i2.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i2.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i2.scrollbarXTop + roundedScrollTop;
  }
  set(i2.scrollbarXRail, xRailOffset);
  var yRailOffset = {
    top: roundedScrollTop,
    height: i2.railYHeight
  };
  if (i2.isScrollbarYUsingRight) {
    if (i2.isRtl) {
      yRailOffset.right = i2.contentWidth - (i2.negativeScrollAdjustment + element.scrollLeft) - i2.scrollbarYRight - i2.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i2.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i2.isRtl) {
      yRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth * 2 - i2.contentWidth - i2.scrollbarYLeft - i2.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i2.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i2.scrollbarYRail, yRailOffset);
  set(i2.scrollbarX, {
    left: i2.scrollbarXLeft,
    width: i2.scrollbarXWidth - i2.railBorderXWidth
  });
  set(i2.scrollbarY, {
    top: i2.scrollbarYTop,
    height: i2.scrollbarYHeight - i2.railBorderYWidth
  });
}
function clickRail(i2) {
  i2.element;
  i2.event.bind(i2.scrollbarY, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarYRail, "mousedown", function(e2) {
    var positionTop = e2.pageY - window.pageYOffset - i2.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i2.scrollbarYTop ? 1 : -1;
    i2.element.scrollTop += direction * i2.containerHeight;
    updateGeometry(i2);
    e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarX, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarXRail, "mousedown", function(e2) {
    var positionLeft = e2.pageX - window.pageXOffset - i2.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i2.scrollbarXLeft ? 1 : -1;
    i2.element.scrollLeft += direction * i2.containerWidth;
    updateGeometry(i2);
    e2.stopPropagation();
  });
}
function dragThumb(i2) {
  bindMouseScrollHandler(i2, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]);
  bindMouseScrollHandler(i2, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"]);
}
function bindMouseScrollHandler(i2, ref2) {
  var containerHeight = ref2[0];
  var contentHeight = ref2[1];
  var pageY = ref2[2];
  var railYHeight = ref2[3];
  var scrollbarY = ref2[4];
  var scrollbarYHeight = ref2[5];
  var scrollTop = ref2[6];
  var y2 = ref2[7];
  var scrollbarYRail = ref2[8];
  var element = i2.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e2) {
    if (e2.touches && e2.touches[0]) {
      e2[pageY] = e2.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy * (e2[pageY] - startingMousePageY);
    addScrollingClass(i2, y2);
    updateGeometry(i2);
    e2.stopPropagation();
    e2.preventDefault();
  }
  function mouseUpHandler() {
    removeScrollingClass(i2, y2);
    i2[scrollbarYRail].classList.remove(cls.state.clicking);
    i2.event.unbind(i2.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e2, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e2.touches) {
      e2[pageY] = e2.touches[0].pageY;
    }
    startingMousePageY = e2[pageY];
    scrollBy = (i2[contentHeight] - i2[containerHeight]) / (i2[railYHeight] - i2[scrollbarYHeight]);
    if (!touchMode) {
      i2.event.bind(i2.ownerDocument, "mousemove", mouseMoveHandler);
      i2.event.once(i2.ownerDocument, "mouseup", mouseUpHandler);
      e2.preventDefault();
    } else {
      i2.event.bind(i2.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i2[scrollbarYRail].classList.add(cls.state.clicking);
    e2.stopPropagation();
  }
  i2.event.bind(i2[scrollbarY], "mousedown", function(e2) {
    bindMoves(e2);
  });
  i2.event.bind(i2[scrollbarY], "touchstart", function(e2) {
    bindMoves(e2, true);
  });
}
function keyboard(i2) {
  var element = i2.element;
  var elementHovered = function elementHovered2() {
    return matches(element, ":hover");
  };
  var scrollbarFocused = function scrollbarFocused2() {
    return matches(i2.scrollbarX, ":focus") || matches(i2.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i2.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i2.contentHeight - i2.containerHeight && deltaY < 0) {
        return !i2.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i2.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i2.contentWidth - i2.containerWidth && deltaX > 0) {
        return !i2.settings.wheelPropagation;
      }
    }
    return true;
  }
  i2.event.bind(i2.ownerDocument, "keydown", function(e2) {
    if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i2.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e2.which) {
      case 37:
        if (e2.metaKey) {
          deltaX = -i2.contentWidth;
        } else if (e2.altKey) {
          deltaX = -i2.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e2.metaKey) {
          deltaY = i2.contentHeight;
        } else if (e2.altKey) {
          deltaY = i2.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e2.metaKey) {
          deltaX = i2.contentWidth;
        } else if (e2.altKey) {
          deltaX = i2.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e2.metaKey) {
          deltaY = -i2.contentHeight;
        } else if (e2.altKey) {
          deltaY = -i2.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e2.shiftKey) {
          deltaY = i2.containerHeight;
        } else {
          deltaY = -i2.containerHeight;
        }
        break;
      case 33:
        deltaY = i2.containerHeight;
        break;
      case 34:
        deltaY = -i2.containerHeight;
        break;
      case 36:
        deltaY = i2.contentHeight;
        break;
      case 35:
        deltaY = -i2.contentHeight;
        break;
      default:
        return;
    }
    if (i2.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i2.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i2);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e2.preventDefault();
    }
  });
}
function wheel(i2) {
  var element = i2.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i2.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e2) {
    var deltaX = e2.deltaX;
    var deltaY = -1 * e2.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e2.wheelDeltaX / 6;
      deltaY = e2.wheelDeltaY / 6;
    }
    if (e2.deltaMode && e2.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e2.wheelDelta;
    }
    if (e2.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e2) {
    var ref2 = getDeltaFromEvent(e2);
    var deltaX = ref2[0];
    var deltaY = ref2[1];
    if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i2.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i2.settings.wheelSpeed;
      element.scrollLeft += deltaX * i2.settings.wheelSpeed;
    } else if (i2.scrollbarYActive && !i2.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i2.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i2.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i2.scrollbarXActive && !i2.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i2.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i2.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i2);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e2.ctrlKey) {
      e2.stopPropagation();
      e2.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i2.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i2.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch(i2) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i2.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = Math.ceil(element.scrollLeft);
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (!i2.settings.wheelPropagation) {
      return true;
    }
    if (magnitudeY > magnitudeX) {
      if (i2.settings.suppressScrollY) {
        return false;
      }
      if (deltaY > 0) {
        return scrollTop !== 0;
      }
      if (deltaY < 0) {
        return scrollTop < i2.contentHeight - i2.containerHeight;
      }
    } else if (magnitudeX > magnitudeY) {
      if (i2.settings.suppressScrollX) {
        return false;
      }
      if (deltaX > 0) {
        return scrollLeft !== 0;
      }
      if (deltaY < 0) {
        return scrollLeft < i2.contentWidth - i2.containerWidth;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i2);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e2) {
    if (e2.targetTouches) {
      return e2.targetTouches[0];
    } else {
      return e2;
    }
  }
  function shouldHandle(e2) {
    if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
      return false;
    }
    if (e2.targetTouches && e2.targetTouches.length === 1) {
      return true;
    }
    if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e2) {
    if (!shouldHandle(e2)) {
      return;
    }
    var touch2 = getTouch(e2);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = (/* @__PURE__ */ new Date()).getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function touchMove(e2) {
    if (shouldHandle(e2)) {
      var touch2 = getTouch(e2);
      var currentOffset = {
        pageX: touch2.pageX,
        pageY: touch2.pageY
      };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (e2.cancelable && shouldPrevent(differenceX, differenceY)) {
        e2.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i2.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i2.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i2.event.bind(element, "touchstart", touchStart);
    i2.event.bind(element, "touchmove", touchMove);
    i2.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i2.event.bind(element, "pointerdown", touchStart);
      i2.event.bind(element, "pointermove", touchMove);
      i2.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i2.event.bind(element, "MSPointerDown", touchStart);
      i2.event.bind(element, "MSPointerMove", touchMove);
      i2.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function defaultSettings2() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0) userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function focus2() {
    return element.classList.add(cls.state.focus);
  };
  var blur = function blur2() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set(this.scrollbarXRail, {
    display: "block"
  });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, {
    display: ""
  });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, {
    display: "block"
  });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, {
    display: ""
  });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e2) {
    return this$1$1.onScroll(e2);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update(disableOnYReachWhenNoScroll) {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set(this.scrollbarXRail, {
    display: "block"
  });
  set(this.scrollbarYRail, {
    display: "block"
  });
  this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
  set(this.scrollbarXRail, {
    display: "none"
  });
  set(this.scrollbarYRail, {
    display: "none"
  });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true, disableOnYReachWhenNoScroll);
  processScrollDiff(this, "left", 0, false, true, disableOnYReachWhenNoScroll);
  set(this.scrollbarXRail, {
    display: ""
  });
  set(this.scrollbarYRail, {
    display: ""
  });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name2) {
    return !name2.match(/^ps([-_].+|)$/);
  }).join(" ");
};
function _typeof$c(o2) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$c(o2);
}
var _excluded$k = ["className", "style", "option", "options", "containerRef", "onScrollY", "onScrollX", "onScrollUp", "onScrollDown", "onScrollLeft", "onScrollRight", "onYReachStart", "onYReachEnd", "onXReachStart", "onXReachEnd", "component", "onSync", "children"];
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _objectWithoutProperties$k(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$k(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$k(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$b(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$b(t2) {
  var i2 = _toPrimitive$b(t2, "string");
  return "symbol" == _typeof$c(i2) ? i2 : String(i2);
}
function _toPrimitive$b(t2, r2) {
  if ("object" != _typeof$c(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$c(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function _callSuper$3(t2, o2, e2) {
  return o2 = _getPrototypeOf$3(o2), _possibleConstructorReturn$3(t2, _isNativeReflectConstruct$3() ? Reflect.construct(o2, e2, _getPrototypeOf$3(t2).constructor) : o2.apply(t2, e2));
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _isNativeReflectConstruct$3() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$3(o2) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf$3(o2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o2, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf$3(o2, p2);
}
var handlerNameByEvent = {
  "ps-scroll-y": "onScrollY",
  "ps-scroll-x": "onScrollX",
  "ps-scroll-up": "onScrollUp",
  "ps-scroll-down": "onScrollDown",
  "ps-scroll-left": "onScrollLeft",
  "ps-scroll-right": "onScrollRight",
  "ps-y-reach-start": "onYReachStart",
  "ps-y-reach-end": "onYReachEnd",
  "ps-x-reach-start": "onXReachStart",
  "ps-x-reach-end": "onXReachEnd"
};
Object.freeze(handlerNameByEvent);
var ScrollBar = /* @__PURE__ */ function(_Component) {
  _inherits$3(ScrollBar2, _Component);
  function ScrollBar2(props) {
    var _this;
    _classCallCheck$3(this, ScrollBar2);
    _this = _callSuper$3(this, ScrollBar2, [props]);
    _this.handleRef = _this.handleRef.bind(_assertThisInitialized$3(_this));
    _this._handlerByEvent = {};
    return _this;
  }
  _createClass$3(ScrollBar2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.option) {
        console.warn('react-perfect-scrollbar: the "option" prop has been deprecated in favor of "options"');
      }
      this._ps = new PerfectScrollbar(this._container, this.props.options || this.props.option);
      this._updateEventHook();
      this._updateClassName();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this._updateEventHook(prevProps);
      this.updateScroll();
      if (prevProps.className !== this.props.className) {
        this._updateClassName();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this2 = this;
      Object.keys(this._handlerByEvent).forEach(function(key) {
        var value = _this2._handlerByEvent[key];
        if (value) {
          _this2._container.removeEventListener(key, value, false);
        }
      });
      this._handlerByEvent = {};
      this._ps.destroy();
      this._ps = null;
    }
  }, {
    key: "_updateEventHook",
    value: function _updateEventHook() {
      var _this3 = this;
      var prevProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.keys(handlerNameByEvent).forEach(function(key) {
        var callback = _this3.props[handlerNameByEvent[key]];
        var prevCallback = prevProps[handlerNameByEvent[key]];
        if (callback !== prevCallback) {
          if (prevCallback) {
            var prevHandler = _this3._handlerByEvent[key];
            _this3._container.removeEventListener(key, prevHandler, false);
            _this3._handlerByEvent[key] = null;
          }
          if (callback) {
            var handler = function handler2() {
              return callback(_this3._container);
            };
            _this3._container.addEventListener(key, handler, false);
            _this3._handlerByEvent[key] = handler;
          }
        }
      });
    }
  }, {
    key: "_updateClassName",
    value: function _updateClassName() {
      var className = this.props.className;
      var psClassNames = this._container.className.split(" ").filter(function(name2) {
        return name2.match(/^ps([-_].+|)$/);
      }).join(" ");
      if (this._container) {
        this._container.className = "scrollbar-container".concat(className ? " ".concat(className) : "").concat(psClassNames ? " ".concat(psClassNames) : "");
      }
    }
  }, {
    key: "updateScroll",
    value: function updateScroll() {
      var onSync = this.props.onSync;
      if (typeof onSync === "function") {
        onSync(this._ps);
      } else {
        this._ps.update();
      }
    }
  }, {
    key: "handleRef",
    value: function handleRef(ref2) {
      var _this$props$container, _this$props;
      this._container = ref2;
      (_this$props$container = (_this$props = this.props).containerRef) === null || _this$props$container === void 0 ? void 0 : _this$props$container.call(_this$props, ref2);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.className;
      var style = _this$props2.style;
      _this$props2.option;
      _this$props2.options;
      _this$props2.containerRef;
      _this$props2.onScrollY;
      _this$props2.onScrollX;
      _this$props2.onScrollUp;
      _this$props2.onScrollDown;
      _this$props2.onScrollLeft;
      _this$props2.onScrollRight;
      _this$props2.onYReachStart;
      _this$props2.onYReachEnd;
      _this$props2.onXReachStart;
      _this$props2.onXReachEnd;
      var component = _this$props2.component;
      _this$props2.onSync;
      var children = _this$props2.children, remainProps = _objectWithoutProperties$k(_this$props2, _excluded$k);
      var Comp = typeof component === "undefined" ? "div" : component;
      return /* @__PURE__ */ React.createElement(Comp, _extends$k({
        style,
        ref: this.handleRef
      }, remainProps), children);
    }
  }]);
  return ScrollBar2;
}(reactExports.Component);
function _typeof$b(o2) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$b(o2);
}
var _excluded$j = ["className", "variant", "children"];
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(t2) {
  var i2 = _toPrimitive$a(t2, "string");
  return "symbol" == _typeof$b(i2) ? i2 : String(i2);
}
function _toPrimitive$a(t2, r2) {
  if ("object" != _typeof$b(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$b(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$j(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$j(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$j(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Loader = function Loader22(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? void 0 : _ref$className, _ref$variant = _ref2.variant, variant = _ref$variant === void 0 ? "default" : _ref$variant, children = _ref2.children, rest = _objectWithoutProperties$j(_ref2, _excluded$j);
  var cName2 = "".concat(prefix, "-loader");
  var textClass = React.Children.count(children) > 0 ? "".concat(cName2, "--content") : "";
  return /* @__PURE__ */ React.createElement("div", _extends$j({}, rest, {
    className: classNames(cName2, textClass, _defineProperty$a({}, "".concat(cName2, "--variant-").concat(variant), variant !== "default"), className),
    role: "status"
  }), children);
};
function _typeof$a(o2) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$a(o2);
}
var _excluded$i = ["className", "children", "blur", "grayscale"];
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(t2) {
  var i2 = _toPrimitive$9(t2, "string");
  return "symbol" == _typeof$a(i2) ? i2 : String(i2);
}
function _toPrimitive$9(t2, r2) {
  if ("object" != _typeof$a(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$i(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$i(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$i(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Overlay = function Overlay2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, _ref$blur = _ref2.blur, blur = _ref$blur === void 0 ? false : _ref$blur, _ref$grayscale = _ref2.grayscale, grayscale = _ref$grayscale === void 0 ? false : _ref$grayscale, rest = _objectWithoutProperties$i(_ref2, _excluded$i);
  var cName2 = "".concat(prefix, "-overlay");
  var blurClass = "".concat(cName2, "--blur");
  var grayscaleClass = "".concat(cName2, "--grayscale");
  return /* @__PURE__ */ React.createElement("div", _extends$i({}, rest, {
    className: classNames(cName2, _defineProperty$9({}, blurClass, blur), _defineProperty$9({}, grayscaleClass, grayscale), className)
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, children));
};
var _excluded$h = ["sender", "sentTime", "children", "className"];
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
function _objectWithoutProperties$h(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$h(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$h(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageHeader = function MessageHeader2(_ref2) {
  var _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$h(_ref2, _excluded$h);
  var cName2 = "".concat(prefix, "-message__header");
  return /* @__PURE__ */ React.createElement("div", _extends$h({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sender-name")
  }, sender), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sent-time")
  }, sentTime)));
};
MessageHeader.displayName = "Message.Header";
var _excluded$g = ["sender", "sentTime", "children", "className"];
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _objectWithoutProperties$g(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$g(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$g(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageFooter = function MessageFooter2(_ref2) {
  var _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$g(_ref2, _excluded$g);
  var cName2 = "".concat(prefix, "-message__footer");
  return /* @__PURE__ */ React.createElement("div", _extends$g({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sender-name")
  }, sender), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sent-time")
  }, sentTime)));
};
MessageFooter.displayName = "Message.Footer";
var MessageCustomContent = function MessageCustomContent2(_ref2) {
  var children = _ref2.children, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__custom-content");
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, children);
};
MessageCustomContent.displayName = "Message.CustomContent";
var MessageImageContent = function MessageImageContent2(_ref2) {
  var src = _ref2.src, width = _ref2.width, height = _ref2.height, alt = _ref2.alt, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__image-content");
  var style = {
    width: typeof width === "number" ? "".concat(width, "px") : typeof width === "string" ? width : void 0,
    height: typeof height === "number" ? "".concat(height, "px") : typeof height === "string" ? height : void 0
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, /* @__PURE__ */ React.createElement("img", {
    src,
    style,
    alt
  }));
};
MessageImageContent.displayName = "Message.ImageContent";
var MessageHtmlContent = function MessageHtmlContent2(_ref2) {
  var html = _ref2.html, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__html-content");
  var createMarkup = function createMarkup2() {
    return {
      __html: html
    };
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className),
    dangerouslySetInnerHTML: createMarkup()
  });
};
MessageHtmlContent.displayName = "Message.HtmlContent";
var MessageTextContent = function MessageTextContent2(_ref2) {
  var text = _ref2.text, className = _ref2.className, children = _ref2.children;
  var cName2 = "".concat(prefix, "-message__text-content");
  var content = children !== null && children !== void 0 ? children : text;
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, content);
};
MessageTextContent.displayName = "Message.TextContent";
var _excluded$f = ["model", "avatarSpacer", "avatarPosition", "type", "payload", "children", "className"];
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(t2) {
  var i2 = _toPrimitive$8(t2, "string");
  return "symbol" == _typeof$9(i2) ? i2 : String(i2);
}
function _toPrimitive$8(t2, r2) {
  if ("object" != _typeof$9(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$9(o2) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$9(o2);
}
function _slicedToArray$5(arr, i2) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i2) || _unsupportedIterableToArray$5(arr, i2) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$5(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$5(o2, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$5(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$f(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$f(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$f(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Message = function Message2(_ref2) {
  var _ref22, _ref3;
  var _ref$model = _ref2.model, _ref$model$message = _ref$model.message, message = _ref$model$message === void 0 ? "" : _ref$model$message, _ref$model$sentTime = _ref$model.sentTime, sentTime = _ref$model$sentTime === void 0 ? "" : _ref$model$sentTime, _ref$model$sender = _ref$model.sender, sender = _ref$model$sender === void 0 ? "" : _ref$model$sender, _ref$model$direction = _ref$model.direction, direction = _ref$model$direction === void 0 ? 1 : _ref$model$direction, position2 = _ref$model.position, modelType = _ref$model.type, modelPayload = _ref$model.payload, _ref$avatarSpacer = _ref2.avatarSpacer, avatarSpacer = _ref$avatarSpacer === void 0 ? false : _ref$avatarSpacer, _ref$avatarPosition = _ref2.avatarPosition, avatarPosition = _ref$avatarPosition === void 0 ? void 0 : _ref$avatarPosition, _ref$type = _ref2.type, type2 = _ref$type === void 0 ? "html" : _ref$type, argPayload = _ref2.payload, children = _ref2.children, className = _ref2.className, rest = _objectWithoutProperties$f(_ref2, _excluded$f);
  var cName2 = "".concat(prefix, "-message");
  var _getChildren = getChildren(children, [Avatar, MessageHeader, MessageFooter, MessageHtmlContent, MessageTextContent, MessageImageContent, MessageCustomContent]), _getChildren2 = _slicedToArray$5(_getChildren, 7), avatar = _getChildren2[0], header = _getChildren2[1], footer = _getChildren2[2], htmlContent = _getChildren2[3], textContent = _getChildren2[4], imageContent = _getChildren2[5], customContent = _getChildren2[6];
  var directionClass = function() {
    if (direction === 0 || direction === "incoming") {
      return "".concat(cName2, "--incoming");
    } else if (direction === 1 || direction === "outgoing") {
      return "".concat(cName2, "--outgoing");
    }
  }();
  var avatarPositionClass = function(position22) {
    var classPrefix = "".concat(cName2, "--avatar-");
    if (position22 === 0 || position22 === "top-left" || position22 === "tl") {
      return "".concat(classPrefix, "tl");
    } else if (position22 === 1 || position22 === "top-right" || position22 === "tr") {
      return "".concat(classPrefix, "tr");
    } else if (position22 === 2 || position22 === "bottom-right" || position22 === "br") {
      return "".concat(classPrefix, "br");
    } else if (position22 === 3 || position22 === "bottom-left" || position22 === "bl") {
      return "".concat(classPrefix, "bl");
    } else if (position22 === 4 || position22 === "center-left" || position22 === "cl") {
      return "".concat(classPrefix, "cl");
    } else if (position22 === 5 || position22 === "center-right" || position22 === "cr") {
      return "".concat(classPrefix, "cr");
    }
  }(avatarPosition);
  var positionClass = function(position22) {
    var classPrefix = "".concat(prefix, "-message--");
    if (position22 === "single" || position22 === 0) {
      return "".concat(classPrefix, "single");
    } else if (position22 === "first" || position22 === 1) {
      return "".concat(classPrefix, "first");
    } else if (position22 === "normal" || position22 === 2) {
      return "";
    } else if (position22 === "last" || position22 === 3) {
      return "".concat(classPrefix, "last");
    }
  }(position2);
  var ariaLabel = function() {
    if ((sender === null || sender === void 0 ? void 0 : sender.length) > 0 && (sentTime === null || sentTime === void 0 ? void 0 : sentTime.length) > 0) {
      return "".concat(sender, ": ").concat(sentTime);
    } else if ((sender === null || sender === void 0 ? void 0 : sender.length) > 0 && (typeof sentTime === "undefined" || (sentTime === null || sentTime === void 0 ? void 0 : sentTime.length) === 0)) {
      return sender;
    } else {
      return null;
    }
  }();
  var childContent = (_ref22 = (_ref3 = htmlContent !== null && htmlContent !== void 0 ? htmlContent : textContent) !== null && _ref3 !== void 0 ? _ref3 : imageContent) !== null && _ref22 !== void 0 ? _ref22 : customContent;
  var messageContent = childContent !== null && childContent !== void 0 ? childContent : function() {
    var messageType = modelType !== null && modelType !== void 0 ? modelType : type2;
    var payloadFromModel = modelPayload !== null && modelPayload !== void 0 ? modelPayload : message;
    var payload = payloadFromModel !== null && payloadFromModel !== void 0 ? payloadFromModel : argPayload;
    var payloadName = _typeof$9(payload) === "object" ? getComponentName(payload) : "";
    if (messageType === "html" && payloadName !== "Message.CustomContent") {
      return /* @__PURE__ */ React.createElement(MessageHtmlContent, {
        html: payload
      });
    } else if (messageType === "text") {
      return /* @__PURE__ */ React.createElement(MessageTextContent, {
        text: payload
      });
    } else if (messageType === "image") {
      return /* @__PURE__ */ React.createElement(MessageImageContent, payload);
    } else if (messageType === "custom" || payloadName === "Message.CustomContent") {
      return payload;
    }
  }();
  return /* @__PURE__ */ React.createElement("section", _extends$f({}, rest, {
    "aria-label": ariaLabel,
    className: classNames(cName2, directionClass, _defineProperty$8({}, "".concat(cName2, "--avatar-spacer"), avatarSpacer), positionClass, avatarPositionClass, className)
  }, _defineProperty$8({}, "data-".concat(prefix, "-message"), "")), typeof avatar !== "undefined" && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content-wrapper")
  }, header, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, messageContent), footer));
};
Message.Header = MessageHeader;
Message.HtmlContent = MessageHtmlContent;
Message.TextContent = MessageTextContent;
Message.ImageContent = MessageImageContent;
Message.CustomContent = MessageCustomContent;
Message.Footer = MessageFooter;
var _excluded$e = ["children", "className"];
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
function _objectWithoutProperties$e(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$e(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupHeader = function MessageGroupHeader2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$e(_ref2, _excluded$e);
  var cName2 = "".concat(prefix, "-message-group__header");
  return /* @__PURE__ */ React.createElement("div", _extends$e({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
MessageGroupHeader.displayName = "MessageGroup.Header";
var _excluded$d = ["children", "className"];
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function _objectWithoutProperties$d(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupFooter = function MessageGroupFooter2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$d(_ref2, _excluded$d);
  var cName2 = "".concat(prefix, "-message-group__footer");
  return /* @__PURE__ */ React.createElement("div", _extends$d({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
MessageGroupFooter.displayName = "MessageGroup.Footer";
var _excluded$c = ["children", "className"];
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _objectWithoutProperties$c(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupMessages = function MessageGroupMessages2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$c(_ref2, _excluded$c);
  var cName2 = "".concat(prefix, "-message-group");
  return /* @__PURE__ */ React.createElement("div", _extends$c({}, rest, {
    className: classNames("".concat(cName2, "__messages"), className)
  }), children);
};
MessageGroupMessages.displayName = "MessageGroup.Messages";
function _typeof$8(o2) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$8(o2);
}
var _excluded$b = ["direction", "avatarPosition", "sender", "sentTime", "children", "className"];
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(t2) {
  var i2 = _toPrimitive$7(t2, "string");
  return "symbol" == _typeof$8(i2) ? i2 : String(i2);
}
function _toPrimitive$7(t2, r2) {
  if ("object" != _typeof$8(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray$4(arr, i2) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i2) || _unsupportedIterableToArray$4(arr, i2) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$4(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$4(o2, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$4(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroup = function MessageGroup2(_ref2) {
  var _ref$direction = _ref2.direction, direction = _ref$direction === void 0 ? "incoming" : _ref$direction, _ref$avatarPosition = _ref2.avatarPosition, avatarPosition = _ref$avatarPosition === void 0 ? void 0 : _ref$avatarPosition, _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, children = _ref2.children, className = _ref2.className, rest = _objectWithoutProperties$b(_ref2, _excluded$b);
  var cName2 = "".concat(prefix, "-message-group");
  var directionClass = function() {
    if (direction === 0 || direction === "incoming") {
      return "".concat(cName2, "--incoming");
    } else if (direction === 1 || direction === "outgoing") {
      return "".concat(cName2, "--outgoing");
    }
  }();
  var avatarPositionClass = function() {
    var prefix2 = "".concat(cName2, "--avatar-");
    if (typeof avatarPosition === "string") {
      if (avatarPosition === "tl" || avatarPosition === "top-left" || avatarPosition === "tr" || avatarPosition === "top-right" || avatarPosition === "bl" || avatarPosition === "bottom-right" || avatarPosition === "br" || avatarPosition === "bottom-right" || avatarPosition === "cl" || avatarPosition === "center-left" || avatarPosition === "cr" || avatarPosition === "center-right") {
        return "".concat(prefix2).concat(avatarPosition);
      }
    }
  }();
  var _getChildren = getChildren(children, [Avatar, MessageGroupHeader, MessageGroupFooter, MessageGroupMessages]), _getChildren2 = _slicedToArray$4(_getChildren, 4), avatar = _getChildren2[0], header = _getChildren2[1], footer = _getChildren2[2], messages2 = _getChildren2[3];
  var ariaLabel = function() {
    if (sender.length > 0 && sentTime.length > 0) {
      return "".concat(sender, ": ").concat(sentTime);
    } else if (sender.length > 0 && sentTime.length === 0) {
      return sender;
    } else {
      return null;
    }
  }();
  return /* @__PURE__ */ React.createElement("section", _extends$b({
    "aria-label": ariaLabel
  }, rest, {
    className: classNames(cName2, directionClass, avatarPositionClass, className)
  }, _defineProperty$7({}, "data-".concat(prefix, "-message-group"), "")), typeof avatar !== "undefined" && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, header, messages2, footer));
};
MessageGroup.Header = MessageGroupHeader;
MessageGroup.Footer = MessageGroupFooter;
MessageGroup.Messages = MessageGroupMessages;
var _excluded$a = ["content", "as", "children", "className"];
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageSeparator = function MessageSeparator2(_ref2) {
  var _ref$content = _ref2.content, content = _ref$content === void 0 ? void 0 : _ref$content, _ref$as = _ref2.as, as = _ref$as === void 0 ? "div" : _ref$as, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$a(_ref2, _excluded$a);
  var cName2 = "".concat(prefix, "-message-separator");
  var Tag = function() {
    if (typeof as === "string" && as.length > 0) {
      return as;
    } else {
      return "div";
    }
  }();
  return /* @__PURE__ */ React.createElement(Tag, _extends$a({}, rest, {
    className: classNames(cName2, className)
  }), isChildrenNil(children) === true ? content : children);
};
var _excluded$9 = ["className", "children"];
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageListContent = function MessageListContent2(_ref2) {
  var className = _ref2.className, children = _ref2.children, rest = _objectWithoutProperties$9(_ref2, _excluded$9);
  return /* @__PURE__ */ React.createElement("div", _extends$9({}, rest, {
    className
  }), children);
};
MessageListContent.displayName = "MessageList.Content";
var _excluded$8 = ["children", "typingIndicator", "loading", "loadingMore", "loadingMorePosition", "onYReachStart", "onYReachEnd", "className", "disableOnYReachWhenNoScroll", "scrollBehavior", "autoScrollToBottom", "autoScrollToBottomOnMount"];
function _typeof$7(o2) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$7(o2);
}
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
function _slicedToArray$3(arr, i2) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$3(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$3(o2, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$3(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$2(t2, o2, e2) {
  return o2 = _getPrototypeOf$2(o2), _possibleConstructorReturn$2(t2, _isNativeReflectConstruct$2() ? Reflect.construct(o2, e2, _getPrototypeOf$2(t2).constructor) : o2.apply(t2, e2));
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _isNativeReflectConstruct$2() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$2(o2) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf$2(o2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(t2) {
  var i2 = _toPrimitive$6(t2, "string");
  return "symbol" == _typeof$7(i2) ? i2 : String(i2);
}
function _toPrimitive$6(t2, r2) {
  if ("object" != _typeof$7(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var MessageListInner = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(MessageListInner2, _React$Component);
  function MessageListInner2(props) {
    var _this;
    _classCallCheck$2(this, MessageListInner2);
    _this = _callSuper$2(this, MessageListInner2, [props]);
    _defineProperty$6(_assertThisInitialized$2(_this), "handleResize", function() {
      if (_this.containerRef.current.clientHeight < _this.lastClientHeight) {
        _this.scrollToEnd(_this.props.scrollBehavior);
      }
      _this.scrollRef.current.updateScroll();
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "handleContainerResize", function() {
      if (_this.resizeTicking === false) {
        window.requestAnimationFrame(function() {
          var list = _this.containerRef.current;
          if (list) {
            var currentHeight = list.clientHeight;
            var diff = currentHeight - _this.lastClientHeight;
            if (diff >= 1) {
              if (_this.preventScrollTop === false) {
                list.scrollTop = Math.round(list.scrollTop) - diff;
              }
            } else {
              list.scrollTop = list.scrollTop - diff;
            }
            _this.lastClientHeight = list.clientHeight;
            _this.scrollRef.current.updateScroll();
          }
          _this.resizeTicking = false;
        });
        _this.resizeTicking = true;
      }
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "isSticked", function() {
      var list = _this.containerRef.current;
      return list.scrollHeight === Math.round(list.scrollTop + list.clientHeight);
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "handleScroll", function() {
      if (_this.scrollTicking === false) {
        window.requestAnimationFrame(function() {
          if (_this.noScroll === false) {
            _this.preventScrollTop = _this.isSticked();
          } else {
            _this.noScroll = false;
          }
          _this.scrollTicking = false;
        });
        _this.scrollTicking = true;
      }
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "getLastMessageOrGroup", function() {
      var lastElement = _this.containerRef.current.querySelector("[data-".concat(prefix, "-message-list]>[data-").concat(prefix, "-message]:last-of-type,[data-").concat(prefix, "-message-list]>[data-").concat(prefix, "-message-group]:last-of-type"));
      var lastMessageInGroup = lastElement === null || lastElement === void 0 ? void 0 : lastElement.querySelector("[data-".concat(prefix, "-message]:last-of-type"));
      return {
        lastElement,
        lastMessageInGroup
      };
    });
    _this.scrollPointRef = /* @__PURE__ */ React.createRef();
    _this.containerRef = /* @__PURE__ */ React.createRef();
    _this.scrollRef = /* @__PURE__ */ React.createRef();
    _this.lastClientHeight = 0;
    _this.preventScrollTop = false;
    _this.resizeObserver = void 0;
    _this.scrollTicking = false;
    _this.resizeTicking = false;
    _this.noScroll = void 0;
    return _this;
  }
  _createClass$2(MessageListInner2, [{
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate() {
      var list = this.containerRef.current;
      var topHeight = Math.round(list.scrollTop + list.clientHeight);
      var sticky = list.scrollHeight === topHeight || list.scrollHeight + 1 === topHeight || list.scrollHeight - 1 === topHeight;
      return {
        sticky,
        clientHeight: list.clientHeight,
        scrollHeight: list.scrollHeight,
        lastMessageOrGroup: this.getLastMessageOrGroup(),
        diff: list.scrollHeight - list.scrollTop
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.autoScrollToBottomOnMount === true) {
        this.scrollToEnd(this.props.scrollBehavior);
      }
      this.lastClientHeight = this.containerRef.current.clientHeight;
      window.addEventListener("resize", this.handleResize);
      if (typeof window.ResizeObserver === "function") {
        this.resizeObserver = new ResizeObserver(this.handleContainerResize);
        this.resizeObserver.observe(this.containerRef.current);
      }
      this.containerRef.current.addEventListener("scroll", this.handleScroll);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot2) {
      var autoScrollToBottom = this.props.autoScrollToBottom;
      if (typeof snapshot2 !== "undefined") {
        var list = this.containerRef.current;
        var _this$getLastMessageO = this.getLastMessageOrGroup(), lastElement = _this$getLastMessageO.lastElement, lastMessageInGroup = _this$getLastMessageO.lastMessageInGroup;
        if (lastElement === snapshot2.lastMessageOrGroup.lastElement) {
          if (typeof lastMessageInGroup === "undefined" || lastMessageInGroup === snapshot2.lastMessageOrGroup.lastMessageInGroup) {
            list.scrollTop = list.scrollHeight - snapshot2.diff + (this.lastClientHeight - list.clientHeight);
          }
        }
        if (snapshot2.sticky === true) {
          if (autoScrollToBottom === true) {
            this.scrollToEnd(this.props.scrollBehavior);
          }
          this.preventScrollTop = true;
        } else {
          if (snapshot2.clientHeight < this.lastClientHeight) {
            var sHeight = list.scrollTop + this.lastClientHeight;
            if (list.scrollHeight === sHeight || list.scrollHeight + 1 === sHeight || list.scrollHeight - 1 === sHeight) {
              if (autoScrollToBottom === true) {
                this.scrollToEnd(this.props.scrollBehavior);
                this.preventScrollTop = true;
              }
            } else {
              this.preventScrollTop = false;
            }
          } else {
            this.preventScrollTop = false;
            if (lastElement === snapshot2.lastMessageOrGroup.lastElement) {
              if (typeof lastMessageInGroup === "undefined" || lastMessageInGroup === snapshot2.lastMessageOrGroup.lastMessageInGroup) {
                if (list.scrollTop === 0 && list.scrollHeight > snapshot2.scrollHeight) {
                  list.scrollTop = list.scrollHeight - snapshot2.scrollHeight;
                }
              }
            }
          }
        }
        this.lastClientHeight = snapshot2.clientHeight;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("resize", this.handleResize);
      if (typeof this.resizeObserver !== "undefined") {
        this.resizeObserver.disconnect();
      }
      this.containerRef.current.removeEventListener("scroll", this.handleScroll);
    }
  }, {
    key: "scrollToEnd",
    value: function scrollToEnd() {
      var scrollBehavior = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.scrollBehavior;
      var list = this.containerRef.current;
      var scrollPoint = this.scrollPointRef.current;
      var parentRect = list.getBoundingClientRect();
      var childRect = scrollPoint.getBoundingClientRect();
      var scrollOffset = childRect.top + list.scrollTop - parentRect.top;
      if (list.scrollBy) {
        list.scrollBy({
          top: scrollOffset,
          behavior: scrollBehavior
        });
      } else {
        list.scrollTop = scrollOffset;
      }
      this.lastClientHeight = list.clientHeight;
      this.noScroll = true;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, children = _this$props.children, typingIndicator = _this$props.typingIndicator, loading = _this$props.loading, loadingMore = _this$props.loadingMore, loadingMorePosition = _this$props.loadingMorePosition, onYReachStart = _this$props.onYReachStart, onYReachEnd = _this$props.onYReachEnd, className = _this$props.className, disableOnYReachWhenNoScroll = _this$props.disableOnYReachWhenNoScroll;
      _this$props.scrollBehavior;
      _this$props.autoScrollToBottom;
      _this$props.autoScrollToBottomOnMount;
      var rest = _objectWithoutProperties$8(_this$props, _excluded$8);
      var cName2 = "".concat(prefix, "-message-list");
      var _getChildren = getChildren(children, [MessageListContent]), _getChildren2 = _slicedToArray$3(_getChildren, 1), customContent = _getChildren2[0];
      return /* @__PURE__ */ React.createElement("div", _extends$8({}, rest, {
        className: classNames(cName2, className)
      }), loadingMore && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(cName2, "__loading-more"), _defineProperty$6({}, "".concat(cName2, "__loading-more--bottom"), loadingMorePosition === "bottom"))
      }, /* @__PURE__ */ React.createElement(Loader, null)), loading && /* @__PURE__ */ React.createElement(Overlay, null, /* @__PURE__ */ React.createElement(Loader, null)), /* @__PURE__ */ React.createElement(ScrollBar, _extends$8({
        onYReachStart,
        onYReachEnd,
        onSync: function onSync(ps) {
          return ps.update(disableOnYReachWhenNoScroll);
        },
        className: "".concat(cName2, "__scroll-wrapper"),
        ref: this.scrollRef,
        containerRef: function containerRef(ref2) {
          return _this2.containerRef.current = ref2;
        },
        options: {
          suppressScrollX: true
        }
      }, _defineProperty$6({}, "data-".concat(prefix, "-message-list"), ""), {
        style: {
          overscrollBehaviorY: "none",
          overflowAnchor: "auto",
          touchAction: "none"
        }
      }), customContent ? customContent : children, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(cName2, "__scroll-to"),
        ref: this.scrollPointRef
      })), typeof typingIndicator !== "undefined" && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(cName2, "__typing-indicator-container")
      }, typingIndicator));
    }
  }]);
  return MessageListInner2;
}(React.Component);
MessageListInner.displayName = "MessageList";
function MessageListFunc(props, ref2) {
  var msgListRef = reactExports.useRef();
  var scrollToBottom = function scrollToBottom2(scrollBehavior) {
    return msgListRef.current.scrollToEnd(scrollBehavior);
  };
  reactExports.useImperativeHandle(ref2, function() {
    return {
      scrollToBottom
    };
  });
  return /* @__PURE__ */ React.createElement(MessageListInner, _extends$8({
    ref: msgListRef
  }, props));
}
var MessageList$1 = /* @__PURE__ */ reactExports.forwardRef(MessageListFunc);
MessageList$1.propTypes = {
  /**
   * Primary content. Message elements
   * Allowed components:
   *
   * * &lt;Message /&gt;
   * * &lt;MessageGroup /&gt;
   * * &lt;MessageSeparator /&gt;
   * * &lt;MessageListContent /&gt;
   */
  children: allowedChildren([Message, MessageGroup, MessageSeparator, MessageListContent]),
  /** Typing indicator element. */
  typingIndicator: PropTypes.node,
  /** Loading flag. */
  loading: PropTypes.bool,
  /** Loading more flag for infinity scroll. */
  loadingMore: PropTypes.bool,
  /** Loading more loader position. */
  loadingMorePosition: PropTypes.oneOf(["top", "bottom"]),
  /**
   * This is fired when the scrollbar reaches the beginning on the y axis.<br/>
   * It can be used to load previous messages using the infinite scroll.
   */
  onYReachStart: PropTypes.func,
  /**
   * This is fired when the scrollbar reaches the end on the y axis.<br/>
   * It can be used to load next messages using the infinite scroll.
   */
  onYReachEnd: PropTypes.func,
  /**
   * Disables onYReachStart and onYReachEnd events from being fired<br />
   * when the list is not scrollable.
   * This is set to false by default for backward compatibility.
   */
  disableOnYReachWhenNoScroll: PropTypes.bool,
  /**
   * Auto scroll to bottom
   */
  autoScrollToBottom: PropTypes.bool,
  /**
   * Auto scroll to bottom on mount
   */
  autoScrollToBottomOnMount: PropTypes.bool,
  /**
   * Scroll behavior
   * https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions/behavior
   */
  scrollBehavior: PropTypes.oneOf(["auto", "smooth"]),
  /** Additional classes. */
  className: PropTypes.string
};
MessageList$1.defaultProps = {
  typingIndicator: void 0,
  loading: false,
  loadingMore: false,
  loadingMorePosition: "top",
  disableOnYReachWhenNoScroll: false,
  autoScrollToBottom: true,
  autoScrollToBottomOnMount: true,
  scrollBehavior: "auto"
};
MessageListInner.defaultProps = MessageList$1.defaultProps;
MessageList$1.Content = MessageListContent;
function _typeof$6(o2) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$6(o2);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$1(t2, o2, e2) {
  return o2 = _getPrototypeOf$1(o2), _possibleConstructorReturn$1(t2, _isNativeReflectConstruct$1() ? Reflect.construct(o2, e2, _getPrototypeOf$1(t2).constructor) : o2.apply(t2, e2));
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _isNativeReflectConstruct$1() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf$1(o2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(t2) {
  var i2 = _toPrimitive$5(t2, "string");
  return "symbol" == _typeof$6(i2) ? i2 : String(i2);
}
function _toPrimitive$5(t2, r2) {
  if ("object" != _typeof$6(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var replaceCaret = function replaceCaret2(el2, activateAfterChange) {
  var isTargetFocused = document.activeElement === el2;
  var target = document.createTextNode("");
  el2.appendChild(target);
  if (target !== null && target.nodeValue !== null && (isTargetFocused || activateAfterChange)) {
    var sel = window.getSelection();
    if (sel !== null) {
      var range2 = document.createRange();
      range2.setStart(target, target.nodeValue.length);
      range2.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range2);
    }
  }
};
var ContentEditable = /* @__PURE__ */ function(_Component) {
  _inherits$1(ContentEditable2, _Component);
  function ContentEditable2(props) {
    var _this;
    _classCallCheck$1(this, ContentEditable2);
    _this = _callSuper$1(this, ContentEditable2, [props]);
    _defineProperty$5(_assertThisInitialized$1(_this), "innerHTML", function() {
      var _assertThisInitialize = _assertThisInitialized$1(_this), value = _assertThisInitialize.props.value;
      return {
        __html: typeof value !== "undefined" ? value : ""
      };
    });
    _defineProperty$5(_assertThisInitialized$1(_this), "handleKeyPress", function(evt) {
      var _assertThisInitialize2 = _assertThisInitialized$1(_this), onKeyPress = _assertThisInitialize2.props.onKeyPress;
      onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(evt);
    });
    _defineProperty$5(_assertThisInitialized$1(_this), "handleInput", function(evt) {
      var _assertThisInitialize3 = _assertThisInitialized$1(_this), onChange = _assertThisInitialize3.props.onChange;
      var target = evt.target;
      onChange === null || onChange === void 0 ? void 0 : onChange(target.innerHTML, target.textContent, target.innerText);
    });
    _this.msgRef = /* @__PURE__ */ React.createRef();
    return _this;
  }
  _createClass$1(ContentEditable2, [{
    key: "focus",
    value: (
      // Public API
      function focus() {
        if (typeof this.msgRef.current !== "undefined") {
          this.msgRef.current.focus();
        }
      }
    )
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.autoFocus === true) {
        this.msgRef.current.focus();
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var msgRef = this.msgRef, _this$props = this.props, placeholder = _this$props.placeholder, disabled = _this$props.disabled, activateAfterChange = _this$props.activateAfterChange;
      if (typeof msgRef.current === "undefined") {
        return true;
      }
      if (nextProps.value !== msgRef.current.innerHTML) {
        return true;
      }
      return placeholder !== nextProps.placeholder || disabled !== nextProps.disabled || activateAfterChange !== nextProps.activateAfterChange;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var msgRef = this.msgRef, _this$props2 = this.props, value = _this$props2.value, activateAfterChange = _this$props2.activateAfterChange;
      if (value !== msgRef.current.innerHTML) {
        msgRef.current.innerHTML = typeof value === "string" ? value : "";
      }
      replaceCaret(msgRef.current, activateAfterChange);
    }
  }, {
    key: "render",
    value: function render() {
      var msgRef = this.msgRef, handleInput = this.handleInput, handleKeyPress = this.handleKeyPress, innerHTML = this.innerHTML, _this$props3 = this.props, placeholder = _this$props3.placeholder, disabled = _this$props3.disabled, className = _this$props3.className, ph2 = typeof placeholder === "string" ? placeholder : "";
      return /* @__PURE__ */ React.createElement("div", {
        ref: msgRef,
        className,
        contentEditable: disabled === false,
        disabled,
        "data-placeholder": ph2,
        onInput: handleInput,
        onKeyPress: handleKeyPress,
        dangerouslySetInnerHTML: innerHTML()
      });
    }
  }]);
  return ContentEditable2;
}(reactExports.Component);
function _typeof$5(o2) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$5(o2);
}
var _excluded$7 = ["fancyScroll", "children", "forwardedRef"], _excluded2 = ["value", "onSend", "onChange", "autoFocus", "placeholder", "fancyScroll", "className", "activateAfterChange", "disabled", "sendDisabled", "sendOnReturnDisabled", "attachDisabled", "sendButton", "attachButton", "onAttachClick"];
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr)) return arr;
}
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$4(t2) {
  var i2 = _toPrimitive$4(t2, "string");
  return "symbol" == _typeof$5(i2) ? i2 : String(i2);
}
function _toPrimitive$4(t2, r2) {
  if ("object" != _typeof$5(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _callSuper(t2, o2, e2) {
  return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o2, e2 || [], _getPrototypeOf(t2).constructor) : o2.apply(t2, e2));
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf(o2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf(o2, p2);
}
function editorContainer() {
  var Container2 = /* @__PURE__ */ function(_Component) {
    _inherits(Container22, _Component);
    function Container22() {
      _classCallCheck(this, Container22);
      return _callSuper(this, Container22, arguments);
    }
    _createClass(Container22, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, fancyScroll = _this$props.fancyScroll, children = _this$props.children, forwardedRef = _this$props.forwardedRef, rest = _objectWithoutProperties$7(_this$props, _excluded$7);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, fancyScroll === true && /* @__PURE__ */ React.createElement(ScrollBar, _extends$7({
          ref: function ref2(elRef) {
            return forwardedRef.current = elRef;
          }
        }, rest, {
          options: {
            suppressScrollX: true
          }
        }), children), fancyScroll === false && /* @__PURE__ */ React.createElement("div", _extends$7({
          ref: forwardedRef
        }, rest), children));
      }
    }]);
    return Container22;
  }(reactExports.Component);
  return /* @__PURE__ */ React.forwardRef(function(props, ref2) {
    return /* @__PURE__ */ React.createElement(Container2, _extends$7({
      forwardedRef: ref2
    }, props));
  });
}
var EditorContainer = editorContainer();
var useControllableState = function useControllableState2(value, initialValue) {
  var initial2 = typeof value !== "undefined" ? value : initialValue;
  var _useState = reactExports.useState(initial2), _useState2 = _slicedToArray$2(_useState, 2), stateValue = _useState2[0], setStateValue = _useState2[1];
  var effectiveValue = typeof value !== "undefined" ? value : stateValue;
  return [effectiveValue, function(newValue) {
    setStateValue(newValue);
  }];
};
function MessageInputInner(_ref2, ref2) {
  var _ref$value = _ref2.value, value = _ref$value === void 0 ? void 0 : _ref$value, _ref$onSend = _ref2.onSend, onSend = _ref$onSend === void 0 ? noop$2 : _ref$onSend, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? noop$2 : _ref$onChange, _ref$autoFocus = _ref2.autoFocus, autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus, _ref$placeholder = _ref2.placeholder, placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder, _ref$fancyScroll = _ref2.fancyScroll, fancyScroll = _ref$fancyScroll === void 0 ? true : _ref$fancyScroll, className = _ref2.className, _ref$activateAfterCha = _ref2.activateAfterChange, activateAfterChange = _ref$activateAfterCha === void 0 ? false : _ref$activateAfterCha, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, sendDisabled = _ref2.sendDisabled, _ref$sendOnReturnDisa = _ref2.sendOnReturnDisabled, sendOnReturnDisabled = _ref$sendOnReturnDisa === void 0 ? false : _ref$sendOnReturnDisa, _ref$attachDisabled = _ref2.attachDisabled, attachDisabled = _ref$attachDisabled === void 0 ? false : _ref$attachDisabled, _ref$sendButton = _ref2.sendButton, sendButton = _ref$sendButton === void 0 ? true : _ref$sendButton, _ref$attachButton = _ref2.attachButton, attachButton = _ref$attachButton === void 0 ? true : _ref$attachButton, _ref$onAttachClick = _ref2.onAttachClick, onAttachClick = _ref$onAttachClick === void 0 ? noop$2 : _ref$onAttachClick, rest = _objectWithoutProperties$7(_ref2, _excluded2);
  var scrollRef = reactExports.useRef();
  var msgRef = reactExports.useRef();
  var _useControllableState = useControllableState(value, ""), _useControllableState2 = _slicedToArray$2(_useControllableState, 2), stateValue = _useControllableState2[0], setStateValue = _useControllableState2[1];
  var _useControllableState3 = useControllableState(sendDisabled, true), _useControllableState4 = _slicedToArray$2(_useControllableState3, 2), stateSendDisabled = _useControllableState4[0], setStateSendDisabled = _useControllableState4[1];
  var focus = function focus2() {
    if (typeof msgRef.current !== "undefined") {
      msgRef.current.focus();
    }
  };
  reactExports.useImperativeHandle(ref2, function() {
    return {
      focus
    };
  });
  reactExports.useEffect(function() {
    if (autoFocus === true) {
      focus();
    }
  }, []);
  reactExports.useEffect(function() {
    if (typeof scrollRef.current.updateScroll === "function") {
      scrollRef.current.updateScroll();
    }
  });
  var getContent = function getContent2() {
    var contentEditableRef = msgRef.current.msgRef.current;
    return [contentEditableRef.textContent, contentEditableRef.innerText, contentEditableRef.cloneNode(true).childNodes];
  };
  var send = function send2() {
    if (stateValue.length > 0) {
      if (value === void 0) {
        setStateValue("");
      }
      if (typeof sendDisabled === "undefined") {
        setStateSendDisabled(true);
      }
      var content = getContent();
      onSend(stateValue, content[0], content[1], content[2]);
    }
  };
  var handleKeyPress = function handleKeyPress2(evt) {
    if (evt.key === "Enter" && evt.shiftKey === false && sendOnReturnDisabled === false) {
      evt.preventDefault();
      send();
    }
  };
  var handleChange = function handleChange2(innerHTML, textContent, innerText) {
    setStateValue(innerHTML);
    if (typeof sendDisabled === "undefined") {
      setStateSendDisabled(textContent.length === 0);
    }
    if (typeof scrollRef.current.updateScroll === "function") {
      scrollRef.current.updateScroll();
    }
    var content = getContent();
    onChange(innerHTML, textContent, innerText, content[2]);
  };
  var cName2 = "".concat(prefix, "-message-input"), ph2 = typeof placeholder === "string" ? placeholder : "";
  return /* @__PURE__ */ React.createElement("div", _extends$7({}, rest, {
    className: classNames(cName2, _defineProperty$4({}, "".concat(cName2, "--disabled"), disabled), className)
  }), attachButton === true && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__tools")
  }, /* @__PURE__ */ React.createElement(AttachmentButton, {
    onClick: onAttachClick,
    disabled: disabled === true || attachDisabled === true
  })), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content-editor-wrapper")
  }, /* @__PURE__ */ React.createElement(EditorContainer, {
    fancyScroll,
    ref: scrollRef,
    className: "".concat(cName2, "__content-editor-container")
  }, /* @__PURE__ */ React.createElement(ContentEditable, {
    ref: msgRef,
    className: "".concat(cName2, "__content-editor"),
    disabled,
    placeholder: ph2,
    onKeyPress: handleKeyPress,
    onChange: handleChange,
    activateAfterChange,
    value: stateValue
  }))), sendButton === true && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__tools")
  }, /* @__PURE__ */ React.createElement(SendButton, {
    onClick: send,
    disabled: disabled === true || stateSendDisabled === true
  })));
}
var MessageInput$1 = /* @__PURE__ */ reactExports.forwardRef(MessageInputInner);
MessageInput$1.displayName = "MessageInput";
MessageInput$1.propTypes = {
  /** Value. */
  value: PropTypes.string,
  /** Placeholder. */
  placeholder: PropTypes.string,
  /** A input can show it is currently unable to be interacted with. */
  disabled: PropTypes.bool,
  /** Prevent that the input message is sent on a return press */
  sendOnReturnDisabled: PropTypes.bool,
  /** Send button can be disabled.<br>
   * It's state is tracked by component, but it can be forced */
  sendDisabled: PropTypes.bool,
  /**
   * Fancy scroll
   * This property is set in constructor, and is not changing when component update.
   */
  fancyScroll: PropTypes.bool,
  /**
   * Sets focus element and caret at the end of input<br>
   * when value is changed programmatically (e.g) from button click and element is not active
   */
  activateAfterChange: PropTypes.bool,
  /** Set focus after mount. */
  autoFocus: PropTypes.bool,
  /**
   * onChange handler<br>
   * @param {String} innerHtml
   * @param {String} textContent
   * @param {String} innerText
   * @param {NodeList} nodes
   */
  onChange: PropTypes.func,
  /**
   * onSend handler<br>
   * @param {String} innerHtml
   * @param {String} textContent
   * @param {String} innerText
   * @param {NodeList} nodes
   */
  onSend: PropTypes.func,
  /** Additional classes. */
  className: PropTypes.string,
  /** Show send button */
  sendButton: PropTypes.bool,
  /** Show add attachment button */
  attachButton: PropTypes.bool,
  /** Disable add attachment button */
  attachDisabled: PropTypes.bool,
  /**
   * onAttachClick handler
   */
  onAttachClick: PropTypes.func
};
var _excluded$6 = ["className", "children"];
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var InputToolbox = function InputToolbox2(_ref2) {
  var className = _ref2.className, children = _ref2.children, rest = _objectWithoutProperties$6(_ref2, _excluded$6);
  var cName2 = "".concat(prefix, "-input-toolbox");
  return /* @__PURE__ */ React.createElement("div", _extends$6({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
InputToolbox.displayName = "InputToolbox";
var _excluded$5 = ["children", "className"];
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit$1(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ChatContainer = function ChatContainer2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$5(_ref2, _excluded$5);
  var cName2 = "".concat(prefix, "-chat-container");
  var _getChildren = getChildren(children, [ConversationHeader, MessageList$1, MessageInput$1, InputToolbox]), _getChildren2 = _slicedToArray$1(_getChildren, 4), header = _getChildren2[0], messageList = _getChildren2[1], messageInput = _getChildren2[2], inputToolbox = _getChildren2[3];
  return /* @__PURE__ */ React.createElement("div", _extends$5({}, rest, {
    className: classNames(cName2, className)
  }), header, messageList, messageInput, inputToolbox);
};
var cName = "".concat(prefix, "-conversation");
function _typeof$4(o2) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$4(o2);
}
var _excluded$4 = ["children", "className", "visible"];
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(t2) {
  var i2 = _toPrimitive$3(t2, "string");
  return "symbol" == _typeof$4(i2) ? i2 : String(i2);
}
function _toPrimitive$3(t2, r2) {
  if ("object" != _typeof$4(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationOperations = function ConversationOperations2(_ref2) {
  var children = _ref2.children, className = _ref2.className, visible = _ref2.visible, rest = _objectWithoutProperties$4(_ref2, _excluded$4);
  return /* @__PURE__ */ React.createElement("div", _extends$4({}, rest, {
    className: classNames("".concat(cName, "__operations"), _defineProperty$3({}, "".concat(cName, "__operations--visible"), visible), className)
  }), React.Children.count(children) > 0 ? children : /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faEllipsisV.faEllipsisV
  }));
};
ConversationOperations.displayName = "Conversation.Operations";
var _excluded$3 = ["lastSenderName", "info", "name", "children", "className"];
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _typeof$3(o2) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$3(o2);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var LastSenderName = function LastSenderName2(_ref2) {
  var name2 = _ref2.name;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__last-sender")
  }, name2), ":");
};
var InfoContent = function InfoContent2(_ref2) {
  var info = _ref2.info;
  return /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__info-content")
  }, info);
};
var ConversationContent = function ConversationContent2(_ref3) {
  var lastSenderName = _ref3.lastSenderName, info = _ref3.info, name2 = _ref3.name, children = _ref3.children, className = _ref3.className, rest = _objectWithoutProperties$3(_ref3, _excluded$3);
  var typeofLastSenderName = _typeof$3(lastSenderName);
  return /* @__PURE__ */ React.createElement("div", _extends$3({}, rest, {
    className: classNames("".concat(cName, "__content"), className)
  }), React.Children.count(children) > 0 ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__name")
  }, name2), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__info")
  }, typeofLastSenderName !== "undefined" ? /* @__PURE__ */ React.createElement(React.Fragment, null, typeofLastSenderName === "string" ? /* @__PURE__ */ React.createElement(LastSenderName, {
    name: lastSenderName
  }) : lastSenderName, " ") : null, typeof info !== "undefined" && /* @__PURE__ */ React.createElement(InfoContent, {
    info
  }))));
};
ConversationContent.displayName = "Conversation.Content";
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$2(o2);
}
var _excluded$2 = ["responsive", "children", "className"];
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(t2) {
  var i2 = _toPrimitive$2(t2, "string");
  return "symbol" == _typeof$2(i2) ? i2 : String(i2);
}
function _toPrimitive$2(t2, r2) {
  if ("object" != _typeof$2(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MainContainer = function MainContainer2(_ref2) {
  var _ref$responsive = _ref2.responsive, responsive = _ref$responsive === void 0 ? false : _ref$responsive, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$2(_ref2, _excluded$2);
  var cName2 = "".concat(prefix, "-main-container");
  return /* @__PURE__ */ React.createElement("div", _extends$2({}, rest, {
    className: classNames(cName2, _defineProperty$2({}, "".concat(cName2, "--responsive"), responsive), className)
  }), children);
};
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
var faSearch = {
  prefix: "fas",
  iconName: "search",
  icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
};
var faTimes = {
  prefix: "fas",
  iconName: "times",
  icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
};
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$1(o2);
}
var _excluded$1 = ["placeholder", "value", "onChange", "onClearClick", "className", "disabled"];
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(t2) {
  var i2 = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i2) ? i2 : String(i2);
}
function _toPrimitive$1(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r22) {
      o2 = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var useControlledOrNot = function useControlledOrNot2(initialValue, value) {
  if (typeof value === "undefined") {
    return reactExports.useState(initialValue);
  } else {
    return [value, function() {
    }];
  }
};
function SearchInner(_ref2, ref2) {
  var _ref$placeholder = _ref2.placeholder, placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder, _ref$value = _ref2.value, value = _ref$value === void 0 ? void 0 : _ref$value, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? function() {
  } : _ref$onChange, _ref$onClearClick = _ref2.onClearClick, onClearClick = _ref$onClearClick === void 0 ? function() {
  } : _ref$onClearClick, className = _ref2.className, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, rest = _objectWithoutProperties$1(_ref2, _excluded$1);
  var cName2 = "".concat(prefix, "-search");
  var isControlled = reactExports.useMemo(function() {
    return typeof value !== "undefined";
  }, []);
  var _useControlledOrNot = useControlledOrNot("", value), _useControlledOrNot2 = _slicedToArray(_useControlledOrNot, 2), searchValue = _useControlledOrNot2[0], setSearchValue = _useControlledOrNot2[1];
  var _useState = reactExports.useState(isControlled ? searchValue.length > 0 : false), _useState2 = _slicedToArray(_useState, 2), clearActive = _useState2[0], setClearActive = _useState2[1];
  if (isControlled !== (typeof value !== "undefined")) {
    throw "Search: Changing from controlled to uncontrolled component and vice versa is not allowed";
  }
  var inputRef = reactExports.useRef(void 0);
  var focus = function focus2() {
    if (typeof inputRef.current !== "undefined") {
      inputRef.current.focus();
    }
  };
  reactExports.useImperativeHandle(ref2, function() {
    return {
      focus
    };
  });
  var handleChange = function handleChange2(e2) {
    var value2 = e2.target.value;
    setClearActive(value2.length > 0);
    if (isControlled === false) {
      setSearchValue(value2);
    }
    onChange(value2);
  };
  var handleClearClick = function handleClearClick2() {
    if (isControlled === false) {
      setSearchValue("");
    }
    setClearActive(false);
    onClearClick();
  };
  return /* @__PURE__ */ React.createElement("div", _extends$1({}, rest, {
    className: classNames(cName2, _defineProperty$1({}, "".concat(cName2, "--disabled"), disabled), className)
  }), /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faSearch,
    className: "".concat(cName2, "__search-icon")
  }), /* @__PURE__ */ React.createElement("input", {
    ref: inputRef,
    type: "text",
    className: "".concat(cName2, "__input"),
    placeholder,
    onChange: handleChange,
    disabled,
    value: searchValue
  }), /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faTimes,
    className: classNames("".concat(cName2, "__clear-icon"), _defineProperty$1({}, "".concat(cName2, "__clear-icon--active"), clearActive)),
    onClick: handleClearClick
  }));
}
var Search = /* @__PURE__ */ reactExports.forwardRef(SearchInner);
Search.displayName = "Search";
Search.propTypes = {
  /** Placeholder. */
  placeholder: PropTypes.string,
  /** Current value of the search input. Creates a controlled component */
  value: PropTypes.string,
  /** OnInput handler. */
  onChange: PropTypes.func,
  /** OnClearClick handler. */
  onClearClick: PropTypes.func,
  /** Additional classes. */
  className: PropTypes.string,
  /** Disabled */
  disabled: PropTypes.bool
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof(o2);
}
var _excluded = ["className", "children", "size", "selected", "onChange", "itemsTabIndex"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : String(i2);
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function StatusListInner(_ref2, ref2) {
  var className = _ref2.className, children = _ref2.children, size2 = _ref2.size, selected = _ref2.selected, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? noop$2 : _ref$onChange, itemsTabIndex = _ref2.itemsTabIndex, rest = _objectWithoutProperties(_ref2, _excluded);
  var cName2 = "".concat(prefix, "-status-list");
  var listRef = reactExports.useRef();
  reactExports.useImperativeHandle(ref2, function() {
    return {
      focus: function focus(idx) {
        var items = Array.from(listRef.current.querySelectorAll("li"));
        var directChild = items.filter(function(item) {
          return item.parentNode === listRef.current;
        });
        if (typeof directChild[idx] !== "undefined") {
          directChild[idx].focus();
        }
      }
    };
  });
  var tabIndex = itemsTabIndex;
  return /* @__PURE__ */ React.createElement("ul", _extends({
    ref: listRef
  }, rest, {
    className: classNames(cName2, className, _defineProperty({}, "".concat(cName2, "--").concat(size2), size2))
  }), React.Children.map(children, function(item) {
    var newProps = {};
    if (selected) {
      newProps.selected = item.props.status === selected;
    }
    if (onChange) {
      newProps.onClick = function(evt) {
        onChange(item.props.status);
        if (item.onClick) {
          item.onClick(evt);
        }
      };
    }
    var onKeyPress = function onKeyPress2(evt) {
      if (onChange) {
        if (evt.key === "Enter" && evt.shiftKey === false && evt.altKey === false) {
          onChange(item.props.status);
        }
      }
    };
    var tIndex = function() {
      if (typeof tabIndex === "number") {
        if (tabIndex > 0) {
          return tabIndex++;
        } else {
          return tabIndex;
        }
      } else {
        return void 0;
      }
    }();
    return /* @__PURE__ */ React.createElement("li", {
      tabIndex: tIndex,
      onKeyPress
    }, /* @__PURE__ */ React.cloneElement(item, newProps));
  }));
}
var StatusList = /* @__PURE__ */ reactExports.forwardRef(StatusListInner);
StatusList.displayName = "StatusList";
StatusList.propTypes = {
  /**
   * Primary content.
   * Allowed components:
   *
   * * &lt;Status /&gt;
   */
  children: allowedChildren([Status]),
  /** Selected element */
  selected: PropTypes.oneOf(StatusEnum),
  /** Size */
  size: PropTypes.oneOf(SizeEnum),
  /** tabindex value for items. Any positive integer will be treated as start index for counting. Zero and negative values will be applied to all items */
  itemsTabIndex: PropTypes.number,
  /** Additional classes. */
  className: PropTypes.string,
  /** onChange handler */
  onChange: PropTypes.func
};
const MessageList = reactExports.memo(({ messages: messages2, messageListRef }) => {
  const lastMessageRef = reactExports.useRef(null);
  const scrollToBottom = reactExports.useCallback(() => {
    if (messageListRef.current) {
      const { scrollHeight } = messageListRef.current;
      const height = messageListRef.current.clientHeight;
      const maxScrollTop = scrollHeight - height;
      messageListRef.current.scrollTo({
        top: maxScrollTop + 100,
        behavior: "smooth"
      });
    }
  }, [messageListRef]);
  reactExports.useEffect(() => {
    scrollToBottom();
  }, [messages2, scrollToBottom]);
  reactExports.useEffect(() => {
    scrollToBottom();
  }, [scrollToBottom]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.chatHistoryPanel.messageList, ref: messageListRef, children: messages2.map((message, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref: index === messages2.length - 1 ? lastMessageRef : null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChatBubble,
        {
          message
        }
      )
    },
    `${message.role}-${message.timestamp}-${message.id}`
  )) });
});
MessageList.displayName = "MessageList";
function ChatHistoryPanel() {
  const { messages: messages2 } = useChatHistory();
  const { confName } = useConfig();
  const { baseUrl } = useWebSocket();
  const userName = "Me";
  const validMessages = messages2.filter((msg) => msg.content && msg.content.trim().length > 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      h: "full",
      overflow: "hidden",
      bg: "gray.900",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: chatPanelStyles }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MainContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MessageList$1, { children: validMessages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "whiteAlpha.500",
            fontSize: "sm",
            children: "No messages yet. Start a conversation!"
          }
        ) : validMessages.map((msg) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Message,
          {
            model: {
              message: msg.content,
              sentTime: msg.timestamp,
              sender: msg.role === "ai" ? msg.name || confName || "AI" : userName,
              direction: msg.role === "ai" ? "incoming" : "outgoing",
              position: "single"
            },
            avatarPosition: msg.role === "ai" ? "tl" : "tr",
            avatarSpacer: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { children: msg.role === "ai" ? msg.avatar ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: `${baseUrl}/avatars/${msg.avatar}`,
                alt: "avatar",
                style: { width: "100%", height: "100%", borderRadius: "50%" }
              }
            ) : msg.name && msg.name[0].toUpperCase() || confName && confName[0].toUpperCase() || "A" : userName[0].toUpperCase() })
          },
          msg.id
        )) }) }) })
      ]
    }
  );
}
const Tooltip = reactExports.forwardRef(
  (props, ref2) => {
    const {
      showArrow,
      children,
      disabled,
      portalled,
      content,
      contentProps,
      portalRef,
      ...rest
    } = props;
    if (disabled) return children;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipRoot, { ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipContent, { ref: ref2, ...contentProps, children: [
        showArrow && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrowTip, {}) }),
        content
      ] }) }) })
    ] });
  }
);
const useCameraPanel = () => {
  const videoRef = reactExports.useRef(null);
  const [error, setError] = reactExports.useState("");
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const {
    isStreaming,
    stream,
    startCamera,
    stopCamera
  } = useCamera();
  const toggleCamera = async () => {
    try {
      if (isStreaming) {
        stopCamera();
      } else {
        await startCamera();
      }
      setError("");
    } catch (error2) {
      let errorMessage = "Unable to access camera";
      if (error2 instanceof Error) {
        errorMessage = error2.message;
      }
      setError(errorMessage);
    }
  };
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  return {
    videoRef,
    error,
    isHovering,
    isStreaming,
    stream,
    toggleCamera,
    handleMouseEnter,
    handleMouseLeave
  };
};
function LiveIndicator() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { color: "red.500", display: "flex", alignItems: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { w: "8px", h: "8px", borderRadius: "full", bg: "red.500", animation: "pulse 2s infinite" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { fontSize: "sm", children: "Live" })
  ] });
}
function CameraPlaceholder() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      position: "absolute",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FiCamera, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { color: "whiteAlpha.600", fontSize: "sm", textAlign: "center", children: "Click to start camera" })
      ]
    }
  );
}
function VideoStream$1({
  videoRef,
  isStreaming
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      ref: videoRef,
      autoPlay: true,
      playsInline: true,
      muted: true,
      style: sidebarStyles.cameraPanel.video,
      ...isStreaming ? {} : { display: "none" }
    }
  );
}
function CameraPanel() {
  const {
    videoRef,
    error,
    isHovering,
    isStreaming,
    stream,
    toggleCamera,
    handleMouseEnter,
    handleMouseLeave
  } = useCameraPanel();
  reactExports.useEffect(() => {
    if (videoRef.current) {
      videoRef.current.srcObject = stream;
    }
  }, [stream]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.cameraPanel.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.cameraPanel.header, children: isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(LiveIndicator, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip,
      {
        showArrow: true,
        content: isStreaming ? "Click to stop camera" : "Click to start camera",
        open: isHovering && !error,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...sidebarStyles.cameraPanel.videoContainer,
            onClick: toggleCamera,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            cursor: "pointer",
            position: "relative",
            _hover: {
              bg: "whiteAlpha.100"
            },
            children: error ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { color: "red.300", fontSize: "sm", textAlign: "center", children: error }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(VideoStream$1, { videoRef, isStreaming }),
              !isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(CameraPlaceholder, {})
            ] })
          }
        )
      }
    )
  ] });
}
function useCaptureScreen() {
  const videoRef = reactExports.useRef(null);
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const { stream, isStreaming, error, startCapture, stopCapture } = useScreenCaptureContext();
  const toggleCapture = () => {
    if (isStreaming) {
      stopCapture();
    } else {
      startCapture();
    }
  };
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  reactExports.useEffect(() => {
    if (videoRef.current) {
      videoRef.current.srcObject = stream;
    }
  }, [stream]);
  return {
    videoRef,
    error,
    isHovering,
    isStreaming,
    stream,
    toggleCapture,
    handleMouseEnter,
    handleMouseLeave
  };
}
function ScreenIndicator() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { color: "red.500", display: "flex", alignItems: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        w: "8px",
        h: "8px",
        borderRadius: "full",
        bg: "red.500",
        animation: "pulse 2s infinite"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { fontSize: "sm", children: "Screen" })
  ] });
}
function ScreenPlaceholder() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      position: "absolute",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FiMonitor, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { color: "whiteAlpha.600", fontSize: "sm", textAlign: "center", children: "Click to start screen capture" })
      ]
    }
  );
}
function VideoStream({
  videoRef,
  isStreaming
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      ref: videoRef,
      autoPlay: true,
      playsInline: true,
      muted: true,
      style: sidebarStyles.screenPanel.video,
      ...isStreaming ? {} : { display: "none" }
    }
  );
}
function ScreenPanel() {
  const {
    videoRef,
    error,
    isHovering,
    isStreaming,
    toggleCapture,
    handleMouseEnter,
    handleMouseLeave
  } = useCaptureScreen();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.screenPanel.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.screenPanel.header, children: isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenIndicator, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip,
      {
        showArrow: true,
        content: isStreaming ? "Click to stop screen capture" : "Click to start screen capture",
        open: isHovering && !error,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...sidebarStyles.screenPanel.screenContainer,
            onClick: toggleCapture,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            cursor: "pointer",
            position: "relative",
            _hover: {
              bg: "whiteAlpha.100"
            },
            children: error ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { color: "red.300", fontSize: "sm", textAlign: "center", children: error }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(VideoStream, { videoRef, isStreaming }),
              !isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenPlaceholder, {})
            ] })
          }
        )
      }
    )
  ] });
}
function BottomTab() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TabsRoot,
    {
      defaultValue: "camera",
      variant: "plain",
      ...sidebarStyles.bottomTab.container,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { ...sidebarStyles.bottomTab.list, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "camera", ...sidebarStyles.bottomTab.trigger, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FiCamera, {}),
            "Camera"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "screen", ...sidebarStyles.bottomTab.trigger, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FiMonitor, {}),
            "Screen"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "camera", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraPanel, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "screen", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenPanel, {}) })
      ]
    }
  );
}
const minutesInMonth = 43200;
const minutesInDay = 1440;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context2) {
  return constructFrom(argument, argument);
}
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context2, ...dates) {
  const normalize2 = constructFrom.bind(
    null,
    context2 || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize2);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function constructNow(date) {
  return constructFrom(date, Date.now());
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function getRoundingMethod(method) {
  return (number) => {
    const round2 = method ? Math[method] : Math.trunc;
    const result = round2(number);
    return result === 0 ? 0 : result;
  };
}
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate(laterDate) - +toDate(earlierDate);
}
function endOfDay(date, options) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date, options) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function isLastDayOfMonth(date, options) {
  const _date = toDate(date);
  return +endOfDay(_date) === +endOfMonth(_date);
}
function differenceInMonths(laterDate, earlierDate, options) {
  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    laterDate,
    earlierDate
  );
  const sign3 = compareAsc(workingLaterDate, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarMonths(workingLaterDate, earlierDate_)
  );
  if (difference < 1) return 0;
  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)
    workingLaterDate.setDate(30);
  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign3 * difference);
  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign3;
  if (isLastDayOfMonth(laterDate_) && difference === 1 && compareAsc(laterDate_, earlierDate_) === 1) {
    isLastMonthNotFull = false;
  }
  const result = sign3 * (difference - +isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInSeconds(laterDate, earlierDate, options) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options?.roundingMethod)(diff);
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance$1 = (token2, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context2 = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context2 === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function formatDistance(laterDate, earlierDate, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const minutesInAlmostTwoDays = 2520;
  const comparison = compareAsc(laterDate, earlierDate);
  if (isNaN(comparison)) throw new RangeError("Invalid time value");
  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison
  });
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    ...comparison > 0 ? [earlierDate, laterDate] : [laterDate, earlierDate]
  );
  const seconds = differenceInSeconds(earlierDate_, laterDate_);
  const offsetInSeconds = (getTimezoneOffsetInMilliseconds(earlierDate_) - getTimezoneOffsetInMilliseconds(laterDate_)) / 1e3;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;
  if (minutes < 2) {
    if (options?.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < minutesInMonth) {
    const days = Math.round(minutes / minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < minutesInMonth * 2) {
    months = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(earlierDate_, laterDate_);
  if (months < 12) {
    const nearestMonth = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
function formatDistanceToNow(date, options) {
  return formatDistance(date, constructNow(date), options);
}
const DrawerContent = reactExports.forwardRef((props, ref2) => {
  const {
    children,
    portalled = true,
    portalRef,
    offset: offset2,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerPositioner, { padding: offset2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerContent$1, { ref: ref2, ...rest, asChild: false, children }) }) });
});
const DrawerCloseTrigger = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  DrawerCloseTrigger$1,
  {
    position: "absolute",
    top: "2",
    insetEnd: "2",
    ...props,
    asChild: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: "sm", ref: ref2 })
  }
));
const DrawerTrigger = DrawerTrigger$1;
const DrawerRoot = DrawerRoot$1;
const DrawerFooter = DrawerFooter$1;
const DrawerHeader = DrawerHeader$1;
const DrawerBody = DrawerBody$1;
const DrawerBackdrop = DrawerBackdrop$1;
const DrawerTitle = DrawerTitle$1;
const DrawerActionTrigger = DrawerActionTrigger$1;
const useHistoryDrawer = () => {
  const [open, setOpen] = reactExports.useState(false);
  const {
    historyList,
    currentHistoryUid,
    setCurrentHistoryUid,
    setHistoryList,
    messages: messages2,
    updateHistoryList
  } = useChatHistory();
  const { sendMessage } = useWebSocket();
  const fetchAndSetHistory = (uid2) => {
    if (!uid2 || uid2 === currentHistoryUid) return;
    if (currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      updateHistoryList(currentHistoryUid, latestMessage);
    }
    setCurrentHistoryUid(uid2);
    sendMessage({
      type: "fetch-and-set-history",
      history_uid: uid2
    });
  };
  const deleteHistory = (uid2) => {
    if (uid2 === currentHistoryUid) {
      toaster.create({
        title: "Cannot delete current chat history",
        type: "warning",
        duration: 2e3
      });
      return;
    }
    sendMessage({
      type: "delete-history",
      history_uid: uid2
    });
    setHistoryList(historyList.filter((history) => history.uid !== uid2));
  };
  const getLatestMessageContent = (history) => {
    if (history.uid === currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      return {
        content: latestMessage.content,
        timestamp: latestMessage.timestamp
      };
    }
    return {
      content: history.latest_message?.content || "",
      timestamp: history.timestamp
    };
  };
  return {
    open,
    setOpen,
    historyList,
    currentHistoryUid,
    fetchAndSetHistory,
    deleteHistory,
    getLatestMessageContent
  };
};
const HistoryItem = reactExports.memo(({
  isSelected,
  latestMessage,
  onSelect,
  onDelete,
  isDeleteDisabled
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Box,
  {
    ...sidebarStyles.historyDrawer.historyItem,
    ...isSelected ? sidebarStyles.historyDrawer.historyItemSelected : {},
    onClick: onSelect,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.historyDrawer.historyHeader, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.timestamp, children: latestMessage.timestamp ? formatDistanceToNow(new Date(latestMessage.timestamp), { addSuffix: true }) : "No messages" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            onClick: onDelete,
            disabled: isDeleteDisabled,
            ...sidebarStyles.historyDrawer.deleteButton,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiTrash2, {})
          }
        )
      ] }),
      latestMessage.content && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.messagePreview, children: latestMessage.content })
    ]
  }
));
HistoryItem.displayName = "HistoryItem";
function HistoryDrawer({ children }) {
  const {
    open,
    setOpen,
    historyList,
    currentHistoryUid,
    fetchAndSetHistory,
    deleteHistory,
    getLatestMessageContent
  } = useHistoryDrawer();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot,
    {
      open,
      onOpenChange: (e2) => setOpen(e2.open),
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTrigger, { asChild: true, children }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent, { style: sidebarStyles.historyDrawer.drawer.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle, { style: sidebarStyles.historyDrawer.drawer.title, children: "Chat History List" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerCloseTrigger, { style: sidebarStyles.historyDrawer.drawer.closeButton })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.listContainer, children: historyList.map((history) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            HistoryItem,
            {
              isSelected: currentHistoryUid === history.uid,
              latestMessage: getLatestMessageContent(history),
              onSelect: () => fetchAndSetHistory(history.uid),
              onDelete: (e2) => {
                e2.stopPropagation();
                deleteHistory(history.uid);
              },
              isDeleteDisabled: currentHistoryUid === history.uid
            },
            history.uid
          )) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerActionTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { ...sidebarStyles.historyDrawer.drawer.actionButton, children: "Close" }) }) })
        ] })
      ]
    }
  );
}
const useSidebar = () => {
  const { open, onOpen, onClose } = useDisclosure();
  const { sendMessage } = useWebSocket();
  const { interrupt } = useInterrupt();
  const { currentHistoryUid, messages: messages2, updateHistoryList } = useChatHistory();
  const createNewHistory = () => {
    if (currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      updateHistoryList(currentHistoryUid, latestMessage);
    }
    interrupt();
    sendMessage({
      type: "create-new-history"
    });
  };
  return {
    settingsOpen: open,
    onSettingsOpen: onOpen,
    onSettingsClose: onClose,
    createNewHistory
  };
};
const ClipboardIcon = reactExports.forwardRef(function ClipboardIcon2(props, ref2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIndicator, { copied: /* @__PURE__ */ jsxRuntimeExports.jsx(LuCheck, {}), ...props, ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuClipboard, {}) });
});
const ClipboardCopyText = reactExports.forwardRef(function ClipboardCopyText2(props, ref2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIndicator, { copied: "Copied", ...props, ref: ref2, children: "Copy" });
});
reactExports.forwardRef(function ClipboardLabel2(props, ref2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ClipboardLabel,
    {
      textStyle: "sm",
      fontWeight: "medium",
      display: "inline-block",
      mb: "1",
      ...props,
      ref: ref2
    }
  );
});
const ClipboardButton = reactExports.forwardRef(
  function ClipboardButton2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$1, { ref: ref2, size: "sm", variant: "surface", ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIcon, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, {})
    ] }) });
  }
);
reactExports.forwardRef(
  function ClipboardLink2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button$1,
      {
        unstyled: true,
        variant: "plain",
        size: "xs",
        display: "inline-flex",
        alignItems: "center",
        gap: "2",
        ref: ref2,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LuLink, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, {})
        ]
      }
    ) });
  }
);
reactExports.forwardRef(function ClipboardIconButton2(props, ref2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton, { ref: ref2, size: "xs", variant: "subtle", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIcon, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, { srOnly: true })
  ] }) });
});
reactExports.forwardRef(
  function ClipboardInputElement(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardInput, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ref: ref2, ...props }) });
  }
);
const ClipboardRoot = ClipboardRoot$1;
const useGroupDrawer = () => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [inviteUid, setInviteUid] = reactExports.useState("");
  const { sendMessage } = useWebSocket();
  const requestGroupInfo = reactExports.useCallback(() => {
    sendMessage({
      type: "request-group-info"
    });
  }, [sendMessage]);
  const handleInvite = reactExports.useCallback(async () => {
    if (!inviteUid.trim()) {
      toaster.create({
        title: "Please enter a valid UUID",
        type: "error",
        duration: 2e3
      });
      return;
    }
    sendMessage({
      type: "add-client-to-group",
      invitee_uid: inviteUid.trim()
    });
    setInviteUid("");
    setTimeout(requestGroupInfo, 100);
  }, [inviteUid, sendMessage, requestGroupInfo]);
  const handleRemove = reactExports.useCallback((targetUid) => {
    sendMessage({
      type: "remove-client-from-group",
      target_uid: targetUid
    });
    setTimeout(requestGroupInfo, 100);
  }, [sendMessage, requestGroupInfo]);
  const handleLeaveGroup = reactExports.useCallback((selfUid) => {
    sendMessage({
      type: "remove-client-from-group",
      target_uid: selfUid
    });
    setTimeout(requestGroupInfo, 100);
  }, [sendMessage, requestGroupInfo]);
  return {
    isOpen,
    setIsOpen,
    inviteUid,
    setInviteUid,
    handleInvite,
    handleRemove,
    handleLeaveGroup,
    requestGroupInfo
  };
};
const GroupContext = reactExports.createContext(null);
function GroupProvider({ children }) {
  const [selfUid, setSelfUid] = reactExports.useState("");
  const [groupMembers, setGroupMembers] = reactExports.useState([]);
  const [isOwner, setIsOwner] = reactExports.useState(false);
  const resetGroupState = () => {
    setGroupMembers([]);
    setIsOwner(false);
  };
  const sortedGroupMembers = reactExports.useMemo(() => {
    if (!groupMembers.includes(selfUid)) return groupMembers;
    return [
      selfUid,
      ...groupMembers.filter((memberId) => memberId !== selfUid)
    ];
  }, [groupMembers, selfUid]);
  return (
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GroupContext.Provider,
      {
        value: {
          selfUid,
          groupMembers,
          isOwner,
          setSelfUid,
          setGroupMembers,
          setIsOwner,
          sortedGroupMembers,
          resetGroupState
        },
        children
      }
    )
  );
}
function useGroup() {
  const context2 = reactExports.useContext(GroupContext);
  if (!context2) {
    throw new Error("useGroup must be used within a GroupProvider");
  }
  return context2;
}
function GroupDrawer({ children }) {
  const { selfUid, sortedGroupMembers, isOwner } = useGroup();
  const {
    isOpen,
    setIsOpen,
    inviteUid,
    setInviteUid,
    handleInvite,
    handleRemove,
    handleLeaveGroup,
    requestGroupInfo
  } = useGroupDrawer();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot,
    {
      open: isOpen,
      onOpenChange: (e2) => {
        setIsOpen(e2.open);
        if (e2.open) {
          requestGroupInfo();
        }
      },
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTrigger, { asChild: true, children }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent, { style: sidebarStyles.historyDrawer.drawer.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle, { style: sidebarStyles.historyDrawer.drawer.title, children: "Group Management" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DrawerCloseTrigger,
              {
                style: sidebarStyles.historyDrawer.drawer.closeButton
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.historyDrawer.listContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...sidebarStyles.groupDrawer.sectionTitle, children: "Your UUID" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.memberItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...sidebarStyles.groupDrawer.memberText, children: selfUid }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardRoot, { value: selfUid, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ClipboardButton,
                  {
                    ...sidebarStyles.groupDrawer.clipboardButton,
                    size: "sm"
                  }
                ) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...sidebarStyles.groupDrawer.sectionTitle, children: "Invite Member From Other Clients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.inviteBox, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    value: inviteUid,
                    onChange: (e2) => setInviteUid(e2.target.value),
                    placeholder: "Enter member UUID",
                    ...sidebarStyles.groupDrawer.input
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    onClick: handleInvite,
                    ...sidebarStyles.groupDrawer.button,
                    children: "Invite"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...sidebarStyles.groupDrawer.sectionTitle, children: "Members" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.groupDrawer.memberList, children: sortedGroupMembers.map((memberId) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.memberItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...sidebarStyles.groupDrawer.memberText, children: memberId === selfUid ? `${memberId} (You)` : memberId }),
                (isOwner && memberId !== selfUid || !isOwner && memberId === selfUid) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    "aria-label": memberId === selfUid ? "Leave group" : "Remove member",
                    onClick: () => memberId === selfUid ? handleLeaveGroup(selfUid) : handleRemove(memberId),
                    ...sidebarStyles.groupDrawer.removeButton,
                    size: "sm",
                    title: memberId === selfUid ? "Leave group" : "Remove member",
                    children: memberId === selfUid ? "Leave" : /* @__PURE__ */ jsxRuntimeExports.jsx(FiX, {})
                  }
                )
              ] }, memberId)) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerActionTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { ...sidebarStyles.historyDrawer.drawer.actionButton, children: "Close" }) }) })
        ] })
      ]
    }
  );
}
const ToggleButton$1 = reactExports.memo(({ isCollapsed, onToggle }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    ...sidebarStyles.sidebar.toggleButton,
    style: {
      transform: isCollapsed ? "rotate(180deg)" : "rotate(0deg)"
    },
    onClick: onToggle,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronLeft, {})
  }
));
ToggleButton$1.displayName = "ToggleButton";
const HeaderButtons = reactExports.memo(({ onSettingsOpen, onNewHistory }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", gap: 1, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onSettingsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiSettings, {}) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(GroupDrawer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiUsers, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(HistoryDrawer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiClock, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onNewHistory, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiPlus, {}) })
] }));
HeaderButtons.displayName = "HeaderButtons";
const SidebarContent = reactExports.memo(({ onSettingsOpen, onNewHistory }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.sidebar.content, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.sidebar.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    HeaderButtons,
    {
      onSettingsOpen,
      onNewHistory
    }
  ) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryPanel, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx(BottomTab, {})
] }));
SidebarContent.displayName = "SidebarContent";
function Sidebar({ isCollapsed = false, onToggle }) {
  const {
    settingsOpen,
    onSettingsOpen,
    onSettingsClose,
    createNewHistory
  } = useSidebar();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.sidebar.container(isCollapsed), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton$1, { isCollapsed, onToggle }),
    !isCollapsed && !settingsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SidebarContent,
      {
        onSettingsOpen,
        onNewHistory: createNewHistory
      }
    ),
    !isCollapsed && settingsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingUI,
      {
        open: settingsOpen,
        onClose: onSettingsClose,
        onToggle
      }
    )
  ] });
}
function BsMicFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0z" }, "child": [] }, { "tag": "path", "attr": { "d": "M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5" }, "child": [] }] })(props);
}
function BsMicMuteFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M13 8c0 .564-.094 1.107-.266 1.613l-.814-.814A4 4 0 0 0 12 8V7a.5.5 0 0 1 1 0zm-5 4c.818 0 1.578-.245 2.212-.667l.718.719a5 5 0 0 1-2.43.923V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 1 0v1a4 4 0 0 0 4 4m3-9v4.879L5.158 2.037A3.001 3.001 0 0 1 11 3" }, "child": [] }, { "tag": "path", "attr": { "d": "M9.486 10.607 5 6.12V8a3 3 0 0 0 4.486 2.607m-7.84-9.253 12 12 .708-.708-12-12z" }, "child": [] }] })(props);
}
function BsPaperclip(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M4.5 3a2.5 2.5 0 0 1 5 0v9a1.5 1.5 0 0 1-3 0V5a.5.5 0 0 1 1 0v7a.5.5 0 0 0 1 0V3a1.5 1.5 0 1 0-3 0v9a2.5 2.5 0 0 0 5 0V5a.5.5 0 0 1 1 0v7a3.5 3.5 0 1 1-7 0z" }, "child": [] }] })(props);
}
function IoHandRightSharp(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M82.42 209.08c15.06-6.62 32.38 1.31 38.5 17.62L156 312h11.27V80c0-17.6 13.3-32 29.55-32 16.26 0 29.55 14.4 29.55 32v151.75l14.78.25V32c0-17.6 13.3-32 29.55-32 16.3 0 29.55 14.4 29.55 32v199.75L315 232V64c0-17.6 13.3-32 29.55-32 16.26 0 29.55 14.4 29.55 32v183.75l14.78.25V128c0-17.6 13.3-32 29.55-32C434.7 96 448 110.4 448 128v216c0 75.8-37.13 168-169 168-40.8 0-79.42-7-100.66-21a121.41 121.41 0 0 1-33.72-33.31 138 138 0 0 1-16-31.78L66.16 250.77c-6.11-16.31 1.2-35.06 16.26-41.69z" }, "child": [] }] })(props);
}
const InputGroup = reactExports.forwardRef(
  (props, ref2) => {
    const {
      startElement,
      startElementProps,
      endElement,
      endElementProps,
      children,
      startOffset = "6px",
      endOffset = "6px",
      ...rest
    } = props;
    const child = reactExports.Children.only(children);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Group, { ref: ref2, ...rest, children: [
      startElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { pointerEvents: "none", ...startElementProps, children: startElement }),
      reactExports.cloneElement(child, {
        ...startElement && {
          ps: `calc(var(--input-height) - ${startOffset})`
        },
        ...endElement && { pe: `calc(var(--input-height) - ${endOffset})` },
        ...children.props
      }),
      endElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { placement: "end", ...endElementProps, children: endElement })
    ] });
  }
);
const footerStyles = {
  footer: {
    container: (isCollapsed) => ({
      bg: isCollapsed ? "transparent" : "gray.800",
      borderTopRadius: isCollapsed ? "none" : "lg",
      transform: isCollapsed ? "translateY(calc(100% - 24px))" : "translateY(0)",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      height: "100%",
      position: "relative",
      overflow: isCollapsed ? "visible" : "hidden",
      pb: "4"
    }),
    toggleButton: {
      height: "24px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      color: "whiteAlpha.700",
      _hover: { color: "white" },
      bg: "transparent",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
    },
    actionButton: {
      borderRadius: "12px",
      width: "50px",
      height: "50px",
      minW: "50px"
    },
    input: {
      bg: "gray.700",
      border: "none",
      height: "80px",
      borderRadius: "12px",
      fontSize: "18px",
      pl: "12",
      pr: "4",
      color: "whiteAlpha.900",
      _placeholder: {
        color: "whiteAlpha.500"
      },
      _focus: {
        border: "none",
        bg: "gray.700"
      },
      resize: "none",
      minHeight: "80px",
      maxHeight: "80px",
      py: "0",
      display: "flex",
      alignItems: "center",
      paddingTop: "28px",
      lineHeight: "1.4"
    },
    attachButton: {
      position: "absolute",
      left: "1",
      top: "50%",
      transform: "translateY(-50%)",
      color: "whiteAlpha.700",
      zIndex: 2,
      _hover: {
        bg: "transparent",
        color: "white"
      }
    }
  },
  aiIndicator: {
    container: {
      bg: "#7C5CFF",
      color: "white",
      width: "110px",
      height: "30px",
      borderRadius: "12px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      boxShadow: "0 2px 6px rgba(0,0,0,0.1)",
      overflow: "hidden"
    },
    text: {
      fontSize: "12px",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  }
};
function AIStateIndicator() {
  const { aiState } = useAiState();
  const styles2 = footerStyles.aiIndicator;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...styles2.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...styles2.text, children: aiState }) });
}
function useTextInput() {
  const [inputText, setInputText] = reactExports.useState("");
  const [isComposing, setIsComposing] = reactExports.useState(false);
  const wsContext = useWebSocket();
  const { aiState, setAiState } = useAiState();
  const { interrupt } = useInterrupt();
  const { appendHumanMessage } = useChatHistory();
  const { stopMic, autoStopMic } = useVAD();
  const { captureAllMedia } = useMediaCapture();
  const handleInputChange = (e2) => {
    setInputText(e2.target.value);
  };
  const handleSend = async () => {
    if (!inputText.trim() || !wsContext) return;
    if (aiState === "thinking-speaking") {
      interrupt();
    }
    const images = await captureAllMedia();
    appendHumanMessage(inputText.trim());
    wsContext.sendMessage({
      type: "text-input",
      text: inputText.trim(),
      images
    });
    setAiState("thinking-speaking");
    if (autoStopMic) stopMic();
    setInputText("");
  };
  const handleKeyPress = (e2) => {
    if (isComposing) return;
    if (e2.key === "Enter" && !e2.shiftKey) {
      e2.preventDefault();
      handleSend();
    }
  };
  const handleCompositionStart = () => setIsComposing(true);
  const handleCompositionEnd = () => setIsComposing(false);
  return {
    inputText,
    setInputText: handleInputChange,
    handleSend,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd
  };
}
const useFooter = () => {
  const {
    inputText: inputValue,
    setInputText: handleChange,
    handleKeyPress: handleKey,
    handleCompositionStart,
    handleCompositionEnd
  } = useTextInput();
  const { interrupt } = useInterrupt();
  const { startMic, autoStartMicOn } = useVAD();
  const { handleMicToggle, micOn } = useMicToggle();
  const { setAiState, aiState } = useAiState();
  const { sendTriggerSignal } = useTriggerSpeak();
  const { settings: settings2 } = useProactiveSpeak();
  const handleInputChange = (e2) => {
    handleChange({ target: { value: e2.target.value } });
    setAiState(AiStateEnum.WAITING);
  };
  const handleKeyPress = (e2) => {
    handleKey(e2);
  };
  const handleInterrupt = () => {
    if (aiState === AiStateEnum.THINKING_SPEAKING) {
      interrupt();
      if (autoStartMicOn) {
        startMic();
      }
    } else if (settings2.allowButtonTrigger) {
      sendTriggerSignal(-1);
    }
  };
  return {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    micOn
  };
};
const ToggleButton = reactExports.memo(({ isCollapsed, onToggle }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    ...footerStyles.footer.toggleButton,
    onClick: onToggle,
    color: "whiteAlpha.500",
    style: {
      transform: isCollapsed ? "rotate(180deg)" : "rotate(0deg)"
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronDown, {})
  }
));
ToggleButton.displayName = "ToggleButton";
const ActionButtons = reactExports.memo(({ micOn, onMicToggle, onInterrupt }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { gap: 2, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      bg: micOn ? "green.500" : "red.500",
      ...footerStyles.footer.actionButton,
      onClick: onMicToggle,
      children: micOn ? /* @__PURE__ */ jsxRuntimeExports.jsx(BsMicFill, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BsMicMuteFill, {})
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      "aria-label": "Raise hand",
      bg: "yellow.500",
      ...footerStyles.footer.actionButton,
      onClick: onInterrupt,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IoHandRightSharp, { size: "24" })
    }
  )
] }));
ActionButtons.displayName = "ActionButtons";
const MessageInput = reactExports.memo(({
  value,
  onChange,
  onKeyDown,
  onCompositionStart,
  onCompositionEnd
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(InputGroup, { flex: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { position: "relative", width: "100%", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      "aria-label": "Attach file",
      variant: "ghost",
      ...footerStyles.footer.attachButton,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(BsPaperclip, { size: "24" })
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Textarea,
    {
      value,
      onChange,
      onKeyDown,
      onCompositionStart,
      onCompositionEnd,
      placeholder: "Type your message...",
      ...footerStyles.footer.input
    }
  )
] }) }));
MessageInput.displayName = "MessageInput";
function Footer({ isCollapsed = false, onToggle }) {
  const {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    micOn
  } = useFooter();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...footerStyles.footer.container(isCollapsed), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { isCollapsed, onToggle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { pt: "0", px: "4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { width: "100%", gap: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { mb: "1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AIStateIndicator, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ActionButtons,
          {
            micOn,
            onMicToggle: handleMicToggle,
            onInterrupt: handleInterrupt
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MessageInput,
        {
          value: inputValue,
          onChange: handleInputChange,
          onKeyDown: handleKeyPress,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd
        }
      )
    ] }) })
  ] });
}
const isElectron = window.api !== void 0;
const getAppHeight = () => {
  if (typeof window !== "undefined" && /Mobi|Android/i.test(navigator.userAgent)) {
    return `${window.innerHeight}px`;
  }
  return isElectron ? "calc(100vh - 30px)" : "100vh";
};
const layoutStyles = {
  appContainer: {
    width: "100vw",
    height: getAppHeight(),
    bg: "gray.900",
    color: "white",
    overflow: "hidden",
    position: "relative",
    display: "flex",
    flexDirection: { base: "column", md: "row" }
  },
  sidebar: {
    position: "relative",
    width: { base: "100%", md: "440px" },
    height: { base: "auto", md: "100%" },
    bg: "gray.800",
    borderRight: "1px solid",
    borderColor: "whiteAlpha.200",
    overflow: "hidden",
    flexShrink: 0,
    transition: "all 0.2s"
  },
  mainContent: {
    flex: 1,
    height: { base: "calc(100% - 120px)", md: "100%" },
    position: "relative",
    display: "flex",
    flexDirection: "column",
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    width: "100%",
    overflow: "hidden"
  },
  canvas: {
    position: "relative",
    width: "100%",
    flex: 1,
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    overflow: "hidden",
    willChange: "transform"
  },
  footer: {
    width: "100%",
    height: { base: "100px", md: "120px" },
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    willChange: "transform",
    position: "relative",
    zIndex: 1
  },
  toggleButton: {
    position: "absolute",
    left: 0,
    top: "50%",
    transform: "translateY(-50%)",
    height: "60px",
    bg: "whiteAlpha.100",
    _hover: { bg: "whiteAlpha.200" },
    borderLeftRadius: 0,
    borderRightRadius: "md",
    zIndex: 10
  },
  canvasHeight: (isFooterCollapsed) => ({
    height: isFooterCollapsed ? "calc(100% - 24px)" : "calc(100% - 120px)"
  }),
  sidebarToggleButton: {
    position: "absolute",
    left: 0,
    top: "50%",
    transform: "translateY(-50%)",
    height: "60px",
    bg: "gray.800",
    borderLeftRadius: 0,
    borderRightRadius: "md",
    zIndex: 10
  },
  collapsedFooter: {
    height: { base: "20px", md: "24px" },
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
  },
  windowsTitleBar: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    height: "30px",
    backgroundColor: "gray.800",
    paddingX: "10px",
    css: { "-webkit-app-region": "drag" }
  },
  macTitleBar: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "30px",
    backgroundColor: "gray.800",
    css: {
      "-webkit-app-region": "drag",
      "-webkit-user-select": "none"
    }
  },
  titleBarTitle: {
    fontSize: "sm",
    color: "whiteAlpha.800",
    textAlign: "center"
  },
  titleBarButtons: {
    display: "flex",
    gap: "1"
  },
  titleBarButton: {
    size: "sm",
    variant: "ghost",
    color: "whiteAlpha.800",
    css: { "-webkit-app-region": "no-drag" },
    _hover: { backgroundColor: "whiteAlpha.200" }
  },
  closeButton: {
    size: "sm",
    variant: "ghost",
    color: "whiteAlpha.800",
    css: { "-webkit-app-region": "no-drag" },
    _hover: { backgroundColor: "red.500" }
  }
};
function WebSocketHandler({ children }) {
  const [wsState, setWsState] = reactExports.useState("CLOSED");
  const [wsUrl, setWsUrl] = useLocalStorage("wsUrl", defaultWsUrl);
  const [baseUrl, setBaseUrl] = useLocalStorage("baseUrl", defaultBaseUrl);
  const { aiState, setAiState, backendSynthComplete, setBackendSynthComplete } = useAiState();
  const { setModelInfo } = useLive2DConfig();
  const { setSubtitleText } = useSubtitle();
  const { clearResponse, setForceNewMessage } = useChatHistory();
  const { addAudioTask } = useAudioTask();
  const bgUrlContext = useBgUrl();
  const { confUid, setConfName, setConfUid, setConfigFiles } = useConfig();
  const [pendingModelInfo, setPendingModelInfo] = reactExports.useState(void 0);
  const { setSelfUid, setGroupMembers, setIsOwner } = useGroup();
  const { startMic, stopMic, autoStartMicOnConvEnd } = useVAD();
  const autoStartMicOnConvEndRef = reactExports.useRef(autoStartMicOnConvEnd);
  const { interrupt } = useInterrupt();
  reactExports.useEffect(() => {
    autoStartMicOnConvEndRef.current = autoStartMicOnConvEnd;
  }, [autoStartMicOnConvEnd]);
  reactExports.useEffect(() => {
    if (pendingModelInfo) {
      setModelInfo(pendingModelInfo);
      setPendingModelInfo(void 0);
    }
  }, [pendingModelInfo, setModelInfo, confUid]);
  const {
    setCurrentHistoryUid,
    setMessages,
    setHistoryList,
    appendHumanMessage
  } = useChatHistory();
  const handleControlMessage = reactExports.useCallback((controlText) => {
    switch (controlText) {
      case "start-mic":
        console.log("Starting microphone...");
        startMic();
        break;
      case "stop-mic":
        console.log("Stopping microphone...");
        stopMic();
        break;
      case "conversation-chain-start":
        setAiState("thinking-speaking");
        audioTaskQueue.clearQueue();
        clearResponse();
        break;
      case "conversation-chain-end":
        audioTaskQueue.addTask(() => new Promise((resolve2) => {
          setAiState((currentState) => {
            if (currentState === "thinking-speaking") {
              if (autoStartMicOnConvEndRef.current) {
                startMic();
              }
              return "idle";
            }
            return currentState;
          });
          resolve2();
        }));
        break;
      default:
        console.warn("Unknown control command:", controlText);
    }
  }, [setAiState, clearResponse, setForceNewMessage, startMic, stopMic]);
  const handleWebSocketMessage = reactExports.useCallback((message) => {
    console.log("Received message from server:", message);
    switch (message.type) {
      case "control":
        if (message.text) {
          handleControlMessage(message.text);
        }
        break;
      case "set-model-and-conf":
        setAiState("loading");
        if (message.conf_name) {
          setConfName(message.conf_name);
        }
        if (message.conf_uid) {
          setConfUid(message.conf_uid);
          console.log("confUid", message.conf_uid);
        }
        if (message.client_uid) {
          setSelfUid(message.client_uid);
        }
        setPendingModelInfo(message.model_info);
        if (message.model_info && !message.model_info.url.startsWith("http")) {
          const modelUrl = baseUrl + message.model_info.url;
          console.log("🎭 Live2D Model URL Construction:", {
            originalUrl: message.model_info.url,
            baseUrl,
            finalUrl: modelUrl,
            hostname: window.location.hostname
          });
          message.model_info.url = modelUrl;
        }
        setAiState("idle");
        break;
      case "full-text":
        if (message.text) {
          setSubtitleText(message.text);
        }
        break;
      case "config-files":
        if (message.configs) {
          setConfigFiles(message.configs);
        }
        break;
      case "config-switched":
        setAiState("idle");
        setSubtitleText("New Character Loaded");
        toaster.create({
          title: "Character switched",
          type: "success",
          duration: 2e3
        });
        wsService.sendMessage({ type: "fetch-history-list" });
        wsService.sendMessage({ type: "create-new-history" });
        break;
      case "background-files":
        if (message.files) {
          bgUrlContext?.setBackgroundFiles(message.files);
        }
        break;
      case "audio":
        if (aiState === "interrupted" || aiState === "listening") {
          console.log("Audio playback intercepted. Sentence:", message.display_text?.text);
        } else {
          console.log("actions", message.actions);
          addAudioTask({
            audioBase64: message.audio || "",
            volumes: message.volumes || [],
            sliceLength: message.slice_length || 0,
            displayText: message.display_text || null,
            expressions: message.actions?.expressions || null,
            forwarded: message.forwarded || false
          });
        }
        break;
      case "history-data":
        if (message.messages) {
          setMessages(message.messages);
        }
        toaster.create({
          title: "History loaded",
          type: "success",
          duration: 2e3
        });
        break;
      case "new-history-created":
        setAiState("idle");
        setSubtitleText("New Conversation Started");
        if (message.history_uid) {
          setCurrentHistoryUid(message.history_uid);
          setMessages([]);
          const newHistory = {
            uid: message.history_uid,
            latest_message: null,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          setHistoryList((prev2) => [newHistory, ...prev2]);
          toaster.create({
            title: "New chat history created",
            type: "success",
            duration: 2e3
          });
        }
        break;
      case "history-deleted":
        toaster.create({
          title: message.success ? "History deleted successfully" : "Failed to delete history",
          type: message.success ? "success" : "error",
          duration: 2e3
        });
        break;
      case "history-list":
        if (message.histories) {
          setHistoryList(message.histories);
          if (message.histories.length > 0) {
            setCurrentHistoryUid(message.histories[0].uid);
          }
        }
        break;
      case "user-input-transcription":
        console.log("user-input-transcription: ", message.text);
        if (message.text) {
          appendHumanMessage(message.text);
        }
        break;
      case "error":
        toaster.create({
          title: message.message,
          type: "error",
          duration: 2e3
        });
        break;
      case "group-update":
        console.log("Received group-update:", message.members);
        if (message.members) {
          setGroupMembers(message.members);
        }
        if (message.is_owner !== void 0) {
          setIsOwner(message.is_owner);
        }
        break;
      case "group-operation-result":
        toaster.create({
          title: message.message,
          type: message.success ? "success" : "error",
          duration: 2e3
        });
        break;
      case "backend-synth-complete":
        setBackendSynthComplete(true);
        break;
      case "conversation-chain-end":
        if (!audioTaskQueue.hasTask()) {
          setAiState((currentState) => {
            if (currentState === "thinking-speaking") {
              return "idle";
            }
            return currentState;
          });
        }
        break;
      case "force-new-message":
        setForceNewMessage(true);
        break;
      case "interrupt-signal":
        interrupt(false);
        break;
      default:
        console.warn("Unknown message type:", message.type);
    }
  }, [aiState, addAudioTask, appendHumanMessage, baseUrl, bgUrlContext, setAiState, setConfName, setConfUid, setConfigFiles, setCurrentHistoryUid, setHistoryList, setMessages, setModelInfo, setSubtitleText, startMic, stopMic, setSelfUid, setGroupMembers, setIsOwner, backendSynthComplete, setBackendSynthComplete, clearResponse]);
  reactExports.useEffect(() => {
    wsService.connect(wsUrl);
  }, [wsUrl]);
  reactExports.useEffect(() => {
    const stateSubscription = wsService.onStateChange(setWsState);
    const messageSubscription = wsService.onMessage(handleWebSocketMessage);
    return () => {
      stateSubscription.unsubscribe();
      messageSubscription.unsubscribe();
    };
  }, [wsUrl, handleWebSocketMessage]);
  const webSocketContextValue = reactExports.useMemo(() => ({
    sendMessage: wsService.sendMessage.bind(wsService),
    wsState,
    reconnect: () => wsService.connect(wsUrl),
    wsUrl,
    setWsUrl,
    baseUrl,
    setBaseUrl
  }), [wsState, wsUrl, baseUrl]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WebSocketContext.Provider, { value: webSocketContextValue, children });
}
function TitleBar() {
  const [isMaximized, setIsMaximized] = reactExports.useState(false);
  const [isFullScreen, setIsFullScreen] = reactExports.useState(false);
  const isMac2 = window.electron?.process.platform === "darwin";
  reactExports.useEffect(() => {
    const handleMaximizeChange = (_event, maximized) => {
      setIsMaximized(maximized);
    };
    const handleFullScreenChange = (_event, fullScreen) => {
      setIsFullScreen(fullScreen);
    };
    window.electron?.ipcRenderer.on("window-maximized-change", handleMaximizeChange);
    window.electron?.ipcRenderer.on("window-fullscreen-change", handleFullScreenChange);
    return () => {
      window.electron?.ipcRenderer.removeAllListeners("window-maximized-change");
      window.electron?.ipcRenderer.removeAllListeners("window-fullscreen-change");
    };
  }, []);
  const handleMaximizeClick = () => {
    if (isFullScreen) {
      window.electron?.ipcRenderer.send("window-unfullscreen");
    } else {
      window.electron?.ipcRenderer.send("window-maximize");
    }
  };
  const getButtonLabel = () => {
    if (isFullScreen) return "Exit Full Screen";
    if (isMaximized) return "Restore";
    return "Maximize";
  };
  const getButtonIcon = () => {
    if (isFullScreen) return /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronsDown, {});
    if (isMaximized) return /* @__PURE__ */ jsxRuntimeExports.jsx(FiMinimize2, {});
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FiMaximize2, {});
  };
  if (isMac2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.macTitleBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.titleBarTitle, children: "Open LLM VTuber" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.windowsTitleBar, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.titleBarTitle, children: "Open LLM VTuber" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.titleBarButtons, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.titleBarButton,
          onClick: () => window.electron?.ipcRenderer.send("window-minimize"),
          "aria-label": "Minimize",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiMinus, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.titleBarButton,
          onClick: handleMaximizeClick,
          "aria-label": getButtonLabel(),
          children: getButtonIcon()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.closeButton,
          onClick: () => window.electron?.ipcRenderer.send("window-close"),
          "aria-label": "Close",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiX, {})
        }
      )
    ] })
  ] });
}
function useInputSubtitle() {
  const {
    inputText: inputValue,
    setInputText: handleChange,
    handleKeyPress: handleKey,
    handleCompositionStart,
    handleCompositionEnd,
    handleSend
  } = useTextInput();
  const { messages: messages2 } = useChatHistory();
  const { startMic, autoStartMicOn } = useVAD();
  const { handleMicToggle, micOn } = useMicToggle();
  const { aiState, setAiState } = useAiState();
  const { interrupt } = useInterrupt();
  const lastAIMessage = messages2.filter((msg) => msg.role === "ai").slice(-1).map((msg) => msg.content)[0];
  const hasAIMessages = messages2.some((msg) => msg.role === "ai");
  const handleInterrupt = () => {
    interrupt();
    if (autoStartMicOn) {
      startMic();
    }
  };
  const handleInputChange = (e2) => {
    handleChange({ target: { value: e2.target.value } });
    setAiState(AiStateEnum.WAITING);
  };
  const handleKeyPress = (e2) => {
    handleKey(e2);
  };
  return {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    lastAIMessage,
    hasAIMessages,
    aiState,
    micOn,
    handleSend
  };
}
function useDraggable({ isPet = false, componentId }) {
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const positionRef = reactExports.useRef({ x: 0, y: 0 });
  const dragStartRef = reactExports.useRef({ x: 0, y: 0 });
  const elementRef = reactExports.useRef(null);
  const handleMouseEnter = () => {
    if (isPet) {
      window.api?.updateComponentHover(componentId, true);
    }
  };
  const handleMouseLeave = () => {
    if (isPet && !isDragging) {
      window.api?.updateComponentHover(componentId, false);
    }
  };
  const handleMouseDown = (e2) => {
    setIsDragging(true);
    dragStartRef.current = {
      x: e2.clientX - positionRef.current.x,
      y: e2.clientY - positionRef.current.y
    };
    const handleMouseMove = (moveEvent) => {
      if (!elementRef.current) return;
      const newPosition = {
        x: moveEvent.clientX - dragStartRef.current.x,
        y: moveEvent.clientY - dragStartRef.current.y
      };
      positionRef.current = newPosition;
      elementRef.current.style.transform = `translateX(-50%) translate(${positionRef.current.x}px, ${positionRef.current.y}px)`;
    };
    const handleMouseUp = () => {
      setIsDragging(false);
      document.removeEventListener("mousemove", handleMouseMove, true);
      document.removeEventListener("mouseup", handleMouseUp, true);
    };
    document.addEventListener("mousemove", handleMouseMove, true);
    document.addEventListener("mouseup", handleMouseUp, true);
  };
  return {
    elementRef,
    isDragging,
    handleMouseDown,
    handleMouseEnter,
    handleMouseLeave
  };
}
const inputSubtitleStyles = {
  container: {
    display: "flex",
    alignItems: "flex-end",
    justifyContent: "center",
    maxW: "fit-content",
    position: "absolute",
    bottom: "120px",
    left: "50%",
    transform: "translateX(-50%)",
    zIndex: 1e3,
    userSelect: "none",
    willChange: "transform",
    padding: 0
  },
  box: {
    w: "400px",
    rounded: "xl",
    overflow: "hidden",
    boxShadow: "lg",
    bg: "blackAlpha.700",
    backdropFilter: "blur(8px)",
    css: { WebkitUserSelect: "none" }
  },
  messageStack: {
    p: "3",
    gap: 1,
    alignItems: "stretch",
    justify: "flex-end"
  },
  messageText: {
    color: "white",
    fontSize: "sm",
    lineHeight: "1.5",
    transition: "all 0.3s"
  },
  statusBox: {
    bg: "blackAlpha.600",
    p: "3",
    borderTop: "1px",
    borderColor: "whiteAlpha.200"
  },
  statusText: {
    fontSize: "xs",
    color: "whiteAlpha.800",
    transition: "all 0.3s"
  },
  iconButton: {
    size: "xs",
    variant: "ghost",
    color: "whiteAlpha.800",
    _hover: { bg: "whiteAlpha.200" }
  },
  inputBox: {
    bg: "blackAlpha.600",
    borderTop: "1px",
    borderColor: "whiteAlpha.200"
  },
  input: {
    size: "sm",
    bg: "blackAlpha.500",
    color: "white",
    _placeholder: { color: "whiteAlpha.500" },
    borderColor: "whiteAlpha.300",
    _focus: {
      borderColor: "whiteAlpha.500",
      outline: "none"
    },
    flex: "1"
  },
  sendButton: {
    p: "1.5",
    bg: "blackAlpha.500",
    rounded: "lg",
    _hover: { bg: "blackAlpha.600" },
    transition: "colors",
    color: "whiteAlpha.800",
    size: "sm"
  },
  draggableContainer: (isDragging) => ({
    cursor: isDragging ? "grabbing" : "grab",
    transition: isDragging ? "none" : "transform 0.1s ease",
    _active: { cursor: "grabbing" }
  }),
  closeButton: {
    position: "absolute",
    top: 0,
    right: 0,
    size: "2xs",
    minW: "6",
    height: "6",
    padding: 0,
    variant: "ghost",
    color: "whiteAlpha.400",
    bg: "transparent",
    _hover: {
      bg: "blackAlpha.300",
      color: "whiteAlpha.800"
    },
    zIndex: 10
  }
};
function InputSubtitle({ isPet = false }) {
  const {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    handleSend,
    lastAIMessage,
    hasAIMessages,
    aiState,
    micOn
  } = useInputSubtitle();
  const {
    elementRef,
    isDragging,
    handleMouseDown,
    handleMouseEnter,
    handleMouseLeave
  } = useDraggable({
    isPet,
    componentId: "input-subtitle"
  });
  const [isVisible, setIsVisible] = reactExports.useState(true);
  const handleClose = reactExports.useCallback(() => {
    if (isPet) {
      window.api?.updateComponentHover("input-subtitle", false);
    }
    setIsVisible(false);
  }, [isPet]);
  const handleOpen = () => {
    setIsVisible(true);
  };
  reactExports.useEffect(() => {
    if (isPet) {
      const cleanup = window.api?.onToggleInputSubtitle(() => {
        if (isVisible) {
          handleClose();
        } else {
          handleOpen();
        }
      });
      return () => cleanup?.();
    }
    return () => {
    };
  }, [handleClose, isPet, isVisible]);
  reactExports.useEffect(() => {
    window.inputSubtitle = {
      open: handleOpen,
      close: handleClose
    };
    return () => {
      delete window.inputSubtitle;
    };
  }, [isPet, handleClose]);
  if (!isVisible) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref: elementRef,
      ...inputSubtitleStyles.container,
      ...inputSubtitleStyles.draggableContainer(isDragging),
      onMouseDown: handleMouseDown,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...inputSubtitleStyles.box, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            "aria-label": "Close subtitle",
            onClick: handleClose,
            ...inputSubtitleStyles.closeButton,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuX, { size: 12 })
          }
        ),
        hasAIMessages && /* @__PURE__ */ jsxRuntimeExports.jsx(
          VStack,
          {
            minH: lastAIMessage ? "32px" : "0px",
            ...inputSubtitleStyles.messageStack,
            children: lastAIMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...inputSubtitleStyles.messageText, children: lastAIMessage })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...inputSubtitleStyles.statusBox, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", justify: "space-between", color: "whiteAlpha.700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LuBell, { size: 16 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { ...inputSubtitleStyles.statusText, children: aiState })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                "aria-label": "Toggle microphone",
                onClick: handleMicToggle,
                ...inputSubtitleStyles.iconButton,
                children: micOn ? /* @__PURE__ */ jsxRuntimeExports.jsx(LuMic, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(LuMicOff, { size: 16 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                "aria-label": "Interrupt",
                onClick: handleInterrupt,
                ...inputSubtitleStyles.iconButton,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuHand, { size: 16 })
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...inputSubtitleStyles.inputBox, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: "2", p: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              value: inputValue,
              onChange: handleInputChange,
              onKeyDown: handleKeyPress,
              onCompositionStart: handleCompositionStart,
              onCompositionEnd: handleCompositionEnd,
              placeholder: "Type your message...",
              ...inputSubtitleStyles.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              onClick: handleSend,
              ...inputSubtitleStyles.sendButton,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuSend, { size: 16 })
            }
          )
        ] }) })
      ] })
    }
  );
}
function App() {
  const [showSidebar, setShowSidebar] = reactExports.useState(true);
  const [isFooterCollapsed, setIsFooterCollapsed] = reactExports.useState(false);
  const [mode, setMode] = reactExports.useState("window");
  const isElectron2 = window.api !== void 0;
  reactExports.useEffect(() => {
    if (isElectron2) {
      window.electron.ipcRenderer.on("pre-mode-changed", (_event, newMode) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            window.electron.ipcRenderer.send("renderer-ready-for-mode-change", newMode);
          });
        });
      });
    }
  }, [isElectron2]);
  reactExports.useEffect(() => {
    if (isElectron2) {
      window.electron.ipcRenderer.on("mode-changed", (_event, newMode) => {
        setMode(newMode);
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            window.electron.ipcRenderer.send("mode-change-rendered");
          });
        });
      });
    }
  }, [isElectron2]);
  reactExports.useEffect(() => {
    const handleResize = () => {
      const vh2 = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vh", `${vh2}px`);
    };
    handleResize();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { value: defaultSystem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DModelProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenCaptureProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CharacterConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AiStateProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProactiveSpeakProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VADProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BgUrlProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WebSocketHandler, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {}),
    mode === "window" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      isElectron2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TitleBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { ...layoutStyles.appContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...layoutStyles.sidebar,
            ...!showSidebar && { width: "24px" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Sidebar,
              {
                isCollapsed: !showSidebar,
                onToggle: () => setShowSidebar(!showSidebar)
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.mainContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              ...layoutStyles.footer,
              ...isFooterCollapsed && layoutStyles.collapsedFooter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Footer,
                {
                  isCollapsed: isFooterCollapsed,
                  onToggle: () => setIsFooterCollapsed(
                    !isFooterCollapsed
                  )
                }
              )
            }
          )
        ] })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Live2D$1, { isPet: mode === "pet" }),
      mode === "pet" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputSubtitle, { isPet: mode === "pet" })
    ] })
  ] }) }) }) }) }) }) }) }) }) }) }) }) }) });
}
const originalConsoleWarn = console.warn;
console.warn = (...args) => {
  if (typeof args[0] === "string" && args[0].includes("onnxruntime")) {
    return;
  }
  originalConsoleWarn.apply(console, args);
};
if (typeof window !== "undefined") {
  createRoot(document.getElementById("root")).render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
  );
}
